import {
  init_src3 as init_src,
  src_exports
} from "./chunk-AVGT6AW7.js";
import {
  _classCallCheck,
  _createClass,
  _defineProperty,
  _slicedToArray,
  _toConsumableArray,
  _typeof,
  init_classCallCheck,
  init_createClass,
  init_defineProperty,
  init_slicedToArray,
  init_toConsumableArray,
  init_typeof,
  require_regenerator
} from "./chunk-JAWQE4LK.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-6DBBYCL5.js";

// node_modules/@antv/util/esm/is-array-like.js
var isArrayLike, is_array_like_default;
var init_is_array_like = __esm({
  "node_modules/@antv/util/esm/is-array-like.js"() {
    isArrayLike = function(value) {
      return value !== null && typeof value !== "function" && isFinite(value.length);
    };
    is_array_like_default = isArrayLike;
  }
});

// node_modules/@antv/util/esm/contains.js
var contains, contains_default;
var init_contains = __esm({
  "node_modules/@antv/util/esm/contains.js"() {
    init_is_array_like();
    contains = function(arr, value) {
      if (!is_array_like_default(arr)) {
        return false;
      }
      return arr.indexOf(value) > -1;
    };
    contains_default = contains;
  }
});

// node_modules/@antv/util/esm/filter.js
var filter, filter_default;
var init_filter = __esm({
  "node_modules/@antv/util/esm/filter.js"() {
    init_is_array_like();
    filter = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index = 0; index < arr.length; index++) {
        var value = arr[index];
        if (func(value, index)) {
          result.push(value);
        }
      }
      return result;
    };
    filter_default = filter;
  }
});

// node_modules/@antv/util/esm/difference.js
var difference, difference_default;
var init_difference = __esm({
  "node_modules/@antv/util/esm/difference.js"() {
    init_filter();
    init_contains();
    difference = function(arr, values2) {
      if (values2 === void 0) {
        values2 = [];
      }
      return filter_default(arr, function(value) {
        return !contains_default(values2, value);
      });
    };
    difference_default = difference;
  }
});

// node_modules/@antv/util/esm/is-type.js
var toString, isType, is_type_default;
var init_is_type = __esm({
  "node_modules/@antv/util/esm/is-type.js"() {
    toString = {}.toString;
    isType = function(value, type) {
      return toString.call(value) === "[object " + type + "]";
    };
    is_type_default = isType;
  }
});

// node_modules/@antv/util/esm/is-function.js
var is_function_default;
var init_is_function = __esm({
  "node_modules/@antv/util/esm/is-function.js"() {
    init_is_type();
    is_function_default = function(value) {
      return is_type_default(value, "Function");
    };
  }
});

// node_modules/@antv/util/esm/is-nil.js
var isNil, is_nil_default;
var init_is_nil = __esm({
  "node_modules/@antv/util/esm/is-nil.js"() {
    isNil = function(value) {
      return value === null || value === void 0;
    };
    is_nil_default = isNil;
  }
});

// node_modules/@antv/util/esm/is-array.js
var is_array_default;
var init_is_array = __esm({
  "node_modules/@antv/util/esm/is-array.js"() {
    init_is_type();
    is_array_default = function(value) {
      return Array.isArray ? Array.isArray(value) : is_type_default(value, "Array");
    };
  }
});

// node_modules/@antv/util/esm/is-object.js
var is_object_default;
var init_is_object = __esm({
  "node_modules/@antv/util/esm/is-object.js"() {
    is_object_default = function(value) {
      var type = typeof value;
      return value !== null && type === "object" || type === "function";
    };
  }
});

// node_modules/@antv/util/esm/each.js
function each(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (is_array_default(elements)) {
    for (var i2 = 0, len5 = elements.length; i2 < len5; i2++) {
      rst = func(elements[i2], i2);
      if (rst === false) {
        break;
      }
    }
  } else if (is_object_default(elements)) {
    for (var k2 in elements) {
      if (elements.hasOwnProperty(k2)) {
        rst = func(elements[k2], k2);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var each_default;
var init_each = __esm({
  "node_modules/@antv/util/esm/each.js"() {
    init_is_array();
    init_is_object();
    each_default = each;
  }
});

// node_modules/@antv/util/esm/keys.js
var keys, keys_default;
var init_keys = __esm({
  "node_modules/@antv/util/esm/keys.js"() {
    init_each();
    init_is_function();
    keys = Object.keys ? function(obj) {
      return Object.keys(obj);
    } : function(obj) {
      var result = [];
      each_default(obj, function(value, key) {
        if (!(is_function_default(obj) && key === "prototype")) {
          result.push(key);
        }
      });
      return result;
    };
    keys_default = keys;
  }
});

// node_modules/@antv/util/esm/is-match.js
function isMatch(obj, attrs) {
  var _keys = keys_default(attrs);
  var length5 = _keys.length;
  if (is_nil_default(obj))
    return !length5;
  for (var i2 = 0; i2 < length5; i2 += 1) {
    var key = _keys[i2];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var is_match_default;
var init_is_match = __esm({
  "node_modules/@antv/util/esm/is-match.js"() {
    init_is_nil();
    init_keys();
    is_match_default = isMatch;
  }
});

// node_modules/@antv/util/esm/is-object-like.js
var isObjectLike, is_object_like_default;
var init_is_object_like = __esm({
  "node_modules/@antv/util/esm/is-object-like.js"() {
    isObjectLike = function(value) {
      return typeof value === "object" && value !== null;
    };
    is_object_like_default = isObjectLike;
  }
});

// node_modules/@antv/util/esm/is-plain-object.js
var isPlainObject, is_plain_object_default;
var init_is_plain_object = __esm({
  "node_modules/@antv/util/esm/is-plain-object.js"() {
    init_is_object_like();
    init_is_type();
    isPlainObject = function(value) {
      if (!is_object_like_default(value) || !is_type_default(value, "Object")) {
        return false;
      }
      if (Object.getPrototypeOf(value) === null) {
        return true;
      }
      var proto = value;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(value) === proto;
    };
    is_plain_object_default = isPlainObject;
  }
});

// node_modules/@antv/util/esm/find.js
function find(arr, predicate) {
  if (!is_array_default(arr))
    return null;
  var _predicate;
  if (is_function_default(predicate)) {
    _predicate = predicate;
  }
  if (is_plain_object_default(predicate)) {
    _predicate = function(a2) {
      return is_match_default(a2, predicate);
    };
  }
  if (_predicate) {
    for (var i2 = 0; i2 < arr.length; i2 += 1) {
      if (_predicate(arr[i2])) {
        return arr[i2];
      }
    }
  }
  return null;
}
var find_default;
var init_find = __esm({
  "node_modules/@antv/util/esm/find.js"() {
    init_is_function();
    init_is_match();
    init_is_array();
    init_is_plain_object();
    find_default = find;
  }
});

// node_modules/@antv/util/esm/find-index.js
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i2 = fromIndex; i2 < arr.length; i2++) {
    if (predicate(arr[i2], i2)) {
      return i2;
    }
  }
  return -1;
}
var find_index_default;
var init_find_index = __esm({
  "node_modules/@antv/util/esm/find-index.js"() {
    find_index_default = findIndex;
  }
});

// node_modules/@antv/util/esm/first-value.js
var firstValue, first_value_default;
var init_first_value = __esm({
  "node_modules/@antv/util/esm/first-value.js"() {
    init_is_nil();
    init_is_array();
    firstValue = function(data, name) {
      var rst = null;
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default(value)) {
          if (is_array_default(value)) {
            rst = value[0];
          } else {
            rst = value;
          }
          break;
        }
      }
      return rst;
    };
    first_value_default = firstValue;
  }
});

// node_modules/@antv/util/esm/flatten.js
var flatten, flatten_default;
var init_flatten = __esm({
  "node_modules/@antv/util/esm/flatten.js"() {
    init_is_array();
    flatten = function(arr) {
      if (!is_array_default(arr)) {
        return [];
      }
      var rst = [];
      for (var i2 = 0; i2 < arr.length; i2++) {
        rst = rst.concat(arr[i2]);
      }
      return rst;
    };
    flatten_default = flatten;
  }
});

// node_modules/@antv/util/esm/flatten-deep.js
var flattenDeep, flatten_deep_default;
var init_flatten_deep = __esm({
  "node_modules/@antv/util/esm/flatten-deep.js"() {
    init_is_array();
    flattenDeep = function(arr, result) {
      if (result === void 0) {
        result = [];
      }
      if (!is_array_default(arr)) {
        result.push(arr);
      } else {
        for (var i2 = 0; i2 < arr.length; i2 += 1) {
          flattenDeep(arr[i2], result);
        }
      }
      return result;
    };
    flatten_deep_default = flattenDeep;
  }
});

// node_modules/@antv/util/esm/max.js
var max_default;
var init_max = __esm({
  "node_modules/@antv/util/esm/max.js"() {
    init_is_array();
    max_default = function(arr) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.max(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/util/esm/min.js
var min_default;
var init_min = __esm({
  "node_modules/@antv/util/esm/min.js"() {
    init_is_array();
    min_default = function(arr) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      return arr.reduce(function(prev, curr) {
        return Math.min(prev, curr);
      }, arr[0]);
    };
  }
});

// node_modules/@antv/util/esm/get-range.js
var getRange, get_range_default;
var init_get_range = __esm({
  "node_modules/@antv/util/esm/get-range.js"() {
    init_is_array();
    init_max();
    init_min();
    getRange = function(values2) {
      var filterValues = values2.filter(function(v2) {
        return !isNaN(v2);
      });
      if (!filterValues.length) {
        return {
          min: 0,
          max: 0
        };
      }
      if (is_array_default(values2[0])) {
        var tmp = [];
        for (var i2 = 0; i2 < values2.length; i2++) {
          tmp = tmp.concat(values2[i2]);
        }
        filterValues = tmp;
      }
      var max7 = max_default(filterValues);
      var min6 = min_default(filterValues);
      return {
        min: min6,
        max: max7
      };
    };
    get_range_default = getRange;
  }
});

// node_modules/@antv/util/esm/pull.js
var arrPrototype, splice, indexOf, pull, pull_default;
var init_pull = __esm({
  "node_modules/@antv/util/esm/pull.js"() {
    arrPrototype = Array.prototype;
    splice = arrPrototype.splice;
    indexOf = arrPrototype.indexOf;
    pull = function(arr) {
      var values2 = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        values2[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < values2.length; i2++) {
        var value = values2[i2];
        var fromIndex = -1;
        while ((fromIndex = indexOf.call(arr, value)) > -1) {
          splice.call(arr, fromIndex, 1);
        }
      }
      return arr;
    };
    pull_default = pull;
  }
});

// node_modules/@antv/util/esm/pull-at.js
var splice2, pullAt, pull_at_default;
var init_pull_at = __esm({
  "node_modules/@antv/util/esm/pull-at.js"() {
    init_is_array_like();
    splice2 = Array.prototype.splice;
    pullAt = function pullAt2(arr, indexes) {
      if (!is_array_like_default(arr)) {
        return [];
      }
      var length5 = arr ? indexes.length : 0;
      var last2 = length5 - 1;
      while (length5--) {
        var previous = void 0;
        var index = indexes[length5];
        if (length5 === last2 || index !== previous) {
          previous = index;
          splice2.call(arr, index, 1);
        }
      }
      return arr;
    };
    pull_at_default = pullAt;
  }
});

// node_modules/@antv/util/esm/reduce.js
var reduce, reduce_default;
var init_reduce = __esm({
  "node_modules/@antv/util/esm/reduce.js"() {
    init_each();
    init_is_array();
    init_is_plain_object();
    reduce = function(arr, fn2, init) {
      if (!is_array_default(arr) && !is_plain_object_default(arr)) {
        return arr;
      }
      var result = init;
      each_default(arr, function(data, i2) {
        result = fn2(result, data, i2);
      });
      return result;
    };
    reduce_default = reduce;
  }
});

// node_modules/@antv/util/esm/remove.js
var remove, remove_default;
var init_remove = __esm({
  "node_modules/@antv/util/esm/remove.js"() {
    init_is_array_like();
    init_pull_at();
    remove = function(arr, predicate) {
      var result = [];
      if (!is_array_like_default(arr)) {
        return result;
      }
      var i2 = -1;
      var indexes = [];
      var length5 = arr.length;
      while (++i2 < length5) {
        var value = arr[i2];
        if (predicate(value, i2, arr)) {
          result.push(value);
          indexes.push(i2);
        }
      }
      pull_at_default(arr, indexes);
      return result;
    };
    remove_default = remove;
  }
});

// node_modules/@antv/util/esm/is-string.js
var is_string_default;
var init_is_string = __esm({
  "node_modules/@antv/util/esm/is-string.js"() {
    init_is_type();
    is_string_default = function(str7) {
      return is_type_default(str7, "String");
    };
  }
});

// node_modules/@antv/util/esm/sort-by.js
function sortBy(arr, key) {
  var comparer;
  if (is_function_default(key)) {
    comparer = function(a2, b10) {
      return key(a2) - key(b10);
    };
  } else {
    var keys_1 = [];
    if (is_string_default(key)) {
      keys_1.push(key);
    } else if (is_array_default(key)) {
      keys_1 = key;
    }
    comparer = function(a2, b10) {
      for (var i2 = 0; i2 < keys_1.length; i2 += 1) {
        var prop = keys_1[i2];
        if (a2[prop] > b10[prop]) {
          return 1;
        }
        if (a2[prop] < b10[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
var sort_by_default;
var init_sort_by = __esm({
  "node_modules/@antv/util/esm/sort-by.js"() {
    init_is_array();
    init_is_string();
    init_is_function();
    sort_by_default = sortBy;
  }
});

// node_modules/@antv/util/esm/uniq.js
function uniq(arr, cache3) {
  if (cache3 === void 0) {
    cache3 = /* @__PURE__ */ new Map();
  }
  var r2 = [];
  if (Array.isArray(arr)) {
    for (var i2 = 0, len5 = arr.length; i2 < len5; i2++) {
      var item = arr[i2];
      if (!cache3.has(item)) {
        r2.push(item);
        cache3.set(item, true);
      }
    }
  }
  return r2;
}
var init_uniq = __esm({
  "node_modules/@antv/util/esm/uniq.js"() {
  }
});

// node_modules/@antv/util/esm/union.js
var union, union_default;
var init_union = __esm({
  "node_modules/@antv/util/esm/union.js"() {
    init_uniq();
    union = function() {
      var sources = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        sources[_i2] = arguments[_i2];
      }
      return uniq([].concat.apply([], sources));
    };
    union_default = union;
  }
});

// node_modules/@antv/util/esm/values-of-key.js
var values_of_key_default;
var init_values_of_key = __esm({
  "node_modules/@antv/util/esm/values-of-key.js"() {
    init_is_array();
    init_is_nil();
    values_of_key_default = function(data, name) {
      var rst = [];
      var tmpMap = {};
      for (var i2 = 0; i2 < data.length; i2++) {
        var obj = data[i2];
        var value = obj[name];
        if (!is_nil_default(value)) {
          if (!is_array_default(value)) {
            value = [value];
          }
          for (var j2 = 0; j2 < value.length; j2++) {
            var val = value[j2];
            if (!tmpMap[val]) {
              rst.push(val);
              tmpMap[val] = true;
            }
          }
        }
      }
      return rst;
    };
  }
});

// node_modules/@antv/util/esm/head.js
function head(o2) {
  if (is_array_like_default(o2)) {
    return o2[0];
  }
  return void 0;
}
var init_head = __esm({
  "node_modules/@antv/util/esm/head.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/util/esm/last.js
function last(o2) {
  if (is_array_like_default(o2)) {
    var arr = o2;
    return arr[arr.length - 1];
  }
  return void 0;
}
var init_last = __esm({
  "node_modules/@antv/util/esm/last.js"() {
    init_is_array_like();
  }
});

// node_modules/@antv/util/esm/starts-with.js
function startsWith(arr, e8) {
  return is_array_default(arr) || is_string_default(arr) ? arr[0] === e8 : false;
}
var starts_with_default;
var init_starts_with = __esm({
  "node_modules/@antv/util/esm/starts-with.js"() {
    init_is_array();
    init_is_string();
    starts_with_default = startsWith;
  }
});

// node_modules/@antv/util/esm/ends-with.js
function endsWith(arr, e8) {
  return is_array_default(arr) || is_string_default(arr) ? arr[arr.length - 1] === e8 : false;
}
var ends_with_default;
var init_ends_with = __esm({
  "node_modules/@antv/util/esm/ends-with.js"() {
    init_is_array();
    init_is_string();
    ends_with_default = endsWith;
  }
});

// node_modules/@antv/util/esm/every.js
var every, every_default;
var init_every = __esm({
  "node_modules/@antv/util/esm/every.js"() {
    every = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (!func(arr[i2], i2))
          return false;
      }
      return true;
    };
    every_default = every;
  }
});

// node_modules/@antv/util/esm/some.js
var some, some_default;
var init_some = __esm({
  "node_modules/@antv/util/esm/some.js"() {
    some = function(arr, func) {
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (func(arr[i2], i2))
          return true;
      }
      return false;
    };
    some_default = some;
  }
});

// node_modules/@antv/util/esm/group-by.js
function groupBy(data, condition) {
  if (!condition || !is_array_default(data)) {
    return {};
  }
  var result = {};
  var predicate = is_function_default(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i2 = 0; i2 < data.length; i2++) {
    var item = data[i2];
    key = predicate(item);
    if (hasOwnProperty.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
var hasOwnProperty, group_by_default;
var init_group_by = __esm({
  "node_modules/@antv/util/esm/group-by.js"() {
    init_is_array();
    init_is_function();
    hasOwnProperty = Object.prototype.hasOwnProperty;
    group_by_default = groupBy;
  }
});

// node_modules/@antv/util/esm/group-to-map.js
function groupToMap(data, condition) {
  if (!condition) {
    return {
      0: data
    };
  }
  if (!is_function_default(condition)) {
    var paramscondition_1 = is_array_default(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i2 = 0, l2 = paramscondition_1.length; i2 < l2; i2++) {
        unique += row[paramscondition_1[i2]] && row[paramscondition_1[i2]].toString();
      }
      return unique;
    };
  }
  return group_by_default(data, condition);
}
var init_group_to_map = __esm({
  "node_modules/@antv/util/esm/group-to-map.js"() {
    init_is_array();
    init_is_function();
    init_group_by();
  }
});

// node_modules/@antv/util/esm/group.js
var group_default;
var init_group = __esm({
  "node_modules/@antv/util/esm/group.js"() {
    init_group_to_map();
    group_default = function(data, condition) {
      if (!condition) {
        return [data];
      }
      var groups = groupToMap(data, condition);
      var array = [];
      for (var i2 in groups) {
        array.push(groups[i2]);
      }
      return array;
    };
  }
});

// node_modules/@antv/util/esm/get-wrap-behavior.js
function getWrapBehavior(obj, action) {
  return obj["_wrap_" + action];
}
var get_wrap_behavior_default;
var init_get_wrap_behavior = __esm({
  "node_modules/@antv/util/esm/get-wrap-behavior.js"() {
    get_wrap_behavior_default = getWrapBehavior;
  }
});

// node_modules/@antv/util/esm/wrap-behavior.js
function wrapBehavior(obj, action) {
  if (obj["_wrap_" + action]) {
    return obj["_wrap_" + action];
  }
  var method = function(e8) {
    obj[action](e8);
  };
  obj["_wrap_" + action] = method;
  return method;
}
var wrap_behavior_default;
var init_wrap_behavior = __esm({
  "node_modules/@antv/util/esm/wrap-behavior.js"() {
    wrap_behavior_default = wrapBehavior;
  }
});

// node_modules/@antv/util/esm/number2color.js
function numberToColor(num) {
  var color3 = numColorCache[num];
  if (!color3) {
    var str7 = num.toString(16);
    for (var i2 = str7.length; i2 < 6; i2++) {
      str7 = "0" + str7;
    }
    color3 = "#" + str7;
    numColorCache[num] = color3;
  }
  return color3;
}
var numColorCache, number2color_default;
var init_number2color = __esm({
  "node_modules/@antv/util/esm/number2color.js"() {
    numColorCache = {};
    number2color_default = numberToColor;
  }
});

// node_modules/@antv/util/esm/parse-radius.js
function parseRadius(radius) {
  var r1 = 0, r2 = 0, r3 = 0, r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var parse_radius_default;
var init_parse_radius = __esm({
  "node_modules/@antv/util/esm/parse-radius.js"() {
    init_is_array();
    parse_radius_default = parseRadius;
  }
});

// node_modules/@antv/util/esm/clamp.js
var clamp, clamp_default;
var init_clamp = __esm({
  "node_modules/@antv/util/esm/clamp.js"() {
    clamp = function(a2, min6, max7) {
      if (a2 < min6) {
        return min6;
      } else if (a2 > max7) {
        return max7;
      }
      return a2;
    };
    clamp_default = clamp;
  }
});

// node_modules/@antv/util/esm/fixed-base.js
var fixedBase, fixed_base_default;
var init_fixed_base = __esm({
  "node_modules/@antv/util/esm/fixed-base.js"() {
    fixedBase = function(v2, base) {
      var str7 = base.toString();
      var index = str7.indexOf(".");
      if (index === -1) {
        return Math.round(v2);
      }
      var length5 = str7.substr(index + 1).length;
      if (length5 > 20) {
        length5 = 20;
      }
      return parseFloat(v2.toFixed(length5));
    };
    fixed_base_default = fixedBase;
  }
});

// node_modules/@antv/util/esm/is-number.js
var isNumber, is_number_default;
var init_is_number = __esm({
  "node_modules/@antv/util/esm/is-number.js"() {
    init_is_type();
    isNumber = function(value) {
      return is_type_default(value, "Number");
    };
    is_number_default = isNumber;
  }
});

// node_modules/@antv/util/esm/is-decimal.js
var isDecimal, is_decimal_default;
var init_is_decimal = __esm({
  "node_modules/@antv/util/esm/is-decimal.js"() {
    init_is_number();
    isDecimal = function(num) {
      return is_number_default(num) && num % 1 !== 0;
    };
    is_decimal_default = isDecimal;
  }
});

// node_modules/@antv/util/esm/is-even.js
var isEven, is_even_default;
var init_is_even = __esm({
  "node_modules/@antv/util/esm/is-even.js"() {
    init_is_number();
    isEven = function(num) {
      return is_number_default(num) && num % 2 === 0;
    };
    is_even_default = isEven;
  }
});

// node_modules/@antv/util/esm/is-integer.js
var isInteger, is_integer_default;
var init_is_integer = __esm({
  "node_modules/@antv/util/esm/is-integer.js"() {
    init_is_number();
    isInteger = Number.isInteger ? Number.isInteger : function(num) {
      return is_number_default(num) && num % 1 === 0;
    };
    is_integer_default = isInteger;
  }
});

// node_modules/@antv/util/esm/is-negative.js
var isNegative, is_negative_default;
var init_is_negative = __esm({
  "node_modules/@antv/util/esm/is-negative.js"() {
    init_is_number();
    isNegative = function(num) {
      return is_number_default(num) && num < 0;
    };
    is_negative_default = isNegative;
  }
});

// node_modules/@antv/util/esm/is-number-equal.js
function isNumberEqual(a2, b10, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a2 - b10) < precision;
}
var PRECISION;
var init_is_number_equal = __esm({
  "node_modules/@antv/util/esm/is-number-equal.js"() {
    PRECISION = 1e-5;
  }
});

// node_modules/@antv/util/esm/is-odd.js
var isOdd, is_odd_default;
var init_is_odd = __esm({
  "node_modules/@antv/util/esm/is-odd.js"() {
    init_is_number();
    isOdd = function(num) {
      return is_number_default(num) && num % 2 !== 0;
    };
    is_odd_default = isOdd;
  }
});

// node_modules/@antv/util/esm/is-positive.js
var isPositive, is_positive_default;
var init_is_positive = __esm({
  "node_modules/@antv/util/esm/is-positive.js"() {
    init_is_number();
    isPositive = function(num) {
      return is_number_default(num) && num > 0;
    };
    is_positive_default = isPositive;
  }
});

// node_modules/@antv/util/esm/max-by.js
var max_by_default;
var init_max_by = __esm({
  "node_modules/@antv/util/esm/max-by.js"() {
    init_is_array();
    init_is_function();
    max_by_default = function(arr, fn2) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      var maxItem;
      var max7 = -Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default(fn2) ? fn2(item) : item[fn2];
        if (v2 > max7) {
          maxItem = item;
          max7 = v2;
        }
      }
      return maxItem;
    };
  }
});

// node_modules/@antv/util/esm/min-by.js
var min_by_default;
var init_min_by = __esm({
  "node_modules/@antv/util/esm/min-by.js"() {
    init_is_array();
    init_is_function();
    min_by_default = function(arr, fn2) {
      if (!is_array_default(arr)) {
        return void 0;
      }
      var minItem;
      var min6 = Infinity;
      for (var i2 = 0; i2 < arr.length; i2++) {
        var item = arr[i2];
        var v2 = is_function_default(fn2) ? fn2(item) : item[fn2];
        if (v2 < min6) {
          minItem = item;
          min6 = v2;
        }
      }
      return minItem;
    };
  }
});

// node_modules/@antv/util/esm/mod.js
var mod, mod_default;
var init_mod = __esm({
  "node_modules/@antv/util/esm/mod.js"() {
    mod = function(n2, m2) {
      return (n2 % m2 + m2) % m2;
    };
    mod_default = mod;
  }
});

// node_modules/@antv/util/esm/to-degree.js
var DEGREE, toDegree, to_degree_default;
var init_to_degree = __esm({
  "node_modules/@antv/util/esm/to-degree.js"() {
    DEGREE = 180 / Math.PI;
    toDegree = function(radian) {
      return DEGREE * radian;
    };
    to_degree_default = toDegree;
  }
});

// node_modules/@antv/util/esm/to-integer.js
var to_integer_default;
var init_to_integer = __esm({
  "node_modules/@antv/util/esm/to-integer.js"() {
    to_integer_default = parseInt;
  }
});

// node_modules/@antv/util/esm/to-radian.js
var RADIAN, toRadian, to_radian_default;
var init_to_radian = __esm({
  "node_modules/@antv/util/esm/to-radian.js"() {
    RADIAN = Math.PI / 180;
    toRadian = function(degree4) {
      return RADIAN * degree4;
    };
    to_radian_default = toRadian;
  }
});

// node_modules/@antv/util/esm/for-in.js
var for_in_default;
var init_for_in = __esm({
  "node_modules/@antv/util/esm/for-in.js"() {
    init_each();
    for_in_default = each_default;
  }
});

// node_modules/@antv/util/esm/has.js
var has_default;
var init_has = __esm({
  "node_modules/@antv/util/esm/has.js"() {
    has_default = function(obj, key) {
      return obj.hasOwnProperty(key);
    };
  }
});

// node_modules/@antv/util/esm/has-key.js
var has_key_default;
var init_has_key = __esm({
  "node_modules/@antv/util/esm/has-key.js"() {
    init_has();
    has_key_default = has_default;
  }
});

// node_modules/@antv/util/esm/values.js
var values, values_default;
var init_values = __esm({
  "node_modules/@antv/util/esm/values.js"() {
    init_each();
    init_is_function();
    values = Object.values ? function(obj) {
      return Object.values(obj);
    } : function(obj) {
      var result = [];
      each_default(obj, function(value, key) {
        if (!(is_function_default(obj) && key === "prototype")) {
          result.push(value);
        }
      });
      return result;
    };
    values_default = values;
  }
});

// node_modules/@antv/util/esm/has-value.js
var has_value_default;
var init_has_value = __esm({
  "node_modules/@antv/util/esm/has-value.js"() {
    init_contains();
    init_values();
    has_value_default = function(obj, value) {
      return contains_default(values_default(obj), value);
    };
  }
});

// node_modules/@antv/util/esm/to-string.js
var to_string_default;
var init_to_string = __esm({
  "node_modules/@antv/util/esm/to-string.js"() {
    init_is_nil();
    to_string_default = function(value) {
      if (is_nil_default(value))
        return "";
      return value.toString();
    };
  }
});

// node_modules/@antv/util/esm/lower-case.js
var lowerCase, lower_case_default;
var init_lower_case = __esm({
  "node_modules/@antv/util/esm/lower-case.js"() {
    init_to_string();
    lowerCase = function(str7) {
      return to_string_default(str7).toLowerCase();
    };
    lower_case_default = lowerCase;
  }
});

// node_modules/@antv/util/esm/lower-first.js
var lowerFirst, lower_first_default;
var init_lower_first = __esm({
  "node_modules/@antv/util/esm/lower-first.js"() {
    init_to_string();
    lowerFirst = function(value) {
      var str7 = to_string_default(value);
      return str7.charAt(0).toLowerCase() + str7.substring(1);
    };
    lower_first_default = lowerFirst;
  }
});

// node_modules/@antv/util/esm/substitute.js
function substitute(str7, o2) {
  if (!str7 || !o2) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o2[name] === void 0 ? "" : o2[name];
  });
}
var substitute_default;
var init_substitute = __esm({
  "node_modules/@antv/util/esm/substitute.js"() {
    substitute_default = substitute;
  }
});

// node_modules/@antv/util/esm/upper-case.js
var upperCase, upper_case_default;
var init_upper_case = __esm({
  "node_modules/@antv/util/esm/upper-case.js"() {
    init_to_string();
    upperCase = function(str7) {
      return to_string_default(str7).toUpperCase();
    };
    upper_case_default = upperCase;
  }
});

// node_modules/@antv/util/esm/upper-first.js
var upperFirst, upper_first_default;
var init_upper_first = __esm({
  "node_modules/@antv/util/esm/upper-first.js"() {
    init_to_string();
    upperFirst = function(value) {
      var str7 = to_string_default(value);
      return str7.charAt(0).toUpperCase() + str7.substring(1);
    };
    upper_first_default = upperFirst;
  }
});

// node_modules/@antv/util/esm/get-type.js
var toString2, getType, get_type_default;
var init_get_type = __esm({
  "node_modules/@antv/util/esm/get-type.js"() {
    toString2 = {}.toString;
    getType = function(value) {
      return toString2.call(value).replace(/^\[object /, "").replace(/]$/, "");
    };
    get_type_default = getType;
  }
});

// node_modules/@antv/util/esm/is-arguments.js
var isArguments, is_arguments_default;
var init_is_arguments = __esm({
  "node_modules/@antv/util/esm/is-arguments.js"() {
    init_is_type();
    isArguments = function(value) {
      return is_type_default(value, "Arguments");
    };
    is_arguments_default = isArguments;
  }
});

// node_modules/@antv/util/esm/is-boolean.js
var isBoolean, is_boolean_default;
var init_is_boolean = __esm({
  "node_modules/@antv/util/esm/is-boolean.js"() {
    init_is_type();
    isBoolean = function(value) {
      return is_type_default(value, "Boolean");
    };
    is_boolean_default = isBoolean;
  }
});

// node_modules/@antv/util/esm/is-date.js
var isDate, is_date_default;
var init_is_date = __esm({
  "node_modules/@antv/util/esm/is-date.js"() {
    init_is_type();
    isDate = function(value) {
      return is_type_default(value, "Date");
    };
    is_date_default = isDate;
  }
});

// node_modules/@antv/util/esm/is-error.js
var isError, is_error_default;
var init_is_error = __esm({
  "node_modules/@antv/util/esm/is-error.js"() {
    init_is_type();
    isError = function(value) {
      return is_type_default(value, "Error");
    };
    is_error_default = isError;
  }
});

// node_modules/@antv/util/esm/is-finite.js
function is_finite_default(value) {
  return is_number_default(value) && isFinite(value);
}
var init_is_finite = __esm({
  "node_modules/@antv/util/esm/is-finite.js"() {
    init_is_number();
  }
});

// node_modules/@antv/util/esm/is-null.js
var isNull, is_null_default;
var init_is_null = __esm({
  "node_modules/@antv/util/esm/is-null.js"() {
    isNull = function(value) {
      return value === null;
    };
    is_null_default = isNull;
  }
});

// node_modules/@antv/util/esm/is-prototype.js
var objectProto, isPrototype, is_prototype_default;
var init_is_prototype = __esm({
  "node_modules/@antv/util/esm/is-prototype.js"() {
    objectProto = Object.prototype;
    isPrototype = function(value) {
      var Ctor = value && value.constructor;
      var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
      return value === proto;
    };
    is_prototype_default = isPrototype;
  }
});

// node_modules/@antv/util/esm/is-reg-exp.js
var isRegExp, is_reg_exp_default;
var init_is_reg_exp = __esm({
  "node_modules/@antv/util/esm/is-reg-exp.js"() {
    init_is_type();
    isRegExp = function(str7) {
      return is_type_default(str7, "RegExp");
    };
    is_reg_exp_default = isRegExp;
  }
});

// node_modules/@antv/util/esm/is-undefined.js
var isUndefined, is_undefined_default;
var init_is_undefined = __esm({
  "node_modules/@antv/util/esm/is-undefined.js"() {
    isUndefined = function(value) {
      return value === void 0;
    };
    is_undefined_default = isUndefined;
  }
});

// node_modules/@antv/util/esm/is-element.js
var isElement, is_element_default;
var init_is_element = __esm({
  "node_modules/@antv/util/esm/is-element.js"() {
    isElement = function(o2) {
      return o2 instanceof Element || o2 instanceof HTMLDocument;
    };
    is_element_default = isElement;
  }
});

// node_modules/@antv/util/esm/request-animation-frame.js
function requestAnimationFrame2(fn2) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function(f2) {
    return setTimeout(f2, 16);
  };
  return method(fn2);
}
var init_request_animation_frame = __esm({
  "node_modules/@antv/util/esm/request-animation-frame.js"() {
  }
});

// node_modules/@antv/util/esm/clear-animation-frame.js
function cancelAnimationFrame2(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
var init_clear_animation_frame = __esm({
  "node_modules/@antv/util/esm/clear-animation-frame.js"() {
  }
});

// node_modules/@antv/util/esm/mix.js
function _mix(dist4, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist4[key] = obj[key];
    }
  }
}
function mix(dist4, src1, src2, src3) {
  if (src1)
    _mix(dist4, src1);
  if (src2)
    _mix(dist4, src2);
  if (src3)
    _mix(dist4, src3);
  return dist4;
}
var init_mix = __esm({
  "node_modules/@antv/util/esm/mix.js"() {
  }
});

// node_modules/@antv/util/esm/augment.js
var augment, augment_default;
var init_augment = __esm({
  "node_modules/@antv/util/esm/augment.js"() {
    init_mix();
    init_is_function();
    augment = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var c2 = args[0];
      for (var i2 = 1; i2 < args.length; i2++) {
        var obj = args[i2];
        if (is_function_default(obj)) {
          obj = obj.prototype;
        }
        mix(c2.prototype, obj);
      }
    };
    augment_default = augment;
  }
});

// node_modules/@antv/util/esm/clone.js
var clone, clone_default;
var init_clone = __esm({
  "node_modules/@antv/util/esm/clone.js"() {
    init_is_array();
    clone = function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return obj;
      }
      var rst;
      if (is_array_default(obj)) {
        rst = [];
        for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
          if (typeof obj[i2] === "object" && obj[i2] != null) {
            rst[i2] = clone(obj[i2]);
          } else {
            rst[i2] = obj[i2];
          }
        }
      } else {
        rst = {};
        for (var k2 in obj) {
          if (typeof obj[k2] === "object" && obj[k2] != null) {
            rst[k2] = clone(obj[k2]);
          } else {
            rst[k2] = obj[k2];
          }
        }
      }
      return rst;
    };
    clone_default = clone;
  }
});

// node_modules/@antv/util/esm/debounce.js
function debounce(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
var debounce_default;
var init_debounce = __esm({
  "node_modules/@antv/util/esm/debounce.js"() {
    debounce_default = debounce;
  }
});

// node_modules/@antv/util/esm/memoize.js
var memoize_default;
var init_memoize = __esm({
  "node_modules/@antv/util/esm/memoize.js"() {
    init_is_function();
    memoize_default = function(f2, resolver) {
      if (!is_function_default(f2)) {
        throw new TypeError("Expected a function");
      }
      var memoized = function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var key = resolver ? resolver.apply(this, args) : args[0];
        var cache3 = memoized.cache;
        if (cache3.has(key)) {
          return cache3.get(key);
        }
        var result = f2.apply(this, args);
        cache3.set(key, result);
        return result;
      };
      memoized.cache = /* @__PURE__ */ new Map();
      return memoized;
    };
  }
});

// node_modules/@antv/util/esm/deep-mix.js
function _deepMix(dist4, src, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      var value = src[key];
      if (value !== null && is_plain_object_default(value)) {
        if (!is_plain_object_default(dist4[key])) {
          dist4[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist4[key], value, level + 1, maxLevel);
        } else {
          dist4[key] = src[key];
        }
      } else if (is_array_default(value)) {
        dist4[key] = [];
        dist4[key] = dist4[key].concat(value);
      } else if (value !== void 0) {
        dist4[key] = value;
      }
    }
  }
}
var MAX_MIX_LEVEL, deepMix, deep_mix_default;
var init_deep_mix = __esm({
  "node_modules/@antv/util/esm/deep-mix.js"() {
    init_is_array();
    init_is_plain_object();
    MAX_MIX_LEVEL = 5;
    deepMix = function(rst) {
      var args = [];
      for (var _i2 = 1; _i2 < arguments.length; _i2++) {
        args[_i2 - 1] = arguments[_i2];
      }
      for (var i2 = 0; i2 < args.length; i2 += 1) {
        _deepMix(rst, args[i2]);
      }
      return rst;
    };
    deep_mix_default = deepMix;
  }
});

// node_modules/@antv/util/esm/extend.js
var extend, extend_default;
var init_extend = __esm({
  "node_modules/@antv/util/esm/extend.js"() {
    init_mix();
    init_is_function();
    extend = function(subclass, superclass, overrides, staticOverrides) {
      if (!is_function_default(superclass)) {
        overrides = superclass;
        superclass = subclass;
        subclass = function() {
        };
      }
      var create8 = Object.create ? function(proto, c2) {
        return Object.create(proto, {
          constructor: {
            value: c2
          }
        });
      } : function(proto, c2) {
        function Tmp() {
        }
        Tmp.prototype = proto;
        var o2 = new Tmp();
        o2.constructor = c2;
        return o2;
      };
      var superObj = create8(superclass.prototype, subclass);
      subclass.prototype = mix(superObj, subclass.prototype);
      subclass.superclass = create8(superclass.prototype, superclass);
      mix(superObj, overrides);
      mix(subclass, staticOverrides);
      return subclass;
    };
    extend_default = extend;
  }
});

// node_modules/@antv/util/esm/index-of.js
var indexOf2, index_of_default;
var init_index_of = __esm({
  "node_modules/@antv/util/esm/index-of.js"() {
    init_is_array_like();
    indexOf2 = function(arr, obj) {
      if (!is_array_like_default(arr)) {
        return -1;
      }
      var m2 = Array.prototype.indexOf;
      if (m2) {
        return m2.call(arr, obj);
      }
      var index = -1;
      for (var i2 = 0; i2 < arr.length; i2++) {
        if (arr[i2] === obj) {
          index = i2;
          break;
        }
      }
      return index;
    };
    index_of_default = indexOf2;
  }
});

// node_modules/@antv/util/esm/is-empty.js
function isEmpty(value) {
  if (is_nil_default(value)) {
    return true;
  }
  if (is_array_like_default(value)) {
    return !value.length;
  }
  var type = get_type_default(value);
  if (type === "Map" || type === "Set") {
    return !value.size;
  }
  if (is_prototype_default(value)) {
    return !Object.keys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty2.call(value, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty2, is_empty_default;
var init_is_empty = __esm({
  "node_modules/@antv/util/esm/is-empty.js"() {
    init_is_nil();
    init_is_array_like();
    init_get_type();
    init_is_prototype();
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    is_empty_default = isEmpty;
  }
});

// node_modules/@antv/util/esm/is-equal.js
var isEqual, is_equal_default;
var init_is_equal = __esm({
  "node_modules/@antv/util/esm/is-equal.js"() {
    init_is_object_like();
    init_is_array_like();
    init_is_string();
    isEqual = function(value, other) {
      if (value === other) {
        return true;
      }
      if (!value || !other) {
        return false;
      }
      if (is_string_default(value) || is_string_default(other)) {
        return false;
      }
      if (is_array_like_default(value) || is_array_like_default(other)) {
        if (value.length !== other.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < value.length; i2++) {
          rst = isEqual(value[i2], other[i2]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      if (is_object_like_default(value) || is_object_like_default(other)) {
        var valueKeys = Object.keys(value);
        var otherKeys = Object.keys(other);
        if (valueKeys.length !== otherKeys.length) {
          return false;
        }
        var rst = true;
        for (var i2 = 0; i2 < valueKeys.length; i2++) {
          rst = isEqual(value[valueKeys[i2]], other[valueKeys[i2]]);
          if (!rst) {
            break;
          }
        }
        return rst;
      }
      return false;
    };
    is_equal_default = isEqual;
  }
});

// node_modules/@antv/util/esm/is-equal-with.js
var is_equal_with_default;
var init_is_equal_with = __esm({
  "node_modules/@antv/util/esm/is-equal-with.js"() {
    init_is_function();
    init_is_equal();
    is_equal_with_default = function(value, other, fn2) {
      if (!is_function_default(fn2)) {
        return is_equal_default(value, other);
      }
      return !!fn2(value, other);
    };
  }
});

// node_modules/@antv/util/esm/map.js
var map, map_default;
var init_map = __esm({
  "node_modules/@antv/util/esm/map.js"() {
    init_is_array_like();
    map = function(arr, func) {
      if (!is_array_like_default(arr)) {
        return arr;
      }
      var result = [];
      for (var index = 0; index < arr.length; index++) {
        var value = arr[index];
        result.push(func(value, index));
      }
      return result;
    };
    map_default = map;
  }
});

// node_modules/@antv/util/esm/map-values.js
var identity, map_values_default;
var init_map_values = __esm({
  "node_modules/@antv/util/esm/map-values.js"() {
    init_is_nil();
    init_is_object();
    identity = function(v2) {
      return v2;
    };
    map_values_default = function(object, func) {
      if (func === void 0) {
        func = identity;
      }
      var r2 = {};
      if (is_object_default(object) && !is_nil_default(object)) {
        Object.keys(object).forEach(function(key) {
          r2[key] = func(object[key], key);
        });
      }
      return r2;
    };
  }
});

// node_modules/@antv/util/esm/get.js
var get_default;
var init_get = __esm({
  "node_modules/@antv/util/esm/get.js"() {
    init_is_string();
    get_default = function(obj, key, defaultValue) {
      var p2 = 0;
      var keyArr = is_string_default(key) ? key.split(".") : key;
      while (obj && p2 < keyArr.length) {
        obj = obj[keyArr[p2++]];
      }
      return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
    };
  }
});

// node_modules/@antv/util/esm/set.js
var set_default;
var init_set = __esm({
  "node_modules/@antv/util/esm/set.js"() {
    init_is_object();
    init_is_string();
    init_is_number();
    set_default = function(obj, path, value) {
      var o2 = obj;
      var keyArr = is_string_default(path) ? path.split(".") : path;
      keyArr.forEach(function(key, idx) {
        if (idx < keyArr.length - 1) {
          if (!is_object_default(o2[key])) {
            o2[key] = is_number_default(keyArr[idx + 1]) ? [] : {};
          }
          o2 = o2[key];
        } else {
          o2[key] = value;
        }
      });
      return obj;
    };
  }
});

// node_modules/@antv/util/esm/pick.js
var hasOwnProperty3, pick_default;
var init_pick = __esm({
  "node_modules/@antv/util/esm/pick.js"() {
    init_each();
    init_is_plain_object();
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
    pick_default = function(object, keys2) {
      if (object === null || !is_plain_object_default(object)) {
        return {};
      }
      var result = {};
      each_default(keys2, function(key) {
        if (hasOwnProperty3.call(object, key)) {
          result[key] = object[key];
        }
      });
      return result;
    };
  }
});

// node_modules/@antv/util/esm/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/@antv/util/esm/omit.js"() {
    init_reduce();
    omit_default = function(obj, keys2) {
      return reduce_default(obj, function(r2, curr, key) {
        if (!keys2.includes(key)) {
          r2[key] = curr;
        }
        return r2;
      }, {});
    };
  }
});

// node_modules/@antv/util/esm/throttle.js
var throttle_default;
var init_throttle = __esm({
  "node_modules/@antv/util/esm/throttle.js"() {
    throttle_default = function(func, wait, options) {
      var timeout2, context, args, result;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : Date.now();
        timeout2 = null;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      };
      var throttled = function() {
        var now2 = Date.now();
        if (!previous && options.leading === false)
          previous = now2;
        var remaining = wait - (now2 - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout2) {
            clearTimeout(timeout2);
            timeout2 = null;
          }
          previous = now2;
          result = func.apply(context, args);
          if (!timeout2)
            context = args = null;
        } else if (!timeout2 && options.trailing !== false) {
          timeout2 = setTimeout(later, remaining);
        }
        return result;
      };
      throttled.cancel = function() {
        clearTimeout(timeout2);
        previous = 0;
        timeout2 = context = args = null;
      };
      return throttled;
    };
  }
});

// node_modules/@antv/util/esm/to-array.js
var to_array_default;
var init_to_array = __esm({
  "node_modules/@antv/util/esm/to-array.js"() {
    init_is_array_like();
    to_array_default = function(value) {
      return is_array_like_default(value) ? Array.prototype.slice.call(value) : [];
    };
  }
});

// node_modules/@antv/util/esm/unique-id.js
var map2, unique_id_default;
var init_unique_id = __esm({
  "node_modules/@antv/util/esm/unique-id.js"() {
    map2 = {};
    unique_id_default = function(prefix) {
      prefix = prefix || "g";
      if (!map2[prefix]) {
        map2[prefix] = 1;
      } else {
        map2[prefix] += 1;
      }
      return prefix + map2[prefix];
    };
  }
});

// node_modules/@antv/util/esm/noop.js
var noop_default;
var init_noop = __esm({
  "node_modules/@antv/util/esm/noop.js"() {
    noop_default = function() {
    };
  }
});

// node_modules/@antv/util/esm/identity.js
var identity_default;
var init_identity = __esm({
  "node_modules/@antv/util/esm/identity.js"() {
    identity_default = function(v2) {
      return v2;
    };
  }
});

// node_modules/@antv/util/esm/size.js
function size(o2) {
  if (is_nil_default(o2)) {
    return 0;
  }
  if (is_array_like_default(o2)) {
    return o2.length;
  }
  return Object.keys(o2).length;
}
var init_size = __esm({
  "node_modules/@antv/util/esm/size.js"() {
    init_is_nil();
    init_is_array_like();
  }
});

// node_modules/@antv/util/node_modules/tslib/tslib.es6.js
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
var init_tslib_es6 = __esm({
  "node_modules/@antv/util/node_modules/tslib/tslib.es6.js"() {
  }
});

// node_modules/@antv/util/esm/measure-text-width.js
var ctx, measure_text_width_default;
var init_measure_text_width = __esm({
  "node_modules/@antv/util/esm/measure-text-width.js"() {
    init_tslib_es6();
    init_values();
    init_memoize();
    init_is_string();
    measure_text_width_default = memoize_default(function(text, font) {
      if (font === void 0) {
        font = {};
      }
      var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
      if (!ctx) {
        ctx = document.createElement("canvas").getContext("2d");
      }
      ctx.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
      return ctx.measureText(is_string_default(text) ? text : "").width;
    }, function(text, font) {
      if (font === void 0) {
        font = {};
      }
      return __spreadArrays([text], values_default(font)).join("");
    });
  }
});

// node_modules/@antv/util/esm/get-ellipsis-text.js
var get_ellipsis_text_default;
var init_get_ellipsis_text = __esm({
  "node_modules/@antv/util/esm/get-ellipsis-text.js"() {
    init_is_string();
    init_to_string();
    init_measure_text_width();
    get_ellipsis_text_default = function(text, maxWidth, font, str7) {
      if (str7 === void 0) {
        str7 = "...";
      }
      var STEP = 16;
      var PLACEHOLDER_WIDTH = measure_text_width_default(str7, font);
      var leftText = !is_string_default(text) ? to_string_default(text) : text;
      var leftWidth = maxWidth;
      var r2 = [];
      var currentText;
      var currentWidth;
      if (measure_text_width_default(text, font) <= maxWidth) {
        return text;
      }
      while (true) {
        currentText = leftText.substr(0, STEP);
        currentWidth = measure_text_width_default(currentText, font);
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
          if (currentWidth > leftWidth) {
            break;
          }
        }
        r2.push(currentText);
        leftWidth -= currentWidth;
        leftText = leftText.substr(STEP);
        if (!leftText) {
          return r2.join("");
        }
      }
      while (true) {
        currentText = leftText.substr(0, 1);
        currentWidth = measure_text_width_default(currentText, font);
        if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
          break;
        }
        r2.push(currentText);
        leftWidth -= currentWidth;
        leftText = leftText.substr(1);
        if (!leftText) {
          return r2.join("");
        }
      }
      return "" + r2.join("") + str7;
    };
  }
});

// node_modules/@antv/util/esm/cache.js
var default_1, cache_default;
var init_cache = __esm({
  "node_modules/@antv/util/esm/cache.js"() {
    default_1 = function() {
      function default_12() {
        this.map = {};
      }
      default_12.prototype.has = function(key) {
        return this.map[key] !== void 0;
      };
      default_12.prototype.get = function(key, def) {
        var v2 = this.map[key];
        return v2 === void 0 ? def : v2;
      };
      default_12.prototype.set = function(key, value) {
        this.map[key] = value;
      };
      default_12.prototype.clear = function() {
        this.map = {};
      };
      default_12.prototype.delete = function(key) {
        delete this.map[key];
      };
      default_12.prototype.size = function() {
        return Object.keys(this.map).length;
      };
      return default_12;
    }();
    cache_default = default_1;
  }
});

// node_modules/@antv/util/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Cache: () => cache_default,
  assign: () => mix,
  augment: () => augment_default,
  clamp: () => clamp_default,
  clearAnimationFrame: () => cancelAnimationFrame2,
  clone: () => clone_default,
  contains: () => contains_default,
  debounce: () => debounce_default,
  deepMix: () => deep_mix_default,
  difference: () => difference_default,
  each: () => each_default,
  endsWith: () => ends_with_default,
  every: () => every_default,
  extend: () => extend_default,
  filter: () => filter_default,
  find: () => find_default,
  findIndex: () => find_index_default,
  firstValue: () => first_value_default,
  fixedBase: () => fixed_base_default,
  flatten: () => flatten_default,
  flattenDeep: () => flatten_deep_default,
  forIn: () => for_in_default,
  get: () => get_default,
  getEllipsisText: () => get_ellipsis_text_default,
  getRange: () => get_range_default,
  getType: () => get_type_default,
  getWrapBehavior: () => get_wrap_behavior_default,
  group: () => group_default,
  groupBy: () => group_by_default,
  groupToMap: () => groupToMap,
  has: () => has_default,
  hasKey: () => has_key_default,
  hasValue: () => has_value_default,
  head: () => head,
  identity: () => identity_default,
  includes: () => contains_default,
  indexOf: () => index_of_default,
  isArguments: () => is_arguments_default,
  isArray: () => is_array_default,
  isArrayLike: () => is_array_like_default,
  isBoolean: () => is_boolean_default,
  isDate: () => is_date_default,
  isDecimal: () => is_decimal_default,
  isElement: () => is_element_default,
  isEmpty: () => is_empty_default,
  isEqual: () => is_equal_default,
  isEqualWith: () => is_equal_with_default,
  isError: () => is_error_default,
  isEven: () => is_even_default,
  isFinite: () => is_finite_default,
  isFunction: () => is_function_default,
  isInteger: () => is_integer_default,
  isMatch: () => is_match_default,
  isNegative: () => is_negative_default,
  isNil: () => is_nil_default,
  isNull: () => is_null_default,
  isNumber: () => is_number_default,
  isNumberEqual: () => isNumberEqual,
  isObject: () => is_object_default,
  isObjectLike: () => is_object_like_default,
  isOdd: () => is_odd_default,
  isPlainObject: () => is_plain_object_default,
  isPositive: () => is_positive_default,
  isPrototype: () => is_prototype_default,
  isRegExp: () => is_reg_exp_default,
  isString: () => is_string_default,
  isType: () => is_type_default,
  isUndefined: () => is_undefined_default,
  keys: () => keys_default,
  last: () => last,
  lowerCase: () => lower_case_default,
  lowerFirst: () => lower_first_default,
  map: () => map_default,
  mapValues: () => map_values_default,
  max: () => max_default,
  maxBy: () => max_by_default,
  measureTextWidth: () => measure_text_width_default,
  memoize: () => memoize_default,
  min: () => min_default,
  minBy: () => min_by_default,
  mix: () => mix,
  mod: () => mod_default,
  noop: () => noop_default,
  number2color: () => number2color_default,
  omit: () => omit_default,
  parseRadius: () => parse_radius_default,
  pick: () => pick_default,
  pull: () => pull_default,
  pullAt: () => pull_at_default,
  reduce: () => reduce_default,
  remove: () => remove_default,
  requestAnimationFrame: () => requestAnimationFrame2,
  set: () => set_default,
  size: () => size,
  some: () => some_default,
  sortBy: () => sort_by_default,
  startsWith: () => starts_with_default,
  substitute: () => substitute_default,
  throttle: () => throttle_default,
  toArray: () => to_array_default,
  toDegree: () => to_degree_default,
  toInteger: () => to_integer_default,
  toRadian: () => to_radian_default,
  toString: () => to_string_default,
  union: () => union_default,
  uniq: () => uniq,
  uniqueId: () => unique_id_default,
  upperCase: () => upper_case_default,
  upperFirst: () => upper_first_default,
  values: () => values_default,
  valuesOfKey: () => values_of_key_default,
  wrapBehavior: () => wrap_behavior_default
});
var init_esm = __esm({
  "node_modules/@antv/util/esm/index.js"() {
    init_contains();
    init_difference();
    init_find();
    init_find_index();
    init_first_value();
    init_flatten();
    init_flatten_deep();
    init_get_range();
    init_pull();
    init_pull_at();
    init_reduce();
    init_remove();
    init_sort_by();
    init_union();
    init_uniq();
    init_values_of_key();
    init_head();
    init_last();
    init_starts_with();
    init_ends_with();
    init_filter();
    init_every();
    init_some();
    init_group();
    init_group_by();
    init_group_to_map();
    init_get_wrap_behavior();
    init_wrap_behavior();
    init_number2color();
    init_parse_radius();
    init_clamp();
    init_fixed_base();
    init_is_decimal();
    init_is_even();
    init_is_integer();
    init_is_negative();
    init_is_number_equal();
    init_is_odd();
    init_is_positive();
    init_max();
    init_max_by();
    init_min();
    init_min_by();
    init_mod();
    init_to_degree();
    init_to_integer();
    init_to_radian();
    init_for_in();
    init_has();
    init_has_key();
    init_has_value();
    init_keys();
    init_is_match();
    init_values();
    init_lower_case();
    init_lower_first();
    init_substitute();
    init_upper_case();
    init_upper_first();
    init_get_type();
    init_is_arguments();
    init_is_array();
    init_is_array_like();
    init_is_boolean();
    init_is_date();
    init_is_error();
    init_is_function();
    init_is_finite();
    init_is_nil();
    init_is_null();
    init_is_number();
    init_is_object();
    init_is_object_like();
    init_is_plain_object();
    init_is_prototype();
    init_is_reg_exp();
    init_is_string();
    init_is_type();
    init_is_undefined();
    init_is_element();
    init_request_animation_frame();
    init_clear_animation_frame();
    init_augment();
    init_clone();
    init_debounce();
    init_memoize();
    init_deep_mix();
    init_each();
    init_extend();
    init_index_of();
    init_is_empty();
    init_is_equal();
    init_is_equal_with();
    init_map();
    init_map_values();
    init_mix();
    init_get();
    init_set();
    init_pick();
    init_omit();
    init_throttle();
    init_to_array();
    init_to_string();
    init_unique_id();
    init_noop();
    init_identity();
    init_size();
    init_measure_text_width();
    init_get_ellipsis_text();
    init_cache();
  }
});

// node_modules/gl-matrix/esm/common.js
var EPSILON, ARRAY_TYPE, RANDOM, degree;
var init_common = __esm({
  "node_modules/gl-matrix/esm/common.js"() {
    EPSILON = 1e-6;
    ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
    RANDOM = Math.random;
    degree = Math.PI / 180;
    if (!Math.hypot)
      Math.hypot = function() {
        var y2 = 0, i2 = arguments.length;
        while (i2--) {
          y2 += arguments[i2] * arguments[i2];
        }
        return Math.sqrt(y2);
      };
  }
});

// node_modules/gl-matrix/esm/mat2.js
var init_mat2 = __esm({
  "node_modules/gl-matrix/esm/mat2.js"() {
    init_common();
  }
});

// node_modules/gl-matrix/esm/mat2d.js
var init_mat2d = __esm({
  "node_modules/gl-matrix/esm/mat2d.js"() {
    init_common();
  }
});

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add,
  adjoint: () => adjoint,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity2,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set2,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[4];
  out[4] = a2[5];
  out[5] = a2[6];
  out[6] = a2[8];
  out[7] = a2[9];
  out[8] = a2[10];
  return out;
}
function clone2(a2) {
  var out = new ARRAY_TYPE(9);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function copy(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a12 = a2[5];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a01;
    out[5] = a2[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a2[0];
    out[1] = a2[3];
    out[2] = a2[6];
    out[3] = a2[1];
    out[4] = a2[4];
    out[5] = a2[7];
    out[6] = a2[2];
    out[7] = a2[5];
    out[8] = a2[8];
  }
  return out;
}
function invert(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a2, b10) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2];
  var a10 = a2[3], a11 = a2[4], a12 = a2[5];
  var a20 = a2[6], a21 = a2[7], a22 = a2[8];
  var b00 = b10[0], b01 = b10[1], b02 = b10[2];
  var b102 = b10[3], b11 = b10[4], b12 = b10[5];
  var b20 = b10[6], b21 = b10[7], b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a2, v2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], x2 = v2[0], y2 = v2[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x2 * a00 + y2 * a10 + a20;
  out[7] = x2 * a01 + y2 * a11 + a21;
  out[8] = x2 * a02 + y2 * a12 + a22;
  return out;
}
function rotate(out, a2, rad) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a10 = a2[3], a11 = a2[4], a12 = a2[5], a20 = a2[6], a21 = a2[7], a22 = a2[8], s2 = Math.sin(rad), c2 = Math.cos(rad);
  out[0] = c2 * a00 + s2 * a10;
  out[1] = c2 * a01 + s2 * a11;
  out[2] = c2 * a02 + s2 * a12;
  out[3] = c2 * a10 - s2 * a00;
  out[4] = c2 * a11 - s2 * a01;
  out[5] = c2 * a12 - s2 * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a2, v2) {
  var x2 = v2[0], y2 = v2[1];
  out[0] = x2 * a2[0];
  out[1] = x2 * a2[1];
  out[2] = x2 * a2[2];
  out[3] = y2 * a2[3];
  out[4] = y2 * a2[4];
  out[5] = y2 * a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  return out;
}
function fromTranslation(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v2[0];
  out[7] = v2[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s2 = Math.sin(rad), c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = -s2;
  out[4] = c2;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v2[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = 0;
  out[3] = a2[2];
  out[4] = a2[3];
  out[5] = 0;
  out[6] = a2[4];
  out[7] = a2[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q2) {
  var x2 = q2[0], y2 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var yx = y2 * x22;
  var yy = y2 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a2) {
  return "mat3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ")";
}
function frob(a2) {
  return Math.hypot(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8]);
}
function add(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  out[2] = a2[2] + b10[2];
  out[3] = a2[3] + b10[3];
  out[4] = a2[4] + b10[4];
  out[5] = a2[5] + b10[5];
  out[6] = a2[6] + b10[6];
  out[7] = a2[7] + b10[7];
  out[8] = a2[8] + b10[8];
  return out;
}
function subtract(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  out[2] = a2[2] - b10[2];
  out[3] = a2[3] - b10[3];
  out[4] = a2[4] - b10[4];
  out[5] = a2[5] - b10[5];
  out[6] = a2[6] - b10[6];
  out[7] = a2[7] - b10[7];
  out[8] = a2[8] - b10[8];
  return out;
}
function multiplyScalar(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  out[2] = a2[2] * b10;
  out[3] = a2[3] * b10;
  out[4] = a2[4] * b10;
  out[5] = a2[5] * b10;
  out[6] = a2[6] * b10;
  out[7] = a2[7] * b10;
  out[8] = a2[8] * b10;
  return out;
}
function multiplyScalarAndAdd(out, a2, b10, scale9) {
  out[0] = a2[0] + b10[0] * scale9;
  out[1] = a2[1] + b10[1] * scale9;
  out[2] = a2[2] + b10[2] * scale9;
  out[3] = a2[3] + b10[3] * scale9;
  out[4] = a2[4] + b10[4] * scale9;
  out[5] = a2[5] + b10[5] * scale9;
  out[6] = a2[6] + b10[6] * scale9;
  out[7] = a2[7] + b10[7] * scale9;
  out[8] = a2[8] + b10[8] * scale9;
  return out;
}
function exactEquals(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1] && a2[2] === b10[2] && a2[3] === b10[3] && a2[4] === b10[4] && a2[5] === b10[5] && a2[6] === b10[6] && a2[7] === b10[7] && a2[8] === b10[8];
}
function equals(a2, b10) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3], a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7], a8 = a2[8];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82));
}
var mul, sub;
var init_mat3 = __esm({
  "node_modules/gl-matrix/esm/mat3.js"() {
    init_common();
    mul = multiply;
    sub = subtract;
  }
});

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add2,
  adjoint: () => adjoint2,
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals2,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity3,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set3,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract2,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone3(a2) {
  var out = new ARRAY_TYPE(16);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function copy2(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  out[4] = a2[4];
  out[5] = a2[5];
  out[6] = a2[6];
  out[7] = a2[7];
  out[8] = a2[8];
  out[9] = a2[9];
  out[10] = a2[10];
  out[11] = a2[11];
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity3(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a2) {
  if (out === a2) {
    var a01 = a2[1], a02 = a2[2], a03 = a2[3];
    var a12 = a2[6], a13 = a2[7];
    var a23 = a2[11];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a01;
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a2[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a2[0];
    out[1] = a2[4];
    out[2] = a2[8];
    out[3] = a2[12];
    out[4] = a2[1];
    out[5] = a2[5];
    out[6] = a2[9];
    out[7] = a2[13];
    out[8] = a2[2];
    out[9] = a2[6];
    out[10] = a2[10];
    out[11] = a2[14];
    out[12] = a2[3];
    out[13] = a2[7];
    out[14] = a2[11];
    out[15] = a2[15];
  }
  return out;
}
function invert2(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a2) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a2, b10) {
  var a00 = a2[0], a01 = a2[1], a02 = a2[2], a03 = a2[3];
  var a10 = a2[4], a11 = a2[5], a12 = a2[6], a13 = a2[7];
  var a20 = a2[8], a21 = a2[9], a22 = a2[10], a23 = a2[11];
  var a30 = a2[12], a31 = a2[13], a32 = a2[14], a33 = a2[15];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  out[0] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[1] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[2] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[3] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[4];
  b12 = b10[5];
  b22 = b10[6];
  b32 = b10[7];
  out[4] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[5] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[6] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[7] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[8];
  b12 = b10[9];
  b22 = b10[10];
  b32 = b10[11];
  out[8] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[9] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[10] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[11] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  b02 = b10[12];
  b12 = b10[13];
  b22 = b10[14];
  b32 = b10[15];
  out[12] = b02 * a00 + b12 * a10 + b22 * a20 + b32 * a30;
  out[13] = b02 * a01 + b12 * a11 + b22 * a21 + b32 * a31;
  out[14] = b02 * a02 + b12 * a12 + b22 * a22 + b32 * a32;
  out[15] = b02 * a03 + b12 * a13 + b22 * a23 + b32 * a33;
  return out;
}
function translate2(out, a2, v2) {
  var x2 = v2[0], y2 = v2[1], z2 = v2[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a2 === out) {
    out[12] = a2[0] * x2 + a2[4] * y2 + a2[8] * z2 + a2[12];
    out[13] = a2[1] * x2 + a2[5] * y2 + a2[9] * z2 + a2[13];
    out[14] = a2[2] * x2 + a2[6] * y2 + a2[10] * z2 + a2[14];
    out[15] = a2[3] * x2 + a2[7] * y2 + a2[11] * z2 + a2[15];
  } else {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x2 + a10 * y2 + a20 * z2 + a2[12];
    out[13] = a01 * x2 + a11 * y2 + a21 * z2 + a2[13];
    out[14] = a02 * x2 + a12 * y2 + a22 * z2 + a2[14];
    out[15] = a03 * x2 + a13 * y2 + a23 * z2 + a2[15];
  }
  return out;
}
function scale2(out, a2, v2) {
  var x2 = v2[0], y2 = v2[1], z2 = v2[2];
  out[0] = a2[0] * x2;
  out[1] = a2[1] * x2;
  out[2] = a2[2] * x2;
  out[3] = a2[3] * x2;
  out[4] = a2[4] * y2;
  out[5] = a2[5] * y2;
  out[6] = a2[6] * y2;
  out[7] = a2[7] * y2;
  out[8] = a2[8] * z2;
  out[9] = a2[9] * z2;
  out[10] = a2[10] * z2;
  out[11] = a2[11] * z2;
  out[12] = a2[12];
  out[13] = a2[13];
  out[14] = a2[14];
  out[15] = a2[15];
  return out;
}
function rotate2(out, a2, rad, axis) {
  var x2 = axis[0], y2 = axis[1], z2 = axis[2];
  var len5 = Math.hypot(x2, y2, z2);
  var s2, c2, t4;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t4 = 1 - c2;
  a00 = a2[0];
  a01 = a2[1];
  a02 = a2[2];
  a03 = a2[3];
  a10 = a2[4];
  a11 = a2[5];
  a12 = a2[6];
  a13 = a2[7];
  a20 = a2[8];
  a21 = a2[9];
  a22 = a2[10];
  a23 = a2[11];
  b00 = x2 * x2 * t4 + c2;
  b01 = y2 * x2 * t4 + z2 * s2;
  b02 = z2 * x2 * t4 - y2 * s2;
  b10 = x2 * y2 * t4 - z2 * s2;
  b11 = y2 * y2 * t4 + c2;
  b12 = z2 * y2 * t4 + x2 * s2;
  b20 = x2 * z2 * t4 + y2 * s2;
  b21 = y2 * z2 * t4 - x2 * s2;
  b22 = z2 * z2 * t4 + c2;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a2 !== out) {
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  return out;
}
function rotateX(out, a2, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[0] = a2[0];
    out[1] = a2[1];
    out[2] = a2[2];
    out[3] = a2[3];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[4] = a10 * c2 + a20 * s2;
  out[5] = a11 * c2 + a21 * s2;
  out[6] = a12 * c2 + a22 * s2;
  out[7] = a13 * c2 + a23 * s2;
  out[8] = a20 * c2 - a10 * s2;
  out[9] = a21 * c2 - a11 * s2;
  out[10] = a22 * c2 - a12 * s2;
  out[11] = a23 * c2 - a13 * s2;
  return out;
}
function rotateY(out, a2, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a20 = a2[8];
  var a21 = a2[9];
  var a22 = a2[10];
  var a23 = a2[11];
  if (a2 !== out) {
    out[4] = a2[4];
    out[5] = a2[5];
    out[6] = a2[6];
    out[7] = a2[7];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 - a20 * s2;
  out[1] = a01 * c2 - a21 * s2;
  out[2] = a02 * c2 - a22 * s2;
  out[3] = a03 * c2 - a23 * s2;
  out[8] = a00 * s2 + a20 * c2;
  out[9] = a01 * s2 + a21 * c2;
  out[10] = a02 * s2 + a22 * c2;
  out[11] = a03 * s2 + a23 * c2;
  return out;
}
function rotateZ(out, a2, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a03 = a2[3];
  var a10 = a2[4];
  var a11 = a2[5];
  var a12 = a2[6];
  var a13 = a2[7];
  if (a2 !== out) {
    out[8] = a2[8];
    out[9] = a2[9];
    out[10] = a2[10];
    out[11] = a2[11];
    out[12] = a2[12];
    out[13] = a2[13];
    out[14] = a2[14];
    out[15] = a2[15];
  }
  out[0] = a00 * c2 + a10 * s2;
  out[1] = a01 * c2 + a11 * s2;
  out[2] = a02 * c2 + a12 * s2;
  out[3] = a03 * c2 + a13 * s2;
  out[4] = a10 * c2 - a00 * s2;
  out[5] = a11 * c2 - a01 * s2;
  out[6] = a12 * c2 - a02 * s2;
  out[7] = a13 * c2 - a03 * s2;
  return out;
}
function fromTranslation2(out, v2) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v2) {
  out[0] = v2[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v2[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v2[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x2 = axis[0], y2 = axis[1], z2 = axis[2];
  var len5 = Math.hypot(x2, y2, z2);
  var s2, c2, t4;
  if (len5 < EPSILON) {
    return null;
  }
  len5 = 1 / len5;
  x2 *= len5;
  y2 *= len5;
  z2 *= len5;
  s2 = Math.sin(rad);
  c2 = Math.cos(rad);
  t4 = 1 - c2;
  out[0] = x2 * x2 * t4 + c2;
  out[1] = y2 * x2 * t4 + z2 * s2;
  out[2] = z2 * x2 * t4 - y2 * s2;
  out[3] = 0;
  out[4] = x2 * y2 * t4 - z2 * s2;
  out[5] = y2 * y2 * t4 + c2;
  out[6] = z2 * y2 * t4 + x2 * s2;
  out[7] = 0;
  out[8] = x2 * z2 * t4 + y2 * s2;
  out[9] = y2 * z2 * t4 - x2 * s2;
  out[10] = z2 * z2 * t4 + c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c2;
  out[6] = s2;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s2;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = 0;
  out[2] = -s2;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s2;
  out[9] = 0;
  out[10] = c2;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s2 = Math.sin(rad);
  var c2 = Math.cos(rad);
  out[0] = c2;
  out[1] = s2;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s2;
  out[5] = c2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q2, v2) {
  var x2 = q2[0], y2 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a2) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a2[0], by = -a2[1], bz = -a2[2], bw = a2[3], ax = a2[4], ay = a2[5], az = a2[6], aw = a2[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a2, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S2 = 0;
  if (trace > 0) {
    S2 = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S2;
    out[0] = (sm23 - sm32) / S2;
    out[1] = (sm31 - sm13) / S2;
    out[2] = (sm12 - sm21) / S2;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S2 = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S2;
    out[0] = 0.25 * S2;
    out[1] = (sm12 + sm21) / S2;
    out[2] = (sm31 + sm13) / S2;
  } else if (sm22 > sm33) {
    S2 = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S2;
    out[0] = (sm12 + sm21) / S2;
    out[1] = 0.25 * S2;
    out[2] = (sm23 + sm32) / S2;
  } else {
    S2 = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S2;
    out[0] = (sm31 + sm13) / S2;
    out[1] = (sm23 + sm32) / S2;
    out[2] = 0.25 * S2;
  }
  return out;
}
function fromRotationTranslationScale(out, q2, v2, s2) {
  var x2 = q2[0], y2 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v2[0];
  out[13] = v2[1];
  out[14] = v2[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q2, v2, s2, o2) {
  var x2 = q2[0], y2 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var xy = x2 * y22;
  var xz = x2 * z22;
  var yy = y2 * y22;
  var yz = y2 * z22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  var sx = s2[0];
  var sy = s2[1];
  var sz = s2[2];
  var ox = o2[0];
  var oy = o2[1];
  var oz = o2[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v2[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v2[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v2[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q2) {
  var x2 = q2[0], y2 = q2[1], z2 = q2[2], w2 = q2[3];
  var x22 = x2 + x2;
  var y22 = y2 + y2;
  var z22 = z2 + z2;
  var xx = x2 * x22;
  var yx = y2 * x22;
  var yy = y2 * y22;
  var zx = z2 * x22;
  var zy = z2 * y22;
  var zz = z2 * z22;
  var wx = w2 * x22;
  var wy = w2 * y22;
  var wz = w2 * z22;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2), nf;
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
function perspectiveZO(out, fovy, aspect, near, far) {
  var f2 = 1 / Math.tan(fovy / 2), nf;
  out[0] = f2 / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr2 = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr2;
  out[13] = (top + bottom) * bt2;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr2 = 1 / (left - right);
  var bt2 = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr2;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt2;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr2;
  out[13] = (top + bottom) * bt2;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len5;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity3(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len5 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len5;
  z1 *= len5;
  z2 *= len5;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len5 = Math.hypot(x0, x1, x2);
  if (!len5) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len5 = 1 / len5;
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len5 = Math.hypot(y0, y1, y2);
  if (!len5) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len5 = 1 / len5;
    y0 *= len5;
    y1 *= len5;
    y2 *= len5;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len5 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len5 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
    x0 *= len5;
    x1 *= len5;
    x2 *= len5;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a2) {
  return "mat4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ", " + a2[4] + ", " + a2[5] + ", " + a2[6] + ", " + a2[7] + ", " + a2[8] + ", " + a2[9] + ", " + a2[10] + ", " + a2[11] + ", " + a2[12] + ", " + a2[13] + ", " + a2[14] + ", " + a2[15] + ")";
}
function frob2(a2) {
  return Math.hypot(a2[0], a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], a2[8], a2[9], a2[10], a2[11], a2[12], a2[13], a2[14], a2[15]);
}
function add2(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  out[2] = a2[2] + b10[2];
  out[3] = a2[3] + b10[3];
  out[4] = a2[4] + b10[4];
  out[5] = a2[5] + b10[5];
  out[6] = a2[6] + b10[6];
  out[7] = a2[7] + b10[7];
  out[8] = a2[8] + b10[8];
  out[9] = a2[9] + b10[9];
  out[10] = a2[10] + b10[10];
  out[11] = a2[11] + b10[11];
  out[12] = a2[12] + b10[12];
  out[13] = a2[13] + b10[13];
  out[14] = a2[14] + b10[14];
  out[15] = a2[15] + b10[15];
  return out;
}
function subtract2(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  out[2] = a2[2] - b10[2];
  out[3] = a2[3] - b10[3];
  out[4] = a2[4] - b10[4];
  out[5] = a2[5] - b10[5];
  out[6] = a2[6] - b10[6];
  out[7] = a2[7] - b10[7];
  out[8] = a2[8] - b10[8];
  out[9] = a2[9] - b10[9];
  out[10] = a2[10] - b10[10];
  out[11] = a2[11] - b10[11];
  out[12] = a2[12] - b10[12];
  out[13] = a2[13] - b10[13];
  out[14] = a2[14] - b10[14];
  out[15] = a2[15] - b10[15];
  return out;
}
function multiplyScalar2(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  out[2] = a2[2] * b10;
  out[3] = a2[3] * b10;
  out[4] = a2[4] * b10;
  out[5] = a2[5] * b10;
  out[6] = a2[6] * b10;
  out[7] = a2[7] * b10;
  out[8] = a2[8] * b10;
  out[9] = a2[9] * b10;
  out[10] = a2[10] * b10;
  out[11] = a2[11] * b10;
  out[12] = a2[12] * b10;
  out[13] = a2[13] * b10;
  out[14] = a2[14] * b10;
  out[15] = a2[15] * b10;
  return out;
}
function multiplyScalarAndAdd2(out, a2, b10, scale9) {
  out[0] = a2[0] + b10[0] * scale9;
  out[1] = a2[1] + b10[1] * scale9;
  out[2] = a2[2] + b10[2] * scale9;
  out[3] = a2[3] + b10[3] * scale9;
  out[4] = a2[4] + b10[4] * scale9;
  out[5] = a2[5] + b10[5] * scale9;
  out[6] = a2[6] + b10[6] * scale9;
  out[7] = a2[7] + b10[7] * scale9;
  out[8] = a2[8] + b10[8] * scale9;
  out[9] = a2[9] + b10[9] * scale9;
  out[10] = a2[10] + b10[10] * scale9;
  out[11] = a2[11] + b10[11] * scale9;
  out[12] = a2[12] + b10[12] * scale9;
  out[13] = a2[13] + b10[13] * scale9;
  out[14] = a2[14] + b10[14] * scale9;
  out[15] = a2[15] + b10[15] * scale9;
  return out;
}
function exactEquals2(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1] && a2[2] === b10[2] && a2[3] === b10[3] && a2[4] === b10[4] && a2[5] === b10[5] && a2[6] === b10[6] && a2[7] === b10[7] && a2[8] === b10[8] && a2[9] === b10[9] && a2[10] === b10[10] && a2[11] === b10[11] && a2[12] === b10[12] && a2[13] === b10[13] && a2[14] === b10[14] && a2[15] === b10[15];
}
function equals2(a2, b10) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var a4 = a2[4], a5 = a2[5], a6 = a2[6], a7 = a2[7];
  var a8 = a2[8], a9 = a2[9], a10 = a2[10], a11 = a2[11];
  var a12 = a2[12], a13 = a2[13], a14 = a2[14], a15 = a2[15];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  var b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7];
  var b82 = b10[8], b92 = b10[9], b102 = b10[10], b11 = b10[11];
  var b122 = b10[12], b13 = b10[13], b14 = b10[14], b15 = b10[15];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32)) && Math.abs(a4 - b42) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b42)) && Math.abs(a5 - b52) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b52)) && Math.abs(a6 - b62) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b62)) && Math.abs(a7 - b72) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b72)) && Math.abs(a8 - b82) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b82)) && Math.abs(a9 - b92) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b92)) && Math.abs(a10 - b102) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b102)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b122) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b122)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var perspective, ortho, mul2, sub2;
var init_mat4 = __esm({
  "node_modules/gl-matrix/esm/mat4.js"() {
    init_common();
    perspective = perspectiveNO;
    ortho = orthoNO;
    mul2 = multiply2;
    sub2 = subtract2;
  }
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add3,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone4,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot,
  equals: () => equals3,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set4,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract3,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone4(a2) {
  var out = new ARRAY_TYPE(3);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function length(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  return Math.hypot(x2, y2, z2);
}
function fromValues3(x2, y2, z2) {
  var out = new ARRAY_TYPE(3);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function copy3(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  return out;
}
function set4(out, x2, y2, z2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  return out;
}
function add3(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  out[2] = a2[2] + b10[2];
  return out;
}
function subtract3(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  out[2] = a2[2] - b10[2];
  return out;
}
function multiply3(out, a2, b10) {
  out[0] = a2[0] * b10[0];
  out[1] = a2[1] * b10[1];
  out[2] = a2[2] * b10[2];
  return out;
}
function divide(out, a2, b10) {
  out[0] = a2[0] / b10[0];
  out[1] = a2[1] / b10[1];
  out[2] = a2[2] / b10[2];
  return out;
}
function ceil(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  return out;
}
function floor(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  return out;
}
function min(out, a2, b10) {
  out[0] = Math.min(a2[0], b10[0]);
  out[1] = Math.min(a2[1], b10[1]);
  out[2] = Math.min(a2[2], b10[2]);
  return out;
}
function max(out, a2, b10) {
  out[0] = Math.max(a2[0], b10[0]);
  out[1] = Math.max(a2[1], b10[1]);
  out[2] = Math.max(a2[2], b10[2]);
  return out;
}
function round(out, a2) {
  out[0] = Math.round(a2[0]);
  out[1] = Math.round(a2[1]);
  out[2] = Math.round(a2[2]);
  return out;
}
function scale3(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  out[2] = a2[2] * b10;
  return out;
}
function scaleAndAdd(out, a2, b10, scale9) {
  out[0] = a2[0] + b10[0] * scale9;
  out[1] = a2[1] + b10[1] * scale9;
  out[2] = a2[2] + b10[2] * scale9;
  return out;
}
function distance(a2, b10) {
  var x2 = b10[0] - a2[0];
  var y2 = b10[1] - a2[1];
  var z2 = b10[2] - a2[2];
  return Math.hypot(x2, y2, z2);
}
function squaredDistance(a2, b10) {
  var x2 = b10[0] - a2[0];
  var y2 = b10[1] - a2[1];
  var z2 = b10[2] - a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function squaredLength(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  return x2 * x2 + y2 * y2 + z2 * z2;
}
function negate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  return out;
}
function inverse(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  return out;
}
function normalize(out, a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var len5 = x2 * x2 + y2 * y2 + z2 * z2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  out[2] = a2[2] * len5;
  return out;
}
function dot(a2, b10) {
  return a2[0] * b10[0] + a2[1] * b10[1] + a2[2] * b10[2];
}
function cross(out, a2, b10) {
  var ax = a2[0], ay = a2[1], az = a2[2];
  var bx = b10[0], by = b10[1], bz = b10[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a2, b10, t4) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  out[2] = az + t4 * (b10[2] - az);
  return out;
}
function hermite(out, a2, b10, c2, d2, t4) {
  var factorTimes2 = t4 * t4;
  var factor1 = factorTimes2 * (2 * t4 - 3) + 1;
  var factor2 = factorTimes2 * (t4 - 2) + t4;
  var factor3 = factorTimes2 * (t4 - 1);
  var factor4 = factorTimes2 * (3 - 2 * t4);
  out[0] = a2[0] * factor1 + b10[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b10[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b10[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function bezier(out, a2, b10, c2, d2, t4) {
  var inverseFactor = 1 - t4;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t4 * t4;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t4 * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t4;
  out[0] = a2[0] * factor1 + b10[0] * factor2 + c2[0] * factor3 + d2[0] * factor4;
  out[1] = a2[1] * factor1 + b10[1] * factor2 + c2[1] * factor3 + d2[1] * factor4;
  out[2] = a2[2] * factor1 + b10[2] * factor2 + c2[2] * factor3 + d2[2] * factor4;
  return out;
}
function random(out, scale9) {
  scale9 = scale9 || 1;
  var r2 = RANDOM() * 2 * Math.PI;
  var z2 = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z2 * z2) * scale9;
  out[0] = Math.cos(r2) * zScale;
  out[1] = Math.sin(r2) * zScale;
  out[2] = z2 * scale9;
  return out;
}
function transformMat4(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  var w2 = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15];
  w2 = w2 || 1;
  out[0] = (m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12]) / w2;
  out[1] = (m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13]) / w2;
  out[2] = (m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14]) / w2;
  return out;
}
function transformMat3(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  out[0] = x2 * m2[0] + y2 * m2[3] + z2 * m2[6];
  out[1] = x2 * m2[1] + y2 * m2[4] + z2 * m2[7];
  out[2] = x2 * m2[2] + y2 * m2[5] + z2 * m2[8];
  return out;
}
function transformQuat(out, a2, q2) {
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  var uvx = qy * z2 - qz * y2, uvy = qz * x2 - qx * z2, uvz = qx * y2 - qy * x2;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x2 + uvx + uuvx;
  out[1] = y2 + uvy + uuvy;
  out[2] = z2 + uvz + uuvz;
  return out;
}
function rotateX2(out, a2, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a2[0] - b10[0];
  p2[1] = a2[1] - b10[1];
  p2[2] = a2[2] - b10[2];
  r2[0] = p2[0];
  r2[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
  r2[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function rotateY2(out, a2, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a2[0] - b10[0];
  p2[1] = a2[1] - b10[1];
  p2[2] = a2[2] - b10[2];
  r2[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
  r2[1] = p2[1];
  r2[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function rotateZ2(out, a2, b10, rad) {
  var p2 = [], r2 = [];
  p2[0] = a2[0] - b10[0];
  p2[1] = a2[1] - b10[1];
  p2[2] = a2[2] - b10[2];
  r2[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
  r2[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
  r2[2] = p2[2];
  out[0] = r2[0] + b10[0];
  out[1] = r2[1] + b10[1];
  out[2] = r2[2] + b10[2];
  return out;
}
function angle(a2, b10) {
  var ax = a2[0], ay = a2[1], az = a2[2], bx = b10[0], by = b10[1], bz = b10[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a2, b10) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a2) {
  return "vec3(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ")";
}
function exactEquals3(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1] && a2[2] === b10[2];
}
function equals3(a2, b10) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22));
}
var sub3, mul3, div, dist, sqrDist, len, sqrLen, forEach;
var init_vec3 = __esm({
  "node_modules/gl-matrix/esm/vec3.js"() {
    init_common();
    sub3 = subtract3;
    mul3 = multiply3;
    div = divide;
    dist = distance;
    sqrDist = squaredDistance;
    len = length;
    sqrLen = squaredLength;
    forEach = function() {
      var vec = create3();
      return function(a2, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 3;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a2.length);
        } else {
          l2 = a2.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a2[i2];
          vec[1] = a2[i2 + 1];
          vec[2] = a2[i2 + 2];
          fn2(vec, vec, arg);
          a2[i2] = vec[0];
          a2[i2 + 1] = vec[1];
          a2[i2 + 2] = vec[2];
        }
        return a2;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add4,
  ceil: () => ceil2,
  clone: () => clone5,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross2,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize2,
  random: () => random2,
  round: () => round2,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set5,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract4,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone5(a2) {
  var out = new ARRAY_TYPE(4);
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function fromValues4(x2, y2, z2, w2) {
  var out = new ARRAY_TYPE(4);
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function copy4(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  out[2] = a2[2];
  out[3] = a2[3];
  return out;
}
function set5(out, x2, y2, z2, w2) {
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = w2;
  return out;
}
function add4(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  out[2] = a2[2] + b10[2];
  out[3] = a2[3] + b10[3];
  return out;
}
function subtract4(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  out[2] = a2[2] - b10[2];
  out[3] = a2[3] - b10[3];
  return out;
}
function multiply4(out, a2, b10) {
  out[0] = a2[0] * b10[0];
  out[1] = a2[1] * b10[1];
  out[2] = a2[2] * b10[2];
  out[3] = a2[3] * b10[3];
  return out;
}
function divide2(out, a2, b10) {
  out[0] = a2[0] / b10[0];
  out[1] = a2[1] / b10[1];
  out[2] = a2[2] / b10[2];
  out[3] = a2[3] / b10[3];
  return out;
}
function ceil2(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  out[2] = Math.ceil(a2[2]);
  out[3] = Math.ceil(a2[3]);
  return out;
}
function floor2(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  out[2] = Math.floor(a2[2]);
  out[3] = Math.floor(a2[3]);
  return out;
}
function min2(out, a2, b10) {
  out[0] = Math.min(a2[0], b10[0]);
  out[1] = Math.min(a2[1], b10[1]);
  out[2] = Math.min(a2[2], b10[2]);
  out[3] = Math.min(a2[3], b10[3]);
  return out;
}
function max2(out, a2, b10) {
  out[0] = Math.max(a2[0], b10[0]);
  out[1] = Math.max(a2[1], b10[1]);
  out[2] = Math.max(a2[2], b10[2]);
  out[3] = Math.max(a2[3], b10[3]);
  return out;
}
function round2(out, a2) {
  out[0] = Math.round(a2[0]);
  out[1] = Math.round(a2[1]);
  out[2] = Math.round(a2[2]);
  out[3] = Math.round(a2[3]);
  return out;
}
function scale4(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  out[2] = a2[2] * b10;
  out[3] = a2[3] * b10;
  return out;
}
function scaleAndAdd2(out, a2, b10, scale9) {
  out[0] = a2[0] + b10[0] * scale9;
  out[1] = a2[1] + b10[1] * scale9;
  out[2] = a2[2] + b10[2] * scale9;
  out[3] = a2[3] + b10[3] * scale9;
  return out;
}
function distance2(a2, b10) {
  var x2 = b10[0] - a2[0];
  var y2 = b10[1] - a2[1];
  var z2 = b10[2] - a2[2];
  var w2 = b10[3] - a2[3];
  return Math.hypot(x2, y2, z2, w2);
}
function squaredDistance2(a2, b10) {
  var x2 = b10[0] - a2[0];
  var y2 = b10[1] - a2[1];
  var z2 = b10[2] - a2[2];
  var w2 = b10[3] - a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function length2(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var w2 = a2[3];
  return Math.hypot(x2, y2, z2, w2);
}
function squaredLength2(a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var w2 = a2[3];
  return x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
}
function negate2(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = -a2[3];
  return out;
}
function inverse2(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  out[2] = 1 / a2[2];
  out[3] = 1 / a2[3];
  return out;
}
function normalize2(out, a2) {
  var x2 = a2[0];
  var y2 = a2[1];
  var z2 = a2[2];
  var w2 = a2[3];
  var len5 = x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = x2 * len5;
  out[1] = y2 * len5;
  out[2] = z2 * len5;
  out[3] = w2 * len5;
  return out;
}
function dot2(a2, b10) {
  return a2[0] * b10[0] + a2[1] * b10[1] + a2[2] * b10[2] + a2[3] * b10[3];
}
function cross2(out, u2, v2, w2) {
  var A3 = v2[0] * w2[1] - v2[1] * w2[0], B3 = v2[0] * w2[2] - v2[2] * w2[0], C3 = v2[0] * w2[3] - v2[3] * w2[0], D3 = v2[1] * w2[2] - v2[2] * w2[1], E3 = v2[1] * w2[3] - v2[3] * w2[1], F2 = v2[2] * w2[3] - v2[3] * w2[2];
  var G2 = u2[0];
  var H2 = u2[1];
  var I2 = u2[2];
  var J2 = u2[3];
  out[0] = H2 * F2 - I2 * E3 + J2 * D3;
  out[1] = -(G2 * F2) + I2 * C3 - J2 * B3;
  out[2] = G2 * E3 - H2 * C3 + J2 * A3;
  out[3] = -(G2 * D3) + H2 * B3 - I2 * A3;
  return out;
}
function lerp2(out, a2, b10, t4) {
  var ax = a2[0];
  var ay = a2[1];
  var az = a2[2];
  var aw = a2[3];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  out[2] = az + t4 * (b10[2] - az);
  out[3] = aw + t4 * (b10[3] - aw);
  return out;
}
function random2(out, scale9) {
  scale9 = scale9 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d2 = Math.sqrt((1 - s1) / s2);
  out[0] = scale9 * v1;
  out[1] = scale9 * v2;
  out[2] = scale9 * v3 * d2;
  out[3] = scale9 * v4 * d2;
  return out;
}
function transformMat42(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2], w2 = a2[3];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[8] * z2 + m2[12] * w2;
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[9] * z2 + m2[13] * w2;
  out[2] = m2[2] * x2 + m2[6] * y2 + m2[10] * z2 + m2[14] * w2;
  out[3] = m2[3] * x2 + m2[7] * y2 + m2[11] * z2 + m2[15] * w2;
  return out;
}
function transformQuat2(out, a2, q2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  var qx = q2[0], qy = q2[1], qz = q2[2], qw = q2[3];
  var ix = qw * x2 + qy * z2 - qz * y2;
  var iy = qw * y2 + qz * x2 - qx * z2;
  var iz = qw * z2 + qx * y2 - qy * x2;
  var iw = -qx * x2 - qy * y2 - qz * z2;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a2[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a2) {
  return "vec4(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
function exactEquals4(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1] && a2[2] === b10[2] && a2[3] === b10[3];
}
function equals4(a2, b10) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var b02 = b10[0], b12 = b10[1], b22 = b10[2], b32 = b10[3];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12)) && Math.abs(a22 - b22) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b22)) && Math.abs(a3 - b32) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b32));
}
var sub4, mul4, div2, dist2, sqrDist2, len2, sqrLen2, forEach2;
var init_vec4 = __esm({
  "node_modules/gl-matrix/esm/vec4.js"() {
    init_common();
    sub4 = subtract4;
    mul4 = multiply4;
    div2 = divide2;
    dist2 = distance2;
    sqrDist2 = squaredDistance2;
    len2 = length2;
    sqrLen2 = squaredLength2;
    forEach2 = function() {
      var vec = create4();
      return function(a2, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 4;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a2.length);
        } else {
          l2 = a2.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a2[i2];
          vec[1] = a2[i2 + 1];
          vec[2] = a2[i2 + 2];
          vec[3] = a2[i2 + 3];
          fn2(vec, vec, arg);
          a2[i2] = vec[0];
          a2[i2 + 1] = vec[1];
          a2[i2 + 2] = vec[2];
          a2[i2 + 3] = vec[3];
        }
        return a2;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add5,
  calculateW: () => calculateW,
  clone: () => clone6,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity4,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize3,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set6,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity4(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s2 = Math.sin(rad);
  out[0] = s2 * axis[0];
  out[1] = s2 * axis[1];
  out[2] = s2 * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q2) {
  var rad = Math.acos(q2[3]) * 2;
  var s2 = Math.sin(rad / 2);
  if (s2 > EPSILON) {
    out_axis[0] = q2[0] / s2;
    out_axis[1] = q2[1] / s2;
    out_axis[2] = q2[2] / s2;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a2, b10) {
  var dotproduct = dot3(a2, b10);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a2, b10) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b10[0], by = b10[1], bz = b10[2], bw = b10[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a2, rad) {
  rad *= 0.5;
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2];
  out[0] = x2;
  out[1] = y2;
  out[2] = z2;
  out[3] = Math.sqrt(Math.abs(1 - x2 * x2 - y2 * y2 - z2 * z2));
  return out;
}
function exp(out, a2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2], w2 = a2[3];
  var r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  var et2 = Math.exp(w2);
  var s2 = r2 > 0 ? et2 * Math.sin(r2) / r2 : 0;
  out[0] = x2 * s2;
  out[1] = y2 * s2;
  out[2] = z2 * s2;
  out[3] = et2 * Math.cos(r2);
  return out;
}
function ln(out, a2) {
  var x2 = a2[0], y2 = a2[1], z2 = a2[2], w2 = a2[3];
  var r2 = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
  var t4 = r2 > 0 ? Math.atan2(r2, w2) / r2 : 0;
  out[0] = x2 * t4;
  out[1] = y2 * t4;
  out[2] = z2 * t4;
  out[3] = 0.5 * Math.log(x2 * x2 + y2 * y2 + z2 * z2 + w2 * w2);
  return out;
}
function pow(out, a2, b10) {
  ln(out, a2);
  scale5(out, out, b10);
  exp(out, out);
  return out;
}
function slerp(out, a2, b10, t4) {
  var ax = a2[0], ay = a2[1], az = a2[2], aw = a2[3];
  var bx = b10[0], by = b10[1], bz = b10[2], bw = b10[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t4) * omega) / sinom;
    scale1 = Math.sin(t4 * omega) / sinom;
  } else {
    scale0 = 1 - t4;
    scale1 = t4;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a2) {
  var a0 = a2[0], a1 = a2[1], a22 = a2[2], a3 = a2[3];
  var dot6 = a0 * a0 + a1 * a1 + a22 * a22 + a3 * a3;
  var invDot = dot6 ? 1 / dot6 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a22 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  out[2] = -a2[2];
  out[3] = a2[3];
  return out;
}
function fromMat3(out, m2) {
  var fTrace = m2[0] + m2[4] + m2[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m2[5] - m2[7]) * fRoot;
    out[1] = (m2[6] - m2[2]) * fRoot;
    out[2] = (m2[1] - m2[3]) * fRoot;
  } else {
    var i2 = 0;
    if (m2[4] > m2[0])
      i2 = 1;
    if (m2[8] > m2[i2 * 3 + i2])
      i2 = 2;
    var j2 = (i2 + 1) % 3;
    var k2 = (i2 + 2) % 3;
    fRoot = Math.sqrt(m2[i2 * 3 + i2] - m2[j2 * 3 + j2] - m2[k2 * 3 + k2] + 1);
    out[i2] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m2[j2 * 3 + k2] - m2[k2 * 3 + j2]) * fRoot;
    out[j2] = (m2[j2 * 3 + i2] + m2[i2 * 3 + j2]) * fRoot;
    out[k2] = (m2[k2 * 3 + i2] + m2[i2 * 3 + k2]) * fRoot;
  }
  return out;
}
function fromEuler(out, x2, y2, z2) {
  var halfToRad = 0.5 * Math.PI / 180;
  x2 *= halfToRad;
  y2 *= halfToRad;
  z2 *= halfToRad;
  var sx = Math.sin(x2);
  var cx = Math.cos(x2);
  var sy = Math.sin(y2);
  var cy = Math.cos(y2);
  var sz = Math.sin(z2);
  var cz = Math.cos(z2);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a2) {
  return "quat(" + a2[0] + ", " + a2[1] + ", " + a2[2] + ", " + a2[3] + ")";
}
var clone6, fromValues5, copy5, set6, add5, mul5, scale5, dot3, lerp3, length3, len3, squaredLength3, sqrLen3, normalize3, exactEquals5, equals5, rotationTo, sqlerp, setAxes;
var init_quat = __esm({
  "node_modules/gl-matrix/esm/quat.js"() {
    init_common();
    init_mat3();
    init_vec3();
    init_vec4();
    clone6 = clone5;
    fromValues5 = fromValues4;
    copy5 = copy4;
    set6 = set5;
    add5 = add4;
    mul5 = multiply5;
    scale5 = scale4;
    dot3 = dot2;
    lerp3 = lerp2;
    length3 = length2;
    len3 = length3;
    squaredLength3 = squaredLength2;
    sqrLen3 = squaredLength3;
    normalize3 = normalize2;
    exactEquals5 = exactEquals4;
    equals5 = equals4;
    rotationTo = function() {
      var tmpvec3 = create3();
      var xUnitVec3 = fromValues3(1, 0, 0);
      var yUnitVec3 = fromValues3(0, 1, 0);
      return function(out, a2, b10) {
        var dot6 = dot(a2, b10);
        if (dot6 < -0.999999) {
          cross(tmpvec3, xUnitVec3, a2);
          if (len(tmpvec3) < 1e-6)
            cross(tmpvec3, yUnitVec3, a2);
          normalize(tmpvec3, tmpvec3);
          setAxisAngle(out, tmpvec3, Math.PI);
          return out;
        } else if (dot6 > 0.999999) {
          out[0] = 0;
          out[1] = 0;
          out[2] = 0;
          out[3] = 1;
          return out;
        } else {
          cross(tmpvec3, a2, b10);
          out[0] = tmpvec3[0];
          out[1] = tmpvec3[1];
          out[2] = tmpvec3[2];
          out[3] = 1 + dot6;
          return normalize3(out, out);
        }
      };
    }();
    sqlerp = function() {
      var temp1 = create5();
      var temp2 = create5();
      return function(out, a2, b10, c2, d2, t4) {
        slerp(temp1, a2, d2, t4);
        slerp(temp2, b10, c2, t4);
        slerp(out, temp1, temp2, 2 * t4 * (1 - t4));
        return out;
      };
    }();
    setAxes = function() {
      var matr = create();
      return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];
        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];
        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];
        return normalize3(out, fromMat3(out, matr));
      };
    }();
  }
});

// node_modules/gl-matrix/esm/quat2.js
var init_quat2 = __esm({
  "node_modules/gl-matrix/esm/quat2.js"() {
    init_common();
    init_quat();
    init_mat4();
  }
});

// node_modules/gl-matrix/esm/vec2.js
var vec2_exports = {};
__export(vec2_exports, {
  add: () => add6,
  angle: () => angle2,
  ceil: () => ceil3,
  clone: () => clone7,
  copy: () => copy6,
  create: () => create6,
  cross: () => cross3,
  dist: () => dist3,
  distance: () => distance3,
  div: () => div3,
  divide: () => divide3,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals6,
  floor: () => floor3,
  forEach: () => forEach3,
  fromValues: () => fromValues6,
  inverse: () => inverse3,
  len: () => len4,
  length: () => length4,
  lerp: () => lerp4,
  max: () => max3,
  min: () => min3,
  mul: () => mul6,
  multiply: () => multiply6,
  negate: () => negate3,
  normalize: () => normalize4,
  random: () => random4,
  rotate: () => rotate3,
  round: () => round3,
  scale: () => scale6,
  scaleAndAdd: () => scaleAndAdd3,
  set: () => set7,
  sqrDist: () => sqrDist3,
  sqrLen: () => sqrLen4,
  squaredDistance: () => squaredDistance3,
  squaredLength: () => squaredLength4,
  str: () => str6,
  sub: () => sub5,
  subtract: () => subtract5,
  transformMat2: () => transformMat2,
  transformMat2d: () => transformMat2d,
  transformMat3: () => transformMat32,
  transformMat4: () => transformMat43,
  zero: () => zero3
});
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function clone7(a2) {
  var out = new ARRAY_TYPE(2);
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function fromValues6(x2, y2) {
  var out = new ARRAY_TYPE(2);
  out[0] = x2;
  out[1] = y2;
  return out;
}
function copy6(out, a2) {
  out[0] = a2[0];
  out[1] = a2[1];
  return out;
}
function set7(out, x2, y2) {
  out[0] = x2;
  out[1] = y2;
  return out;
}
function add6(out, a2, b10) {
  out[0] = a2[0] + b10[0];
  out[1] = a2[1] + b10[1];
  return out;
}
function subtract5(out, a2, b10) {
  out[0] = a2[0] - b10[0];
  out[1] = a2[1] - b10[1];
  return out;
}
function multiply6(out, a2, b10) {
  out[0] = a2[0] * b10[0];
  out[1] = a2[1] * b10[1];
  return out;
}
function divide3(out, a2, b10) {
  out[0] = a2[0] / b10[0];
  out[1] = a2[1] / b10[1];
  return out;
}
function ceil3(out, a2) {
  out[0] = Math.ceil(a2[0]);
  out[1] = Math.ceil(a2[1]);
  return out;
}
function floor3(out, a2) {
  out[0] = Math.floor(a2[0]);
  out[1] = Math.floor(a2[1]);
  return out;
}
function min3(out, a2, b10) {
  out[0] = Math.min(a2[0], b10[0]);
  out[1] = Math.min(a2[1], b10[1]);
  return out;
}
function max3(out, a2, b10) {
  out[0] = Math.max(a2[0], b10[0]);
  out[1] = Math.max(a2[1], b10[1]);
  return out;
}
function round3(out, a2) {
  out[0] = Math.round(a2[0]);
  out[1] = Math.round(a2[1]);
  return out;
}
function scale6(out, a2, b10) {
  out[0] = a2[0] * b10;
  out[1] = a2[1] * b10;
  return out;
}
function scaleAndAdd3(out, a2, b10, scale9) {
  out[0] = a2[0] + b10[0] * scale9;
  out[1] = a2[1] + b10[1] * scale9;
  return out;
}
function distance3(a2, b10) {
  var x2 = b10[0] - a2[0], y2 = b10[1] - a2[1];
  return Math.hypot(x2, y2);
}
function squaredDistance3(a2, b10) {
  var x2 = b10[0] - a2[0], y2 = b10[1] - a2[1];
  return x2 * x2 + y2 * y2;
}
function length4(a2) {
  var x2 = a2[0], y2 = a2[1];
  return Math.hypot(x2, y2);
}
function squaredLength4(a2) {
  var x2 = a2[0], y2 = a2[1];
  return x2 * x2 + y2 * y2;
}
function negate3(out, a2) {
  out[0] = -a2[0];
  out[1] = -a2[1];
  return out;
}
function inverse3(out, a2) {
  out[0] = 1 / a2[0];
  out[1] = 1 / a2[1];
  return out;
}
function normalize4(out, a2) {
  var x2 = a2[0], y2 = a2[1];
  var len5 = x2 * x2 + y2 * y2;
  if (len5 > 0) {
    len5 = 1 / Math.sqrt(len5);
  }
  out[0] = a2[0] * len5;
  out[1] = a2[1] * len5;
  return out;
}
function dot4(a2, b10) {
  return a2[0] * b10[0] + a2[1] * b10[1];
}
function cross3(out, a2, b10) {
  var z2 = a2[0] * b10[1] - a2[1] * b10[0];
  out[0] = out[1] = 0;
  out[2] = z2;
  return out;
}
function lerp4(out, a2, b10, t4) {
  var ax = a2[0], ay = a2[1];
  out[0] = ax + t4 * (b10[0] - ax);
  out[1] = ay + t4 * (b10[1] - ay);
  return out;
}
function random4(out, scale9) {
  scale9 = scale9 || 1;
  var r2 = RANDOM() * 2 * Math.PI;
  out[0] = Math.cos(r2) * scale9;
  out[1] = Math.sin(r2) * scale9;
  return out;
}
function transformMat2(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2;
  out[1] = m2[1] * x2 + m2[3] * y2;
  return out;
}
function transformMat2d(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1];
  out[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
  out[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
  return out;
}
function transformMat32(out, a2, m2) {
  var x2 = a2[0], y2 = a2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function transformMat43(out, a2, m2) {
  var x2 = a2[0];
  var y2 = a2[1];
  out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
  out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
  return out;
}
function rotate3(out, a2, b10, rad) {
  var p0 = a2[0] - b10[0], p1 = a2[1] - b10[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
  out[0] = p0 * cosC - p1 * sinC + b10[0];
  out[1] = p0 * sinC + p1 * cosC + b10[1];
  return out;
}
function angle2(a2, b10) {
  var x1 = a2[0], y1 = a2[1], x2 = b10[0], y2 = b10[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero3(out) {
  out[0] = 0;
  out[1] = 0;
  return out;
}
function str6(a2) {
  return "vec2(" + a2[0] + ", " + a2[1] + ")";
}
function exactEquals6(a2, b10) {
  return a2[0] === b10[0] && a2[1] === b10[1];
}
function equals6(a2, b10) {
  var a0 = a2[0], a1 = a2[1];
  var b02 = b10[0], b12 = b10[1];
  return Math.abs(a0 - b02) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b12));
}
var len4, sub5, mul6, div3, dist3, sqrDist3, sqrLen4, forEach3;
var init_vec2 = __esm({
  "node_modules/gl-matrix/esm/vec2.js"() {
    init_common();
    len4 = length4;
    sub5 = subtract5;
    mul6 = multiply6;
    div3 = divide3;
    dist3 = distance3;
    sqrDist3 = squaredDistance3;
    sqrLen4 = squaredLength4;
    forEach3 = function() {
      var vec = create6();
      return function(a2, stride, offset, count, fn2, arg) {
        var i2, l2;
        if (!stride) {
          stride = 2;
        }
        if (!offset) {
          offset = 0;
        }
        if (count) {
          l2 = Math.min(count * stride + offset, a2.length);
        } else {
          l2 = a2.length;
        }
        for (i2 = offset; i2 < l2; i2 += stride) {
          vec[0] = a2[i2];
          vec[1] = a2[i2 + 1];
          fn2(vec, vec, arg);
          a2[i2] = vec[0];
          a2[i2 + 1] = vec[1];
        }
        return a2;
      };
    }();
  }
});

// node_modules/gl-matrix/esm/index.js
var init_esm2 = __esm({
  "node_modules/gl-matrix/esm/index.js"() {
    init_common();
    init_mat2();
    init_mat2d();
    init_mat3();
    init_mat4();
    init_quat();
    init_quat2();
    init_vec2();
    init_vec3();
    init_vec4();
  }
});

// node_modules/@antv/algorithm/lib/workers/constant.js
var require_constant = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MESSAGE = exports.ALGORITHM = void 0;
    var ALGORITHM = {
      pageRank: "pageRank",
      breadthFirstSearch: "breadthFirstSearch",
      connectedComponent: "connectedComponent",
      depthFirstSearch: "depthFirstSearch",
      detectCycle: "detectCycle",
      detectDirectedCycle: "detectDirectedCycle",
      detectAllCycles: "detectAllCycles",
      detectAllDirectedCycle: "detectAllDirectedCycle",
      detectAllUndirectedCycle: "detectAllUndirectedCycle",
      dijkstra: "dijkstra",
      findAllPath: "findAllPath",
      findShortestPath: "findShortestPath",
      floydWarshall: "floydWarshall",
      getAdjMatrix: "getAdjMatrix",
      getDegree: "getDegree",
      getInDegree: "getInDegree",
      getNeighbors: "getNeighbors",
      getOutDegree: "getOutDegree",
      labelPropagation: "labelPropagation",
      louvain: "louvain",
      GADDI: "GADDI",
      minimumSpanningTree: "minimumSpanningTree",
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.ALGORITHM = ALGORITHM;
    var MESSAGE = {
      SUCCESS: "SUCCESS",
      FAILURE: "FAILURE"
    };
    exports.MESSAGE = MESSAGE;
  }
});

// node_modules/@antv/algorithm/lib/adjacent-matrix.js
var require_adjacent_matrix = __commonJS({
  "node_modules/@antv/algorithm/lib/adjacent-matrix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var adjMatrix3 = function adjMatrix4(graphData, directed) {
      var nodes = graphData.nodes, edges = graphData.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      if (edges) {
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sIndex = nodeMap[source];
          var tIndex = nodeMap[target];
          if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0)
            return;
          matrix[sIndex][tIndex] = 1;
          if (!directed) {
            matrix[tIndex][sIndex] = 1;
          }
        });
      }
      return matrix;
    };
    var _default = adjMatrix3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/linked-list.js
var require_linked_list = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/linked-list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.LinkedListNode = void 0;
    var defaultComparator3 = function defaultComparator4(a2, b10) {
      if (a2 === b10) {
        return true;
      }
      return false;
    };
    var LinkedListNode2 = function() {
      function LinkedListNode3(value, next) {
        if (next === void 0) {
          next = null;
        }
        this.value = value;
        this.next = next;
      }
      LinkedListNode3.prototype.toString = function(callback) {
        return callback ? callback(this.value) : "".concat(this.value);
      };
      return LinkedListNode3;
    }();
    exports.LinkedListNode = LinkedListNode2;
    var LinkedList2 = function() {
      function LinkedList3(comparator) {
        if (comparator === void 0) {
          comparator = defaultComparator3;
        }
        this.head = null;
        this.tail = null;
        this.compare = comparator;
      }
      LinkedList3.prototype.prepend = function(value) {
        var newNode = new LinkedListNode2(value, this.head);
        this.head = newNode;
        if (!this.tail) {
          this.tail = newNode;
        }
        return this;
      };
      LinkedList3.prototype.append = function(value) {
        var newNode = new LinkedListNode2(value);
        if (!this.head) {
          this.head = newNode;
          this.tail = newNode;
          return this;
        }
        this.tail.next = newNode;
        this.tail = newNode;
        return this;
      };
      LinkedList3.prototype.delete = function(value) {
        if (!this.head) {
          return null;
        }
        var deleteNode = null;
        while (this.head && this.compare(this.head.value, value)) {
          deleteNode = this.head;
          this.head = this.head.next;
        }
        var currentNode = this.head;
        if (currentNode !== null) {
          while (currentNode.next) {
            if (this.compare(currentNode.next.value, value)) {
              deleteNode = currentNode.next;
              currentNode.next = currentNode.next.next;
            } else {
              currentNode = currentNode.next;
            }
          }
        }
        if (this.compare(this.tail.value, value)) {
          this.tail = currentNode;
        }
        return deleteNode;
      };
      LinkedList3.prototype.find = function(_a2) {
        var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
        if (!this.head) {
          return null;
        }
        var currentNode = this.head;
        while (currentNode) {
          if (callback && callback(currentNode.value)) {
            return currentNode;
          }
          if (value !== void 0 && this.compare(currentNode.value, value)) {
            return currentNode;
          }
          currentNode = currentNode.next;
        }
        return null;
      };
      LinkedList3.prototype.deleteTail = function() {
        var deletedTail = this.tail;
        if (this.head === this.tail) {
          this.head = null;
          this.tail = null;
          return deletedTail;
        }
        var currentNode = this.head;
        while (currentNode.next) {
          if (!currentNode.next.next) {
            currentNode.next = null;
          } else {
            currentNode = currentNode.next;
          }
        }
        this.tail = currentNode;
        return deletedTail;
      };
      LinkedList3.prototype.deleteHead = function() {
        if (!this.head) {
          return null;
        }
        var deletedHead = this.head;
        if (this.head.next) {
          this.head = this.head.next;
        } else {
          this.head = null;
          this.tail = null;
        }
        return deletedHead;
      };
      LinkedList3.prototype.fromArray = function(values2) {
        var _this = this;
        values2.forEach(function(value) {
          return _this.append(value);
        });
        return this;
      };
      LinkedList3.prototype.toArray = function() {
        var nodes = [];
        var currentNode = this.head;
        while (currentNode) {
          nodes.push(currentNode);
          currentNode = currentNode.next;
        }
        return nodes;
      };
      LinkedList3.prototype.reverse = function() {
        var currentNode = this.head;
        var prevNode = null;
        var nextNode = null;
        while (currentNode) {
          nextNode = currentNode.next;
          currentNode.next = prevNode;
          prevNode = currentNode;
          currentNode = nextNode;
        }
        this.tail = this.head;
        this.head = prevNode;
      };
      LinkedList3.prototype.toString = function(callback) {
        if (callback === void 0) {
          callback = void 0;
        }
        return this.toArray().map(function(node) {
          return node.toString(callback);
        }).toString();
      };
      return LinkedList3;
    }();
    var _default = LinkedList2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/queue.js
var require_queue = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/queue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _linkedList = _interopRequireDefault(require_linked_list());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Queue2 = function() {
      function Queue3() {
        this.linkedList = new _linkedList.default();
      }
      Queue3.prototype.isEmpty = function() {
        return !this.linkedList.head;
      };
      Queue3.prototype.peek = function() {
        if (!this.linkedList.head) {
          return null;
        }
        return this.linkedList.head.value;
      };
      Queue3.prototype.enqueue = function(value) {
        this.linkedList.append(value);
      };
      Queue3.prototype.dequeue = function() {
        var removeHead = this.linkedList.deleteHead();
        return removeHead ? removeHead.value : null;
      };
      Queue3.prototype.toString = function(callback) {
        return this.linkedList.toString(callback);
      };
      return Queue3;
    }();
    var _default = Queue2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/util.js
var require_util = __commonJS({
  "node_modules/@antv/algorithm/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.uniqueId = exports.getOutEdgesNodeId = exports.getNeighbors = exports.getEdgesByNodeId = void 0;
    var getNeighbors3 = function getNeighbors4(nodeId, edges, type) {
      if (edges === void 0) {
        edges = [];
      }
      var currentEdges = edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
      if (type === "target") {
        var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
          return edge.source === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
          return edge.target;
        });
      }
      if (type === "source") {
        var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
          return edge.target === nodeId;
        };
        return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
          return edge.source;
        });
      }
      var neighhborsConverter = function neighhborsConverter2(edge) {
        return edge.source === nodeId ? edge.target : edge.source;
      };
      return currentEdges.map(neighhborsConverter);
    };
    exports.getNeighbors = getNeighbors3;
    var getOutEdgesNodeId3 = function getOutEdgesNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId;
      });
    };
    exports.getOutEdgesNodeId = getOutEdgesNodeId3;
    var getEdgesByNodeId3 = function getEdgesByNodeId4(nodeId, edges) {
      return edges.filter(function(edge) {
        return edge.source === nodeId || edge.target === nodeId;
      });
    };
    exports.getEdgesByNodeId = getEdgesByNodeId3;
    var uniqueId5 = function uniqueId6(index) {
      if (index === void 0) {
        index = 0;
      }
      var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      var random22 = "".concat(Math.random()).split(".")[1].substr(0, 5);
      return "".concat(index, "-").concat(random1).concat(random22);
    };
    exports.uniqueId = uniqueId5;
  }
});

// node_modules/@antv/algorithm/lib/bfs.js
var require_bfs = __commonJS({
  "node_modules/@antv/algorithm/lib/bfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _queue = _interopRequireDefault(require_queue());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          var id2 = next;
          if (!seen[id2]) {
            seen[id2] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    var breadthFirstSearch3 = function breadthFirstSearch4(graphData, startNodeId, originalCallbacks, directed) {
      if (directed === void 0) {
        directed = true;
      }
      var callbacks = initCallbacks3(originalCallbacks);
      var nodeQueue = new _queue.default();
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      nodeQueue.enqueue(startNodeId);
      var previousNode = "";
      var _loop_1 = function _loop_12() {
        var currentNode = nodeQueue.dequeue();
        callbacks.enter({
          current: currentNode,
          previous: previousNode
        });
        (0, _util.getNeighbors)(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
          if (callbacks.allowTraversal({
            previous: previousNode,
            current: currentNode,
            next: nextNode
          })) {
            nodeQueue.enqueue(nextNode);
          }
        });
        callbacks.leave({
          current: currentNode,
          previous: previousNode
        });
        previousNode = currentNode;
      };
      while (!nodeQueue.isEmpty()) {
        _loop_1();
      }
    };
    var _default = breadthFirstSearch3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/connected-component.js
var require_connected_component = __commonJS({
  "node_modules/@antv/algorithm/lib/connected-component.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = getConnectedComponents2;
    exports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;
    var _util = require_util();
    var detectConnectedComponents3 = function detectConnectedComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allComponents = [];
      var visited = {};
      var nodeStack = [];
      var getComponent = function getComponent2(node2) {
        nodeStack.push(node2);
        visited[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges);
        var _loop_1 = function _loop_12(i4) {
          var neighbor = neighbors[i4];
          if (!visited[neighbor]) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === neighbor;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
          }
        };
        for (var i3 = 0; i3 < neighbors.length; ++i3) {
          _loop_1(i3);
        }
      };
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (!visited[node.id]) {
          getComponent(node);
          var component = [];
          while (nodeStack.length > 0) {
            component.push(nodeStack.pop());
          }
          allComponents.push(component);
        }
      }
      return allComponents;
    };
    exports.detectConnectedComponents = detectConnectedComponents3;
    var detectStrongConnectComponents3 = function detectStrongConnectComponents4(graphData) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeStack = [];
      var inStack = {};
      var indices = {};
      var lowLink = {};
      var allComponents = [];
      var index = 0;
      var getComponent = function getComponent2(node2) {
        indices[node2.id] = index;
        lowLink[node2.id] = index;
        index += 1;
        nodeStack.push(node2);
        inStack[node2.id] = true;
        var neighbors = (0, _util.getNeighbors)(node2.id, edges, "target").filter(function(n2) {
          return nodes.map(function(node3) {
            return node3.id;
          }).indexOf(n2) > -1;
        });
        var _loop_2 = function _loop_22(i3) {
          var targetNodeID = neighbors[i3];
          if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
            var targetNode = nodes.filter(function(node3) {
              return node3.id === targetNodeID;
            });
            if (targetNode.length > 0) {
              getComponent2(targetNode[0]);
            }
            lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
          } else if (inStack[targetNodeID]) {
            lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
          }
        };
        for (var i2 = 0; i2 < neighbors.length; i2++) {
          _loop_2(i2);
        }
        if (lowLink[node2.id] === indices[node2.id]) {
          var component = [];
          while (nodeStack.length > 0) {
            var tmpNode = nodeStack.pop();
            inStack[tmpNode.id] = false;
            component.push(tmpNode);
            if (tmpNode === node2)
              break;
          }
          if (component.length > 0) {
            allComponents.push(component);
          }
        }
      };
      for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
        var node = nodes_1[_i2];
        if (!indices[node.id] && indices[node.id] !== 0) {
          getComponent(node);
        }
      }
      return allComponents;
    };
    exports.detectStrongConnectComponents = detectStrongConnectComponents3;
    function getConnectedComponents2(graphData, directed) {
      if (directed)
        return detectStrongConnectComponents3(graphData);
      return detectConnectedComponents3(graphData);
    }
  }
});

// node_modules/@antv/algorithm/lib/degree.js
var require_degree = __commonJS({
  "node_modules/@antv/algorithm/lib/degree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getOutDegree = exports.getInDegree = exports.default = void 0;
    var degree4 = function degree5(graphData) {
      var degrees2 = {};
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      nodes.forEach(function(node) {
        degrees2[node.id] = {
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
      });
      edges.forEach(function(edge) {
        degrees2[edge.source].degree++;
        degrees2[edge.source].outDegree++;
        degrees2[edge.target].degree++;
        degrees2[edge.target].inDegree++;
      });
      return degrees2;
    };
    var _default = degree4;
    exports.default = _default;
    var getInDegree3 = function getInDegree4(graphData, nodeId) {
      var nodeDegree = degree4(graphData);
      if (nodeDegree[nodeId]) {
        return degree4(graphData)[nodeId].inDegree;
      }
      return 0;
    };
    exports.getInDegree = getInDegree3;
    var getOutDegree3 = function getOutDegree4(graphData, nodeId) {
      var nodeDegree = degree4(graphData);
      if (nodeDegree[nodeId]) {
        return degree4(graphData)[nodeId].outDegree;
      }
      return 0;
    };
    exports.getOutDegree = getOutDegree3;
  }
});

// node_modules/@antv/algorithm/lib/dfs.js
var require_dfs = __commonJS({
  "node_modules/@antv/algorithm/lib/dfs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = depthFirstSearch2;
    var _util = require_util();
    function initCallbacks3(callbacks) {
      if (callbacks === void 0) {
        callbacks = {};
      }
      var initiatedCallback = callbacks;
      var stubCallback = function stubCallback2() {
      };
      var allowTraversalCallback = function() {
        var seen = {};
        return function(_a2) {
          var next = _a2.next;
          if (!seen[next]) {
            seen[next] = true;
            return true;
          }
          return false;
        };
      }();
      initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
      initiatedCallback.enter = callbacks.enter || stubCallback;
      initiatedCallback.leave = callbacks.leave || stubCallback;
      return initiatedCallback;
    }
    function depthFirstSearchRecursive2(graphData, currentNode, previousNode, callbacks) {
      callbacks.enter({
        current: currentNode,
        previous: previousNode
      });
      var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
      (0, _util.getNeighbors)(currentNode, edges, "target").forEach(function(nextNode) {
        if (callbacks.allowTraversal({
          previous: previousNode,
          current: currentNode,
          next: nextNode
        })) {
          depthFirstSearchRecursive2(graphData, nextNode, currentNode, callbacks);
        }
      });
      callbacks.leave({
        current: currentNode,
        previous: previousNode
      });
    }
    function depthFirstSearch2(graphData, startNodeId, callbacks) {
      depthFirstSearchRecursive2(graphData, startNodeId, "", initCallbacks3(callbacks));
    }
  }
});

// node_modules/@antv/algorithm/lib/detect-cycle.js
var require_detect_cycle = __commonJS({
  "node_modules/@antv/algorithm/lib/detect-cycle.js"(exports) {
    "use strict";
    function _typeof6(obj) {
      "@babel/helpers - typeof";
      return _typeof6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof6(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.detectAllUndirectedCycle = exports.detectAllDirectedCycle = exports.detectAllCycles = exports.default = void 0;
    var _dfs = _interopRequireDefault(require_dfs());
    var _connectedComponent = _interopRequireWildcard(require_connected_component());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof6(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var detectDirectedCycle4 = function detectDirectedCycle5(graphData) {
      var cycle = null;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      var dfsParentMap = {};
      var unvisitedSet = {};
      var visitingSet = {};
      var visitedSet = {};
      nodes.forEach(function(node) {
        unvisitedSet[node.id] = node;
      });
      var callbacks = {
        enter: function enter(_a3) {
          var currentNode = _a3.current, previousNode = _a3.previous;
          if (visitingSet[currentNode]) {
            cycle = {};
            var currentCycleNode = currentNode;
            var previousCycleNode = previousNode;
            while (previousCycleNode !== currentNode) {
              cycle[currentCycleNode] = previousCycleNode;
              currentCycleNode = previousCycleNode;
              previousCycleNode = dfsParentMap[previousCycleNode];
            }
            cycle[currentCycleNode] = previousCycleNode;
          } else {
            visitingSet[currentNode] = currentNode;
            delete unvisitedSet[currentNode];
            dfsParentMap[currentNode] = previousNode;
          }
        },
        leave: function leave(_a3) {
          var currentNode = _a3.current;
          visitedSet[currentNode] = currentNode;
          delete visitingSet[currentNode];
        },
        allowTraversal: function allowTraversal(_a3) {
          var nextNode = _a3.next;
          if (cycle) {
            return false;
          }
          return !visitedSet[nextNode];
        }
      };
      while (Object.keys(unvisitedSet).length) {
        var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
        (0, _dfs.default)(graphData, firsetUnVisitedKey, callbacks);
      }
      return cycle;
    };
    var detectAllUndirectedCycle3 = function detectAllUndirectedCycle4(graphData, nodeIds, include) {
      var _a2, _b;
      if (include === void 0) {
        include = true;
      }
      var allCycles = [];
      var components3 = (0, _connectedComponent.default)(graphData, false);
      for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
        var component = components_1[_i2];
        if (!component.length)
          continue;
        var root = component[0];
        var rootId = root.id;
        var stack = [root];
        var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
        var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
        while (stack.length > 0) {
          var curNode = stack.pop();
          var curNodeId = curNode.id;
          var neighbors = (0, _util.getNeighbors)(curNodeId, graphData.edges);
          var _loop_1 = function _loop_12(i3) {
            var _c;
            var neighborId = neighbors[i3];
            var neighbor = graphData.nodes.find(function(node) {
              return node.id === neighborId;
            });
            if (neighborId === curNodeId) {
              allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
            } else if (!(neighborId in used)) {
              parent_1[neighborId] = curNode;
              stack.push(neighbor);
              used[neighborId] = /* @__PURE__ */ new Set([curNode]);
            } else if (!used[curNodeId].has(neighbor)) {
              var cycleValid = true;
              var cyclePath = [neighbor, curNode];
              var p2 = parent_1[curNodeId];
              while (used[neighborId].size && !used[neighborId].has(p2)) {
                cyclePath.push(p2);
                if (p2 === parent_1[p2.id])
                  break;
                else
                  p2 = parent_1[p2.id];
              }
              cyclePath.push(p2);
              if (nodeIds && include) {
                cycleValid = false;
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = true;
                }
              } else if (nodeIds && !include) {
                if (cyclePath.findIndex(function(node) {
                  return nodeIds.indexOf(node.id) > -1;
                }) > -1) {
                  cycleValid = false;
                }
              }
              if (cycleValid) {
                var cycle = {};
                for (var index = 1; index < cyclePath.length; index += 1) {
                  cycle[cyclePath[index - 1].id] = cyclePath[index];
                }
                if (cyclePath.length) {
                  cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
                }
                allCycles.push(cycle);
              }
              used[neighborId].add(curNode);
            }
          };
          for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
            _loop_1(i2);
          }
        }
      }
      return allCycles;
    };
    exports.detectAllUndirectedCycle = detectAllUndirectedCycle3;
    var detectAllDirectedCycle3 = function detectAllDirectedCycle4(graphData, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      var path = [];
      var blocked = /* @__PURE__ */ new Set();
      var B3 = [];
      var allCycles = [];
      var idx2Node = {};
      var node2Idx = {};
      var unblock = function unblock2(thisNode) {
        var stack = [thisNode];
        while (stack.length > 0) {
          var node2 = stack.pop();
          if (blocked.has(node2)) {
            blocked.delete(node2);
            B3[node2.id].forEach(function(n2) {
              stack.push(n2);
            });
            B3[node2.id].clear();
          }
        }
      };
      var circuit = function circuit2(node2, start, adjList2) {
        var closed = false;
        if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1)
          return closed;
        path.push(node2);
        blocked.add(node2);
        var neighbors = adjList2[node2.id];
        for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
          var neighbor = idx2Node[neighbors[i3]];
          if (neighbor === start) {
            var cycle = {};
            for (var index = 1; index < path.length; index += 1) {
              cycle[path[index - 1].id] = path[index];
            }
            if (path.length) {
              cycle[path[path.length - 1].id] = path[0];
            }
            allCycles.push(cycle);
            closed = true;
          } else if (!blocked.has(neighbor)) {
            if (circuit2(neighbor, start, adjList2)) {
              closed = true;
            }
          }
        }
        if (closed) {
          unblock(node2);
        } else {
          for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
            var neighbor = idx2Node[neighbors[i3]];
            if (!B3[neighbor.id].has(node2)) {
              B3[neighbor.id].add(node2);
            }
          }
        }
        path.pop();
        return closed;
      };
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
      for (var i2 = 0; i2 < nodes.length; i2 += 1) {
        var node = nodes[i2];
        var nodeId = node.id;
        node2Idx[nodeId] = i2;
        idx2Node[i2] = node;
      }
      if (nodeIds && include) {
        var _loop_2 = function _loop_22(i3) {
          var nodeId2 = nodeIds[i3];
          node2Idx[nodes[i3].id] = node2Idx[nodeId2];
          node2Idx[nodeId2] = 0;
          idx2Node[0] = nodes.find(function(node2) {
            return node2.id === nodeId2;
          });
          idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
        };
        for (var i2 = 0; i2 < nodeIds.length; i2++) {
          _loop_2(i2);
        }
      }
      var getMinComponentAdj = function getMinComponentAdj2(components3) {
        var _a3;
        var minCompIdx;
        var minIdx2 = Infinity;
        for (var i3 = 0; i3 < components3.length; i3 += 1) {
          var comp = components3[i3];
          for (var j2 = 0; j2 < comp.length; j2++) {
            var nodeIdx_1 = node2Idx[comp[j2].id];
            if (nodeIdx_1 < minIdx2) {
              minIdx2 = nodeIdx_1;
              minCompIdx = i3;
            }
          }
        }
        var component2 = components3[minCompIdx];
        var adjList2 = [];
        for (var i3 = 0; i3 < component2.length; i3 += 1) {
          var node2 = component2[i3];
          adjList2[node2.id] = [];
          for (var _i2 = 0, _b = (0, _util.getNeighbors)(node2.id, graphData.edges, "target").filter(function(n2) {
            return component2.map(function(c2) {
              return c2.id;
            }).indexOf(n2) > -1;
          }); _i2 < _b.length; _i2++) {
            var neighbor = _b[_i2];
            if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
              allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
            } else {
              adjList2[node2.id].push(node2Idx[neighbor]);
            }
          }
        }
        return {
          component: component2,
          adjList: adjList2,
          minIdx: minIdx2
        };
      };
      var nodeIdx = 0;
      while (nodeIdx < nodes.length) {
        var subgraphNodes = nodes.filter(function(n2) {
          return node2Idx[n2.id] >= nodeIdx;
        });
        var sccs = (0, _connectedComponent.detectStrongConnectComponents)({
          nodes: subgraphNodes,
          edges: graphData.edges
        }).filter(function(component2) {
          return component2.length > 1;
        });
        if (sccs.length === 0)
          break;
        var scc = getMinComponentAdj(sccs);
        var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
        if (component.length > 1) {
          component.forEach(function(node2) {
            B3[node2.id] = /* @__PURE__ */ new Set();
          });
          var startNode = idx2Node[minIdx];
          if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1)
            return allCycles;
          circuit(startNode, startNode, adjList);
          nodeIdx = minIdx + 1;
        } else {
          break;
        }
      }
      return allCycles;
    };
    exports.detectAllDirectedCycle = detectAllDirectedCycle3;
    var detectAllCycles3 = function detectAllCycles4(graphData, directed, nodeIds, include) {
      if (include === void 0) {
        include = true;
      }
      if (directed)
        return detectAllDirectedCycle3(graphData, nodeIds, include);
      return detectAllUndirectedCycle3(graphData, nodeIds, include);
    };
    exports.detectAllCycles = detectAllCycles3;
    var _default = detectDirectedCycle4;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/@antv/algorithm/node_modules/tslib/tslib.js"(exports, module) {
    var __extends19;
    var __assign16;
    var __rest5;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter3;
    var __generator3;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays3;
    var __spreadArray8;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id2, v2) {
          return exports2[id2] = previous ? previous(id2, v2) : v2;
        };
      }
    })(function(exporter) {
      var extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
        d2.__proto__ = b10;
      } || function(d2, b10) {
        for (var p2 in b10)
          if (Object.prototype.hasOwnProperty.call(b10, p2))
            d2[p2] = b10[p2];
      };
      __extends19 = function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      __rest5 = function(s2, e8) {
        var t4 = {};
        for (var p2 in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
            t4[p2] = s2[p2];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
            if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
              t4[p2[i2]] = s2[p2[i2]];
          }
        return t4;
      };
      __decorate = function(decorators, target, key, desc) {
        var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r2 = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i2 = decorators.length - 1; i2 >= 0; i2--)
            if (d2 = decorators[i2])
              r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
        return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter3 = function(thisArg, _arguments, P2, generator) {
        function adopt(value) {
          return value instanceof P2 ? value : new P2(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P2 || (P2 = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e8) {
              reject(e8);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e8) {
              reject(e8);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator3 = function(thisArg, body) {
        var _2 = { label: 0, sent: function() {
          if (t4[0] & 1)
            throw t4[1];
          return t4[1];
        }, trys: [], ops: [] }, f2, y2, t4, g2;
        return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
          return this;
        }), g2;
        function verb(n2) {
          return function(v2) {
            return step([n2, v2]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_2)
            try {
              if (f2 = 1, y2 && (t4 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op[1])).done)
                return t4;
              if (y2 = 0, t4)
                op = [op[0] & 2, t4.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t4 = op;
                  break;
                case 4:
                  _2.label++;
                  return { value: op[1], done: false };
                case 5:
                  _2.label++;
                  y2 = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _2.ops.pop();
                  _2.trys.pop();
                  continue;
                default:
                  if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _2 = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                    _2.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _2.label < t4[1]) {
                    _2.label = t4[1];
                    t4 = op;
                    break;
                  }
                  if (t4 && _2.label < t4[2]) {
                    _2.label = t4[2];
                    _2.ops.push(op);
                    break;
                  }
                  if (t4[2])
                    _2.ops.pop();
                  _2.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _2);
            } catch (e8) {
              op = [6, e8];
              y2 = 0;
            } finally {
              f2 = t4 = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m2, o2) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
            __createBinding(o2, m2, p2);
      };
      __createBinding = Object.create ? function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        Object.defineProperty(o2, k22, { enumerable: true, get: function() {
          return m2[k2];
        } });
      } : function(o2, m2, k2, k22) {
        if (k22 === void 0)
          k22 = k2;
        o2[k22] = m2[k2];
      };
      __values = function(o2) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
        if (m2)
          return m2.call(o2);
        if (o2 && typeof o2.length === "number")
          return {
            next: function() {
              if (o2 && i2 >= o2.length)
                o2 = void 0;
              return { value: o2 && o2[i2++], done: !o2 };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o2, n2) {
        var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
        if (!m2)
          return o2;
        var i2 = m2.call(o2), r2, ar2 = [], e8;
        try {
          while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
            ar2.push(r2.value);
        } catch (error) {
          e8 = { error };
        } finally {
          try {
            if (r2 && !r2.done && (m2 = i2["return"]))
              m2.call(i2);
          } finally {
            if (e8)
              throw e8.error;
          }
        }
        return ar2;
      };
      __spread = function() {
        for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
          ar2 = ar2.concat(__read(arguments[i2]));
        return ar2;
      };
      __spreadArrays3 = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
          s2 += arguments[i2].length;
        for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
            r2[k2] = a2[j2];
        return r2;
      };
      __spreadArray8 = function(to2, from, pack) {
        if (pack || arguments.length === 2)
          for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
            if (ar2 || !(i2 in from)) {
              if (!ar2)
                ar2 = Array.prototype.slice.call(from, 0, i2);
              ar2[i2] = from[i2];
            }
          }
        return to2.concat(ar2 || Array.prototype.slice.call(from));
      };
      __await = function(v2) {
        return this instanceof __await ? (this.v = v2, this) : new __await(v2);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n2) {
          if (g2[n2])
            i2[n2] = function(v2) {
              return new Promise(function(a2, b10) {
                q2.push([n2, v2, a2, b10]) > 1 || resume(n2, v2);
              });
            };
        }
        function resume(n2, v2) {
          try {
            step(g2[n2](v2));
          } catch (e8) {
            settle(q2[0][3], e8);
          }
        }
        function step(r2) {
          r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f2, v2) {
          if (f2(v2), q2.shift(), q2.length)
            resume(q2[0][0], q2[0][1]);
        }
      };
      __asyncDelegator = function(o2) {
        var i2, p2;
        return i2 = {}, verb("next"), verb("throw", function(e8) {
          throw e8;
        }), verb("return"), i2[Symbol.iterator] = function() {
          return this;
        }, i2;
        function verb(n2, f2) {
          i2[n2] = o2[n2] ? function(v2) {
            return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
          } : f2;
        }
      };
      __asyncValues = function(o2) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m2 = o2[Symbol.asyncIterator], i2;
        return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n2) {
          i2[n2] = o2[n2] && function(v2) {
            return new Promise(function(resolve2, reject) {
              v2 = o2[n2](v2), settle(resolve2, reject, v2.done, v2.value);
            });
          };
        }
        function settle(resolve2, reject, d2, v2) {
          Promise.resolve(v2).then(function(v3) {
            resolve2({ value: v3, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      };
      __importStar = function(mod3) {
        if (mod3 && mod3.__esModule)
          return mod3;
        var result = {};
        if (mod3 != null) {
          for (var k2 in mod3)
            if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k2))
              __createBinding(result, mod3, k2);
        }
        __setModuleDefault(result, mod3);
        return result;
      };
      __importDefault = function(mod3) {
        return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f2) {
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f2)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends19);
      exporter("__assign", __assign16);
      exporter("__rest", __rest5);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter3);
      exporter("__generator", __generator3);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays3);
      exporter("__spreadArray", __spreadArray8);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    });
  }
});

// node_modules/@antv/algorithm/lib/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/@antv/algorithm/lib/dijkstra.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = require_tslib();
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _util2 = require_util();
    var minVertex3 = function minVertex4(D3, nodes, marks) {
      var minDis = Infinity;
      var minNode;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var nodeId = nodes[i2].id;
        if (!marks[nodeId] && D3[nodeId] <= minDis) {
          minDis = D3[nodeId];
          minNode = nodes[i2];
        }
      }
      return minNode;
    };
    var dijkstra5 = function dijkstra6(graphData, source, directed, weightPropertyName) {
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodeIds = [];
      var marks = {};
      var D3 = {};
      var prevs = {};
      nodes.forEach(function(node, i3) {
        var id2 = node.id;
        nodeIds.push(id2);
        D3[id2] = Infinity;
        if (id2 === source)
          D3[id2] = 0;
      });
      var nodeNum = nodes.length;
      var _loop_1 = function _loop_12(i3) {
        var minNode = minVertex3(D3, nodes, marks);
        var minNodeId = minNode.id;
        marks[minNodeId] = true;
        if (D3[minNodeId] === Infinity)
          return "continue";
        var relatedEdges = [];
        if (directed)
          relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);
        else
          relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);
        relatedEdges.forEach(function(edge) {
          var edgeTarget = edge.target;
          var edgeSource = edge.source;
          var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
          var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
          if (D3[w2] > D3[minNode.id] + weight) {
            D3[w2] = D3[minNode.id] + weight;
            prevs[w2] = [minNode.id];
          } else if (D3[w2] === D3[minNode.id] + weight) {
            prevs[w2].push(minNode.id);
          }
        });
      };
      for (var i2 = 0; i2 < nodeNum; i2++) {
        _loop_1(i2);
      }
      prevs[source] = [source];
      var paths = {};
      for (var target in D3) {
        if (D3[target] !== Infinity) {
          findAllPaths2(source, target, prevs, paths);
        }
      }
      var path = {};
      for (var target in paths) {
        path[target] = paths[target][0];
      }
      return {
        length: D3,
        path,
        allPath: paths
      };
    };
    var _default = dijkstra5;
    exports.default = _default;
    function findAllPaths2(source, target, prevs, foundPaths) {
      if (source === target) {
        return [source];
      }
      if (foundPaths[target]) {
        return foundPaths[target];
      }
      var paths = [];
      for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
        var prev = _a2[_i2];
        var prevPaths = findAllPaths2(source, prev, prevs, foundPaths);
        if (!prevPaths)
          return;
        for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
          var prePath = prevPaths_1[_b];
          if ((0, _util.isArray)(prePath))
            paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath, true), [target], false));
          else
            paths.push([prePath, target]);
        }
      }
      foundPaths[target] = paths;
      return foundPaths[target];
    }
  }
});

// node_modules/@antv/algorithm/lib/find-path.js
var require_find_path = __commonJS({
  "node_modules/@antv/algorithm/lib/find-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.findShortestPath = exports.findAllPath = void 0;
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findShortestPath3 = function findShortestPath4(graphData, start, end2, directed, weightPropertyName) {
      var _a2 = (0, _dijkstra.default)(graphData, start, directed, weightPropertyName), length5 = _a2.length, path = _a2.path, allPath = _a2.allPath;
      return {
        length: length5[end2],
        path: path[end2],
        allPath: allPath[end2]
      };
    };
    exports.findShortestPath = findShortestPath3;
    var findAllPath3 = function findAllPath4(graphData, start, end2, directed) {
      var _a2;
      if (start === end2)
        return [[start]];
      var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var visited = [start];
      var isVisited = (_a2 = {}, _a2[start] = true, _a2);
      var stack = [];
      var allPath = [];
      var neighbors = directed ? (0, _util.getNeighbors)(start, edges, "target") : (0, _util.getNeighbors)(start, edges);
      stack.push(neighbors);
      while (visited.length > 0 && stack.length > 0) {
        var children = stack[stack.length - 1];
        if (children.length) {
          var child = children.shift();
          if (child) {
            visited.push(child);
            isVisited[child] = true;
            neighbors = directed ? (0, _util.getNeighbors)(child, edges, "target") : (0, _util.getNeighbors)(child, edges);
            stack.push(neighbors.filter(function(neighbor) {
              return !isVisited[neighbor];
            }));
          }
        } else {
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
          continue;
        }
        if (visited[visited.length - 1] === end2) {
          var path = visited.map(function(node2) {
            return node2;
          });
          allPath.push(path);
          var node = visited.pop();
          isVisited[node] = false;
          stack.pop();
        }
      }
      return allPath;
    };
    exports.findAllPath = findAllPath3;
  }
});

// node_modules/@antv/algorithm/lib/floydWarshall.js
var require_floydWarshall = __commonJS({
  "node_modules/@antv/algorithm/lib/floydWarshall.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var floydWarshall6 = function floydWarshall7(graphData, directed) {
      var adjacentMatrix = (0, _adjacentMatrix.default)(graphData, directed);
      var dist4 = [];
      var size2 = adjacentMatrix.length;
      for (var i2 = 0; i2 < size2; i2 += 1) {
        dist4[i2] = [];
        for (var j2 = 0; j2 < size2; j2 += 1) {
          if (i2 === j2) {
            dist4[i2][j2] = 0;
          } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
            dist4[i2][j2] = Infinity;
          } else {
            dist4[i2][j2] = adjacentMatrix[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size2; k2 += 1) {
        for (var i2 = 0; i2 < size2; i2 += 1) {
          for (var j2 = 0; j2 < size2; j2 += 1) {
            if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
              dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
            }
          }
        }
      }
      return dist4;
    };
    var _default = floydWarshall6;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/label-propagation.js
var require_label_propagation = __commonJS({
  "node_modules/@antv/algorithm/lib/label-propagation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var labelPropagation3 = function labelPropagation4(graphData, directed, weightPropertyName, maxIteration) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = (0, _util.uniqueId)();
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry)
            return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
        });
        ks.push(k2);
      });
      var iter = 0;
      var _loop_1 = function _loop_12() {
        var changed = false;
        nodes.forEach(function(node) {
          var neighborClusters = {};
          Object.keys(neighbors[node.id]).forEach(function(neighborId) {
            var neighborWeight = neighbors[node.id][neighborId];
            var neighborNode = nodeMap[neighborId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (!neighborClusters[neighborClusterId])
              neighborClusters[neighborClusterId] = 0;
            neighborClusters[neighborClusterId] += neighborWeight;
          });
          var maxWeight = -Infinity;
          var bestClusterIds = [];
          Object.keys(neighborClusters).forEach(function(clusterId) {
            if (maxWeight < neighborClusters[clusterId]) {
              maxWeight = neighborClusters[clusterId];
              bestClusterIds = [clusterId];
            } else if (maxWeight === neighborClusters[clusterId]) {
              bestClusterIds.push(clusterId);
            }
          });
          if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId)
            return;
          var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
          if (selfClusterIdx >= 0)
            bestClusterIds.splice(selfClusterIdx, 1);
          if (bestClusterIds && bestClusterIds.length) {
            changed = true;
            var selfCluster = clusters[node.clusterId];
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
            var bestCluster = clusters[bestClusterIds[randomIdx]];
            bestCluster.nodes.push(node);
            node.clusterId = bestCluster.id;
          }
        });
        if (!changed)
          return "break";
        iter++;
      };
      while (iter < maxIteration) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
      Object.keys(clusters).forEach(function(clusterId) {
        var cluster = clusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete clusters[clusterId];
        }
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(clusters).forEach(function(clusterId) {
        clustersArray.push(clusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = labelPropagation3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/utils/vector.js
var require_vector = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/vector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var Vector2 = function() {
      function Vector3(arr) {
        this.arr = arr;
      }
      Vector3.prototype.getArr = function() {
        return this.arr || [];
      };
      Vector3.prototype.add = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return new Vector3(otherArr);
        }
        if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return new Vector3(this.arr);
        }
        if (this.arr.length === otherArr.length) {
          var res = [];
          for (var index in this.arr) {
            res[index] = this.arr[index] + otherArr[index];
          }
          return new Vector3(res);
        }
      };
      Vector3.prototype.subtract = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return new Vector3(otherArr);
        }
        if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return new Vector3(this.arr);
        }
        if (this.arr.length === otherArr.length) {
          var res = [];
          for (var index in this.arr) {
            res[index] = this.arr[index] - otherArr[index];
          }
          return new Vector3(res);
        }
      };
      Vector3.prototype.avg = function(length5) {
        var res = [];
        if (length5 !== 0) {
          for (var index in this.arr) {
            res[index] = this.arr[index] / length5;
          }
        }
        return new Vector3(res);
      };
      Vector3.prototype.negate = function() {
        var res = [];
        for (var index in this.arr) {
          res[index] = -this.arr[index];
        }
        return new Vector3(res);
      };
      Vector3.prototype.squareEuclideanDistance = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index in this.arr) {
            res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
          }
          return res;
        }
      };
      Vector3.prototype.euclideanDistance = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index in this.arr) {
            res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
          }
          return Math.sqrt(res);
        } else {
          console.error("The two vectors are unequal in length.");
        }
      };
      Vector3.prototype.normalize = function() {
        var res = [];
        var cloneArr = (0, _util.clone)(this.arr);
        cloneArr.sort(function(a2, b10) {
          return a2 - b10;
        });
        var max7 = cloneArr[cloneArr.length - 1];
        var min6 = cloneArr[0];
        for (var index in this.arr) {
          res[index] = (this.arr[index] - min6) / (max7 - min6);
        }
        return new Vector3(res);
      };
      Vector3.prototype.norm2 = function() {
        var _a2;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          return 0;
        }
        var res = 0;
        for (var index in this.arr) {
          res += Math.pow(this.arr[index], 2);
        }
        return Math.sqrt(res);
      };
      Vector3.prototype.dot = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return 0;
        }
        if (this.arr.length === otherArr.length) {
          var res = 0;
          for (var index in this.arr) {
            res += this.arr[index] * otherVector.arr[index];
          }
          return res;
        } else {
          console.error("The two vectors are unequal in length.");
        }
      };
      Vector3.prototype.equal = function(otherVector) {
        var _a2;
        var otherArr = otherVector.arr;
        if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
          return false;
        }
        for (var index in this.arr) {
          if (this.arr[index] !== otherArr[index]) {
            return false;
          }
        }
        return true;
      };
      return Vector3;
    }();
    var _default = Vector2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/constants/time.js
var require_time = __commonJS({
  "node_modules/@antv/algorithm/lib/constants/time.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.secondReg = exports.dateReg = void 0;
    var secondReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2})$/;
    exports.secondReg = secondReg2;
    var dateReg2 = /^(\d{1,4})(-|\/)(\d{1,2})\2(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/;
    exports.dateReg = dateReg2;
  }
});

// node_modules/@antv/algorithm/lib/utils/node-properties.js
var require_node_properties = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/node-properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getPropertyWeight = exports.getAllSortProperties = exports.getAllProperties = exports.default = void 0;
    var _time = require_time();
    var getAllSortProperties = function getAllSortProperties2(nodes, n2) {
      if (nodes === void 0) {
        nodes = [];
      }
      if (n2 === void 0) {
        n2 = 100;
      }
      var propertyKeyInfo = {};
      nodes.forEach(function(node) {
        if (!node.properties) {
          return;
        }
        Object.keys(node.properties).forEach(function(propertyKey) {
          if (propertyKey === "id" || !"".concat(node.properties[propertyKey]).match(_time.secondReg) && !"".concat(node.properties[propertyKey]).match(_time.dateReg) && isNaN(Number(node.properties[propertyKey]))) {
            if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
              delete propertyKeyInfo[propertyKey];
            }
            return;
          }
          if (propertyKeyInfo.hasOwnProperty(propertyKey)) {
            propertyKeyInfo[propertyKey] += 1;
          } else {
            propertyKeyInfo[propertyKey] = 1;
          }
        });
      });
      var sortKeys = Object.keys(propertyKeyInfo).sort(function(a2, b10) {
        return propertyKeyInfo[b10] - propertyKeyInfo[a2];
      });
      return sortKeys.length < n2 ? sortKeys : sortKeys.slice(0, n2);
    };
    exports.getAllSortProperties = getAllSortProperties;
    var processProperty = function processProperty2(properties, propertyKeys) {
      return propertyKeys.map(function(key) {
        if (properties.hasOwnProperty(key)) {
          if (!isNaN(Number(properties[key]))) {
            return Number(properties[key]);
          }
          if (properties[key].match(_time.secondReg) || properties[key].match(_time.dateReg)) {
            return Number(Date.parse(new Date(properties[key]))) / 1e3;
          }
        }
        return 0;
      });
    };
    var getPropertyWeight = function getPropertyWeight2(nodes) {
      var propertyKeys = getAllSortProperties(nodes);
      var allPropertiesWeight = [];
      for (var i2 = 0; i2 < nodes.length; i2++) {
        allPropertiesWeight[i2] = processProperty(nodes[i2].properties, propertyKeys);
      }
      return allPropertiesWeight;
    };
    exports.getPropertyWeight = getPropertyWeight;
    var getAllProperties3 = function getAllProperties4(nodes, key) {
      if (key === void 0) {
        key = void 0;
      }
      var allProperties = [];
      nodes.forEach(function(node) {
        if (key === void 0) {
          allProperties.push(node);
        }
        if (node[key] !== void 0) {
          allProperties.push(node[key]);
        }
      });
      return allProperties;
    };
    exports.getAllProperties = getAllProperties3;
    var _default = {
      getAllSortProperties,
      getPropertyWeight,
      getAllProperties: getAllProperties3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/types.js
var require_types = __commonJS({
  "node_modules/@antv/algorithm/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.DistanceType = void 0;
    var DistanceType2;
    exports.DistanceType = DistanceType2;
    (function(DistanceType3) {
      DistanceType3["EuclideanDistance"] = "euclideanDistance";
    })(DistanceType2 || (exports.DistanceType = DistanceType2 = {}));
  }
});

// node_modules/@antv/algorithm/lib/utils/data-preprocessing.js
var require_data_preprocessing = __commonJS({
  "node_modules/@antv/algorithm/lib/utils/data-preprocessing.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.oneHot = exports.getDistance = exports.getAllKeyValueMap = exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _types = require_types();
    var _vector = _interopRequireDefault(require_vector());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAllKeyValueMap3 = function getAllKeyValueMap4(dataList, involvedKeys, uninvolvedKeys) {
      var keys2 = [];
      if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
        keys2 = involvedKeys;
      } else {
        dataList.forEach(function(data) {
          keys2 = keys2.concat(Object.keys(data));
        });
        keys2 = (0, _util.uniq)(keys2);
      }
      var allKeyValueMap = {};
      keys2.forEach(function(key) {
        var value = [];
        dataList.forEach(function(data) {
          if (data[key] !== void 0 && data[key] !== "") {
            value.push(data[key]);
          }
        });
        if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
          allKeyValueMap[key] = (0, _util.uniq)(value);
        }
      });
      return allKeyValueMap;
    };
    exports.getAllKeyValueMap = getAllKeyValueMap3;
    var oneHot3 = function oneHot4(dataList, involvedKeys, uninvolvedKeys) {
      var allKeyValueMap = getAllKeyValueMap3(dataList, involvedKeys, uninvolvedKeys);
      var oneHotCode = [];
      if (!Object.keys(allKeyValueMap).length) {
        return oneHotCode;
      }
      dataList.forEach(function(data, index) {
        var code = [];
        if (Object.keys(allKeyValueMap).length === 1) {
          var key = Object.keys(allKeyValueMap)[0];
          var keyValue = allKeyValueMap[key];
          if (keyValue.every(function(value) {
            return !isNaN(Number(value));
          })) {
            code = [data[key]];
          }
        } else {
          Object.keys(allKeyValueMap).forEach(function(key2) {
            var keyValue2 = data[key2];
            var allKeyValue = allKeyValueMap[key2];
            var valueIndex = allKeyValue.findIndex(function(value) {
              return keyValue2 === value;
            });
            var subCode = [];
            for (var i2 = 0; i2 < allKeyValue.length; i2++) {
              if (i2 === valueIndex) {
                subCode.push(1);
              } else {
                subCode.push(0);
              }
            }
            code = code.concat(subCode);
          });
        }
        oneHotCode[index] = code;
      });
      return oneHotCode;
    };
    exports.oneHot = oneHot3;
    var getDistance3 = function getDistance4(item, otherItem, distanceType, graphData) {
      if (distanceType === void 0) {
        distanceType = _types.DistanceType.EuclideanDistance;
      }
      var distance11 = 0;
      switch (distanceType) {
        case _types.DistanceType.EuclideanDistance:
          distance11 = new _vector.default(item).euclideanDistance(new _vector.default(otherItem));
          break;
        default:
          break;
      }
      return distance11;
    };
    exports.getDistance = getDistance3;
    var _default = {
      getAllKeyValueMap: getAllKeyValueMap3,
      oneHot: oneHot3,
      getDistance: getDistance3
    };
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/louvain.js
var require_louvain = __commonJS({
  "node_modules/@antv/algorithm/lib/louvain.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _vector = _interopRequireDefault(require_vector());
    var _nodeProperties = require_node_properties();
    var _dataPreprocessing = require_data_preprocessing();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getModularity3 = function getModularity4(nodes, adjMatrix3, ks, m2) {
      var length5 = adjMatrix3.length;
      var param = 2 * m2;
      var modularity = 0;
      for (var i2 = 0; i2 < length5; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length5; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (clusteri !== clusterj)
            continue;
          var entry = adjMatrix3[i2][j2] || 0;
          var ki2 = ks[i2] || 0;
          var kj = ks[j2] || 0;
          modularity += entry - ki2 * kj / param;
        }
      }
      modularity *= 1 / param;
      return modularity;
    };
    var getInertialModularity3 = function getInertialModularity4(nodes, allPropertiesWeight) {
      if (nodes === void 0) {
        nodes = [];
      }
      var length5 = nodes.length;
      var totalProperties = new _vector.default([]);
      for (var i2 = 0; i2 < length5; i2++) {
        totalProperties = totalProperties.add(new _vector.default(allPropertiesWeight[i2]));
      }
      var avgProperties = totalProperties.avg(length5);
      avgProperties.normalize();
      var variance = 0;
      for (var i2 = 0; i2 < length5; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
        variance += squareEuclideanDistance;
      }
      var squareEuclideanDistanceInfo = [];
      nodes.forEach(function() {
        squareEuclideanDistanceInfo.push([]);
      });
      for (var i2 = 0; i2 < length5; i2++) {
        var propertiesi = new _vector.default(allPropertiesWeight[i2]);
        nodes[i2]["clusterInertial"] = 0;
        for (var j2 = 0; j2 < length5; j2++) {
          if (i2 === j2) {
            squareEuclideanDistanceInfo[i2][j2] = 0;
            continue;
          }
          var propertiesj = new _vector.default(allPropertiesWeight[j2]);
          squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
          nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
        }
      }
      var inertialModularity = 0;
      var param = 2 * length5 * variance;
      for (var i2 = 0; i2 < length5; i2++) {
        var clusteri = nodes[i2].clusterId;
        for (var j2 = 0; j2 < length5; j2++) {
          var clusterj = nodes[j2].clusterId;
          if (i2 === j2 || clusteri !== clusterj)
            continue;
          var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
          inertialModularity += inertial;
        }
      }
      return Number(inertialModularity.toFixed(4));
    };
    var louvain3 = function louvain4(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
      if (directed === void 0) {
        directed = false;
      }
      if (weightPropertyName === void 0) {
        weightPropertyName = "weight";
      }
      if (threshold === void 0) {
        threshold = 1e-4;
      }
      if (inertialModularity === void 0) {
        inertialModularity = false;
      }
      if (propertyKey === void 0) {
        propertyKey = void 0;
      }
      if (involvedKeys === void 0) {
        involvedKeys = [];
      }
      if (uninvolvedKeys === void 0) {
        uninvolvedKeys = ["id"];
      }
      if (inertialWeight === void 0) {
        inertialWeight = 1;
      }
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var allPropertiesWeight = [];
      if (inertialModularity) {
        nodes.forEach(function(node, index) {
          node.properties = node.properties || {};
          node.originIndex = index;
        });
        var nodeTypeInfo_1 = [];
        if (nodes.every(function(node) {
          return node.hasOwnProperty("nodeType");
        })) {
          nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
            return node.nodeType;
          })));
          nodes.forEach(function(node) {
            node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
              return nodeType === node.nodeType;
            });
          });
        }
        var properties = (0, _nodeProperties.getAllProperties)(nodes, propertyKey);
        allPropertiesWeight = (0, _dataPreprocessing.oneHot)(properties, involvedKeys, uninvolvedKeys);
      }
      var uniqueId5 = 1;
      var clusters = {};
      var nodeMap = {};
      nodes.forEach(function(node, i2) {
        var cid = String(uniqueId5++);
        node.clusterId = cid;
        clusters[cid] = {
          id: cid,
          nodes: [node]
        };
        nodeMap[node.id] = {
          node,
          idx: i2
        };
      });
      var adjMatrix3 = (0, _adjacentMatrix.default)(graphData, directed);
      var ks = [];
      var neighbors = {};
      var m2 = 0;
      adjMatrix3.forEach(function(row, i2) {
        var k2 = 0;
        var iid = nodes[i2].id;
        neighbors[iid] = {};
        row.forEach(function(entry, j2) {
          if (!entry)
            return;
          k2 += entry;
          var jid = nodes[j2].id;
          neighbors[iid][jid] = entry;
          m2 += entry;
        });
        ks.push(k2);
      });
      m2 /= 2;
      var totalModularity = Infinity;
      var previousModularity = Infinity;
      var iter = 0;
      var finalNodes = [];
      var finalClusters = {};
      while (true) {
        if (inertialModularity && nodes.every(function(node) {
          return node.hasOwnProperty("properties");
        })) {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m2) + getInertialModularity3(nodes, allPropertiesWeight) * inertialWeight;
        } else {
          totalModularity = getModularity3(nodes, adjMatrix3, ks, m2);
        }
        if (iter === 0) {
          previousModularity = totalModularity;
          finalNodes = nodes;
          finalClusters = clusters;
        }
        var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
        if (totalModularity > previousModularity) {
          finalNodes = nodes.map(function(node) {
            return {
              node,
              clusterId: node.clusterId
            };
          });
          finalClusters = (0, _util.clone)(clusters);
          previousModularity = totalModularity;
        }
        if (increaseWithinThreshold || iter > 100) {
          break;
        }
        ;
        iter++;
        Object.keys(clusters).forEach(function(clusterId) {
          var sumTot = 0;
          edges.forEach(function(edge) {
            var source = edge.source, target = edge.target;
            var sourceClusterId = nodeMap[source].node.clusterId;
            var targetClusterId = nodeMap[target].node.clusterId;
            if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
              sumTot = sumTot + (edge[weightPropertyName] || 1);
            }
          });
          clusters[clusterId].sumTot = sumTot;
        });
        nodes.forEach(function(node, i2) {
          var selfCluster = clusters[node.clusterId];
          var bestIncrease = 0;
          var bestCluster;
          var commonParam = ks[i2] / (2 * m2);
          var kiin = 0;
          var selfClusterNodes = selfCluster.nodes;
          selfClusterNodes.forEach(function(scNode) {
            var scNodeIdx = nodeMap[scNode.id].idx;
            kiin += adjMatrix3[i2][scNodeIdx] || 0;
          });
          var removeModurarity = kiin - selfCluster.sumTot * commonParam;
          var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
            return scNode.id !== node.id;
          });
          var propertiesWeightRemove = [];
          selfClusterNodesAfterRemove.forEach(function(nodeRemove, index) {
            propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];
          });
          var removeInertialModularity = getInertialModularity3(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
          var nodeNeighborIds = neighbors[node.id];
          Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
            var neighborNode = nodeMap[neighborNodeId].node;
            var neighborClusterId = neighborNode.clusterId;
            if (neighborClusterId === node.clusterId)
              return;
            var neighborCluster = clusters[neighborClusterId];
            var clusterNodes = neighborCluster.nodes;
            if (!clusterNodes || !clusterNodes.length)
              return;
            var neighborClusterKiin = 0;
            clusterNodes.forEach(function(cNode) {
              var cNodeIdx = nodeMap[cNode.id].idx;
              neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
            });
            var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
            var clusterNodesAfterAdd = clusterNodes.concat([node]);
            var propertiesWeightAdd = [];
            clusterNodesAfterAdd.forEach(function(nodeAdd, index) {
              propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];
            });
            var addInertialModularity = getInertialModularity3(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
            var increase = addModurarity - removeModurarity;
            if (inertialModularity) {
              increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
            }
            if (increase > bestIncrease) {
              bestIncrease = increase;
              bestCluster = neighborCluster;
            }
          });
          if (bestIncrease > 0) {
            bestCluster.nodes.push(node);
            var previousClusterId_1 = node.clusterId;
            node.clusterId = bestCluster.id;
            var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
            selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
            var neighborClusterSumTot_1 = 0;
            var selfClusterSumTot_1 = 0;
            edges.forEach(function(edge) {
              var source = edge.source, target = edge.target;
              var sourceClusterId = nodeMap[source].node.clusterId;
              var targetClusterId = nodeMap[target].node.clusterId;
              if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
                neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
              if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
                selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
              }
            });
            bestCluster.sumTot = neighborClusterSumTot_1;
            selfCluster.sumTot = selfClusterSumTot_1;
          }
        });
      }
      var newClusterIdMap = {};
      var clusterIdx = 0;
      Object.keys(finalClusters).forEach(function(clusterId) {
        var cluster = finalClusters[clusterId];
        if (!cluster.nodes || !cluster.nodes.length) {
          delete finalClusters[clusterId];
          return;
        }
        var newId = String(clusterIdx + 1);
        if (newId === clusterId) {
          return;
        }
        cluster.id = newId;
        cluster.nodes = cluster.nodes.map(function(item) {
          return {
            id: item.id,
            clusterId: newId
          };
        });
        finalClusters[newId] = cluster;
        newClusterIdMap[clusterId] = newId;
        delete finalClusters[clusterId];
        clusterIdx++;
      });
      finalNodes.forEach(function(nodeInfo) {
        var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
        node.clusterId = clusterId;
        if (node.clusterId && newClusterIdMap[node.clusterId])
          node.clusterId = newClusterIdMap[node.clusterId];
      });
      var clusterEdges = [];
      var clusterEdgeMap = {};
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var weight = edge[weightPropertyName] || 1;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
        if (clusterEdgeMap[newEdgeId]) {
          clusterEdgeMap[newEdgeId].weight += weight;
          clusterEdgeMap[newEdgeId].count++;
        } else {
          var newEdge = {
            source: sourceClusterId,
            target: targetClusterId,
            weight,
            count: 1
          };
          clusterEdgeMap[newEdgeId] = newEdge;
          clusterEdges.push(newEdge);
        }
      });
      var clustersArray = [];
      Object.keys(finalClusters).forEach(function(clusterId) {
        clustersArray.push(finalClusters[clusterId]);
      });
      return {
        clusters: clustersArray,
        clusterEdges
      };
    };
    var _default = louvain3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/union-find.js
var require_union_find = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/union-find.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var UnionFind2 = function() {
      function UnionFind3(items) {
        this.count = items.length;
        this.parent = {};
        for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
          var i2 = items_1[_i2];
          this.parent[i2] = i2;
        }
      }
      UnionFind3.prototype.find = function(item) {
        while (this.parent[item] !== item) {
          item = this.parent[item];
        }
        return item;
      };
      UnionFind3.prototype.union = function(a2, b10) {
        var rootA = this.find(a2);
        var rootB = this.find(b10);
        if (rootA === rootB)
          return;
        if (rootA < rootB) {
          if (this.parent[b10] !== b10)
            this.union(this.parent[b10], a2);
          this.parent[b10] = this.parent[a2];
        } else {
          if (this.parent[a2] !== a2)
            this.union(this.parent[a2], b10);
          this.parent[a2] = this.parent[b10];
        }
      };
      UnionFind3.prototype.connected = function(a2, b10) {
        return this.find(a2) === this.find(b10);
      };
      return UnionFind3;
    }();
    var _default = UnionFind2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/structs/binary-heap.js
var require_binary_heap = __commonJS({
  "node_modules/@antv/algorithm/lib/structs/binary-heap.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var defaultCompare3 = function defaultCompare4(a2, b10) {
      return a2 - b10;
    };
    var MinBinaryHeap2 = function() {
      function MinBinaryHeap3(compareFn) {
        if (compareFn === void 0) {
          compareFn = defaultCompare3;
        }
        this.compareFn = compareFn;
        this.list = [];
      }
      MinBinaryHeap3.prototype.getLeft = function(index) {
        return 2 * index + 1;
      };
      MinBinaryHeap3.prototype.getRight = function(index) {
        return 2 * index + 2;
      };
      MinBinaryHeap3.prototype.getParent = function(index) {
        if (index === 0) {
          return null;
        }
        return Math.floor((index - 1) / 2);
      };
      MinBinaryHeap3.prototype.isEmpty = function() {
        return this.list.length <= 0;
      };
      MinBinaryHeap3.prototype.top = function() {
        return this.isEmpty() ? void 0 : this.list[0];
      };
      MinBinaryHeap3.prototype.delMin = function() {
        var top = this.top();
        var bottom = this.list.pop();
        if (this.list.length > 0) {
          this.list[0] = bottom;
          this.moveDown(0);
        }
        return top;
      };
      MinBinaryHeap3.prototype.insert = function(value) {
        if (value !== null) {
          this.list.push(value);
          var index = this.list.length - 1;
          this.moveUp(index);
          return true;
        }
        return false;
      };
      MinBinaryHeap3.prototype.moveUp = function(index) {
        var parent = this.getParent(index);
        while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {
          var tmp = this.list[parent];
          this.list[parent] = this.list[index];
          this.list[index] = tmp;
          index = parent;
          parent = this.getParent(index);
        }
      };
      MinBinaryHeap3.prototype.moveDown = function(index) {
        var _a2;
        var element = index;
        var left = this.getLeft(index);
        var right = this.getRight(index);
        var size2 = this.list.length;
        if (left !== null && left < size2 && this.compareFn(this.list[element], this.list[left]) > 0) {
          element = left;
        } else if (right !== null && right < size2 && this.compareFn(this.list[element], this.list[right]) > 0) {
          element = right;
        }
        if (index !== element) {
          _a2 = [this.list[element], this.list[index]], this.list[index] = _a2[0], this.list[element] = _a2[1];
          this.moveDown(element);
        }
      };
      return MinBinaryHeap3;
    }();
    var _default = MinBinaryHeap2;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/mts.js
var require_mts = __commonJS({
  "node_modules/@antv/algorithm/lib/mts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _unionFind = _interopRequireDefault(require_union_find());
    var _binaryHeap = _interopRequireDefault(require_binary_heap());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var primMST3 = function primMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var currNode = nodes[0];
      var visited = /* @__PURE__ */ new Set();
      visited.add(currNode);
      var compareWeight = function compareWeight2(a2, b10) {
        if (weight) {
          return a2.weight - b10.weight;
        }
        return 0;
      };
      var edgeQueue = new _binaryHeap.default(compareWeight);
      (0, _util.getEdgesByNodeId)(currNode.id, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
      while (!edgeQueue.isEmpty()) {
        var currEdge = edgeQueue.delMin();
        var source = currEdge.source;
        var target = currEdge.target;
        if (visited.has(source) && visited.has(target))
          continue;
        selectedEdges.push(currEdge);
        if (!visited.has(source)) {
          visited.add(source);
          (0, _util.getEdgesByNodeId)(source, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
        if (!visited.has(target)) {
          visited.add(target);
          (0, _util.getEdgesByNodeId)(target, edges).forEach(function(edge) {
            edgeQueue.insert(edge);
          });
        }
      }
      return selectedEdges;
    };
    var kruskalMST3 = function kruskalMST4(graphData, weight) {
      var selectedEdges = [];
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      if (nodes.length === 0) {
        return selectedEdges;
      }
      var weightEdges = edges.map(function(edge) {
        return edge;
      });
      if (weight) {
        weightEdges.sort(function(a2, b10) {
          return a2.weight - b10.weight;
        });
      }
      var disjointSet = new _unionFind.default(nodes.map(function(n2) {
        return n2.id;
      }));
      while (weightEdges.length > 0) {
        var curEdge = weightEdges.shift();
        var source = curEdge.source;
        var target = curEdge.target;
        if (!disjointSet.connected(source, target)) {
          selectedEdges.push(curEdge);
          disjointSet.union(source, target);
        }
      }
      return selectedEdges;
    };
    var minimumSpanningTree3 = function minimumSpanningTree4(graphData, weight, algo) {
      var algos = {
        prim: primMST3,
        kruskal: kruskalMST3
      };
      if (!algo)
        return kruskalMST3(graphData, weight);
      return algos[algo](graphData, weight);
    };
    var _default = minimumSpanningTree3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/pageRank.js
var require_pageRank = __commonJS({
  "node_modules/@antv/algorithm/lib/pageRank.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _degree = _interopRequireDefault(require_degree());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pageRank3 = function pageRank4(graphData, epsilon, linkProb) {
      if (typeof epsilon !== "number")
        epsilon = 1e-6;
      if (typeof linkProb !== "number")
        linkProb = 0.85;
      var distance11 = 1;
      var leakedRank = 0;
      var maxIterations = 1e3;
      var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
      var nodesCount = nodes.length;
      var currentRank;
      var curRanks = {};
      var prevRanks = {};
      for (var j2 = 0; j2 < nodesCount; ++j2) {
        var node = nodes[j2];
        var nodeId = node.id;
        curRanks[nodeId] = 1 / nodesCount;
        prevRanks[nodeId] = 1 / nodesCount;
      }
      var nodeDegree = (0, _degree.default)(graphData);
      while (maxIterations > 0 && distance11 > epsilon) {
        leakedRank = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = 0;
          if (nodeDegree[node.id].inDegree === 0) {
            curRanks[nodeId] = 0;
          } else {
            var neighbors = (0, _util.getNeighbors)(nodeId, edges, "source");
            for (var i2 = 0; i2 < neighbors.length; ++i2) {
              var neighbor = neighbors[i2];
              var outDegree = nodeDegree[neighbor].outDegree;
              if (outDegree > 0)
                currentRank += prevRanks[neighbor] / outDegree;
            }
            curRanks[nodeId] = linkProb * currentRank;
            leakedRank += curRanks[nodeId];
          }
        }
        leakedRank = (1 - leakedRank) / nodesCount;
        distance11 = 0;
        for (var j2 = 0; j2 < nodesCount; ++j2) {
          var node = nodes[j2];
          var nodeId = node.id;
          currentRank = curRanks[nodeId] + leakedRank;
          distance11 += Math.abs(currentRank - prevRanks[nodeId]);
          prevRanks[nodeId] = currentRank;
        }
        maxIterations -= 1;
      }
      return prevRanks;
    };
    var _default = pageRank3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/struct.js
var require_struct = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/struct.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.VACANT_NODE_LABEL = exports.VACANT_NODE_ID = exports.VACANT_GRAPH_ID = exports.VACANT_EDGE_LABEL = exports.VACANT_EDGE_ID = exports.Node = exports.Graph = exports.Edge = exports.AUTO_EDGE_ID = void 0;
    var VACANT_EDGE_ID2 = -1;
    exports.VACANT_EDGE_ID = VACANT_EDGE_ID2;
    var VACANT_NODE_ID2 = -1;
    exports.VACANT_NODE_ID = VACANT_NODE_ID2;
    var VACANT_EDGE_LABEL2 = "-1";
    exports.VACANT_EDGE_LABEL = VACANT_EDGE_LABEL2;
    var VACANT_NODE_LABEL2 = "-1";
    exports.VACANT_NODE_LABEL = VACANT_NODE_LABEL2;
    var VACANT_GRAPH_ID2 = -1;
    exports.VACANT_GRAPH_ID = VACANT_GRAPH_ID2;
    var AUTO_EDGE_ID = "-1";
    exports.AUTO_EDGE_ID = AUTO_EDGE_ID;
    var Edge3 = function() {
      function Edge4(id2, from, to2, label) {
        if (id2 === void 0) {
          id2 = VACANT_EDGE_ID2;
        }
        if (from === void 0) {
          from = VACANT_NODE_ID2;
        }
        if (to2 === void 0) {
          to2 = VACANT_NODE_ID2;
        }
        if (label === void 0) {
          label = VACANT_EDGE_LABEL2;
        }
        this.id = id2;
        this.from = from;
        this.to = to2;
        this.label = label;
      }
      return Edge4;
    }();
    exports.Edge = Edge3;
    var Node3 = function() {
      function Node4(id2, label) {
        if (id2 === void 0) {
          id2 = VACANT_NODE_ID2;
        }
        if (label === void 0) {
          label = VACANT_NODE_LABEL2;
        }
        this.id = id2;
        this.label = label;
        this.edges = [];
        this.edgeMap = {};
      }
      Node4.prototype.addEdge = function(edge) {
        this.edges.push(edge);
        this.edgeMap[edge.id] = edge;
      };
      return Node4;
    }();
    exports.Node = Node3;
    var Graph5 = function() {
      function Graph6(id2, edgeIdAutoIncrease, directed) {
        if (id2 === void 0) {
          id2 = VACANT_NODE_ID2;
        }
        if (edgeIdAutoIncrease === void 0) {
          edgeIdAutoIncrease = true;
        }
        if (directed === void 0) {
          directed = false;
        }
        this.id = id2;
        this.edgeIdAutoIncrease = edgeIdAutoIncrease;
        this.edges = [];
        this.nodes = [];
        this.nodeMap = {};
        this.edgeMap = {};
        this.nodeLabelMap = {};
        this.edgeLabelMap = {};
        this.counter = 0;
        this.directed = directed;
      }
      Graph6.prototype.getNodeNum = function() {
        return this.nodes.length;
      };
      Graph6.prototype.addNode = function(id2, label) {
        if (this.nodeMap[id2])
          return;
        var node = new Node3(id2, label);
        this.nodes.push(node);
        this.nodeMap[id2] = node;
        if (!this.nodeLabelMap[label])
          this.nodeLabelMap[label] = [];
        this.nodeLabelMap[label].push(id2);
      };
      Graph6.prototype.addEdge = function(id2, from, to2, label) {
        if (this.edgeIdAutoIncrease || id2 === void 0)
          id2 = this.counter++;
        if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id2])
          return;
        var edge = new Edge3(id2, from, to2, label);
        this.edges.push(edge);
        this.edgeMap[id2] = edge;
        this.nodeMap[from].addEdge(edge);
        if (!this.edgeLabelMap[label])
          this.edgeLabelMap[label] = [];
        this.edgeLabelMap[label].push(edge);
        if (!this.directed) {
          var rEdge = new Edge3(id2, to2, from, label);
          this.nodeMap[to2].addEdge(rEdge);
          this.edgeLabelMap[label].push(rEdge);
        }
      };
      return Graph6;
    }();
    exports.Graph = Graph5;
  }
});

// node_modules/@antv/algorithm/lib/gSpan/gSpan.js
var require_gSpan = __commonJS({
  "node_modules/@antv/algorithm/lib/gSpan/gSpan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _util = (init_esm(), __toCommonJS(esm_exports));
    var _struct = require_struct();
    var DFSedge2 = function() {
      function DFSedge3(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
        this.fromNode = fromNode;
        this.toNode = toNode;
        this.nodeEdgeNodeLabel = {
          nodeLabel1: fromNodeLabel || _struct.VACANT_NODE_LABEL,
          edgeLabel: edgeLabel || _struct.VACANT_EDGE_LABEL,
          nodeLabel2: toNodeLabel || _struct.VACANT_NODE_LABEL
        };
      }
      DFSedge3.prototype.equalTo = function(other) {
        return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
      };
      DFSedge3.prototype.notEqualTo = function(other) {
        return !this.equalTo(other);
      };
      return DFSedge3;
    }();
    var DFScode2 = function() {
      function DFScode3() {
        this.rmpath = [];
        this.dfsEdgeList = [];
      }
      DFScode3.prototype.equalTo = function(other) {
        var aLength = this.dfsEdgeList.length;
        var bLength = other.length;
        if (aLength !== bLength)
          return false;
        for (var i2 = 0; i2 < aLength; i2++) {
          if (this.dfsEdgeList[i2] !== other[i2])
            return false;
        }
        return true;
      };
      DFScode3.prototype.notEqualTo = function(other) {
        return !this.equalTo(other);
      };
      DFScode3.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
        this.dfsEdgeList.push(new DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
        return this.dfsEdgeList;
      };
      DFScode3.prototype.toGraph = function(graphId, directed) {
        if (graphId === void 0) {
          graphId = _struct.VACANT_GRAPH_ID;
        }
        if (directed === void 0) {
          directed = false;
        }
        var graph = new _struct.Graph(graphId, true, directed);
        this.dfsEdgeList.forEach(function(dfsEdge) {
          var fromNodeId = dfsEdge.fromNode;
          var toNodeId = dfsEdge.toNode;
          var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          if (nodeLabel1 !== _struct.VACANT_NODE_LABEL)
            graph.addNode(fromNodeId, nodeLabel1);
          if (nodeLabel2 !== _struct.VACANT_NODE_LABEL)
            graph.addNode(toNodeId, nodeLabel2);
          if (nodeLabel1 !== _struct.VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1)
            graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
        });
        return graph;
      };
      DFScode3.prototype.buildRmpath = function() {
        this.rmpath = [];
        var oldFrom = void 0;
        var selfLength = this.dfsEdgeList.length;
        for (var i2 = selfLength - 1; i2 >= 0; i2--) {
          var dfsEdge = this.dfsEdgeList[i2];
          var fromNodeIdx = dfsEdge.fromNode;
          var toNodeIdx = dfsEdge.toNode;
          if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
            this.rmpath.push(i2);
            oldFrom = fromNodeIdx;
          }
        }
        return this.rmpath;
      };
      DFScode3.prototype.getNodeNum = function() {
        var nodeMap = {};
        this.dfsEdgeList.forEach(function(dfsEdge) {
          if (!nodeMap[dfsEdge.fromNode])
            nodeMap[dfsEdge.fromNode] = true;
          if (!nodeMap[dfsEdge.toNode])
            nodeMap[dfsEdge.toNode] = true;
        });
        return Object.keys(nodeMap).length;
      };
      return DFScode3;
    }();
    var History2 = function() {
      function History3(pdfs) {
        this.his = {};
        this.nodesUsed = {};
        this.edgesUsed = {};
        this.edges = [];
        if (!pdfs)
          return;
        while (pdfs) {
          var e8 = pdfs.edge;
          this.edges.push(e8);
          this.nodesUsed[e8.from] = 1;
          this.nodesUsed[e8.to] = 1;
          this.edgesUsed[e8.id] = 1;
          pdfs = pdfs.preNode;
        }
        this.edges = this.edges.reverse();
      }
      History3.prototype.hasNode = function(node) {
        return this.nodesUsed[node.id] === 1;
      };
      History3.prototype.hasEdge = function(edge) {
        return this.edgesUsed[edge.id] === 1;
      };
      return History3;
    }();
    var GSpan2 = function() {
      function GSpan3(_a2) {
        var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
        this.graphs = graphs;
        this.dfsCode = new DFScode2();
        this.support = 0;
        this.frequentSize1Subgraphs = [];
        this.frequentSubgraphs = [];
        this.minSupport = minSupport;
        this.top = top;
        this.directed = directed;
        this.counter = 0;
        this.maxNodeNum = maxNodeNum;
        this.minNodeNum = minNodeNum;
        this.verbose = verbose;
        if (this.maxNodeNum < this.minNodeNum)
          this.maxNodeNum = this.minNodeNum;
        this.reportDF = [];
      }
      GSpan3.prototype.findForwardRootEdges = function(graph, fromNode) {
        var _this = this;
        var result = [];
        var nodeMap = graph.nodeMap;
        fromNode.edges.forEach(function(edge) {
          if (_this.directed || fromNode.label <= nodeMap[edge.to].label)
            result.push(edge);
        });
        return result;
      };
      GSpan3.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
        if (!this.directed && edge1 === edge2)
          return null;
        var nodeMap = graph.nodeMap;
        var edge2To = nodeMap[edge2.to];
        var edge2ToEdges = edge2To.edges;
        var edgeLength = edge2ToEdges.length;
        for (var i2 = 0; i2 < edgeLength; i2++) {
          var edge = edge2ToEdges[i2];
          if (history.hasEdge(edge) || edge.to !== edge1.from)
            continue;
          if (!this.directed) {
            if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
              return edge;
            }
          } else {
            if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
              return edge;
            }
          }
        }
        return null;
      };
      GSpan3.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
        var result = [];
        var rightmostEdgeToId = rightmostEdge.to;
        var edges = graph.nodeMap[rightmostEdgeToId].edges;
        var edgeLength = edges.length;
        for (var i2 = 0; i2 < edgeLength; i2++) {
          var edge = edges[i2];
          var toNode = graph.nodeMap[edge.to];
          if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
            result.push(edge);
          }
        }
        return result;
      };
      GSpan3.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
        var result = [];
        var nodeMap = graph.nodeMap;
        var toNodeLabel = nodeMap[rightmostEdge.to].label;
        var fromNode = nodeMap[rightmostEdge.from];
        var edges = fromNode.edges;
        var edgeLength = edges.length;
        for (var i2 = 0; i2 < edgeLength; i2++) {
          var edge = edges[i2];
          var newToNodeLabel = nodeMap[edge.to].label;
          if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
            continue;
          }
          if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
            result.push(edge);
          }
        }
        return result;
      };
      GSpan3.prototype.getSupport = function(projected) {
        var graphMap = {};
        projected.forEach(function(pro) {
          if (!graphMap[pro.graphId])
            graphMap[pro.graphId] = true;
        });
        return Object.keys(graphMap).length;
      };
      GSpan3.prototype.findMinLabel = function(obj) {
        var minLabel = void 0;
        Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
          var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          if (!minLabel) {
            minLabel = {
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
            return;
          }
          if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
            minLabel = {
              nodeLabel1,
              edgeLabel,
              nodeLabel2
            };
          }
        });
        return minLabel;
      };
      GSpan3.prototype.isMin = function() {
        var _this = this;
        var dfsCode = this.dfsCode;
        if (this.verbose)
          console.log("isMin checking", dfsCode);
        if (dfsCode.dfsEdgeList.length === 1)
          return true;
        var directed = this.directed;
        var graph = dfsCode.toGraph(_struct.VACANT_GRAPH_ID, directed);
        var nodeMap = graph.nodeMap;
        var dfsCodeMin = new DFScode2();
        var root = {};
        graph.nodes.forEach(function(node) {
          var forwardEdges = _this.findForwardRootEdges(graph, node);
          forwardEdges.forEach(function(edge) {
            var otherNode = nodeMap[edge.to];
            var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
            if (!root[nodeEdgeNodeLabel])
              root[nodeEdgeNodeLabel] = {
                projected: [],
                nodeLabel1: node.label,
                edgeLabel: edge.label,
                nodeLabel2: otherNode.label
              };
            var pdfs = {
              graphId: graph.id,
              edge,
              preNode: null
            };
            root[nodeEdgeNodeLabel].projected.push(pdfs);
          });
        });
        var minLabel = this.findMinLabel(root);
        if (!minLabel)
          return;
        dfsCodeMin.dfsEdgeList.push(new DFSedge2(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
        var projectIsMin = function projectIsMin2(projected) {
          var rmpath = dfsCodeMin.buildRmpath();
          var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
          var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
          var backwardRoot = {};
          var flag = false, newTo = 0;
          var end2 = directed ? -1 : 0;
          var _loop_1 = function _loop_12(i3) {
            if (flag)
              return "break";
            projected.forEach(function(p2) {
              var history = new History2(p2);
              var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
              if (backwardEdge) {
                if (!backwardRoot[backwardEdge.label]) {
                  backwardRoot[backwardEdge.label] = {
                    projected: [],
                    edgeLabel: backwardEdge.label
                  };
                }
                backwardRoot[backwardEdge.label].projected.push({
                  graphId: graph.id,
                  edge: backwardRoot,
                  preNode: p2
                });
                newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
                flag = true;
              }
            });
          };
          for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
            var state_1 = _loop_1(i2);
            if (state_1 === "break")
              break;
          }
          if (flag) {
            var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
            dfsCodeMin.dfsEdgeList.push(new DFSedge2(maxToC, newTo, _struct.VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, _struct.VACANT_NODE_LABEL));
            var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
            if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1])
              return false;
            return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
          }
          var forwardRoot = {};
          flag = false;
          var newFrom = 0;
          projected.forEach(function(p2) {
            var history = new History2(p2);
            var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
            if (forwardPureEdges.length > 0) {
              flag = true;
              newFrom = maxToC;
              forwardPureEdges.forEach(function(edge) {
                var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                if (!forwardRoot[key2])
                  forwardRoot[key2] = {
                    projected: [],
                    edgeLabel: edge.label,
                    nodeLabel2: nodeMap[edge.to].label
                  };
                forwardRoot[key2].projected.push({
                  graphId: graph.id,
                  edge,
                  preNode: p2
                });
              });
            }
          });
          var pathLength = rmpath.length;
          var _loop_2 = function _loop_22(i3) {
            if (flag)
              return "break";
            var value = rmpath[i3];
            projected.forEach(function(p2) {
              var history = new History2(p2);
              var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
              if (forwardRmpathEdges.length > 0) {
                flag = true;
                newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
                forwardRmpathEdges.forEach(function(edge) {
                  var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
                  if (!forwardRoot[key2])
                    forwardRoot[key2] = {
                      projected: [],
                      edgeLabel: edge.label,
                      nodeLabel2: nodeMap[edge.to].label
                    };
                  forwardRoot[key2].projected.push({
                    graphId: graph.id,
                    edge,
                    preNode: p2
                  });
                });
              }
            });
          };
          for (var i2 = 0; i2 < pathLength; i2++) {
            var state_2 = _loop_2(i2);
            if (state_2 === "break")
              break;
          }
          if (!flag)
            return true;
          var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
          dfsCodeMin.dfsEdgeList.push(new DFSedge2(newFrom, maxToC + 1, _struct.VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
          var idx = dfsCodeMin.dfsEdgeList.length - 1;
          if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])
            return false;
          return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
        };
        var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
        return projectIsMin(root[key].projected);
      };
      GSpan3.prototype.report = function() {
        if (this.dfsCode.getNodeNum() < this.minNodeNum)
          return;
        this.counter++;
        var graph = this.dfsCode.toGraph(this.counter, this.directed);
        this.frequentSubgraphs.push((0, _util.clone)(graph));
      };
      GSpan3.prototype.subGraphMining = function(projected) {
        var _this = this;
        var support = this.getSupport(projected);
        if (support < this.minSupport)
          return;
        if (!this.isMin())
          return;
        this.report();
        var nodeNum = this.dfsCode.getNodeNum();
        var rmpath = this.dfsCode.buildRmpath();
        var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
        var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
        var forwardRoot = {};
        var backwardRoot = {};
        projected.forEach(function(p2) {
          var graph = _this.graphs[p2.graphId];
          var nodeMap = graph.nodeMap;
          var history = new History2(p2);
          for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
            var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
            if (backwardEdge) {
              var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
              if (!backwardRoot[key])
                backwardRoot[key] = {
                  projected: [],
                  toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
                  edgeLabel: backwardEdge.label
                };
              backwardRoot[key].projected.push({
                graphId: p2.graphId,
                edge: backwardEdge,
                preNode: p2
              });
            }
          }
          if (nodeNum >= _this.maxNodeNum)
            return;
          var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
          forwardPureEdges.forEach(function(edge) {
            var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2])
              forwardRoot[key2] = {
                projected: [],
                fromNodeId: maxToC,
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
            forwardRoot[key2].projected.push({
              graphId: p2.graphId,
              edge,
              preNode: p2
            });
          });
          var _loop_3 = function _loop_32(i3) {
            var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
            forwardRmpathEdges.forEach(function(edge) {
              var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2])
                forwardRoot[key2] = {
                  projected: [],
                  fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
              forwardRoot[key2].projected.push({
                graphId: p2.graphId,
                edge,
                preNode: p2
              });
            });
          };
          for (var i2 = 0; i2 < rmpath.length; i2++) {
            _loop_3(i2);
          }
        });
        Object.keys(backwardRoot).forEach(function(key) {
          var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
          _this.dfsCode.dfsEdgeList.push(new DFSedge2(maxToC, toNodeId, "-1", edgeLabel, "-1"));
          _this.subGraphMining(backwardRoot[key].projected);
          _this.dfsCode.dfsEdgeList.pop();
        });
        Object.keys(forwardRoot).forEach(function(key) {
          var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          _this.dfsCode.dfsEdgeList.push(new DFSedge2(fromNodeId, maxToC + 1, _struct.VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
          _this.subGraphMining(forwardRoot[key].projected);
          _this.dfsCode.dfsEdgeList.pop();
        });
      };
      GSpan3.prototype.generate1EdgeFrequentSubGraphs = function() {
        var graphs = this.graphs;
        var directed = this.directed;
        var minSupport = this.minSupport;
        var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
        var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
        var nodeLableCounted = {};
        var nodeEdgeNodeLabelCounted = {};
        Object.keys(graphs).forEach(function(key) {
          var graph = graphs[key];
          var nodeMap = graph.nodeMap;
          graph.nodes.forEach(function(node, i2) {
            var nodeLabel = node.label;
            var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
            if (!nodeLableCounted[graphNodeKey]) {
              var counter = nodeLabelCounter[nodeLabel] || 0;
              counter++;
              nodeLabelCounter[nodeLabel] = counter;
            }
            nodeLableCounted[graphNodeKey] = {
              graphKey: key,
              label: nodeLabel
            };
            node.edges.forEach(function(edge) {
              var nodeLabel1 = nodeLabel;
              var nodeLabel2 = nodeMap[edge.to].label;
              if (!directed && nodeLabel1 > nodeLabel2) {
                var tmp = nodeLabel2;
                nodeLabel2 = nodeLabel1;
                nodeLabel1 = tmp;
              }
              var edgeLabel = edge.label;
              var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
              var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
              if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
                var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
                counter2++;
                nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
              }
              nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
                graphId: key,
                nodeLabel1,
                edgeLabel,
                nodeLabel2
              };
            });
          });
        });
        Object.keys(nodeLabelCounter).forEach(function(label) {
          var count = nodeLabelCounter[label];
          if (count < minSupport)
            return;
          var g2 = {
            nodes: [],
            edges: []
          };
          g2.nodes.push({
            id: "0",
            label
          });
          frequentSize1Subgraphs.push(g2);
        });
        return frequentSize1Subgraphs;
      };
      GSpan3.prototype.run = function() {
        var _this = this;
        this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
        if (this.maxNodeNum < 2)
          return;
        var graphs = this.graphs;
        var directed = this.directed;
        var root = {};
        Object.keys(graphs).forEach(function(graphId) {
          var graph = graphs[graphId];
          var nodeMap = graph.nodeMap;
          graph.nodes.forEach(function(node) {
            var forwardRootEdges = _this.findForwardRootEdges(graph, node);
            forwardRootEdges.forEach(function(edge) {
              var toNode = nodeMap[edge.to];
              var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
              if (!root[nodeEdgeNodeLabel])
                root[nodeEdgeNodeLabel] = {
                  projected: [],
                  nodeLabel1: node.label,
                  edgeLabel: edge.label,
                  nodeLabel2: toNode.label
                };
              var pdfs = {
                graphId,
                edge,
                preNode: null
              };
              root[nodeEdgeNodeLabel].projected.push(pdfs);
            });
          });
        });
        Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
          var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
          _this.dfsCode.dfsEdgeList.push(new DFSedge2(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
          _this.subGraphMining(projected);
          _this.dfsCode.dfsEdgeList.pop();
        });
      };
      return GSpan3;
    }();
    var formatGraphs3 = function formatGraphs4(graphs, directed, nodeLabelProp, edgeLabelProp) {
      var result = {};
      Object.keys(graphs).forEach(function(key, i2) {
        var graph = graphs[key];
        var fGraph = new _struct.Graph(i2, true, directed);
        var nodeIdxMap = {};
        graph.nodes.forEach(function(node, j2) {
          fGraph.addNode(j2, node[nodeLabelProp]);
          nodeIdxMap[node.id] = j2;
        });
        graph.edges.forEach(function(edge, k2) {
          var sourceIdx = nodeIdxMap[edge.source];
          var targetIdx = nodeIdxMap[edge.target];
          fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
        });
        if (fGraph && fGraph.getNodeNum())
          result[fGraph.id] = fGraph;
      });
      return result;
    };
    var toGraphDatas3 = function toGraphDatas4(graphs, nodeLabelProp, edgeLabelProp) {
      var result = [];
      graphs.forEach(function(graph) {
        var graphData = {
          nodes: [],
          edges: []
        };
        graph.nodes.forEach(function(node) {
          var _a2;
          graphData.nodes.push((_a2 = {
            id: "".concat(node.id)
          }, _a2[nodeLabelProp] = node.label, _a2));
        });
        graph.edges.forEach(function(edge) {
          var _a2;
          graphData.edges.push((_a2 = {
            source: "".concat(edge.from),
            target: "".concat(edge.to)
          }, _a2[edgeLabelProp] = edge.label, _a2));
        });
        result.push(graphData);
      });
      return result;
    };
    var DEFAULT_LABEL_NAME2 = "cluster";
    var gSpan3 = function gSpan4(params) {
      var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME2 : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME2 : _c;
      var formattedGraphs = formatGraphs3(graphs, directed, nodeLabelProp, edgeLabelProp);
      var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
      var algoParams = {
        graphs: formattedGraphs,
        minSupport,
        maxNodeNum,
        minNodeNum,
        top,
        verbose,
        directed
      };
      var calculator = new GSpan2(algoParams);
      calculator.run();
      var result = toGraphDatas3(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
      return result;
    };
    var _default = gSpan3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/gaddi.js
var require_gaddi = __commonJS({
  "node_modules/@antv/algorithm/lib/gaddi.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _tslib = require_tslib();
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _gSpan = _interopRequireDefault(require_gSpan());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _util = require_util();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var findKNeighborUnits3 = function findKNeighborUnits4(graphData, spm, nodeLabelProp, k2) {
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (k2 === void 0) {
        k2 = 2;
      }
      var units = [];
      var nodes = graphData.nodes;
      spm.forEach(function(row, i2) {
        units.push(findKNeighborUnit3(nodes, row, i2, nodeLabelProp, k2));
      });
      return units;
    };
    var findKNeighborUnit3 = function findKNeighborUnit4(nodes, row, i2, nodeLabelProp, k2) {
      var unitNodeIdxs = [i2];
      var neighbors = [];
      var labelCountMap = {};
      row.forEach(function(v2, j2) {
        if (v2 <= k2 && i2 !== j2) {
          unitNodeIdxs.push(j2);
          neighbors.push(nodes[j2]);
          var label = nodes[j2][nodeLabelProp];
          if (!labelCountMap[label])
            labelCountMap[label] = {
              count: 1,
              dists: [v2]
            };
          else {
            labelCountMap[label].count++;
            labelCountMap[label].dists.push(v2);
          }
        }
      });
      Object.keys(labelCountMap).forEach(function(label) {
        labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a2, b10) {
          return a2 - b10;
        });
      });
      return {
        nodeIdx: i2,
        nodeId: nodes[i2].id,
        nodeIdxs: unitNodeIdxs,
        neighbors,
        neighborNum: unitNodeIdxs.length - 1,
        nodeLabelCountMap: labelCountMap
      };
    };
    var findNodePairsRandomly3 = function findNodePairsRandomly4(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
      var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
      var nodePairMap = {};
      var foundNodePairCount = 0;
      kNeighborUnits.forEach(function(unit, i2) {
        var nodePairForICount = 0;
        var outerLoopCount = 0;
        var neighbors = unit.nodeIdxs;
        var neighborNum = unit.neighborNum - 1;
        while (nodePairForICount < nodePairNumEachNode) {
          var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
          var innerLoopCount = 0;
          while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
            oidx = Math.floor(Math.random() * nodeNum);
            innerLoopCount++;
            if (innerLoopCount > 2 * nodeNum)
              break;
          }
          if (innerLoopCount < 2 * nodeNum) {
            nodePairMap["".concat(i2, "-").concat(oidx)] = {
              start: i2,
              end: oidx,
              distance: spm[i2][oidx]
            };
            nodePairForICount++;
            foundNodePairCount++;
            if (foundNodePairCount >= maxNodePairNum)
              return nodePairMap;
          }
          outerLoopCount++;
          if (outerLoopCount > 2 * nodeNum)
            break;
        }
        if (nodePairForICount < nodePairNumEachNode) {
          var gap = nodePairNumEachNode - nodePairForICount;
          nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
        }
      });
      return nodePairMap;
    };
    var getIntersectNeighborInducedGraph3 = function getIntersectNeighborInducedGraph4(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
      var nodes = graphData.nodes;
      if (!cachedInducedGraphMap)
        cachedInducedGraphMap = {};
      Object.keys(nodePairMap).forEach(function(key) {
        var _a2, _b;
        if (cachedInducedGraphMap && cachedInducedGraphMap[key])
          return;
        cachedInducedGraphMap[key] = {
          nodes: [],
          edges: []
        };
        var pair = nodePairMap[key];
        var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
        var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
        if (!startUnitNodeIds || !endUnitNodeIds)
          return;
        var endSet = new Set(endUnitNodeIds);
        var intersect2 = startUnitNodeIds.filter(function(x2) {
          return endSet.has(x2);
        });
        if (!intersect2 || !intersect2.length)
          return;
        var intersectIdMap = {};
        var intersectLength = intersect2.length;
        for (var i2 = 0; i2 < intersectLength; i2++) {
          var node = nodes[intersect2[i2]];
          cachedInducedGraphMap[key].nodes.push(node);
          intersectIdMap[node.id] = true;
        }
        graphData.edges.forEach(function(edge) {
          if (intersectIdMap[edge.source] && intersectIdMap[edge.target])
            cachedInducedGraphMap[key].edges.push(edge);
        });
      });
      return cachedInducedGraphMap;
    };
    var getMatchedCount3 = function getMatchedCount4(graph, structure, nodeLabelProp, edgeLabelProp) {
      var _a2, _b;
      var nodeMap = {};
      graph.nodes.forEach(function(node) {
        nodeMap[node.id] = node;
      });
      var count = 0;
      if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2)
        return 0;
      graph.edges.forEach(function(e8) {
        var sourceLabel = nodeMap[e8.source][nodeLabelProp];
        var targetLabel = nodeMap[e8.target][nodeLabelProp];
        var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
        var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
        var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
        if (e8[edgeLabelProp] !== strEdgeLabel)
          return;
        if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
          count++;
        }
      });
      return count;
    };
    var findRepresentStructure3 = function findRepresentStructure4(matchedCountMap, structureNum, structures) {
      var maxOffset = Infinity, representClusterType = 0;
      var _loop_1 = function _loop_12(i3) {
        var countMapI = matchedCountMap[i3];
        var sortedGraphKeys = Object.keys(countMapI).sort(function(a2, b10) {
          return countMapI[a2] - countMapI[b10];
        });
        var groupNum = 10;
        var clusters = [];
        sortedGraphKeys.forEach(function(key, j2) {
          if (!clusters[j2 % groupNum])
            clusters[j2 % groupNum] = {
              graphs: [],
              totalCount: 0,
              aveCount: 0
            };
          clusters[j2 % groupNum].graphs.push(key);
          clusters[j2 % groupNum].totalCount += countMapI[key];
        });
        var aveIntraDist = 0;
        var aveCounts = [];
        clusters.forEach(function(graphsInCluster) {
          var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
          graphsInCluster.aveCount = aveCount;
          aveCounts.push(aveCount);
          var aveIntraPerCluster = 0;
          var graphsNum = graphsInCluster.length;
          graphsInCluster.graphs.forEach(function(graphKey1, j2) {
            var graph1Count = countMapI[graphKey1];
            graphsInCluster.graphs.forEach(function(graphKey2, k2) {
              if (j2 === k2)
                return;
              aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
            });
          });
          aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
          aveIntraDist += aveIntraPerCluster;
        });
        aveIntraDist /= clusters.length;
        var aveInterDist = 0;
        aveCounts.forEach(function(aveCount1, j2) {
          aveCounts.forEach(function(aveCount2, k2) {
            if (j2 === k2)
              return;
            aveInterDist += Math.abs(aveCount1 - aveCount2);
          });
          aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
        });
        var offset = aveInterDist - aveIntraDist;
        if (maxOffset < offset) {
          maxOffset = offset;
          representClusterType = i3;
        }
      };
      for (var i2 = 0; i2 < structureNum; i2++) {
        _loop_1(i2);
      }
      return {
        structure: structures[representClusterType],
        structureCountMap: matchedCountMap[representClusterType]
      };
    };
    var getNodeMaps3 = function getNodeMaps4(nodes, nodeLabelProp) {
      var nodeMap = {}, nodeLabelMap = {};
      nodes.forEach(function(node, i2) {
        nodeMap[node.id] = {
          idx: i2,
          node,
          degree: 0,
          inDegree: 0,
          outDegree: 0
        };
        var label = node[nodeLabelProp];
        if (!nodeLabelMap[label])
          nodeLabelMap[label] = [];
        nodeLabelMap[label].push(node);
      });
      return {
        nodeMap,
        nodeLabelMap
      };
    };
    var getEdgeMaps3 = function getEdgeMaps4(edges, edgeLabelProp, nodeMap) {
      var edgeMap = {}, edgeLabelMap = {};
      edges.forEach(function(edge, i2) {
        edgeMap["".concat(_util.uniqueId)] = {
          idx: i2,
          edge
        };
        var label = edge[edgeLabelProp];
        if (!edgeLabelMap[label])
          edgeLabelMap[label] = [];
        edgeLabelMap[label].push(edge);
        var sourceNode = nodeMap[edge.source];
        if (sourceNode) {
          sourceNode.degree++;
          sourceNode.outDegree++;
        }
        var targetNode = nodeMap[edge.target];
        if (targetNode) {
          targetNode.degree++;
          targetNode.inDegree++;
        }
      });
      return {
        edgeMap,
        edgeLabelMap
      };
    };
    var getSpmMap3 = function getSpmMap4(nodes, spm, directed) {
      var length5 = spm.length;
      var map4 = {};
      spm.forEach(function(row, i2) {
        var start = directed ? 0 : i2 + 1;
        var iId = nodes[i2].id;
        for (var j2 = start; j2 < length5; j2++) {
          if (i2 === j2)
            continue;
          var jId = nodes[j2].id;
          var dist4 = row[j2];
          map4["".concat(iId, "-").concat(jId)] = dist4;
          if (!directed)
            map4["".concat(jId, "-").concat(iId)] = dist4;
        }
      });
      return map4;
    };
    var getNDSDist3 = function getNDSDist4(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
      var _a2;
      var key = "".concat(node1.id, "-").concat(node2.id);
      if (cachedNDSMap && cachedNDSMap[key])
        return cachedNDSMap[key];
      var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
      if (!interInducedGraph) {
        var pairMap = (_a2 = {}, _a2[key] = {
          start: nodeMap[node1.id].idx,
          end: nodeMap[node2.id].idx,
          distance: spDist
        }, _a2);
        cachedInterInducedGraph = getIntersectNeighborInducedGraph3(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
        interInducedGraph = cachedInterInducedGraph[key];
      }
      return getMatchedCount3(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
    };
    var stashPatternNodeLabelDegreeMap3 = function stashPatternNodeLabelDegreeMap4(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
      var _a2, _b, _c;
      var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
      var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
      var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
      if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
        minPatternNodeLabelDegree = Infinity;
        minPatternNodeLabelInDegree = Infinity;
        minPatternNodeLabelOutDegree = Infinity;
        patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
          var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
          if (minPatternNodeLabelDegree > patternNodeDegree)
            minPatternNodeLabelDegree = patternNodeDegree;
          var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
          if (minPatternNodeLabelInDegree > patternNodeInDegree)
            minPatternNodeLabelInDegree = patternNodeInDegree;
          var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
          if (minPatternNodeLabelOutDegree > patternNodeOutDegree)
            minPatternNodeLabelOutDegree = patternNodeOutDegree;
        });
        minPatternNodeLabelDegreeMap[neighborLabel] = {
          degree: minPatternNodeLabelDegree,
          inDegree: minPatternNodeLabelInDegree,
          outDegree: minPatternNodeLabelOutDegree
        };
      }
      return {
        minPatternNodeLabelDegree,
        minPatternNodeLabelInDegree,
        minPatternNodeLabelOutDegree
      };
    };
    var GADDI3 = function GADDI4(graphData, pattern, directed, k2, length5, nodeLabelProp, edgeLabelProp) {
      var _a2;
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      if (!graphData || !graphData.nodes)
        return;
      var nodeNum = graphData.nodes.length;
      if (!nodeNum)
        return;
      var spm = (0, _floydWarshall.default)(graphData, directed);
      var patternSpm = (0, _floydWarshall.default)(pattern, directed);
      var spmMap = getSpmMap3(graphData.nodes, spm, directed);
      var patternSpmMap = getSpmMap3(pattern.nodes, patternSpm, directed);
      var _b = getNodeMaps3(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
      var _c = getNodeMaps3(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
      getEdgeMaps3(graphData.edges, edgeLabelProp, nodeMap);
      var patternEdgeLabelMap = getEdgeMaps3(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
      var patternSpmSpread = [];
      patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
        patternSpmSpread = patternSpmSpread.concat(row);
      });
      if (!length5)
        length5 = Math.max.apply(Math, (0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], patternSpmSpread, false), [2], false));
      if (!k2)
        k2 = length5;
      var kNeighborUnits = findKNeighborUnits3(graphData, spm, nodeLabelProp, k2);
      var patternKNeighborUnits = findKNeighborUnits3(pattern, patternSpm, nodeLabelProp, k2);
      var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
      var nodePairsMap = findNodePairsRandomly3(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
      var intGMap = getIntersectNeighborInducedGraph3(nodePairsMap, kNeighborUnits, graphData);
      var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
      var params = {
        graphs: intGMap,
        nodeLabelProp,
        edgeLabelProp,
        minSupport,
        minNodeNum,
        maxNodeNum,
        directed
      };
      var freStructures = (0, _gSpan.default)(params).slice(0, top);
      var structureNum = freStructures.length;
      var matchedCountMap = [];
      freStructures.forEach(function(structure, i3) {
        matchedCountMap[i3] = {};
        Object.keys(intGMap).forEach(function(key) {
          var graph = intGMap[key];
          var subStructureCount = getMatchedCount3(graph, structure, nodeLabelProp, edgeLabelProp);
          matchedCountMap[i3][key] = subStructureCount;
        });
      });
      var _d = findRepresentStructure3(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
      var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
      pattern.nodes.forEach(function(node) {
        var pLabel = node[nodeLabelProp];
        var nodesWithSameLabel = nodeLabelMap[pLabel];
        if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
          maxNodeNumWithSameLabel = nodesWithSameLabel.length;
          candidates = nodesWithSameLabel;
          label = pLabel;
          beginPNode = node;
        }
      });
      var minPatternNodeLabelDegreeMap = {};
      var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
      var patternSpDist = {};
      var patternSpDistBack = {};
      Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
        patternSpDist[label2] = [];
        if (directed) {
          patternSpDistBack[label2] = [];
        }
        var maxDist = -Infinity;
        var patternNodesWithLabel2 = patternNodeLabelMap[label2];
        var patternNodePairMap = {};
        patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
          var dist4 = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
          dist4 && patternSpDist[label2].push(dist4);
          if (maxDist < dist4)
            maxDist = dist4;
          patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
            start: 0,
            end: patternNodeMap[nodeWithLabel2.id].idx,
            distance: dist4
          };
          if (directed) {
            var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
            distBack && patternSpDistBack[label2].push(distBack);
          }
        });
        patternSpDist[label2] = patternSpDist[label2].sort(function(a2, b10) {
          return a2 - b10;
        });
        if (directed)
          patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a2, b10) {
            return a2 - b10;
          });
        patternIntGraphMap = getIntersectNeighborInducedGraph3(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
        var currentPatternNDSDistArray = [];
        Object.keys(patternNodePairMap).forEach(function(key) {
          if (patternNDSDist[key]) {
            currentPatternNDSDistArray.push(patternNDSDist[key]);
            return;
          }
          var patternIntGraph = patternIntGraphMap[key];
          patternNDSDist[key] = getMatchedCount3(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
          currentPatternNDSDistArray.push(patternNDSDist[key]);
        });
        currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a2, b10) {
          return b10 - a2;
        });
        patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
        if (label2 === label)
          return;
        var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
        var _loop_4 = function _loop_42(m3) {
          var cNode = candidates[m3];
          var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
          var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
          var patternLabel2Num = patternNodeLabelMap[label2].length;
          if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
            candidates.splice(m3, 1);
            return "continue";
          }
          var prune2Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
              prune2Invalid = true;
              break;
            }
          }
          if (prune2Invalid) {
            candidates.splice(m3, 1);
            return "continue";
          }
          var cNodePairMap = {};
          graphNeighborUnit.neighbors.forEach(function(neighborNode) {
            var dist4 = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
            cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
              start: nodeMap[cNode.id].idx,
              end: nodeMap[neighborNode.id].idx,
              distance: dist4
            };
          });
          intGMap = getIntersectNeighborInducedGraph3(cNodePairMap, kNeighborUnits, graphData, intGMap);
          var currentNDSDistArray = [];
          Object.keys(cNodePairMap).forEach(function(key) {
            if (ndsDist[key]) {
              currentNDSDistArray.push(ndsDist[key]);
              return;
            }
            var intGraph = intGMap[key];
            ndsDist[key] = getMatchedCount3(intGraph, dsG, nodeLabelProp, edgeLabelProp);
            currentNDSDistArray.push(ndsDist[key]);
          });
          currentNDSDistArray = currentNDSDistArray.sort(function(a2, b10) {
            return b10 - a2;
          });
          var prune3Invalid = false;
          for (var n2 = 0; n2 < patternLabel2Num; n2++) {
            if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
              prune3Invalid = true;
              break;
            }
          }
          if (prune3Invalid) {
            candidates.splice(m3, 1);
            return "continue";
          }
        };
        for (var m2 = candidatesNum - 1; m2 >= 0; m2--) {
          _loop_4(m2);
        }
      });
      var candidateGraphs = [];
      candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
        var nodeIdx = nodeMap[candidate.id].idx;
        var lengthNeighborUnit = findKNeighborUnit3(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length5);
        var neighborNodes = lengthNeighborUnit.neighbors;
        var neighborNum = neighborNodes.length;
        var unmatched = false;
        for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
          if (neighborNodes.length + 1 < pattern.nodes.length) {
            unmatched = true;
            return;
          }
          var neighborNode = neighborNodes[i3];
          var neighborLabel = neighborNode[nodeLabelProp];
          if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var key = "".concat(candidate.id, "-").concat(neighborNode.id);
          var distToCandidate = spmMap[key];
          var idx = patternSpDist[neighborLabel].length - 1;
          var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
          if (distToCandidate > maxDistWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          if (directed) {
            var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
            var distFromCandidate = spmMap[keyBack];
            idx = patternSpDistBack[neighborLabel].length - 1;
            var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
            if (distFromCandidate > maxBackDistWithLabelInPattern) {
              neighborNodes.splice(i3, 1);
              continue;
            }
          }
          var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist3(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
          var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
          var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
          if (ndsToCandidate < minNdsWithLabelInPattern) {
            neighborNodes.splice(i3, 1);
            continue;
          }
          var _a3 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
          if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
            neighborNodes.splice(i3, 1);
            continue;
          }
        }
        if (!unmatched) {
          candidateGraphs.push({
            nodes: [candidate].concat(neighborNodes)
          });
        }
      });
      var undirectedLengthsToBeginPNode = (0, _dijkstra.default)(pattern, beginPNode.id, false).length;
      var undirectedLengthsToBeginPNodeLabelMap = {};
      if (directed) {
        Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
          var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])
            undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
          else
            undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
        });
        Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
          undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a2, b10) {
            return a2 - b10;
          });
        });
      } else {
        undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
      }
      var candidateGraphNum = candidateGraphs.length;
      var _loop_2 = function _loop_22(i3) {
        var candidateGraph = candidateGraphs[i3];
        var candidate = candidateGraph.nodes[0];
        var candidateNodeLabelCountMap = {};
        var candidateNodeMap = {};
        candidateGraph.nodes.forEach(function(node, q2) {
          candidateNodeMap[node.id] = {
            idx: q2,
            node,
            degree: 0,
            inDegree: 0,
            outDegree: 0
          };
          var cNodeLabel2 = node[nodeLabelProp];
          if (!candidateNodeLabelCountMap[cNodeLabel2])
            candidateNodeLabelCountMap[cNodeLabel2] = 1;
          else
            candidateNodeLabelCountMap[cNodeLabel2]++;
        });
        var candidateEdges = [];
        var edgeLabelCountMap = {};
        graphData.edges.forEach(function(edge) {
          if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
            candidateEdges.push(edge);
            if (!edgeLabelCountMap[edge[edgeLabelProp]])
              edgeLabelCountMap[edge[edgeLabelProp]] = 1;
            else
              edgeLabelCountMap[edge[edgeLabelProp]]++;
            candidateNodeMap[edge.source].degree++;
            candidateNodeMap[edge.target].degree++;
            candidateNodeMap[edge.source].outDegree++;
            candidateNodeMap[edge.target].inDegree++;
          }
        });
        var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
        var prunedByEdgeLabel = false;
        for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
          var label_1 = Object.keys(patternEdgeLabelMap)[e8];
          if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
            prunedByEdgeLabel = true;
            break;
          }
        }
        if (prunedByEdgeLabel) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var candidateEdgeNum = candidateEdges.length;
        if (candidateEdgeNum < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "break";
        }
        var candidateGraphInvalid = false;
        var _loop_5 = function _loop_52(e9) {
          var edge = candidateEdges[e9];
          var edgeLabel2 = edge[edgeLabelProp];
          var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
          if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
          var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
          var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
          var edgeMatched = false;
          patternEdgesWithLabel.forEach(function(patternEdge) {
            var patternSource = patternNodeMap[patternEdge.source].node;
            var patternTarget = patternNodeMap[patternEdge.target].node;
            if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel)
              edgeMatched = true;
            if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel)
              edgeMatched = true;
          });
          if (!edgeMatched) {
            edgeLabelCountMap[edgeLabel2]--;
            if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
              candidateGraphInvalid = true;
              return "break";
            }
            candidateEdges.splice(e9, 1);
            candidateNodeMap[edge.source].degree--;
            candidateNodeMap[edge.target].degree--;
            candidateNodeMap[edge.source].outDegree--;
            candidateNodeMap[edge.target].inDegree--;
            return "continue";
          }
        };
        for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
          var state_2 = _loop_5(e8);
          if (state_2 === "break")
            break;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        candidateGraph.edges = candidateEdges;
        var lengthsToCandidate = (0, _dijkstra.default)(candidateGraph, candidateGraph.nodes[0].id, false).length;
        Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
          if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid)
            return;
          if (lengthsToCandidate[targetId] === Infinity) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
            return;
          }
          var nLabel = nodeMap[targetId].node[nodeLabelProp];
          if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
            var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
            candidateNodeLabelCountMap[targetNodeLabel]--;
            if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
              candidateGraphInvalid = true;
              return;
            }
            var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
            candidateGraph.nodes.splice(idx, 1);
            candidateNodeMap[targetId] = void 0;
          }
        });
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        var degreeChanged = true;
        var loopCount = 0;
        while (degreeChanged && !candidateGraphInvalid) {
          degreeChanged = false;
          var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
          if (condition) {
            candidateGraphInvalid = true;
            break;
          }
          if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          var currentCandidateNodeNum = candidateGraph.nodes.length;
          for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
            var cgNode = candidateGraph.nodes[o2];
            var nodeDegree = candidateNodeMap[cgNode.id].degree;
            var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
            var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
            var cNodeLabel = cgNode[nodeLabelProp];
            var _e2 = stashPatternNodeLabelDegreeMap3(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
            var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
            if (deleteCondition) {
              candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
              if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
                candidateGraphInvalid = true;
                break;
              }
              candidateGraph.nodes.splice(o2, 1);
              candidateNodeMap[cgNode.id] = void 0;
              degreeChanged = true;
            }
          }
          if (candidateGraphInvalid || !degreeChanged && loopCount !== 0)
            break;
          candidateEdgeNum = candidateEdges.length;
          for (var y2 = candidateEdgeNum - 1; y2 >= 0; y2--) {
            var cedge = candidateEdges[y2];
            if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
              candidateEdges.splice(y2, 1);
              var edgeLabel = cedge[edgeLabelProp];
              edgeLabelCountMap[edgeLabel]--;
              if (candidateNodeMap[cedge.source]) {
                candidateNodeMap[cedge.source].degree--;
                candidateNodeMap[cedge.source].outDegree--;
              }
              if (candidateNodeMap[cedge.target]) {
                candidateNodeMap[cedge.target].degree--;
                candidateNodeMap[cedge.target].inDegree--;
              }
              if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
                candidateGraphInvalid = true;
                break;
              }
              degreeChanged = true;
            }
          }
          loopCount++;
        }
        if (candidateGraphInvalid) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
        if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
          candidateGraphs.splice(i3, 1);
          return "continue";
        }
      };
      for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
        var state_1 = _loop_2(i2);
        if (state_1 === "break")
          break;
      }
      var currentLength = candidateGraphs.length;
      var _loop_3 = function _loop_32(i3) {
        var cg1 = candidateGraphs[i3];
        var cg1EdgeMap = {};
        cg1.edges.forEach(function(edge) {
          var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
          if (!cg1EdgeMap[key])
            cg1EdgeMap[key] = 1;
          else
            cg1EdgeMap[key]++;
        });
        var _loop_6 = function _loop_62(j3) {
          var cg2 = candidateGraphs[j3];
          var cg2EdgeMap = {};
          cg2.edges.forEach(function(edge) {
            var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
            if (!cg2EdgeMap[key])
              cg2EdgeMap[key] = 1;
            else
              cg2EdgeMap[key]++;
          });
          var same = true;
          if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
            same = false;
          } else {
            Object.keys(cg1EdgeMap).forEach(function(key) {
              if (cg2EdgeMap[key] !== cg1EdgeMap[key])
                same = false;
            });
          }
          if (same) {
            candidateGraphs.splice(j3, 1);
          }
        };
        for (var j2 = currentLength - 1; j2 > i3; j2--) {
          _loop_6(j2);
        }
        currentLength = candidateGraphs.length;
      };
      for (var i2 = 0; i2 <= currentLength - 1; i2++) {
        _loop_3(i2);
      }
      return candidateGraphs;
    };
    var _default = GADDI3;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/algorithm.js
var require_algorithm = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/algorithm.js"(exports) {
    "use strict";
    function _typeof6(obj) {
      "@babel/helpers - typeof";
      return _typeof6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof6(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDI", {
      enumerable: true,
      get: function get2() {
        return _gaddi.default;
      }
    });
    Object.defineProperty(exports, "breadthFirstSearch", {
      enumerable: true,
      get: function get2() {
        return _bfs.default;
      }
    });
    Object.defineProperty(exports, "connectedComponent", {
      enumerable: true,
      get: function get2() {
        return _connectedComponent.default;
      }
    });
    Object.defineProperty(exports, "depthFirstSearch", {
      enumerable: true,
      get: function get2() {
        return _dfs.default;
      }
    });
    Object.defineProperty(exports, "detectCycle", {
      enumerable: true,
      get: function get2() {
        return _detectCycle.default;
      }
    });
    Object.defineProperty(exports, "dijkstra", {
      enumerable: true,
      get: function get2() {
        return _dijkstra.default;
      }
    });
    Object.defineProperty(exports, "findAllPath", {
      enumerable: true,
      get: function get2() {
        return _findPath.findAllPath;
      }
    });
    Object.defineProperty(exports, "findShortestPath", {
      enumerable: true,
      get: function get2() {
        return _findPath.findShortestPath;
      }
    });
    Object.defineProperty(exports, "floydWarshall", {
      enumerable: true,
      get: function get2() {
        return _floydWarshall.default;
      }
    });
    Object.defineProperty(exports, "getAdjMatrix", {
      enumerable: true,
      get: function get2() {
        return _adjacentMatrix.default;
      }
    });
    Object.defineProperty(exports, "getDegree", {
      enumerable: true,
      get: function get2() {
        return _degree.default;
      }
    });
    Object.defineProperty(exports, "getInDegree", {
      enumerable: true,
      get: function get2() {
        return _degree.getInDegree;
      }
    });
    Object.defineProperty(exports, "getNeighbors", {
      enumerable: true,
      get: function get2() {
        return _util.getNeighbors;
      }
    });
    Object.defineProperty(exports, "getOutDegree", {
      enumerable: true,
      get: function get2() {
        return _degree.getOutDegree;
      }
    });
    Object.defineProperty(exports, "labelPropagation", {
      enumerable: true,
      get: function get2() {
        return _labelPropagation.default;
      }
    });
    Object.defineProperty(exports, "louvain", {
      enumerable: true,
      get: function get2() {
        return _louvain.default;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTree", {
      enumerable: true,
      get: function get2() {
        return _mts.default;
      }
    });
    Object.defineProperty(exports, "pageRank", {
      enumerable: true,
      get: function get2() {
        return _pageRank.default;
      }
    });
    var _adjacentMatrix = _interopRequireDefault(require_adjacent_matrix());
    var _bfs = _interopRequireDefault(require_bfs());
    var _connectedComponent = _interopRequireDefault(require_connected_component());
    var _degree = _interopRequireWildcard(require_degree());
    var _detectCycle = _interopRequireDefault(require_detect_cycle());
    var _dfs = _interopRequireDefault(require_dfs());
    var _dijkstra = _interopRequireDefault(require_dijkstra());
    var _findPath = require_find_path();
    var _floydWarshall = _interopRequireDefault(require_floydWarshall());
    var _labelPropagation = _interopRequireDefault(require_label_propagation());
    var _louvain = _interopRequireDefault(require_louvain());
    var _mts = _interopRequireDefault(require_mts());
    var _pageRank = _interopRequireDefault(require_pageRank());
    var _gaddi = _interopRequireDefault(require_gaddi());
    var _util = require_util();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof6(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@antv/algorithm/lib/workers/index.worker.js
var require_index_worker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.worker.js"(exports) {
    "use strict";
    function _typeof6(obj) {
      "@babel/helpers - typeof";
      return _typeof6 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof6(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var algorithm = _interopRequireWildcard(require_algorithm());
    var _constant = require_constant();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof6(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache3 = _getRequireWildcardCache(nodeInterop);
      if (cache3 && cache3.has(obj)) {
        return cache3.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache3) {
        cache3.set(obj, newObj);
      }
      return newObj;
    }
    var ctx2 = typeof self !== "undefined" ? self : {};
    ctx2.onmessage = function(event) {
      var _a2 = event.data, _algorithmType = _a2._algorithmType, data = _a2.data;
      if (!_algorithmType) {
        return;
      }
      if (typeof algorithm[_algorithmType] === "function") {
        var result = algorithm[_algorithmType].apply(algorithm, data);
        ctx2.postMessage({
          _algorithmType: _constant.MESSAGE.SUCCESS,
          data: result
        });
        return;
      }
      ctx2.postMessage({
        _algorithmType: _constant.MESSAGE.FAILURE
      });
    };
    var _default = null;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/createWorker.js
var require_createWorker = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/createWorker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _constant = require_constant();
    var _index = _interopRequireDefault(require_index_worker());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var createWorker = function createWorker2(type) {
      return function() {
        var data = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          data[_i2] = arguments[_i2];
        }
        return new Promise(function(resolve2, reject) {
          var worker = new _index.default();
          worker.postMessage({
            _algorithmType: type,
            data
          });
          worker.onmessage = function(event) {
            var _a2 = event.data, data2 = _a2.data, _algorithmType = _a2._algorithmType;
            if (_constant.MESSAGE.SUCCESS === _algorithmType) {
              resolve2(data2);
            } else {
              reject();
            }
            worker.terminate();
          };
        });
      };
    };
    var _default = createWorker;
    exports.default = _default;
  }
});

// node_modules/@antv/algorithm/lib/workers/index.js
var require_workers = __commonJS({
  "node_modules/@antv/algorithm/lib/workers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pageRankAsync = exports.minimumSpanningTreeAsync = exports.louvainAsync = exports.labelPropagationAsync = exports.getOutDegreeAsync = exports.getNeighborsAsync = exports.getInDegreeAsync = exports.getDegreeAsync = exports.getAdjMatrixAsync = exports.floydWarshallAsync = exports.findShortestPathAsync = exports.findAllPathAsync = exports.dijkstraAsync = exports.detectCycleAsync = exports.detectAllUndirectedCycleAsync = exports.detectAllDirectedCycleAsync = exports.detectAllCyclesAsync = exports.connectedComponentAsync = exports.GADDIAsync = void 0;
    var _createWorker = _interopRequireDefault(require_createWorker());
    var _constant = require_constant();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var getAdjMatrixAsync = function getAdjMatrixAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getAdjMatrix).apply(void 0, [graphData, directed]);
    };
    exports.getAdjMatrixAsync = getAdjMatrixAsync;
    var connectedComponentAsync = function connectedComponentAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.connectedComponent).apply(void 0, [graphData, directed]);
    };
    exports.connectedComponentAsync = connectedComponentAsync;
    var getDegreeAsync = function getDegreeAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getDegree)(graphData);
    };
    exports.getDegreeAsync = getDegreeAsync;
    var getInDegreeAsync = function getInDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getInDegree)(graphData, nodeId);
    };
    exports.getInDegreeAsync = getInDegreeAsync;
    var getOutDegreeAsync = function getOutDegreeAsync2(graphData, nodeId) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getOutDegree)(graphData, nodeId);
    };
    exports.getOutDegreeAsync = getOutDegreeAsync;
    var detectCycleAsync = function detectCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectCycle)(graphData);
    };
    exports.detectCycleAsync = detectCycleAsync;
    var detectAllCyclesAsync = function detectAllCyclesAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllCycles)(graphData);
    };
    exports.detectAllCyclesAsync = detectAllCyclesAsync;
    var detectAllDirectedCycleAsync = function detectAllDirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllDirectedCycle)(graphData);
    };
    exports.detectAllDirectedCycleAsync = detectAllDirectedCycleAsync;
    var detectAllUndirectedCycleAsync = function detectAllUndirectedCycleAsync2(graphData) {
      return (0, _createWorker.default)(_constant.ALGORITHM.detectAllUndirectedCycle)(graphData);
    };
    exports.detectAllUndirectedCycleAsync = detectAllUndirectedCycleAsync;
    var dijkstraAsync = function dijkstraAsync2(graphData, source, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.dijkstra).apply(void 0, [graphData, source, directed, weightPropertyName]);
    };
    exports.dijkstraAsync = dijkstraAsync;
    var findAllPathAsync = function findAllPathAsync2(graphData, start, end2, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findAllPath).apply(void 0, [graphData, start, end2, directed]);
    };
    exports.findAllPathAsync = findAllPathAsync;
    var findShortestPathAsync = function findShortestPathAsync2(graphData, start, end2, directed, weightPropertyName) {
      return (0, _createWorker.default)(_constant.ALGORITHM.findShortestPath).apply(void 0, [graphData, start, end2, directed, weightPropertyName]);
    };
    exports.findShortestPathAsync = findShortestPathAsync;
    var floydWarshallAsync = function floydWarshallAsync2(graphData, directed) {
      return (0, _createWorker.default)(_constant.ALGORITHM.floydWarshall).apply(void 0, [graphData, directed]);
    };
    exports.floydWarshallAsync = floydWarshallAsync;
    var labelPropagationAsync = function labelPropagationAsync2(graphData, directed, weightPropertyName, maxIteration) {
      if (maxIteration === void 0) {
        maxIteration = 1e3;
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.labelPropagation)(graphData, directed, weightPropertyName, maxIteration);
    };
    exports.labelPropagationAsync = labelPropagationAsync;
    var louvainAsync = function louvainAsync2(graphData, directed, weightPropertyName, threshold) {
      return (0, _createWorker.default)(_constant.ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);
    };
    exports.louvainAsync = louvainAsync;
    var minimumSpanningTreeAsync = function minimumSpanningTreeAsync2(graphData, weight, algo) {
      return (0, _createWorker.default)(_constant.ALGORITHM.minimumSpanningTree).apply(void 0, [graphData, weight, algo]);
    };
    exports.minimumSpanningTreeAsync = minimumSpanningTreeAsync;
    var pageRankAsync = function pageRankAsync2(graphData, epsilon, linkProb) {
      return (0, _createWorker.default)(_constant.ALGORITHM.pageRank).apply(void 0, [graphData, epsilon, linkProb]);
    };
    exports.pageRankAsync = pageRankAsync;
    var getNeighborsAsync = function getNeighborsAsync2(nodeId, edges, type) {
      return (0, _createWorker.default)(_constant.ALGORITHM.getNeighbors).apply(void 0, [nodeId, edges, type]);
    };
    exports.getNeighborsAsync = getNeighborsAsync;
    var GADDIAsync = function GADDIAsync2(graphData, pattern, directed, k2, length5, nodeLabelProp, edgeLabelProp) {
      if (directed === void 0) {
        directed = false;
      }
      if (nodeLabelProp === void 0) {
        nodeLabelProp = "cluster";
      }
      if (edgeLabelProp === void 0) {
        edgeLabelProp = "cluster";
      }
      return (0, _createWorker.default)(_constant.ALGORITHM.GADDI).apply(void 0, [graphData, pattern, directed, k2, length5, nodeLabelProp, edgeLabelProp]);
    };
    exports.GADDIAsync = GADDIAsync;
  }
});

// node_modules/@antv/algorithm/lib/asyncIndex.js
var require_asyncIndex = __commonJS({
  "node_modules/@antv/algorithm/lib/asyncIndex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "GADDIAsync", {
      enumerable: true,
      get: function get2() {
        return _index.GADDIAsync;
      }
    });
    Object.defineProperty(exports, "connectedComponentAsync", {
      enumerable: true,
      get: function get2() {
        return _index.connectedComponentAsync;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "detectAllCyclesAsync", {
      enumerable: true,
      get: function get2() {
        return _index.detectAllCyclesAsync;
      }
    });
    Object.defineProperty(exports, "detectAllDirectedCycleAsync", {
      enumerable: true,
      get: function get2() {
        return _index.detectAllDirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectAllUndirectedCycleAsync", {
      enumerable: true,
      get: function get2() {
        return _index.detectAllUndirectedCycleAsync;
      }
    });
    Object.defineProperty(exports, "detectCycleAsync", {
      enumerable: true,
      get: function get2() {
        return _index.detectCycleAsync;
      }
    });
    exports.detectDirectedCycleAsync = void 0;
    Object.defineProperty(exports, "dijkstraAsync", {
      enumerable: true,
      get: function get2() {
        return _index.dijkstraAsync;
      }
    });
    Object.defineProperty(exports, "findAllPathAsync", {
      enumerable: true,
      get: function get2() {
        return _index.findAllPathAsync;
      }
    });
    Object.defineProperty(exports, "findShortestPathAsync", {
      enumerable: true,
      get: function get2() {
        return _index.findShortestPathAsync;
      }
    });
    Object.defineProperty(exports, "floydWarshallAsync", {
      enumerable: true,
      get: function get2() {
        return _index.floydWarshallAsync;
      }
    });
    Object.defineProperty(exports, "getAdjMatrixAsync", {
      enumerable: true,
      get: function get2() {
        return _index.getAdjMatrixAsync;
      }
    });
    Object.defineProperty(exports, "getDegreeAsync", {
      enumerable: true,
      get: function get2() {
        return _index.getDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getInDegreeAsync", {
      enumerable: true,
      get: function get2() {
        return _index.getInDegreeAsync;
      }
    });
    Object.defineProperty(exports, "getNeighborsAsync", {
      enumerable: true,
      get: function get2() {
        return _index.getNeighborsAsync;
      }
    });
    Object.defineProperty(exports, "getOutDegreeAsync", {
      enumerable: true,
      get: function get2() {
        return _index.getOutDegreeAsync;
      }
    });
    Object.defineProperty(exports, "labelPropagationAsync", {
      enumerable: true,
      get: function get2() {
        return _index.labelPropagationAsync;
      }
    });
    Object.defineProperty(exports, "louvainAsync", {
      enumerable: true,
      get: function get2() {
        return _index.louvainAsync;
      }
    });
    Object.defineProperty(exports, "minimumSpanningTreeAsync", {
      enumerable: true,
      get: function get2() {
        return _index.minimumSpanningTreeAsync;
      }
    });
    Object.defineProperty(exports, "pageRankAsync", {
      enumerable: true,
      get: function get2() {
        return _index.pageRankAsync;
      }
    });
    var _index = require_workers();
    var detectDirectedCycleAsync = _index.detectCycleAsync;
    exports.detectDirectedCycleAsync = detectDirectedCycleAsync;
    var _default = {
      getAdjMatrixAsync: _index.getAdjMatrixAsync,
      connectedComponentAsync: _index.connectedComponentAsync,
      getDegreeAsync: _index.getDegreeAsync,
      getInDegreeAsync: _index.getInDegreeAsync,
      getOutDegreeAsync: _index.getOutDegreeAsync,
      detectCycleAsync: _index.detectCycleAsync,
      detectDirectedCycleAsync,
      detectAllCyclesAsync: _index.detectAllCyclesAsync,
      detectAllDirectedCycleAsync: _index.detectAllDirectedCycleAsync,
      detectAllUndirectedCycleAsync: _index.detectAllUndirectedCycleAsync,
      dijkstraAsync: _index.dijkstraAsync,
      findAllPathAsync: _index.findAllPathAsync,
      findShortestPathAsync: _index.findShortestPathAsync,
      floydWarshallAsync: _index.floydWarshallAsync,
      labelPropagationAsync: _index.labelPropagationAsync,
      louvainAsync: _index.louvainAsync,
      minimumSpanningTreeAsync: _index.minimumSpanningTreeAsync,
      pageRankAsync: _index.pageRankAsync,
      getNeighborsAsync: _index.getNeighborsAsync,
      GADDIAsync: _index.GADDIAsync
    };
    exports.default = _default;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports, module) {
    module.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports, module) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module.exports = function swizzle2(args) {
      var results = [];
      for (var i2 = 0, len5 = args.length; i2 < len5; i2++) {
        var arg = args[i2];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn2) {
      return function() {
        return fn2(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports, module) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty4 = Object.hasOwnProperty;
    var reverseNames = {};
    for (name in colorNames) {
      if (hasOwnProperty4.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb2 = [0, 0, 0, 1];
      var match;
      var i2;
      var hexAlpha;
      if (match = string.match(hex2)) {
        hexAlpha = match[2];
        match = match[1];
        for (i2 = 0; i2 < 3; i2++) {
          var i22 = i2 * 2;
          rgb2[i2] = parseInt(match.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = parseInt(match[i2] + match[i2], 16);
        }
        if (hexAlpha) {
          rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba2)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = parseInt(match[i2 + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i2 = 0; i2 < 3; i2++) {
          rgb2[i2] = Math.round(parseFloat(match[i2 + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb2[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb2[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty4.call(colorNames, match[1])) {
          return null;
        }
        rgb2 = colorNames[match[1]];
        rgb2[3] = 1;
        return rgb2;
      } else {
        return null;
      }
      for (i2 = 0; i2 < 3; i2++) {
        rgb2[i2] = clamp2(rgb2[i2], 0, 255);
      }
      rgb2[3] = clamp2(rgb2[3], 0, 1);
      return rgb2;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl3 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl3);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var s2 = clamp2(parseFloat(match[2]), 0, 100);
        var l2 = clamp2(parseFloat(match[3]), 0, 100);
        var a2 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, s2, l2, a2];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h2 = (parseFloat(match[1]) % 360 + 360) % 360;
        var w2 = clamp2(parseFloat(match[2]), 0, 100);
        var b10 = clamp2(parseFloat(match[3]), 0, 100);
        var a2 = clamp2(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h2, w2, b10, a2];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba2 = swizzle(arguments);
      return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba2 = swizzle(arguments);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba2 = swizzle(arguments);
      var r2 = Math.round(rgba2[0] / 255 * 100);
      var g2 = Math.round(rgba2[1] / 255 * 100);
      var b10 = Math.round(rgba2[2] / 255 * 100);
      return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r2 + "%, " + g2 + "%, " + b10 + "%)" : "rgba(" + r2 + "%, " + g2 + "%, " + b10 + "%, " + rgba2[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla2 = swizzle(arguments);
      return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a2 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a2 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a2 + ")";
    };
    cs.to.keyword = function(rgb2) {
      return reverseNames[rgb2.slice(0, 3)];
    };
    function clamp2(num, min6, max7) {
      return Math.min(Math.max(min6, num), max7);
    }
    function hexDouble(num) {
      var str7 = Math.round(num).toString(16).toUpperCase();
      return str7.length < 2 ? "0" + str7 : str7;
    }
  }
});

// node_modules/color/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color/node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color/node_modules/color-convert/conversions.js"(exports, module) {
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module.exports = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var min6 = Math.min(r2, g2, b10);
      var max7 = Math.max(r2, g2, b10);
      var delta = max7 - min6;
      var h2;
      var s2;
      var l2;
      if (max7 === min6) {
        h2 = 0;
      } else if (r2 === max7) {
        h2 = (g2 - b10) / delta;
      } else if (g2 === max7) {
        h2 = 2 + (b10 - r2) / delta;
      } else if (b10 === max7) {
        h2 = 4 + (r2 - g2) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      l2 = (min6 + max7) / 2;
      if (max7 === min6) {
        s2 = 0;
      } else if (l2 <= 0.5) {
        s2 = delta / (max7 + min6);
      } else {
        s2 = delta / (2 - max7 - min6);
      }
      return [h2, s2 * 100, l2 * 100];
    };
    convert.rgb.hsv = function(rgb2) {
      var rdif;
      var gdif;
      var bdif;
      var h2;
      var s2;
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var v2 = Math.max(r2, g2, b10);
      var diff = v2 - Math.min(r2, g2, b10);
      var diffc = function(c2) {
        return (v2 - c2) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h2 = s2 = 0;
      } else {
        s2 = diff / v2;
        rdif = diffc(r2);
        gdif = diffc(g2);
        bdif = diffc(b10);
        if (r2 === v2) {
          h2 = bdif - gdif;
        } else if (g2 === v2) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b10 === v2) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s2 * 100,
        v2 * 100
      ];
    };
    convert.rgb.hwb = function(rgb2) {
      var r2 = rgb2[0];
      var g2 = rgb2[1];
      var b10 = rgb2[2];
      var h2 = convert.rgb.hsl(rgb2)[0];
      var w2 = 1 / 255 * Math.min(r2, Math.min(g2, b10));
      b10 = 1 - 1 / 255 * Math.max(r2, Math.max(g2, b10));
      return [h2, w2 * 100, b10 * 100];
    };
    convert.rgb.cmyk = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var c2;
      var m2;
      var y2;
      var k2;
      k2 = Math.min(1 - r2, 1 - g2, 1 - b10);
      c2 = (1 - r2 - k2) / (1 - k2) || 0;
      m2 = (1 - g2 - k2) / (1 - k2) || 0;
      y2 = (1 - b10 - k2) / (1 - k2) || 0;
      return [c2 * 100, m2 * 100, y2 * 100, k2 * 100];
    };
    function comparativeDistance(x2, y2) {
      return Math.pow(x2[0] - y2[0], 2) + Math.pow(x2[1] - y2[1], 2) + Math.pow(x2[2] - y2[2], 2);
    }
    convert.rgb.keyword = function(rgb2) {
      var reversed = reverseKeywords[rgb2];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value = cssKeywords[keyword];
          var distance11 = comparativeDistance(rgb2, value);
          if (distance11 < currentClosestDistance) {
            currentClosestDistance = distance11;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      r2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92;
      g2 = g2 > 0.04045 ? Math.pow((g2 + 0.055) / 1.055, 2.4) : g2 / 12.92;
      b10 = b10 > 0.04045 ? Math.pow((b10 + 0.055) / 1.055, 2.4) : b10 / 12.92;
      var x2 = r2 * 0.4124 + g2 * 0.3576 + b10 * 0.1805;
      var y2 = r2 * 0.2126 + g2 * 0.7152 + b10 * 0.0722;
      var z2 = r2 * 0.0193 + g2 * 0.1192 + b10 * 0.9505;
      return [x2 * 100, y2 * 100, z2 * 100];
    };
    convert.rgb.lab = function(rgb2) {
      var xyz = convert.rgb.xyz(rgb2);
      var x2 = xyz[0];
      var y2 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a2;
      var b10;
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y2 - 16;
      a2 = 500 * (x2 - y2);
      b10 = 200 * (y2 - z2);
      return [l2, a2, b10];
    };
    convert.hsl.rgb = function(hsl3) {
      var h2 = hsl3[0] / 360;
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var t12;
      var t22;
      var t32;
      var rgb2;
      var val;
      if (s2 === 0) {
        val = l2 * 255;
        return [val, val, val];
      }
      if (l2 < 0.5) {
        t22 = l2 * (1 + s2);
      } else {
        t22 = l2 + s2 - l2 * s2;
      }
      t12 = 2 * l2 - t22;
      rgb2 = [0, 0, 0];
      for (var i2 = 0; i2 < 3; i2++) {
        t32 = h2 + 1 / 3 * -(i2 - 1);
        if (t32 < 0) {
          t32++;
        }
        if (t32 > 1) {
          t32--;
        }
        if (6 * t32 < 1) {
          val = t12 + (t22 - t12) * 6 * t32;
        } else if (2 * t32 < 1) {
          val = t22;
        } else if (3 * t32 < 2) {
          val = t12 + (t22 - t12) * (2 / 3 - t32) * 6;
        } else {
          val = t12;
        }
        rgb2[i2] = val * 255;
      }
      return rgb2;
    };
    convert.hsl.hsv = function(hsl3) {
      var h2 = hsl3[0];
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var smin = s2;
      var lmin = Math.max(l2, 0.01);
      var sv;
      var v2;
      l2 *= 2;
      s2 *= l2 <= 1 ? l2 : 2 - l2;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v2 = (l2 + s2) / 2;
      sv = l2 === 0 ? 2 * smin / (lmin + smin) : 2 * s2 / (l2 + s2);
      return [h2, sv * 100, v2 * 100];
    };
    convert.hsv.rgb = function(hsv) {
      var h2 = hsv[0] / 60;
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var hi2 = Math.floor(h2) % 6;
      var f2 = h2 - Math.floor(h2);
      var p2 = 255 * v2 * (1 - s2);
      var q2 = 255 * v2 * (1 - s2 * f2);
      var t4 = 255 * v2 * (1 - s2 * (1 - f2));
      v2 *= 255;
      switch (hi2) {
        case 0:
          return [v2, t4, p2];
        case 1:
          return [q2, v2, p2];
        case 2:
          return [p2, v2, t4];
        case 3:
          return [p2, q2, v2];
        case 4:
          return [t4, p2, v2];
        case 5:
          return [v2, p2, q2];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h2 = hsv[0];
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var vmin = Math.max(v2, 0.01);
      var lmin;
      var sl;
      var l2;
      l2 = (2 - s2) * v2;
      lmin = (2 - s2) * vmin;
      sl = s2 * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l2 /= 2;
      return [h2, sl * 100, l2 * 100];
    };
    convert.hwb.rgb = function(hwb) {
      var h2 = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i2;
      var v2;
      var f2;
      var n2;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i2 = Math.floor(6 * h2);
      v2 = 1 - bl;
      f2 = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f2 = 1 - f2;
      }
      n2 = wh + f2 * (v2 - wh);
      var r2;
      var g2;
      var b10;
      switch (i2) {
        default:
        case 6:
        case 0:
          r2 = v2;
          g2 = n2;
          b10 = wh;
          break;
        case 1:
          r2 = n2;
          g2 = v2;
          b10 = wh;
          break;
        case 2:
          r2 = wh;
          g2 = v2;
          b10 = n2;
          break;
        case 3:
          r2 = wh;
          g2 = n2;
          b10 = v2;
          break;
        case 4:
          r2 = n2;
          g2 = wh;
          b10 = v2;
          break;
        case 5:
          r2 = v2;
          g2 = wh;
          b10 = n2;
          break;
      }
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c2 = cmyk[0] / 100;
      var m2 = cmyk[1] / 100;
      var y2 = cmyk[2] / 100;
      var k2 = cmyk[3] / 100;
      var r2;
      var g2;
      var b10;
      r2 = 1 - Math.min(1, c2 * (1 - k2) + k2);
      g2 = 1 - Math.min(1, m2 * (1 - k2) + k2);
      b10 = 1 - Math.min(1, y2 * (1 - k2) + k2);
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.xyz.rgb = function(xyz) {
      var x2 = xyz[0] / 100;
      var y2 = xyz[1] / 100;
      var z2 = xyz[2] / 100;
      var r2;
      var g2;
      var b10;
      r2 = x2 * 3.2406 + y2 * -1.5372 + z2 * -0.4986;
      g2 = x2 * -0.9689 + y2 * 1.8758 + z2 * 0.0415;
      b10 = x2 * 0.0557 + y2 * -0.204 + z2 * 1.057;
      r2 = r2 > 31308e-7 ? 1.055 * Math.pow(r2, 1 / 2.4) - 0.055 : r2 * 12.92;
      g2 = g2 > 31308e-7 ? 1.055 * Math.pow(g2, 1 / 2.4) - 0.055 : g2 * 12.92;
      b10 = b10 > 31308e-7 ? 1.055 * Math.pow(b10, 1 / 2.4) - 0.055 : b10 * 12.92;
      r2 = Math.min(Math.max(0, r2), 1);
      g2 = Math.min(Math.max(0, g2), 1);
      b10 = Math.min(Math.max(0, b10), 1);
      return [r2 * 255, g2 * 255, b10 * 255];
    };
    convert.xyz.lab = function(xyz) {
      var x2 = xyz[0];
      var y2 = xyz[1];
      var z2 = xyz[2];
      var l2;
      var a2;
      var b10;
      x2 /= 95.047;
      y2 /= 100;
      z2 /= 108.883;
      x2 = x2 > 8856e-6 ? Math.pow(x2, 1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? Math.pow(y2, 1 / 3) : 7.787 * y2 + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l2 = 116 * y2 - 16;
      a2 = 500 * (x2 - y2);
      b10 = 200 * (y2 - z2);
      return [l2, a2, b10];
    };
    convert.lab.xyz = function(lab3) {
      var l2 = lab3[0];
      var a2 = lab3[1];
      var b10 = lab3[2];
      var x2;
      var y2;
      var z2;
      y2 = (l2 + 16) / 116;
      x2 = a2 / 500 + y2;
      z2 = y2 - b10 / 200;
      var y22 = Math.pow(y2, 3);
      var x22 = Math.pow(x2, 3);
      var z22 = Math.pow(z2, 3);
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x2 *= 95.047;
      y2 *= 100;
      z2 *= 108.883;
      return [x2, y2, z2];
    };
    convert.lab.lch = function(lab3) {
      var l2 = lab3[0];
      var a2 = lab3[1];
      var b10 = lab3[2];
      var hr2;
      var h2;
      var c2;
      hr2 = Math.atan2(b10, a2);
      h2 = hr2 * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      c2 = Math.sqrt(a2 * a2 + b10 * b10);
      return [l2, c2, h2];
    };
    convert.lch.lab = function(lch2) {
      var l2 = lch2[0];
      var c2 = lch2[1];
      var h2 = lch2[2];
      var a2;
      var b10;
      var hr2;
      hr2 = h2 / 360 * 2 * Math.PI;
      a2 = c2 * Math.cos(hr2);
      b10 = c2 * Math.sin(hr2);
      return [l2, a2, b10];
    };
    convert.rgb.ansi16 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b10 = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      var ansi = 30 + (Math.round(b10 / 255) << 2 | Math.round(g2 / 255) << 1 | Math.round(r2 / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r2 = args[0];
      var g2 = args[1];
      var b10 = args[2];
      if (r2 === g2 && g2 === b10) {
        if (r2 < 8) {
          return 16;
        }
        if (r2 > 248) {
          return 231;
        }
        return Math.round((r2 - 8) / 247 * 24) + 232;
      }
      var ansi = 16 + 36 * Math.round(r2 / 255 * 5) + 6 * Math.round(g2 / 255 * 5) + Math.round(b10 / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      var color3 = args % 10;
      if (color3 === 0 || color3 === 7) {
        if (args > 50) {
          color3 += 3.5;
        }
        color3 = color3 / 10.5 * 255;
        return [color3, color3, color3];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r2 = (color3 & 1) * mult * 255;
      var g2 = (color3 >> 1 & 1) * mult * 255;
      var b10 = (color3 >> 2 & 1) * mult * 255;
      return [r2, g2, b10];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c2 = (args - 232) * 10 + 8;
        return [c2, c2, c2];
      }
      args -= 16;
      var rem;
      var r2 = Math.floor(args / 36) / 5 * 255;
      var g2 = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b10 = rem % 6 / 5 * 255;
      return [r2, g2, b10];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r2 = integer >> 16 & 255;
      var g2 = integer >> 8 & 255;
      var b10 = integer & 255;
      return [r2, g2, b10];
    };
    convert.rgb.hcg = function(rgb2) {
      var r2 = rgb2[0] / 255;
      var g2 = rgb2[1] / 255;
      var b10 = rgb2[2] / 255;
      var max7 = Math.max(Math.max(r2, g2), b10);
      var min6 = Math.min(Math.min(r2, g2), b10);
      var chroma = max7 - min6;
      var grayscale;
      var hue2;
      if (chroma < 1) {
        grayscale = min6 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue2 = 0;
      } else if (max7 === r2) {
        hue2 = (g2 - b10) / chroma % 6;
      } else if (max7 === g2) {
        hue2 = 2 + (b10 - r2) / chroma;
      } else {
        hue2 = 4 + (r2 - g2) / chroma + 4;
      }
      hue2 /= 6;
      hue2 %= 1;
      return [hue2 * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl3) {
      var s2 = hsl3[1] / 100;
      var l2 = hsl3[2] / 100;
      var c2 = 1;
      var f2 = 0;
      if (l2 < 0.5) {
        c2 = 2 * s2 * l2;
      } else {
        c2 = 2 * s2 * (1 - l2);
      }
      if (c2 < 1) {
        f2 = (l2 - 0.5 * c2) / (1 - c2);
      }
      return [hsl3[0], c2 * 100, f2 * 100];
    };
    convert.hsv.hcg = function(hsv) {
      var s2 = hsv[1] / 100;
      var v2 = hsv[2] / 100;
      var c2 = s2 * v2;
      var f2 = 0;
      if (c2 < 1) {
        f2 = (v2 - c2) / (1 - c2);
      }
      return [hsv[0], c2 * 100, f2 * 100];
    };
    convert.hcg.rgb = function(hcg) {
      var h2 = hcg[0] / 360;
      var c2 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      if (c2 === 0) {
        return [g2 * 255, g2 * 255, g2 * 255];
      }
      var pure = [0, 0, 0];
      var hi2 = h2 % 1 * 6;
      var v2 = hi2 % 1;
      var w2 = 1 - v2;
      var mg = 0;
      switch (Math.floor(hi2)) {
        case 0:
          pure[0] = 1;
          pure[1] = v2;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w2;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v2;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w2;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v2;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w2;
      }
      mg = (1 - c2) * g2;
      return [
        (c2 * pure[0] + mg) * 255,
        (c2 * pure[1] + mg) * 255,
        (c2 * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c2 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c2 + g2 * (1 - c2);
      var f2 = 0;
      if (v2 > 0) {
        f2 = c2 / v2;
      }
      return [hcg[0], f2 * 100, v2 * 100];
    };
    convert.hcg.hsl = function(hcg) {
      var c2 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var l2 = g2 * (1 - c2) + 0.5 * c2;
      var s2 = 0;
      if (l2 > 0 && l2 < 0.5) {
        s2 = c2 / (2 * l2);
      } else if (l2 >= 0.5 && l2 < 1) {
        s2 = c2 / (2 * (1 - l2));
      }
      return [hcg[0], s2 * 100, l2 * 100];
    };
    convert.hcg.hwb = function(hcg) {
      var c2 = hcg[1] / 100;
      var g2 = hcg[2] / 100;
      var v2 = c2 + g2 * (1 - c2);
      return [hcg[0], (v2 - c2) * 100, (1 - v2) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      var w2 = hwb[1] / 100;
      var b10 = hwb[2] / 100;
      var v2 = 1 - b10;
      var c2 = v2 - w2;
      var g2 = 0;
      if (c2 < 1) {
        g2 = (v2 - c2) / (1 - c2);
      }
      return [hwb[0], c2 * 100, g2 * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb2) {
      return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hwb = function(gray2) {
      return [0, 100, gray2[0]];
    };
    convert.gray.cmyk = function(gray2) {
      return [0, 0, 0, gray2[0]];
    };
    convert.gray.lab = function(gray2) {
      return [gray2[0], 0, 0];
    };
    convert.gray.hex = function(gray2) {
      var val = Math.round(gray2[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb2) {
      var val = (rgb2[0] + rgb2[1] + rgb2[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color/node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color/node_modules/color-convert/route.js"(exports, module) {
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len5 = models.length, i2 = 0; i2 < len5; i2++) {
        graph[models[i2]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len5 = adjacents.length, i2 = 0; i2 < len5; i2++) {
          var adjacent = adjacents[i2];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to2) {
      return function(args) {
        return to2(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      var path = [graph[toModel].parent, toModel];
      var fn2 = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn2 = link(conversions[graph[cur].parent][cur], fn2);
        cur = graph[cur].parent;
      }
      fn2.conversion = path;
      return fn2;
    }
    module.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len5 = models.length, i2 = 0; i2 < len5; i2++) {
        var toModel = models[i2];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color/node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color/node_modules/color-convert/index.js"(exports, module) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn2(args);
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn2) {
      var wrappedFn = function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result = fn2(args);
        if (typeof result === "object") {
          for (var len5 = result.length, i2 = 0; i2 < len5; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn2) {
        wrappedFn.conversion = fn2.conversion;
      }
      return wrappedFn;
    }
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn2 = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn2);
        convert[fromModel][toModel].raw = wrapRaw(fn2);
      });
    });
    module.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports, module) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      "keyword",
      "gray",
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color2(obj, model) {
      if (!(this instanceof Color2)) {
        return new Color2(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i2;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [0, 0, 0];
        this.valpha = 1;
      } else if (obj instanceof Color2) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result = colorString.get(obj);
        if (result === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result.model;
        channels = convert[this.model].channels;
        this.color = result.value.slice(0, channels);
        this.valpha = typeof result.value[channels] === "number" ? result.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys2 = Object.keys(obj);
        if ("alpha" in obj) {
          keys2.splice(keys2.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys2.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color3 = [];
        for (i2 = 0; i2 < labels.length; i2++) {
          color3.push(obj[labels[i2]]);
        }
        this.color = zeroArray(color3);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i2 = 0; i2 < channels; i2++) {
          var limit = limiters[this.model][i2];
          if (limit) {
            this.color[i2] = limit(this.color[i2]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    Color2.prototype = {
      toString: function() {
        return this.string();
      },
      toJSON: function() {
        return this[this.model]();
      },
      string: function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      },
      percentString: function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      },
      array: function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      },
      object: function() {
        var result = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i2 = 0; i2 < channels; i2++) {
          result[labels[i2]] = this.color[i2];
        }
        if (this.valpha !== 1) {
          result.alpha = this.valpha;
        }
        return result;
      },
      unitArray: function() {
        var rgb2 = this.rgb().color;
        rgb2[0] /= 255;
        rgb2[1] /= 255;
        rgb2[2] /= 255;
        if (this.valpha !== 1) {
          rgb2.push(this.valpha);
        }
        return rgb2;
      },
      unitObject: function() {
        var rgb2 = this.rgb().object();
        rgb2.r /= 255;
        rgb2.g /= 255;
        rgb2.b /= 255;
        if (this.valpha !== 1) {
          rgb2.alpha = this.valpha;
        }
        return rgb2;
      },
      round: function(places) {
        places = Math.max(places || 0, 0);
        return new Color2(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      },
      alpha: function(val) {
        if (arguments.length) {
          return new Color2(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      },
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return convert[this.model].keyword(this.color);
      },
      hex: function(val) {
        if (arguments.length) {
          return new Color2(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      },
      rgbNumber: function() {
        var rgb2 = this.rgb().color;
        return (rgb2[0] & 255) << 16 | (rgb2[1] & 255) << 8 | rgb2[2] & 255;
      },
      luminosity: function() {
        var rgb2 = this.rgb().color;
        var lum = [];
        for (var i2 = 0; i2 < rgb2.length; i2++) {
          var chan = rgb2[i2] / 255;
          lum[i2] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      },
      contrast: function(color22) {
        var lum1 = this.luminosity();
        var lum2 = color22.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      },
      level: function(color22) {
        var contrastRatio = this.contrast(color22);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      },
      isDark: function() {
        var rgb2 = this.rgb().color;
        var yiq = (rgb2[0] * 299 + rgb2[1] * 587 + rgb2[2] * 114) / 1e3;
        return yiq < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      negate: function() {
        var rgb2 = this.rgb();
        for (var i2 = 0; i2 < 3; i2++) {
          rgb2.color[i2] = 255 - rgb2.color[i2];
        }
        return rgb2;
      },
      lighten: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[2] += hsl3.color[2] * ratio;
        return hsl3;
      },
      darken: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[2] -= hsl3.color[2] * ratio;
        return hsl3;
      },
      saturate: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[1] += hsl3.color[1] * ratio;
        return hsl3;
      },
      desaturate: function(ratio) {
        var hsl3 = this.hsl();
        hsl3.color[1] -= hsl3.color[1] * ratio;
        return hsl3;
      },
      whiten: function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      },
      blacken: function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      },
      grayscale: function() {
        var rgb2 = this.rgb().color;
        var val = rgb2[0] * 0.3 + rgb2[1] * 0.59 + rgb2[2] * 0.11;
        return Color2.rgb(val, val, val);
      },
      fade: function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      },
      opaquer: function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      },
      rotate: function(degrees2) {
        var hsl3 = this.hsl();
        var hue2 = hsl3.color[0];
        hue2 = (hue2 + degrees2) % 360;
        hue2 = hue2 < 0 ? 360 + hue2 : hue2;
        hsl3.color[0] = hue2;
        return hsl3;
      },
      mix: function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color22 = this.rgb();
        var p2 = weight === void 0 ? 0.5 : weight;
        var w2 = 2 * p2 - 1;
        var a2 = color1.alpha() - color22.alpha();
        var w1 = ((w2 * a2 === -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
        var w22 = 1 - w1;
        return Color2.rgb(w1 * color1.red() + w22 * color22.red(), w1 * color1.green() + w22 * color22.green(), w1 * color1.blue() + w22 * color22.blue(), color1.alpha() * p2 + color22.alpha() * (1 - p2));
      }
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color2.prototype[model] = function() {
        if (this.model === model) {
          return new Color2(this);
        }
        if (arguments.length) {
          return new Color2(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color2(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color2[model] = function(color3) {
        if (typeof color3 === "number") {
          color3 = zeroArray(_slice.call(arguments), channels);
        }
        return new Color2(color3, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [model];
      model.forEach(function(m2) {
        (limiters[m2] || (limiters[m2] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result = this[model]();
          result.color[channel] = val;
          return result;
        }
        result = this[model]().color[channel];
        if (modifier) {
          result = modifier(result);
        }
        return result;
      };
    }
    function maxfn(max7) {
      return function(v2) {
        return Math.max(0, Math.min(max7, v2));
      };
    }
    function assertArray(val) {
      return Array.isArray(val) ? val : [val];
    }
    function zeroArray(arr, length5) {
      for (var i2 = 0; i2 < length5; i2++) {
        if (typeof arr[i2] !== "number") {
          arr[i2] = 0;
        }
      }
      return arr;
    }
    module.exports = Color2;
  }
});

// node_modules/tinycolor2/tinycolor.js
var require_tinycolor = __commonJS({
  "node_modules/tinycolor2/tinycolor.js"(exports, module) {
    (function(Math2) {
      var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
      function tinycolor2(color3, opts) {
        color3 = color3 ? color3 : "";
        opts = opts || {};
        if (color3 instanceof tinycolor2) {
          return color3;
        }
        if (!(this instanceof tinycolor2)) {
          return new tinycolor2(color3, opts);
        }
        var rgb2 = inputToRGB(color3);
        this._originalInput = color3, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb2.format;
        this._gradientType = opts.gradientType;
        if (this._r < 1) {
          this._r = mathRound(this._r);
        }
        if (this._g < 1) {
          this._g = mathRound(this._g);
        }
        if (this._b < 1) {
          this._b = mathRound(this._b);
        }
        this._ok = rgb2.ok;
        this._tc_id = tinyCounter++;
      }
      tinycolor2.prototype = {
        isDark: function() {
          return this.getBrightness() < 128;
        },
        isLight: function() {
          return !this.isDark();
        },
        isValid: function() {
          return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
          return this._format;
        },
        getAlpha: function() {
          return this._a;
        },
        getBrightness: function() {
          var rgb2 = this.toRgb();
          return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
        },
        getLuminance: function() {
          var rgb2 = this.toRgb();
          var RsRGB, GsRGB, BsRGB, R2, G2, B3;
          RsRGB = rgb2.r / 255;
          GsRGB = rgb2.g / 255;
          BsRGB = rgb2.b / 255;
          if (RsRGB <= 0.03928) {
            R2 = RsRGB / 12.92;
          } else {
            R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
          }
          if (GsRGB <= 0.03928) {
            G2 = GsRGB / 12.92;
          } else {
            G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
          }
          if (BsRGB <= 0.03928) {
            B3 = BsRGB / 12.92;
          } else {
            B3 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
          }
          return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B3;
        },
        setAlpha: function(value) {
          this._a = boundAlpha(value);
          this._roundA = mathRound(100 * this._a) / 100;
          return this;
        },
        toHsv: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
          var hsv = rgbToHsv(this._r, this._g, this._b);
          var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
          return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
        },
        toHsl: function() {
          var hsl3 = rgbToHsl(this._r, this._g, this._b);
          return { h: hsl3.h * 360, s: hsl3.s, l: hsl3.l, a: this._a };
        },
        toHslString: function() {
          var hsl3 = rgbToHsl(this._r, this._g, this._b);
          var h2 = mathRound(hsl3.h * 360), s2 = mathRound(hsl3.s * 100), l2 = mathRound(hsl3.l * 100);
          return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
        },
        toHex: function(allow3Char) {
          return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
          return "#" + this.toHex(allow3Char);
        },
        toHex8: function(allow4Char) {
          return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
        },
        toHex8String: function(allow4Char) {
          return "#" + this.toHex8(allow4Char);
        },
        toRgb: function() {
          return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
          return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
          return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
          if (this._a === 0) {
            return "transparent";
          }
          if (this._a < 1) {
            return false;
          }
          return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
          var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
          var secondHex8String = hex8String;
          var gradientType = this._gradientType ? "GradientType = 1, " : "";
          if (secondColor) {
            var s2 = tinycolor2(secondColor);
            secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
        },
        toString: function(format2) {
          var formatSet = !!format2;
          format2 = format2 || this._format;
          var formattedString = false;
          var hasAlpha = this._a < 1 && this._a >= 0;
          var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
          if (needsAlphaFormat) {
            if (format2 === "name" && this._a === 0) {
              return this.toName();
            }
            return this.toRgbString();
          }
          if (format2 === "rgb") {
            formattedString = this.toRgbString();
          }
          if (format2 === "prgb") {
            formattedString = this.toPercentageRgbString();
          }
          if (format2 === "hex" || format2 === "hex6") {
            formattedString = this.toHexString();
          }
          if (format2 === "hex3") {
            formattedString = this.toHexString(true);
          }
          if (format2 === "hex4") {
            formattedString = this.toHex8String(true);
          }
          if (format2 === "hex8") {
            formattedString = this.toHex8String();
          }
          if (format2 === "name") {
            formattedString = this.toName();
          }
          if (format2 === "hsl") {
            formattedString = this.toHslString();
          }
          if (format2 === "hsv") {
            formattedString = this.toHsvString();
          }
          return formattedString || this.toHexString();
        },
        clone: function() {
          return tinycolor2(this.toString());
        },
        _applyModification: function(fn2, args) {
          var color3 = fn2.apply(null, [this].concat([].slice.call(args)));
          this._r = color3._r;
          this._g = color3._g;
          this._b = color3._b;
          this.setAlpha(color3._a);
          return this;
        },
        lighten: function() {
          return this._applyModification(lighten, arguments);
        },
        brighten: function() {
          return this._applyModification(brighten, arguments);
        },
        darken: function() {
          return this._applyModification(darken, arguments);
        },
        desaturate: function() {
          return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
          return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
          return this._applyModification(greyscale, arguments);
        },
        spin: function() {
          return this._applyModification(spin, arguments);
        },
        _applyCombination: function(fn2, args) {
          return fn2.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
          return this._applyCombination(analogous, arguments);
        },
        complement: function() {
          return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
          return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
          return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
          return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
          return this._applyCombination(tetrad, arguments);
        }
      };
      tinycolor2.fromRatio = function(color3, opts) {
        if (typeof color3 == "object") {
          var newColor = {};
          for (var i2 in color3) {
            if (color3.hasOwnProperty(i2)) {
              if (i2 === "a") {
                newColor[i2] = color3[i2];
              } else {
                newColor[i2] = convertToPercentage(color3[i2]);
              }
            }
          }
          color3 = newColor;
        }
        return tinycolor2(color3, opts);
      };
      function inputToRGB(color3) {
        var rgb2 = { r: 0, g: 0, b: 0 };
        var a2 = 1;
        var s2 = null;
        var v2 = null;
        var l2 = null;
        var ok = false;
        var format2 = false;
        if (typeof color3 == "string") {
          color3 = stringInputToObject(color3);
        }
        if (typeof color3 == "object") {
          if (isValidCSSUnit(color3.r) && isValidCSSUnit(color3.g) && isValidCSSUnit(color3.b)) {
            rgb2 = rgbToRgb(color3.r, color3.g, color3.b);
            ok = true;
            format2 = String(color3.r).substr(-1) === "%" ? "prgb" : "rgb";
          } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.v)) {
            s2 = convertToPercentage(color3.s);
            v2 = convertToPercentage(color3.v);
            rgb2 = hsvToRgb(color3.h, s2, v2);
            ok = true;
            format2 = "hsv";
          } else if (isValidCSSUnit(color3.h) && isValidCSSUnit(color3.s) && isValidCSSUnit(color3.l)) {
            s2 = convertToPercentage(color3.s);
            l2 = convertToPercentage(color3.l);
            rgb2 = hslToRgb(color3.h, s2, l2);
            ok = true;
            format2 = "hsl";
          }
          if (color3.hasOwnProperty("a")) {
            a2 = color3.a;
          }
        }
        a2 = boundAlpha(a2);
        return {
          ok,
          format: color3.format || format2,
          r: mathMin(255, mathMax(rgb2.r, 0)),
          g: mathMin(255, mathMax(rgb2.g, 0)),
          b: mathMin(255, mathMax(rgb2.b, 0)),
          a: a2
        };
      }
      function rgbToRgb(r2, g2, b10) {
        return {
          r: bound01(r2, 255) * 255,
          g: bound01(g2, 255) * 255,
          b: bound01(b10, 255) * 255
        };
      }
      function rgbToHsl(r2, g2, b10) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b10 = bound01(b10, 255);
        var max7 = mathMax(r2, g2, b10), min6 = mathMin(r2, g2, b10);
        var h2, s2, l2 = (max7 + min6) / 2;
        if (max7 == min6) {
          h2 = s2 = 0;
        } else {
          var d2 = max7 - min6;
          s2 = l2 > 0.5 ? d2 / (2 - max7 - min6) : d2 / (max7 + min6);
          switch (max7) {
            case r2:
              h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
              break;
            case g2:
              h2 = (b10 - r2) / d2 + 2;
              break;
            case b10:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, l: l2 };
      }
      function hslToRgb(h2, s2, l2) {
        var r2, g2, b10;
        h2 = bound01(h2, 360);
        s2 = bound01(s2, 100);
        l2 = bound01(l2, 100);
        function hue2rgb(p3, q3, t4) {
          if (t4 < 0)
            t4 += 1;
          if (t4 > 1)
            t4 -= 1;
          if (t4 < 1 / 6)
            return p3 + (q3 - p3) * 6 * t4;
          if (t4 < 1 / 2)
            return q3;
          if (t4 < 2 / 3)
            return p3 + (q3 - p3) * (2 / 3 - t4) * 6;
          return p3;
        }
        if (s2 === 0) {
          r2 = g2 = b10 = l2;
        } else {
          var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
          var p2 = 2 * l2 - q2;
          r2 = hue2rgb(p2, q2, h2 + 1 / 3);
          g2 = hue2rgb(p2, q2, h2);
          b10 = hue2rgb(p2, q2, h2 - 1 / 3);
        }
        return { r: r2 * 255, g: g2 * 255, b: b10 * 255 };
      }
      function rgbToHsv(r2, g2, b10) {
        r2 = bound01(r2, 255);
        g2 = bound01(g2, 255);
        b10 = bound01(b10, 255);
        var max7 = mathMax(r2, g2, b10), min6 = mathMin(r2, g2, b10);
        var h2, s2, v2 = max7;
        var d2 = max7 - min6;
        s2 = max7 === 0 ? 0 : d2 / max7;
        if (max7 == min6) {
          h2 = 0;
        } else {
          switch (max7) {
            case r2:
              h2 = (g2 - b10) / d2 + (g2 < b10 ? 6 : 0);
              break;
            case g2:
              h2 = (b10 - r2) / d2 + 2;
              break;
            case b10:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2, s: s2, v: v2 };
      }
      function hsvToRgb(h2, s2, v2) {
        h2 = bound01(h2, 360) * 6;
        s2 = bound01(s2, 100);
        v2 = bound01(v2, 100);
        var i2 = Math2.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t4 = v2 * (1 - (1 - f2) * s2), mod3 = i2 % 6, r2 = [v2, q2, p2, p2, t4, v2][mod3], g2 = [t4, v2, v2, q2, p2, p2][mod3], b10 = [p2, p2, t4, v2, v2, q2][mod3];
        return { r: r2 * 255, g: g2 * 255, b: b10 * 255 };
      }
      function rgbToHex(r2, g2, b10, allow3Char) {
        var hex2 = [
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g2).toString(16)),
          pad2(mathRound(b10).toString(16))
        ];
        if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToHex(r2, g2, b10, a2, allow4Char) {
        var hex2 = [
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g2).toString(16)),
          pad2(mathRound(b10).toString(16)),
          pad2(convertDecimalToHex(a2))
        ];
        if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
          return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
        }
        return hex2.join("");
      }
      function rgbaToArgbHex(r2, g2, b10, a2) {
        var hex2 = [
          pad2(convertDecimalToHex(a2)),
          pad2(mathRound(r2).toString(16)),
          pad2(mathRound(g2).toString(16)),
          pad2(mathRound(b10).toString(16))
        ];
        return hex2.join("");
      }
      tinycolor2.equals = function(color1, color22) {
        if (!color1 || !color22) {
          return false;
        }
        return tinycolor2(color1).toRgbString() == tinycolor2(color22).toRgbString();
      };
      tinycolor2.random = function() {
        return tinycolor2.fromRatio({
          r: mathRandom(),
          g: mathRandom(),
          b: mathRandom()
        });
      };
      function desaturate(color3, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl3 = tinycolor2(color3).toHsl();
        hsl3.s -= amount / 100;
        hsl3.s = clamp01(hsl3.s);
        return tinycolor2(hsl3);
      }
      function saturate(color3, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl3 = tinycolor2(color3).toHsl();
        hsl3.s += amount / 100;
        hsl3.s = clamp01(hsl3.s);
        return tinycolor2(hsl3);
      }
      function greyscale(color3) {
        return tinycolor2(color3).desaturate(100);
      }
      function lighten(color3, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl3 = tinycolor2(color3).toHsl();
        hsl3.l += amount / 100;
        hsl3.l = clamp01(hsl3.l);
        return tinycolor2(hsl3);
      }
      function brighten(color3, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb2 = tinycolor2(color3).toRgb();
        rgb2.r = mathMax(0, mathMin(255, rgb2.r - mathRound(255 * -(amount / 100))));
        rgb2.g = mathMax(0, mathMin(255, rgb2.g - mathRound(255 * -(amount / 100))));
        rgb2.b = mathMax(0, mathMin(255, rgb2.b - mathRound(255 * -(amount / 100))));
        return tinycolor2(rgb2);
      }
      function darken(color3, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl3 = tinycolor2(color3).toHsl();
        hsl3.l -= amount / 100;
        hsl3.l = clamp01(hsl3.l);
        return tinycolor2(hsl3);
      }
      function spin(color3, amount) {
        var hsl3 = tinycolor2(color3).toHsl();
        var hue2 = (hsl3.h + amount) % 360;
        hsl3.h = hue2 < 0 ? 360 + hue2 : hue2;
        return tinycolor2(hsl3);
      }
      function complement(color3) {
        var hsl3 = tinycolor2(color3).toHsl();
        hsl3.h = (hsl3.h + 180) % 360;
        return tinycolor2(hsl3);
      }
      function triad(color3) {
        var hsl3 = tinycolor2(color3).toHsl();
        var h2 = hsl3.h;
        return [
          tinycolor2(color3),
          tinycolor2({ h: (h2 + 120) % 360, s: hsl3.s, l: hsl3.l }),
          tinycolor2({ h: (h2 + 240) % 360, s: hsl3.s, l: hsl3.l })
        ];
      }
      function tetrad(color3) {
        var hsl3 = tinycolor2(color3).toHsl();
        var h2 = hsl3.h;
        return [
          tinycolor2(color3),
          tinycolor2({ h: (h2 + 90) % 360, s: hsl3.s, l: hsl3.l }),
          tinycolor2({ h: (h2 + 180) % 360, s: hsl3.s, l: hsl3.l }),
          tinycolor2({ h: (h2 + 270) % 360, s: hsl3.s, l: hsl3.l })
        ];
      }
      function splitcomplement(color3) {
        var hsl3 = tinycolor2(color3).toHsl();
        var h2 = hsl3.h;
        return [
          tinycolor2(color3),
          tinycolor2({ h: (h2 + 72) % 360, s: hsl3.s, l: hsl3.l }),
          tinycolor2({ h: (h2 + 216) % 360, s: hsl3.s, l: hsl3.l })
        ];
      }
      function analogous(color3, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl3 = tinycolor2(color3).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor2(color3)];
        for (hsl3.h = (hsl3.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl3.h = (hsl3.h + part) % 360;
          ret.push(tinycolor2(hsl3));
        }
        return ret;
      }
      function monochromatic(color3, results) {
        results = results || 6;
        var hsv = tinycolor2(color3).toHsv();
        var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
          ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return ret;
      }
      tinycolor2.mix = function(color1, color22, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor2(color1).toRgb();
        var rgb2 = tinycolor2(color22).toRgb();
        var p2 = amount / 100;
        var rgba2 = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return tinycolor2(rgba2);
      };
      tinycolor2.readability = function(color1, color22) {
        var c1 = tinycolor2(color1);
        var c2 = tinycolor2(color22);
        return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
      };
      tinycolor2.isReadable = function(color1, color22, wcag2) {
        var readability = tinycolor2.readability(color1, color22);
        var wcag2Parms, out;
        out = false;
        wcag2Parms = validateWCAG2Parms(wcag2);
        switch (wcag2Parms.level + wcag2Parms.size) {
          case "AAsmall":
          case "AAAlarge":
            out = readability >= 4.5;
            break;
          case "AAlarge":
            out = readability >= 3;
            break;
          case "AAAsmall":
            out = readability >= 7;
            break;
        }
        return out;
      };
      tinycolor2.mostReadable = function(baseColor, colorList, args) {
        var bestColor = null;
        var bestScore = 0;
        var readability;
        var includeFallbackColors, level, size2;
        args = args || {};
        includeFallbackColors = args.includeFallbackColors;
        level = args.level;
        size2 = args.size;
        for (var i2 = 0; i2 < colorList.length; i2++) {
          readability = tinycolor2.readability(baseColor, colorList[i2]);
          if (readability > bestScore) {
            bestScore = readability;
            bestColor = tinycolor2(colorList[i2]);
          }
        }
        if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size2 }) || !includeFallbackColors) {
          return bestColor;
        } else {
          args.includeFallbackColors = false;
          return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
        }
      };
      var names = tinycolor2.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
      };
      var hexNames = tinycolor2.hexNames = flip(names);
      function flip(o2) {
        var flipped = {};
        for (var i2 in o2) {
          if (o2.hasOwnProperty(i2)) {
            flipped[o2[i2]] = i2;
          }
        }
        return flipped;
      }
      function boundAlpha(a2) {
        a2 = parseFloat(a2);
        if (isNaN(a2) || a2 < 0 || a2 > 1) {
          a2 = 1;
        }
        return a2;
      }
      function bound01(n2, max7) {
        if (isOnePointZero(n2)) {
          n2 = "100%";
        }
        var processPercent = isPercentage(n2);
        n2 = mathMin(max7, mathMax(0, parseFloat(n2)));
        if (processPercent) {
          n2 = parseInt(n2 * max7, 10) / 100;
        }
        if (Math2.abs(n2 - max7) < 1e-6) {
          return 1;
        }
        return n2 % max7 / parseFloat(max7);
      }
      function clamp01(val) {
        return mathMin(1, mathMax(0, val));
      }
      function parseIntFromHex(val) {
        return parseInt(val, 16);
      }
      function isOnePointZero(n2) {
        return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
      }
      function isPercentage(n2) {
        return typeof n2 === "string" && n2.indexOf("%") != -1;
      }
      function pad2(c2) {
        return c2.length == 1 ? "0" + c2 : "" + c2;
      }
      function convertToPercentage(n2) {
        if (n2 <= 1) {
          n2 = n2 * 100 + "%";
        }
        return n2;
      }
      function convertDecimalToHex(d2) {
        return Math2.round(parseFloat(d2) * 255).toString(16);
      }
      function convertHexToDecimal(h2) {
        return parseIntFromHex(h2) / 255;
      }
      var matchers = function() {
        var CSS_INTEGER = "[-\\+]?\\d+%?";
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        return {
          CSS_UNIT: new RegExp(CSS_UNIT),
          rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
          rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
          hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
          hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
          hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
          hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
      }();
      function isValidCSSUnit(color3) {
        return !!matchers.CSS_UNIT.exec(color3);
      }
      function stringInputToObject(color3) {
        color3 = color3.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
        var named3 = false;
        if (names[color3]) {
          color3 = names[color3];
          named3 = true;
        } else if (color3 == "transparent") {
          return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }
        var match;
        if (match = matchers.rgb.exec(color3)) {
          return { r: match[1], g: match[2], b: match[3] };
        }
        if (match = matchers.rgba.exec(color3)) {
          return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if (match = matchers.hsl.exec(color3)) {
          return { h: match[1], s: match[2], l: match[3] };
        }
        if (match = matchers.hsla.exec(color3)) {
          return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if (match = matchers.hsv.exec(color3)) {
          return { h: match[1], s: match[2], v: match[3] };
        }
        if (match = matchers.hsva.exec(color3)) {
          return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if (match = matchers.hex8.exec(color3)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named3 ? "name" : "hex8"
          };
        }
        if (match = matchers.hex6.exec(color3)) {
          return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named3 ? "name" : "hex"
          };
        }
        if (match = matchers.hex4.exec(color3)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            a: convertHexToDecimal(match[4] + "" + match[4]),
            format: named3 ? "name" : "hex8"
          };
        }
        if (match = matchers.hex3.exec(color3)) {
          return {
            r: parseIntFromHex(match[1] + "" + match[1]),
            g: parseIntFromHex(match[2] + "" + match[2]),
            b: parseIntFromHex(match[3] + "" + match[3]),
            format: named3 ? "name" : "hex"
          };
        }
        return false;
      }
      function validateWCAG2Parms(parms) {
        var level, size2;
        parms = parms || { "level": "AA", "size": "small" };
        level = (parms.level || "AA").toUpperCase();
        size2 = (parms.size || "small").toLowerCase();
        if (level !== "AA" && level !== "AAA") {
          level = "AA";
        }
        if (size2 !== "small" && size2 !== "large") {
          size2 = "small";
        }
        return { "level": level, "size": size2 };
      }
      if (typeof module !== "undefined" && module.exports) {
        module.exports = tinycolor2;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return tinycolor2;
        });
      } else {
        window.tinycolor = tinycolor2;
      }
    })(Math);
  }
});

// node_modules/@antv/layout/lib/layout/base.js
var require_base = __commonJS({
  "node_modules/@antv/layout/lib/layout/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Base = void 0;
    var Base2 = function() {
      function Base3() {
        this.nodes = [];
        this.edges = [];
        this.combos = [];
        this.comboEdges = [];
        this.hiddenNodes = [];
        this.hiddenEdges = [];
        this.hiddenCombos = [];
        this.positions = [];
        this.destroyed = false;
        this.onLayoutEnd = function() {
        };
      }
      Base3.prototype.layout = function(data) {
        this.init(data);
        return this.execute(true);
      };
      Base3.prototype.init = function(data) {
        this.nodes = data.nodes || [];
        this.edges = data.edges || [];
        this.combos = data.combos || [];
        this.comboEdges = data.comboEdges || [];
        this.hiddenNodes = data.hiddenNodes || [];
        this.hiddenEdges = data.hiddenEdges || [];
        this.hiddenCombos = data.hiddenCombos || [];
      };
      Base3.prototype.execute = function(reloadData) {
      };
      Base3.prototype.executeWithWorker = function() {
      };
      Base3.prototype.getDefaultCfg = function() {
        return {};
      };
      Base3.prototype.updateCfg = function(cfg) {
        if (cfg) {
          Object.assign(this, cfg);
        }
      };
      Base3.prototype.getType = function() {
        return "base";
      };
      Base3.prototype.destroy = function() {
        this.nodes = null;
        this.edges = null;
        this.combos = null;
        this.positions = null;
        this.destroyed = true;
      };
      return Base3;
    }();
    exports.Base = Base2;
  }
});

// node_modules/@antv/layout/lib/util/string.js
var require_string = __commonJS({
  "node_modules/@antv/layout/lib/util/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.camelize = exports.isString = void 0;
    var isString = function(val) {
      return typeof val === "string";
    };
    exports.isString = isString;
    var cacheStringFunction = function(fn2) {
      var cache3 = /* @__PURE__ */ Object.create(null);
      return function(str7) {
        var hit = cache3[str7];
        return hit || (cache3[str7] = fn2(str7));
      };
    };
    var camelizeRE = /-(\w)/g;
    exports.camelize = cacheStringFunction(function(str7) {
      return str7.replace(camelizeRE, function(_2, c2) {
        return c2 ? c2.toUpperCase() : "";
      });
    });
  }
});

// node_modules/@antv/layout/lib/util/array.js
var require_array = __commonJS({
  "node_modules/@antv/layout/lib/util/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isArray = void 0;
    exports.isArray = Array.isArray;
  }
});

// node_modules/@antv/layout/lib/util/number.js
var require_number = __commonJS({
  "node_modules/@antv/layout/lib/util/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toNumber = exports.isNaN = exports.isNumber = void 0;
    var isNumber5 = function(val) {
      return typeof val === "number";
    };
    exports.isNumber = isNumber5;
    var isNaN5 = function(num) {
      return Number.isNaN(Number(num));
    };
    exports.isNaN = isNaN5;
    var toNumber = function(val) {
      var n2 = parseFloat(val);
      return (0, exports.isNaN)(n2) ? val : n2;
    };
    exports.toNumber = toNumber;
  }
});

// node_modules/@antv/layout/lib/util/object.js
var require_object = __commonJS({
  "node_modules/@antv/layout/lib/util/object.js"(exports) {
    "use strict";
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = exports.isObject = void 0;
    var isObject2 = function(val) {
      return val !== null && typeof val === "object";
    };
    exports.isObject = isObject2;
    var clone8 = function(target) {
      if (target === null) {
        return target;
      }
      if (target instanceof Date) {
        return new Date(target.getTime());
      }
      if (target instanceof Array) {
        var cp_1 = [];
        target.forEach(function(v2) {
          cp_1.push(v2);
        });
        return cp_1.map(function(n2) {
          return (0, exports.clone)(n2);
        });
      }
      if (typeof target === "object" && target !== {}) {
        var cp_2 = __assign16({}, target);
        Object.keys(cp_2).forEach(function(k2) {
          cp_2[k2] = (0, exports.clone)(cp_2[k2]);
        });
        return cp_2;
      }
      return target;
    };
    exports.clone = clone8;
  }
});

// node_modules/@antv/layout/lib/util/math.js
var require_math = __commonJS({
  "node_modules/@antv/layout/lib/util/math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findMinMaxNodeXY = exports.traverseTreeUp = exports.scaleMatrix = exports.getAdjMatrix = exports.floydWarshall = exports.getDegree = exports.getEdgeTerminal = void 0;
    var object_1 = require_object();
    var getEdgeTerminal = function(edge, type) {
      var terminal = edge[type];
      if ((0, object_1.isObject)(terminal)) {
        return terminal.cell;
      }
      return terminal;
    };
    exports.getEdgeTerminal = getEdgeTerminal;
    var getDegree3 = function(n2, nodeIdxMap, edges) {
      var degrees2 = [];
      for (var i2 = 0; i2 < n2; i2++) {
        degrees2[i2] = 0;
      }
      if (!edges)
        return degrees2;
      edges.forEach(function(e8) {
        var source = (0, exports.getEdgeTerminal)(e8, "source");
        var target = (0, exports.getEdgeTerminal)(e8, "target");
        if (source) {
          degrees2[nodeIdxMap[source]] += 1;
        }
        if (target) {
          degrees2[nodeIdxMap[target]] += 1;
        }
      });
      return degrees2;
    };
    exports.getDegree = getDegree3;
    var floydWarshall6 = function(adjMatrix3) {
      var dist4 = [];
      var size2 = adjMatrix3.length;
      for (var i2 = 0; i2 < size2; i2 += 1) {
        dist4[i2] = [];
        for (var j2 = 0; j2 < size2; j2 += 1) {
          if (i2 === j2) {
            dist4[i2][j2] = 0;
          } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
            dist4[i2][j2] = Infinity;
          } else {
            dist4[i2][j2] = adjMatrix3[i2][j2];
          }
        }
      }
      for (var k2 = 0; k2 < size2; k2 += 1) {
        for (var i2 = 0; i2 < size2; i2 += 1) {
          for (var j2 = 0; j2 < size2; j2 += 1) {
            if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
              dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
            }
          }
        }
      }
      return dist4;
    };
    exports.floydWarshall = floydWarshall6;
    var getAdjMatrix3 = function(data, directed) {
      var nodes = data.nodes, edges = data.edges;
      var matrix = [];
      var nodeMap = {};
      if (!nodes) {
        throw new Error("invalid nodes data!");
      }
      if (nodes) {
        nodes.forEach(function(node, i2) {
          nodeMap[node.id] = i2;
          var row = [];
          matrix.push(row);
        });
      }
      if (edges) {
        edges.forEach(function(e8) {
          var source = (0, exports.getEdgeTerminal)(e8, "source");
          var target = (0, exports.getEdgeTerminal)(e8, "target");
          var sIndex = nodeMap[source];
          var tIndex = nodeMap[target];
          matrix[sIndex][tIndex] = 1;
          if (!directed) {
            matrix[tIndex][sIndex] = 1;
          }
        });
      }
      return matrix;
    };
    exports.getAdjMatrix = getAdjMatrix3;
    var scaleMatrix3 = function(matrix, ratio) {
      var result = [];
      matrix.forEach(function(row) {
        var newRow = [];
        row.forEach(function(v2) {
          newRow.push(v2 * ratio);
        });
        result.push(newRow);
      });
      return result;
    };
    exports.scaleMatrix = scaleMatrix3;
    var traverseUp3 = function(data, fn2) {
      if (data && data.children) {
        for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
          if (!traverseUp3(data.children[i2], fn2))
            return;
        }
      }
      if (!fn2(data)) {
        return false;
      }
      return true;
    };
    var traverseTreeUp3 = function(data, fn2) {
      if (typeof fn2 !== "function") {
        return;
      }
      traverseUp3(data, fn2);
    };
    exports.traverseTreeUp = traverseTreeUp3;
    var findMinMaxNodeXY = function(nodes) {
      var minX = Infinity;
      var minY = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      nodes.forEach(function(node) {
        if (minX > node.x)
          minX = node.x;
        if (minY > node.y)
          minY = node.y;
        if (maxX < node.x)
          maxX = node.x;
        if (maxY < node.y)
          maxY = node.y;
      });
      return { minX, minY, maxX, maxY };
    };
    exports.findMinMaxNodeXY = findMinMaxNodeXY;
  }
});

// node_modules/@antv/layout/lib/util/function.js
var require_function = __commonJS({
  "node_modules/@antv/layout/lib/util/function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFuncByUnknownType = exports.getFunc = exports.isFunction = void 0;
    var _1 = require_util2();
    var number_1 = require_number();
    var isFunction2 = function(val) {
      return typeof val === "function";
    };
    exports.isFunction = isFunction2;
    var getFunc = function(value, defaultValue, func) {
      var resultFunc;
      if (func) {
        resultFunc = func;
      } else if ((0, number_1.isNumber)(value)) {
        resultFunc = function() {
          return value;
        };
      } else {
        resultFunc = function() {
          return defaultValue;
        };
      }
      return resultFunc;
    };
    exports.getFunc = getFunc;
    var getFuncByUnknownType = function(defaultValue, value, resultIsNumber) {
      if (resultIsNumber === void 0) {
        resultIsNumber = true;
      }
      if (!value && value !== 0) {
        return function(d2) {
          if (d2.size) {
            if ((0, _1.isArray)(d2.size))
              return d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
            if ((0, _1.isObject)(d2.size))
              return d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
            return d2.size;
          }
          return defaultValue;
        };
      }
      if ((0, exports.isFunction)(value)) {
        return value;
      }
      if ((0, number_1.isNumber)(value)) {
        return function() {
          return value;
        };
      }
      if ((0, _1.isArray)(value)) {
        return function() {
          if (resultIsNumber) {
            var max7 = Math.max.apply(Math, value);
            return isNaN(max7) ? defaultValue : max7;
          }
          return value;
        };
      }
      if ((0, _1.isObject)(value)) {
        return function() {
          if (resultIsNumber) {
            var max7 = Math.max(value.width, value.height);
            return isNaN(max7) ? defaultValue : max7;
          }
          return [value.width, value.height];
        };
      }
      return function() {
        return defaultValue;
      };
    };
    exports.getFuncByUnknownType = getFuncByUnknownType;
  }
});

// node_modules/@antv/layout/lib/util/index.js
var require_util2 = __commonJS({
  "node_modules/@antv/layout/lib/util/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_string(), exports);
    __exportStar(require_array(), exports);
    __exportStar(require_number(), exports);
    __exportStar(require_math(), exports);
    __exportStar(require_object(), exports);
    __exportStar(require_function(), exports);
  }
});

// node_modules/@antv/layout/lib/registy/index.js
var require_registy = __commonJS({
  "node_modules/@antv/layout/lib/registy/index.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var map4 = /* @__PURE__ */ new Map();
    var registerLayout3 = function(name, layoutOverride) {
      if (map4.get(name)) {
        console.warn("The layout with the name ".concat(name, " exists already, it will be overridden"));
      }
      if ((0, util_1.isObject)(layoutOverride)) {
        var GLayout = function(_super) {
          __extends19(GLayout2, _super);
          function GLayout2(cfg) {
            var _this = _super.call(this) || this;
            var self2 = _this;
            var props = {};
            var defaultCfg2 = self2.getDefaultCfg();
            Object.assign(props, defaultCfg2, layoutOverride, cfg);
            Object.keys(props).forEach(function(key) {
              var value = props[key];
              self2[key] = value;
            });
            return _this;
          }
          return GLayout2;
        }(base_1.Base);
        map4.set(name, GLayout);
      } else {
        map4.set(name, layoutOverride);
      }
      return map4.get(name);
    };
    exports.registerLayout = registerLayout3;
    var unRegisterLayout = function(name) {
      if (map4.has(name)) {
        map4.delete(name);
      }
    };
    exports.unRegisterLayout = unRegisterLayout;
    var getLayoutByName = function(name) {
      if (map4.has(name)) {
        return map4.get(name);
      }
      return null;
    };
    exports.getLayoutByName = getLayoutByName;
  }
});

// node_modules/@antv/layout/lib/layout/grid.js
var require_grid = __commonJS({
  "node_modules/@antv/layout/lib/layout/grid.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GridLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var GridLayout2 = function(_super) {
      __extends19(GridLayout3, _super);
      function GridLayout3(options) {
        var _this = _super.call(this) || this;
        _this.begin = [0, 0];
        _this.preventOverlap = true;
        _this.preventOverlapPadding = 10;
        _this.condense = false;
        _this.sortBy = "degree";
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.row = 0;
        _this.col = 0;
        _this.cellWidth = 0;
        _this.cellHeight = 0;
        _this.cellUsed = {};
        _this.id2manPos = {};
        _this.onLayoutEnd = function() {
        };
        _this.updateCfg(options);
        return _this;
      }
      GridLayout3.prototype.getDefaultCfg = function() {
        return {
          begin: [0, 0],
          preventOverlap: true,
          preventOverlapPadding: 10,
          condense: false,
          rows: void 0,
          cols: void 0,
          position: void 0,
          sortBy: "degree",
          nodeSize: 30
        };
      };
      GridLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges, begin = self2.begin;
        var n2 = nodes.length;
        if (n2 === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        }
        if (n2 === 1) {
          nodes[0].x = begin[0];
          nodes[0].y = begin[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return {
            nodes,
            edges
          };
        }
        var sortBy2 = self2.sortBy, width = self2.width, height = self2.height;
        var condense = self2.condense, preventOverlapPadding = self2.preventOverlapPadding, preventOverlap = self2.preventOverlap, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
        var layoutNodes = [];
        nodes.forEach(function(node2) {
          layoutNodes.push(node2);
        });
        var nodeIdxMap = {};
        layoutNodes.forEach(function(node2, i3) {
          nodeIdxMap[node2.id] = i3;
        });
        if (sortBy2 === "degree" || !(0, util_1.isString)(sortBy2) || layoutNodes[0][sortBy2] === void 0) {
          sortBy2 = "degree";
          if ((0, util_1.isNaN)(nodes[0].degree)) {
            var values_1 = (0, util_1.getDegree)(layoutNodes.length, nodeIdxMap, edges);
            layoutNodes.forEach(function(node2, i3) {
              node2.degree = values_1[i3];
            });
          }
        }
        layoutNodes.sort(function(n1, n22) {
          return n22[sortBy2] - n1[sortBy2];
        });
        if (!width && typeof window !== "undefined") {
          width = window.innerWidth;
        }
        if (!height && typeof window !== "undefined") {
          height = window.innerHeight;
        }
        var oRows = self2.rows;
        var oCols = self2.cols != null ? self2.cols : self2.columns;
        self2.cells = n2;
        if (oRows != null && oCols != null) {
          self2.rows = oRows;
          self2.cols = oCols;
        } else if (oRows != null && oCols == null) {
          self2.rows = oRows;
          self2.cols = Math.ceil(self2.cells / self2.rows);
        } else if (oRows == null && oCols != null) {
          self2.cols = oCols;
          self2.rows = Math.ceil(self2.cells / self2.cols);
        } else {
          self2.splits = Math.sqrt(self2.cells * self2.height / self2.width);
          self2.rows = Math.round(self2.splits);
          self2.cols = Math.round(self2.width / self2.height * self2.splits);
        }
        if (self2.cols * self2.rows > self2.cells) {
          var sm = self2.small();
          var lg = self2.large();
          if ((sm - 1) * lg >= self2.cells) {
            self2.small(sm - 1);
          } else if ((lg - 1) * sm >= self2.cells) {
            self2.large(lg - 1);
          }
        } else {
          while (self2.cols * self2.rows < self2.cells) {
            var sm = self2.small();
            var lg = self2.large();
            if ((lg + 1) * sm >= self2.cells) {
              self2.large(lg + 1);
            } else {
              self2.small(sm + 1);
            }
          }
        }
        self2.cellWidth = width / self2.cols;
        self2.cellHeight = height / self2.rows;
        if (condense) {
          self2.cellWidth = 0;
          self2.cellHeight = 0;
        }
        if (preventOverlap || paramNodeSpacing) {
          var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
          var nodeSize_1 = (0, util_1.getFuncByUnknownType)(30, paramNodeSize, false);
          layoutNodes.forEach(function(node2) {
            if (!node2.x || !node2.y) {
              node2.x = 0;
              node2.y = 0;
            }
            var _a2 = nodeSize_1(node2), _b = _a2[0], nodew = _b === void 0 ? 30 : _b, _c = _a2[1], nodeh = _c === void 0 ? 30 : _c;
            var p2 = nodeSpacing_1 !== void 0 ? nodeSpacing_1(node2) : preventOverlapPadding;
            var w2 = nodew + p2;
            var h2 = nodeh + p2;
            self2.cellWidth = Math.max(self2.cellWidth, w2);
            self2.cellHeight = Math.max(self2.cellHeight, h2);
          });
        }
        self2.cellUsed = {};
        self2.row = 0;
        self2.col = 0;
        self2.id2manPos = {};
        for (var i2 = 0; i2 < layoutNodes.length; i2++) {
          var node = layoutNodes[i2];
          var rcPos = void 0;
          if (self2.position) {
            rcPos = self2.position(node);
          }
          if (rcPos && (rcPos.row !== void 0 || rcPos.col !== void 0)) {
            var pos = {
              row: rcPos.row,
              col: rcPos.col
            };
            if (pos.col === void 0) {
              pos.col = 0;
              while (self2.used(pos.row, pos.col)) {
                pos.col++;
              }
            } else if (pos.row === void 0) {
              pos.row = 0;
              while (self2.used(pos.row, pos.col)) {
                pos.row++;
              }
            }
            self2.id2manPos[node.id] = pos;
            self2.use(pos.row, pos.col);
          }
          self2.getPos(node);
        }
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          edges,
          nodes: layoutNodes
        };
      };
      GridLayout3.prototype.small = function(val) {
        var self2 = this;
        var res;
        var rows = self2.rows || 5;
        var cols = self2.cols || 5;
        if (val == null) {
          res = Math.min(rows, cols);
        } else {
          var min6 = Math.min(rows, cols);
          if (min6 === self2.rows) {
            self2.rows = val;
          } else {
            self2.cols = val;
          }
        }
        return res;
      };
      GridLayout3.prototype.large = function(val) {
        var self2 = this;
        var res;
        var rows = self2.rows || 5;
        var cols = self2.cols || 5;
        if (val == null) {
          res = Math.max(rows, cols);
        } else {
          var max7 = Math.max(rows, cols);
          if (max7 === self2.rows) {
            self2.rows = val;
          } else {
            self2.cols = val;
          }
        }
        return res;
      };
      GridLayout3.prototype.used = function(row, col) {
        var self2 = this;
        return self2.cellUsed["c-".concat(row, "-").concat(col)] || false;
      };
      GridLayout3.prototype.use = function(row, col) {
        var self2 = this;
        self2.cellUsed["c-".concat(row, "-").concat(col)] = true;
      };
      GridLayout3.prototype.moveToNextCell = function() {
        var self2 = this;
        var cols = self2.cols || 5;
        self2.col++;
        if (self2.col >= cols) {
          self2.col = 0;
          self2.row++;
        }
      };
      GridLayout3.prototype.getPos = function(node) {
        var self2 = this;
        var begin = self2.begin, cellWidth = self2.cellWidth, cellHeight = self2.cellHeight;
        var x2;
        var y2;
        var rcPos = self2.id2manPos[node.id];
        if (rcPos) {
          x2 = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
          y2 = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
        } else {
          while (self2.used(self2.row, self2.col)) {
            self2.moveToNextCell();
          }
          x2 = self2.col * cellWidth + cellWidth / 2 + begin[0];
          y2 = self2.row * cellHeight + cellHeight / 2 + begin[1];
          self2.use(self2.row, self2.col);
          self2.moveToNextCell();
        }
        node.x = x2;
        node.y = y2;
      };
      GridLayout3.prototype.getType = function() {
        return "grid";
      };
      return GridLayout3;
    }(base_1.Base);
    exports.GridLayout = GridLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/random.js
var require_random = __commonJS({
  "node_modules/@antv/layout/lib/layout/random.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RandomLayout = void 0;
    var base_1 = require_base();
    var RandomLayout2 = function(_super) {
      __extends19(RandomLayout3, _super);
      function RandomLayout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.width = 300;
        _this.height = 300;
        _this.nodes = [];
        _this.edges = [];
        _this.onLayoutEnd = function() {
        };
        _this.updateCfg(options);
        return _this;
      }
      RandomLayout3.prototype.getDefaultCfg = function() {
        return {
          center: [0, 0],
          width: 300,
          height: 300
        };
      };
      RandomLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var layoutScale = 0.9;
        var center = self2.center;
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (nodes) {
          nodes.forEach(function(node) {
            node.x = (Math.random() - 0.5) * layoutScale * self2.width + center[0];
            node.y = (Math.random() - 0.5) * layoutScale * self2.height + center[1];
          });
        }
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges: this.edges
        };
      };
      RandomLayout3.prototype.getType = function() {
        return "random";
      };
      return RandomLayout3;
    }(base_1.Base);
    exports.RandomLayout = RandomLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gForce.js
var require_gForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/gForce.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function(d2) {
          return defaultV || 1;
        };
      } else if ((0, util_1.isNumber)(value)) {
        func = function(d2) {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    var GForceLayout2 = function(_super) {
      __extends19(GForceLayout3, _super);
      function GForceLayout3(options) {
        var _this = _super.call(this) || this;
        _this.maxIteration = 500;
        _this.workerEnabled = false;
        _this.edgeStrength = 200;
        _this.nodeStrength = 1e3;
        _this.coulombDisScale = 5e-3;
        _this.damping = 0.9;
        _this.maxSpeed = 1e3;
        _this.minMovement = 0.5;
        _this.interval = 0.02;
        _this.factor = 1;
        _this.linkDistance = 1;
        _this.gravity = 10;
        _this.preventOverlap = true;
        _this.collideStrength = 1;
        _this.tick = function() {
        };
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.nodeMap = {};
        _this.nodeIdxMap = {};
        _this.animate = true;
        _this.updateCfg(options);
        return _this;
      }
      GForceLayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 500,
          gravity: 10,
          enableTick: true,
          animate: true
        };
      };
      GForceLayout3.prototype.execute = function() {
        var _a2, _b;
        var self2 = this;
        var nodes = self2.nodes;
        if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
          window.clearInterval(self2.timeInterval);
        }
        if (!nodes || nodes.length === 0) {
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return;
        }
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (!self2.center) {
          self2.center = [self2.width / 2, self2.height / 2];
        }
        var center = self2.center;
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
          return;
        }
        var nodeMap = {};
        var nodeIdxMap = {};
        nodes.forEach(function(node, i2) {
          if (!(0, util_1.isNumber)(node.x))
            node.x = Math.random() * self2.width;
          if (!(0, util_1.isNumber)(node.y))
            node.y = Math.random() * self2.height;
          nodeMap[node.id] = node;
          nodeIdxMap[node.id] = i2;
        });
        self2.nodeMap = nodeMap;
        self2.nodeIdxMap = nodeIdxMap;
        self2.linkDistance = proccessToFunc3(self2.linkDistance, 1);
        self2.nodeStrength = proccessToFunc3(self2.nodeStrength, 1);
        self2.edgeStrength = proccessToFunc3(self2.edgeStrength, 1);
        var nodeSize = self2.nodeSize;
        var nodeSizeFunc;
        if (self2.preventOverlap) {
          var nodeSpacing_1 = self2.nodeSpacing;
          var nodeSpacingFunc_1;
          if ((0, util_1.isNumber)(nodeSpacing_1)) {
            nodeSpacingFunc_1 = function() {
              return nodeSpacing_1;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
            nodeSpacingFunc_1 = nodeSpacing_1;
          } else {
            nodeSpacingFunc_1 = function() {
              return 0;
            };
          }
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  return Math.max(d2.size[0], d2.size[1]) + nodeSpacingFunc_1(d2);
                }
                if ((0, util_1.isObject)(d2.size)) {
                  return Math.max(d2.size.width, d2.size.height) + nodeSpacingFunc_1(d2);
                }
                return d2.size + nodeSpacingFunc_1(d2);
              }
              return 10 + nodeSpacingFunc_1(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              return Math.max(nodeSize[0], nodeSize[1]) + nodeSpacingFunc_1(d2);
            };
          } else {
            nodeSizeFunc = function(d2) {
              return nodeSize + nodeSpacingFunc_1(d2);
            };
          }
        }
        self2.nodeSize = nodeSizeFunc;
        var edges = self2.edges;
        self2.degrees = (0, util_1.getDegree)(nodes.length, self2.nodeIdxMap, edges);
        if (!self2.getMass) {
          self2.getMass = function(d2) {
            var mass = d2.mass || self2.degrees[self2.nodeIdxMap[d2.id]] || 1;
            return mass;
          };
        }
        self2.run();
      };
      GForceLayout3.prototype.run = function() {
        var _a2;
        var self2 = this;
        var maxIteration = self2.maxIteration, nodes = self2.nodes, workerEnabled = self2.workerEnabled, minMovement = self2.minMovement, animate = self2.animate;
        if (!nodes)
          return;
        if (workerEnabled || !animate) {
          for (var i2 = 0; i2 < maxIteration; i2++) {
            var previousPos = self2.runOneStep(i2);
            if (self2.reachMoveThreshold(nodes, previousPos, minMovement)) {
              break;
            }
          }
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        } else {
          if (typeof window === "undefined")
            return;
          var iter_1 = 0;
          this.timeInterval = window.setInterval(function() {
            var _a3, _b;
            if (!nodes)
              return;
            var previousPos2 = self2.runOneStep(iter_1) || [];
            if (self2.reachMoveThreshold(nodes, previousPos2, minMovement)) {
              (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
              window.clearInterval(self2.timeInterval);
            }
            iter_1++;
            if (iter_1 >= maxIteration) {
              (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
              window.clearInterval(self2.timeInterval);
            }
          }, 0);
        }
      };
      GForceLayout3.prototype.reachMoveThreshold = function(nodes, previousPos, minMovement) {
        var movement = 0;
        nodes.forEach(function(node, j2) {
          var vx = node.x - previousPos[j2].x;
          var vy = node.y - previousPos[j2].y;
          movement += Math.sqrt(vx * vx + vy * vy);
        });
        movement /= nodes.length;
        return movement < minMovement;
      };
      GForceLayout3.prototype.runOneStep = function(iter) {
        var _a2;
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges;
        var accArray = [];
        var velArray = [];
        if (!nodes)
          return;
        nodes.forEach(function(_2, i2) {
          accArray[2 * i2] = 0;
          accArray[2 * i2 + 1] = 0;
          velArray[2 * i2] = 0;
          velArray[2 * i2 + 1] = 0;
        });
        self2.calRepulsive(accArray, nodes);
        if (edges)
          self2.calAttractive(accArray, edges);
        self2.calGravity(accArray, nodes);
        var stepInterval = Math.max(0.02, self2.interval - iter * 2e-3);
        self2.updateVelocity(accArray, velArray, stepInterval, nodes);
        var previousPos = [];
        nodes.forEach(function(node) {
          previousPos.push({
            x: node.x,
            y: node.y
          });
        });
        self2.updatePosition(velArray, stepInterval, nodes);
        (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        return previousPos;
      };
      GForceLayout3.prototype.calRepulsive = function(accArray, nodes) {
        var self2 = this;
        var getMass = self2.getMass, factor = self2.factor, coulombDisScale = self2.coulombDisScale, preventOverlap = self2.preventOverlap, _a2 = self2.collideStrength, collideStrength = _a2 === void 0 ? 1 : _a2;
        var nodeStrength = self2.nodeStrength;
        var nodeSize = self2.nodeSize;
        nodes.forEach(function(ni2, i2) {
          var massi = getMass ? getMass(ni2) : 1;
          nodes.forEach(function(nj, j2) {
            if (i2 >= j2)
              return;
            var vecX = ni2.x - nj.x;
            var vecY = ni2.y - nj.y;
            if (vecX === 0 && vecY === 0) {
              vecX = Math.random() * 0.01;
              vecY = Math.random() * 0.01;
            }
            var lengthSqr = vecX * vecX + vecY * vecY;
            var vecLength = Math.sqrt(lengthSqr);
            var nVecLength = (vecLength + 0.1) * coulombDisScale;
            var direX = vecX / vecLength;
            var direY = vecY / vecLength;
            var param = (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 * factor / (nVecLength * nVecLength);
            var massj = getMass ? getMass(nj) : 1;
            accArray[2 * i2] += direX * param;
            accArray[2 * i2 + 1] += direY * param;
            accArray[2 * j2] -= direX * param;
            accArray[2 * j2 + 1] -= direY * param;
            if (preventOverlap && (nodeSize(ni2) + nodeSize(nj)) / 2 > vecLength) {
              var paramOverlap = collideStrength * (nodeStrength(ni2) + nodeStrength(nj)) * 0.5 / lengthSqr;
              accArray[2 * i2] += direX * paramOverlap / massi;
              accArray[2 * i2 + 1] += direY * paramOverlap / massi;
              accArray[2 * j2] -= direX * paramOverlap / massj;
              accArray[2 * j2 + 1] -= direY * paramOverlap / massj;
            }
          });
        });
      };
      GForceLayout3.prototype.calAttractive = function(accArray, edges) {
        var self2 = this;
        var nodeMap = self2.nodeMap, nodeIdxMap = self2.nodeIdxMap, linkDistance = self2.linkDistance, edgeStrength = self2.edgeStrength;
        var nodeSize = self2.nodeSize;
        var getMass = self2.getMass;
        edges.forEach(function(edge, i2) {
          var source = (0, util_1.getEdgeTerminal)(edge, "source");
          var target = (0, util_1.getEdgeTerminal)(edge, "target");
          var sourceNode = nodeMap[source];
          var targetNode = nodeMap[target];
          var vecX = targetNode.x - sourceNode.x;
          var vecY = targetNode.y - sourceNode.y;
          if (vecX === 0 && vecY === 0) {
            vecX = Math.random() * 0.01;
            vecY = Math.random() * 0.01;
          }
          var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
          var direX = vecX / vecLength;
          var direY = vecY / vecLength;
          var length5 = linkDistance(edge, sourceNode, targetNode) || 1 + (nodeSize(sourceNode) + nodeSize(sourceNode) || 0) / 2;
          var diff = length5 - vecLength;
          var param = diff * edgeStrength(edge);
          var sourceIdx = nodeIdxMap[source];
          var targetIdx = nodeIdxMap[target];
          var massSource = getMass ? getMass(sourceNode) : 1;
          var massTarget = getMass ? getMass(targetNode) : 1;
          accArray[2 * sourceIdx] -= direX * param / massSource;
          accArray[2 * sourceIdx + 1] -= direY * param / massSource;
          accArray[2 * targetIdx] += direX * param / massTarget;
          accArray[2 * targetIdx + 1] += direY * param / massTarget;
        });
      };
      GForceLayout3.prototype.calGravity = function(accArray, nodes) {
        var self2 = this;
        var center = self2.center;
        var defaultGravity = self2.gravity;
        var degrees2 = self2.degrees;
        var nodeLength = nodes.length;
        for (var i2 = 0; i2 < nodeLength; i2++) {
          var node = nodes[i2];
          var vecX = node.x - center[0];
          var vecY = node.y - center[1];
          var gravity = defaultGravity;
          if (self2.getCenter) {
            var customCenterOpt = self2.getCenter(node, degrees2[i2]);
            if (customCenterOpt && (0, util_1.isNumber)(customCenterOpt[0]) && (0, util_1.isNumber)(customCenterOpt[1]) && (0, util_1.isNumber)(customCenterOpt[2])) {
              vecX = node.x - customCenterOpt[0];
              vecY = node.y - customCenterOpt[1];
              gravity = customCenterOpt[2];
            }
          }
          if (!gravity)
            continue;
          accArray[2 * i2] -= gravity * vecX;
          accArray[2 * i2 + 1] -= gravity * vecY;
        }
      };
      GForceLayout3.prototype.updateVelocity = function(accArray, velArray, stepInterval, nodes) {
        var self2 = this;
        var param = stepInterval * self2.damping;
        nodes.forEach(function(node, i2) {
          var vx = accArray[2 * i2] * param || 0.01;
          var vy = accArray[2 * i2 + 1] * param || 0.01;
          var vLength = Math.sqrt(vx * vx + vy * vy);
          if (vLength > self2.maxSpeed) {
            var param2 = self2.maxSpeed / vLength;
            vx = param2 * vx;
            vy = param2 * vy;
          }
          velArray[2 * i2] = vx;
          velArray[2 * i2 + 1] = vy;
        });
      };
      GForceLayout3.prototype.updatePosition = function(velArray, stepInterval, nodes) {
        nodes.forEach(function(node, i2) {
          if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
            node.x = node.fx;
            node.y = node.fy;
            return;
          }
          var distX = velArray[2 * i2] * stepInterval;
          var distY = velArray[2 * i2 + 1] * stepInterval;
          node.x += distX;
          node.y += distY;
        });
      };
      GForceLayout3.prototype.stop = function() {
        if (this.timeInterval && typeof window !== "undefined") {
          window.clearInterval(this.timeInterval);
        }
      };
      GForceLayout3.prototype.destroy = function() {
        var self2 = this;
        self2.stop();
        self2.tick = null;
        self2.nodes = null;
        self2.edges = null;
        self2.destroyed = true;
      };
      GForceLayout3.prototype.getType = function() {
        return "gForce";
      };
      return GForceLayout3;
    }(base_1.Base);
    exports.GForceLayout = GForceLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/force/force-in-a-box.js
var require_force_in_a_box = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force-in-a-box.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k2 in mod3)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k2))
            __createBinding(result, mod3, k2);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar((init_src(), __toCommonJS(src_exports)));
    var util_1 = require_util2();
    function forceInABox() {
      function constant(_2) {
        return function() {
          return _2;
        };
      }
      var groupBy2 = function(d2) {
        return d2.cluster;
      };
      var forceNodeSize = constant(1);
      var forceCharge = constant(-1);
      var forceLinkDistance = constant(100);
      var forceLinkStrength = constant(0.1);
      var offset = [0, 0];
      var nodes = [];
      var nodesMap = {};
      var links = [];
      var centerX = 100;
      var centerY = 100;
      var foci = {
        none: {
          x: 0,
          y: 0
        }
      };
      var templateNodes = [];
      var templateForce;
      var template = "force";
      var enableGrouping = true;
      var strength = 0.1;
      function force(alpha) {
        if (!enableGrouping) {
          return force;
        }
        templateForce.tick();
        getFocisFromTemplate();
        for (var i2 = 0, n2 = nodes.length, node = void 0, k2 = alpha * strength; i2 < n2; ++i2) {
          node = nodes[i2];
          node.vx += (foci[groupBy2(node)].x - node.x) * k2;
          node.vy += (foci[groupBy2(node)].y - node.y) * k2;
        }
      }
      function initialize() {
        if (!nodes)
          return;
        initializeWithForce();
      }
      function initializeWithForce() {
        if (!nodes || !nodes.length) {
          return;
        }
        if (groupBy2(nodes[0]) === void 0) {
          throw Error("Couldnt find the grouping attribute for the nodes. Make sure to set it up with forceInABox.groupBy('clusterAttr') before calling .links()");
        }
        var net = getGroupsGraph();
        templateForce = d3Force.forceSimulation(net.nodes).force("x", d3Force.forceX(centerX).strength(0.1)).force("y", d3Force.forceY(centerY).strength(0.1)).force("collide", d3Force.forceCollide(function(d2) {
          return d2.r;
        }).iterations(4)).force("charge", d3Force.forceManyBody().strength(forceCharge)).force("links", d3Force.forceLink(net.nodes.length ? net.links : []).distance(forceLinkDistance).strength(forceLinkStrength));
        templateNodes = templateForce.nodes();
        getFocisFromTemplate();
      }
      function getGroupsGraph() {
        var gnodes = [];
        var glinks = [];
        var dNodes = {};
        var clustersList = [];
        var clustersCounts = {};
        var clustersLinks = [];
        clustersCounts = computeClustersNodeCounts(nodes);
        clustersLinks = computeClustersLinkCounts(links);
        clustersList = Object.keys(clustersCounts);
        clustersList.forEach(function(key, index) {
          var val = clustersCounts[key];
          gnodes.push({
            id: key,
            size: val.count,
            r: Math.sqrt(val.sumforceNodeSize / Math.PI)
          });
          dNodes[key] = index;
        });
        clustersLinks.forEach(function(l2) {
          var sourceTerminal = (0, util_1.getEdgeTerminal)(l2, "source");
          var targetTerminal = (0, util_1.getEdgeTerminal)(l2, "target");
          var source = dNodes[sourceTerminal];
          var target = dNodes[targetTerminal];
          if (source !== void 0 && target !== void 0) {
            glinks.push({
              source,
              target,
              count: l2.count
            });
          }
        });
        return {
          nodes: gnodes,
          links: glinks
        };
      }
      function computeClustersNodeCounts(nodes2) {
        var clustersCounts = {};
        nodes2.forEach(function(d2) {
          var key = groupBy2(d2);
          if (!clustersCounts[key]) {
            clustersCounts[key] = {
              count: 0,
              sumforceNodeSize: 0
            };
          }
        });
        nodes2.forEach(function(d2) {
          var key = groupBy2(d2);
          var nodeSize = forceNodeSize(d2);
          var tmpCount = clustersCounts[key];
          tmpCount.count = tmpCount.count + 1;
          tmpCount.sumforceNodeSize = tmpCount.sumforceNodeSize + Math.PI * (nodeSize * nodeSize) * 1.3;
          clustersCounts[key] = tmpCount;
        });
        return clustersCounts;
      }
      function computeClustersLinkCounts(links2) {
        var dClusterLinks = {};
        var clusterLinks = [];
        links2.forEach(function(l2) {
          var key = getLinkKey(l2);
          var count = 0;
          if (dClusterLinks[key] !== void 0) {
            count = dClusterLinks[key];
          }
          count += 1;
          dClusterLinks[key] = count;
        });
        var entries = Object.entries(dClusterLinks);
        entries.forEach(function(_a2) {
          var key = _a2[0], count = _a2[1];
          var source = key.split("~")[0];
          var target = key.split("~")[1];
          if (source !== void 0 && target !== void 0) {
            clusterLinks.push({
              source,
              target,
              count
            });
          }
        });
        return clusterLinks;
      }
      function getFocisFromTemplate() {
        foci = {
          none: {
            x: 0,
            y: 0
          }
        };
        templateNodes.forEach(function(d2) {
          foci[d2.id] = {
            x: d2.x - offset[0],
            y: d2.y - offset[1]
          };
        });
        return foci;
      }
      function getLinkKey(l2) {
        var source = (0, util_1.getEdgeTerminal)(l2, "source");
        var target = (0, util_1.getEdgeTerminal)(l2, "target");
        var sourceID = groupBy2(nodesMap[source]);
        var targetID = groupBy2(nodesMap[target]);
        return sourceID <= targetID ? "".concat(sourceID, "~").concat(targetID) : "".concat(targetID, "~").concat(sourceID);
      }
      function genNodesMap(nodes2) {
        nodesMap = {};
        nodes2.forEach(function(node) {
          nodesMap[node.id] = node;
        });
      }
      function setTemplate(x2) {
        if (!arguments.length)
          return template;
        template = x2;
        initialize();
        return force;
      }
      function setGroupBy(x2) {
        if (!arguments.length)
          return groupBy2;
        if (typeof x2 === "string") {
          groupBy2 = function(d2) {
            return d2[x2];
          };
          return force;
        }
        groupBy2 = x2;
        return force;
      }
      function setEnableGrouping(x2) {
        if (!arguments.length)
          return enableGrouping;
        enableGrouping = x2;
        return force;
      }
      function setStrength(x2) {
        if (!arguments.length)
          return strength;
        strength = x2;
        return force;
      }
      function setCenterX(_2) {
        if (arguments.length) {
          centerX = _2;
          return force;
        }
        return centerX;
      }
      function setCenterY(_2) {
        if (arguments.length) {
          centerY = _2;
          return force;
        }
        return centerY;
      }
      function setNodes(_2) {
        if (arguments.length) {
          genNodesMap(_2 || []);
          nodes = _2 || [];
          return force;
        }
        return nodes;
      }
      function setLinks(_2) {
        if (arguments.length) {
          links = _2 || [];
          initialize();
          return force;
        }
        return links;
      }
      function setForceNodeSize(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceNodeSize = _2;
          } else {
            forceNodeSize = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceNodeSize;
      }
      function setForceCharge(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceCharge = _2;
          } else {
            forceCharge = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceCharge;
      }
      function setForceLinkDistance(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkDistance = _2;
          } else {
            forceLinkDistance = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkDistance;
      }
      function setForceLinkStrength(_2) {
        if (arguments.length) {
          if (typeof _2 === "function") {
            forceLinkStrength = _2;
          } else {
            forceLinkStrength = constant(+_2);
          }
          initialize();
          return force;
        }
        return forceLinkStrength;
      }
      function setOffset(_2) {
        if (arguments.length) {
          offset = _2;
          return force;
        }
        return offset;
      }
      force.initialize = function(_2) {
        nodes = _2;
        initialize();
      };
      force.template = setTemplate;
      force.groupBy = setGroupBy;
      force.enableGrouping = setEnableGrouping;
      force.strength = setStrength;
      force.centerX = setCenterX;
      force.centerY = setCenterY;
      force.nodes = setNodes;
      force.links = setLinks;
      force.forceNodeSize = setForceNodeSize;
      force.nodeSize = force.forceNodeSize;
      force.forceCharge = setForceCharge;
      force.forceLinkDistance = setForceLinkDistance;
      force.forceLinkStrength = setForceLinkStrength;
      force.offset = setOffset;
      force.getFocis = getFocisFromTemplate;
      return force;
    }
    exports.default = forceInABox;
  }
});

// node_modules/@antv/layout/lib/layout/constants.js
var require_constants = __commonJS({
  "node_modules/@antv/layout/lib/layout/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FORCE_LAYOUT_TYPE_MAP = exports.LAYOUT_MESSAGE = void 0;
    exports.LAYOUT_MESSAGE = {
      RUN: "LAYOUT_RUN",
      END: "LAYOUT_END",
      ERROR: "LAYOUT_ERROR",
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    exports.FORCE_LAYOUT_TYPE_MAP = {
      "gForce": true,
      "fruchterman": true,
      "forceAtlas2": true,
      "force": true,
      "graphin-force": true
    };
  }
});

// node_modules/@antv/layout/lib/layout/force/force.js
var require_force = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/force.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k2 in mod3)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k2))
            __createBinding(result, mod3, k2);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceLayout = void 0;
    var d3Force = __importStar((init_src(), __toCommonJS(src_exports)));
    var force_in_a_box_1 = __importDefault(require_force_in_a_box());
    var util_1 = require_util2();
    var base_1 = require_base();
    var constants_1 = require_constants();
    var ForceLayout2 = function(_super) {
      __extends19(ForceLayout3, _super);
      function ForceLayout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.nodeStrength = null;
        _this.edgeStrength = null;
        _this.preventOverlap = false;
        _this.clusterNodeStrength = null;
        _this.clusterEdgeStrength = null;
        _this.clusterEdgeDistance = null;
        _this.clusterNodeSize = null;
        _this.clusterFociStrength = null;
        _this.linkDistance = 50;
        _this.alphaDecay = 0.028;
        _this.alphaMin = 1e-3;
        _this.alpha = 0.3;
        _this.collideStrength = 1;
        _this.workerEnabled = false;
        _this.tick = function() {
        };
        _this.onLayoutEnd = function() {
        };
        _this.ticking = void 0;
        if (options) {
          _this.updateCfg(options);
        }
        return _this;
      }
      ForceLayout3.prototype.getDefaultCfg = function() {
        return {
          center: [0, 0],
          nodeStrength: null,
          edgeStrength: null,
          preventOverlap: false,
          nodeSize: void 0,
          nodeSpacing: void 0,
          linkDistance: 50,
          forceSimulation: null,
          alphaDecay: 0.028,
          alphaMin: 1e-3,
          alpha: 0.3,
          collideStrength: 1,
          clustering: false,
          clusterNodeStrength: -1,
          clusterEdgeStrength: 0.1,
          clusterEdgeDistance: 100,
          clusterFociStrength: 0.8,
          clusterNodeSize: 10,
          tick: function() {
          },
          onLayoutEnd: function() {
          },
          workerEnabled: false
        };
      };
      ForceLayout3.prototype.init = function(data) {
        var self2 = this;
        self2.nodes = data.nodes || [];
        var edges = data.edges || [];
        self2.edges = edges.map(function(edge) {
          var res = {};
          var expectKeys = ["targetNode", "sourceNode", "startPoint", "endPoint"];
          Object.keys(edge).forEach(function(key) {
            if (!(expectKeys.indexOf(key) > -1)) {
              res[key] = edge[key];
            }
          });
          return res;
        });
        self2.ticking = false;
      };
      ForceLayout3.prototype.execute = function(reloadData) {
        var self2 = this;
        var nodes = self2.nodes;
        var edges = self2.edges;
        if (self2.ticking) {
          return;
        }
        var simulation = self2.forceSimulation;
        var alphaMin = self2.alphaMin;
        var alphaDecay = self2.alphaDecay;
        var alpha = self2.alpha;
        if (!simulation) {
          try {
            var nodeForce = d3Force.forceManyBody();
            if (self2.nodeStrength) {
              nodeForce.strength(self2.nodeStrength);
            }
            simulation = d3Force.forceSimulation().nodes(nodes);
            if (self2.clustering) {
              var clusterForce = (0, force_in_a_box_1.default)();
              clusterForce.centerX(self2.center[0]).centerY(self2.center[1]).template("force").strength(self2.clusterFociStrength);
              if (edges) {
                clusterForce.links(edges);
              }
              if (nodes) {
                clusterForce.nodes(nodes);
              }
              clusterForce.forceLinkDistance(self2.clusterEdgeDistance).forceLinkStrength(self2.clusterEdgeStrength).forceCharge(self2.clusterNodeStrength).forceNodeSize(self2.clusterNodeSize);
              self2.clusterForce = clusterForce;
              simulation.force("group", clusterForce);
            }
            simulation.force("center", d3Force.forceCenter(self2.center[0], self2.center[1])).force("charge", nodeForce).alpha(alpha).alphaDecay(alphaDecay).alphaMin(alphaMin);
            if (self2.preventOverlap) {
              self2.overlapProcess(simulation);
            }
            if (edges) {
              var edgeForce = d3Force.forceLink().id(function(d2) {
                return d2.id;
              }).links(edges);
              if (self2.edgeStrength) {
                edgeForce.strength(self2.edgeStrength);
              }
              if (self2.linkDistance) {
                edgeForce.distance(self2.linkDistance);
              }
              self2.edgeForce = edgeForce;
              simulation.force("link", edgeForce);
            }
            if (self2.workerEnabled && !isInWorker()) {
              self2.workerEnabled = false;
              console.warn("workerEnabled option is only supported when running in web worker.");
            }
            if (!self2.workerEnabled) {
              simulation.on("tick", function() {
                self2.tick();
              }).on("end", function() {
                self2.ticking = false;
                if (self2.onLayoutEnd)
                  self2.onLayoutEnd();
              });
              self2.ticking = true;
            } else {
              simulation.stop();
              var totalTicks = getSimulationTicks(simulation);
              for (var currentTick = 1; currentTick <= totalTicks; currentTick++) {
                simulation.tick();
                postMessage({
                  nodes,
                  currentTick,
                  totalTicks,
                  type: constants_1.LAYOUT_MESSAGE.TICK
                }, void 0);
              }
              self2.ticking = false;
            }
            self2.forceSimulation = simulation;
            self2.ticking = true;
          } catch (e8) {
            self2.ticking = false;
            console.warn(e8);
          }
        } else {
          if (reloadData) {
            if (self2.clustering && self2.clusterForce) {
              self2.clusterForce.nodes(nodes);
              self2.clusterForce.links(edges);
            }
            simulation.nodes(nodes);
            if (edges && self2.edgeForce)
              self2.edgeForce.links(edges);
            else if (edges && !self2.edgeForce) {
              var edgeForce = d3Force.forceLink().id(function(d2) {
                return d2.id;
              }).links(edges);
              if (self2.edgeStrength) {
                edgeForce.strength(self2.edgeStrength);
              }
              if (self2.linkDistance) {
                edgeForce.distance(self2.linkDistance);
              }
              self2.edgeForce = edgeForce;
              simulation.force("link", edgeForce);
            }
          }
          if (self2.preventOverlap) {
            self2.overlapProcess(simulation);
          }
          simulation.alpha(alpha).restart();
          this.ticking = true;
        }
      };
      ForceLayout3.prototype.overlapProcess = function(simulation) {
        var self2 = this;
        var nodeSize = self2.nodeSize;
        var nodeSpacing = self2.nodeSpacing;
        var nodeSizeFunc;
        var nodeSpacingFunc;
        var collideStrength = self2.collideStrength;
        if ((0, util_1.isNumber)(nodeSpacing)) {
          nodeSpacingFunc = function() {
            return nodeSpacing;
          };
        } else if ((0, util_1.isFunction)(nodeSpacing)) {
          nodeSpacingFunc = nodeSpacing;
        } else {
          nodeSpacingFunc = function() {
            return 0;
          };
        }
        if (!nodeSize) {
          nodeSizeFunc = function(d2) {
            if (d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                return res / 2 + nodeSpacingFunc(d2);
              }
              if ((0, util_1.isObject)(d2.size)) {
                var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                return res / 2 + nodeSpacingFunc(d2);
              }
              return d2.size / 2 + nodeSpacingFunc(d2);
            }
            return 10 + nodeSpacingFunc(d2);
          };
        } else if ((0, util_1.isFunction)(nodeSize)) {
          nodeSizeFunc = function(d2) {
            var size2 = nodeSize(d2);
            return size2 + nodeSpacingFunc(d2);
          };
        } else if ((0, util_1.isArray)(nodeSize)) {
          var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
          var radius_1 = larger / 2;
          nodeSizeFunc = function(d2) {
            return radius_1 + nodeSpacingFunc(d2);
          };
        } else if ((0, util_1.isNumber)(nodeSize)) {
          var radius_2 = nodeSize / 2;
          nodeSizeFunc = function(d2) {
            return radius_2 + nodeSpacingFunc(d2);
          };
        } else {
          nodeSizeFunc = function() {
            return 10;
          };
        }
        simulation.force("collisionForce", d3Force.forceCollide(nodeSizeFunc).strength(collideStrength));
      };
      ForceLayout3.prototype.updateCfg = function(cfg) {
        var self2 = this;
        if (self2.ticking) {
          self2.forceSimulation.stop();
          self2.ticking = false;
        }
        self2.forceSimulation = null;
        Object.assign(self2, cfg);
      };
      ForceLayout3.prototype.destroy = function() {
        var self2 = this;
        if (self2.ticking) {
          self2.forceSimulation.stop();
          self2.ticking = false;
        }
        self2.nodes = null;
        self2.edges = null;
        self2.destroyed = true;
      };
      return ForceLayout3;
    }(base_1.Base);
    exports.ForceLayout = ForceLayout2;
    function getSimulationTicks(simulation) {
      var alphaMin = simulation.alphaMin();
      var alphaTarget = simulation.alphaTarget();
      var alpha = simulation.alpha();
      var totalTicksFloat = Math.log((alphaMin - alphaTarget) / (alpha - alphaTarget)) / Math.log(1 - simulation.alphaDecay());
      var totalTicks = Math.ceil(totalTicksFloat);
      return totalTicks;
    }
    function isInWorker() {
      return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    }
  }
});

// node_modules/@antv/layout/lib/layout/force/index.js
var require_force2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/force/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_force(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/circular.js
var require_circular = __commonJS({
  "node_modules/@antv/layout/lib/layout/circular.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CircularLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    function initHierarchy(nodes, edges, nodeMap, directed) {
      nodes.forEach(function(_2, i2) {
        nodes[i2].children = [];
        nodes[i2].parent = [];
      });
      if (directed) {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var child = nodes[sourceIdx].children;
          var parent = nodes[targetIdx].parent;
          child.push(nodes[targetIdx].id);
          parent.push(nodes[sourceIdx].id);
        });
      } else {
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          var sourceIdx = 0;
          if (source) {
            sourceIdx = nodeMap[source];
          }
          var targetIdx = 0;
          if (target) {
            targetIdx = nodeMap[target];
          }
          var sourceChildren = nodes[sourceIdx].children;
          var targetChildren = nodes[targetIdx].children;
          sourceChildren.push(nodes[targetIdx].id);
          targetChildren.push(nodes[sourceIdx].id);
        });
      }
    }
    function connect(a2, b10, edges) {
      var m2 = edges.length;
      for (var i2 = 0; i2 < m2; i2++) {
        var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
        var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
        if (a2.id === source && b10.id === target || b10.id === source && a2.id === target) {
          return true;
        }
      }
      return false;
    }
    function compareDegree(a2, b10) {
      var aDegree = a2.degree;
      var bDegree = b10.degree;
      if (aDegree < bDegree) {
        return -1;
      }
      if (aDegree > bDegree) {
        return 1;
      }
      return 0;
    }
    var CircularLayout2 = function(_super) {
      __extends19(CircularLayout3, _super);
      function CircularLayout3(options) {
        var _this = _super.call(this) || this;
        _this.radius = null;
        _this.nodeSize = void 0;
        _this.startRadius = null;
        _this.endRadius = null;
        _this.startAngle = 0;
        _this.endAngle = 2 * Math.PI;
        _this.clockwise = true;
        _this.divisions = 1;
        _this.ordering = null;
        _this.angleRatio = 1;
        _this.nodes = [];
        _this.edges = [];
        _this.nodeMap = {};
        _this.degrees = [];
        _this.width = 300;
        _this.height = 300;
        _this.updateCfg(options);
        return _this;
      }
      CircularLayout3.prototype.getDefaultCfg = function() {
        return {
          radius: null,
          startRadius: null,
          endRadius: null,
          startAngle: 0,
          endAngle: 2 * Math.PI,
          clockwise: true,
          divisions: 1,
          ordering: null,
          angleRatio: 1
        };
      };
      CircularLayout3.prototype.execute = function() {
        var _a2;
        var self2 = this;
        var nodes = self2.nodes;
        var edges = self2.edges;
        var n2 = nodes.length;
        if (n2 === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (!self2.center) {
          self2.center = [self2.width / 2, self2.height / 2];
        }
        var center = self2.center;
        if (n2 === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        var radius = self2.radius, startRadius = self2.startRadius, endRadius = self2.endRadius;
        var divisions = self2.divisions, startAngle = self2.startAngle, endAngle = self2.endAngle, angleRatio = self2.angleRatio, ordering = self2.ordering, clockwise = self2.clockwise, paramNodeSpacing = self2.nodeSpacing, paramNodeSize = self2.nodeSize;
        var angleStep = (endAngle - startAngle) / n2;
        var nodeMap = {};
        nodes.forEach(function(node, i3) {
          nodeMap[node.id] = i3;
        });
        self2.nodeMap = nodeMap;
        var degrees2 = (0, util_1.getDegree)(nodes.length, nodeMap, edges);
        self2.degrees = degrees2;
        if (paramNodeSpacing) {
          var nodeSpacing_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSpacing);
          var nodeSize_1 = (0, util_1.getFuncByUnknownType)(10, paramNodeSize);
          var maxNodeSize_1 = -Infinity;
          nodes.forEach(function(node) {
            var nSize = nodeSize_1(node);
            if (maxNodeSize_1 < nSize)
              maxNodeSize_1 = nSize;
          });
          var length_1 = 0;
          nodes.forEach(function(node, i3) {
            if (i3 === 0)
              length_1 += maxNodeSize_1 || 10;
            else
              length_1 += (nodeSpacing_1(node) || 0) + (maxNodeSize_1 || 10);
          });
          radius = length_1 / (2 * Math.PI);
        } else if (!radius && !startRadius && !endRadius) {
          radius = self2.height > self2.width ? self2.width / 2 : self2.height / 2;
        } else if (!startRadius && endRadius) {
          startRadius = endRadius;
        } else if (startRadius && !endRadius) {
          endRadius = startRadius;
        }
        var astep = angleStep * angleRatio;
        var layoutNodes = [];
        if (ordering === "topology") {
          layoutNodes = self2.topologyOrdering();
        } else if (ordering === "topology-directed") {
          layoutNodes = self2.topologyOrdering(true);
        } else if (ordering === "degree") {
          layoutNodes = self2.degreeOrdering();
        } else {
          layoutNodes = nodes;
        }
        var divN = Math.ceil(n2 / divisions);
        for (var i2 = 0; i2 < n2; ++i2) {
          var r2 = radius;
          if (!r2 && startRadius !== null && endRadius !== null) {
            r2 = startRadius + i2 * (endRadius - startRadius) / (n2 - 1);
          }
          if (!r2) {
            r2 = 10 + i2 * 100 / (n2 - 1);
          }
          var angle3 = startAngle + i2 % divN * astep + 2 * Math.PI / divisions * Math.floor(i2 / divN);
          if (!clockwise) {
            angle3 = endAngle - i2 % divN * astep - 2 * Math.PI / divisions * Math.floor(i2 / divN);
          }
          layoutNodes[i2].x = center[0] + Math.cos(angle3) * r2;
          layoutNodes[i2].y = center[1] + Math.sin(angle3) * r2;
          layoutNodes[i2].weight = degrees2[i2];
        }
        (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        return {
          nodes: layoutNodes,
          edges: this.edges
        };
      };
      CircularLayout3.prototype.topologyOrdering = function(directed) {
        if (directed === void 0) {
          directed = false;
        }
        var self2 = this;
        var degrees2 = self2.degrees;
        var edges = self2.edges;
        var nodes = self2.nodes;
        var cnodes = (0, util_1.clone)(nodes);
        var nodeMap = self2.nodeMap;
        var orderedCNodes = [cnodes[0]];
        var resNodes = [nodes[0]];
        var pickFlags = [];
        var n2 = nodes.length;
        pickFlags[0] = true;
        initHierarchy(cnodes, edges, nodeMap, directed);
        var k2 = 0;
        cnodes.forEach(function(cnode, i2) {
          if (i2 !== 0) {
            if ((i2 === n2 - 1 || degrees2[i2] !== degrees2[i2 + 1] || connect(orderedCNodes[k2], cnode, edges)) && !pickFlags[i2]) {
              orderedCNodes.push(cnode);
              resNodes.push(nodes[nodeMap[cnode.id]]);
              pickFlags[i2] = true;
              k2++;
            } else {
              var children = orderedCNodes[k2].children;
              var foundChild = false;
              for (var j2 = 0; j2 < children.length; j2++) {
                var childIdx = nodeMap[children[j2]];
                if (degrees2[childIdx] === degrees2[i2] && !pickFlags[childIdx]) {
                  orderedCNodes.push(cnodes[childIdx]);
                  resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);
                  pickFlags[childIdx] = true;
                  foundChild = true;
                  break;
                }
              }
              var ii2 = 0;
              while (!foundChild) {
                if (!pickFlags[ii2]) {
                  orderedCNodes.push(cnodes[ii2]);
                  resNodes.push(nodes[nodeMap[cnodes[ii2].id]]);
                  pickFlags[ii2] = true;
                  foundChild = true;
                }
                ii2++;
                if (ii2 === n2) {
                  break;
                }
              }
            }
          }
        });
        return resNodes;
      };
      CircularLayout3.prototype.degreeOrdering = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var orderedNodes = [];
        var degrees2 = self2.degrees;
        nodes.forEach(function(node, i2) {
          node.degree = degrees2[i2];
          orderedNodes.push(node);
        });
        orderedNodes.sort(compareDegree);
        return orderedNodes;
      };
      CircularLayout3.prototype.getType = function() {
        return "circular";
      };
      return CircularLayout3;
    }(base_1.Base);
    exports.CircularLayout = CircularLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/data/list.js
var require_list = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/data/list.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var filterOutLinks = function(k2, v2) {
      if (k2 !== "next" && k2 !== "prev") {
        return v2;
      }
    };
    var unlink = function(entry) {
      entry.prev.next = entry.next;
      entry.next.prev = entry.prev;
      delete entry.next;
      delete entry.prev;
    };
    var List = function() {
      function List2() {
        var shortcut = {};
        shortcut.prev = shortcut;
        shortcut.next = shortcut.prev;
        this.shortcut = shortcut;
      }
      List2.prototype.dequeue = function() {
        var shortcut = this.shortcut;
        var entry = shortcut.prev;
        if (entry && entry !== shortcut) {
          unlink(entry);
          return entry;
        }
      };
      List2.prototype.enqueue = function(entry) {
        var shortcut = this.shortcut;
        if (entry.prev && entry.next) {
          unlink(entry);
        }
        entry.next = shortcut.next;
        shortcut.next.prev = entry;
        shortcut.next = entry;
        entry.prev = shortcut;
      };
      List2.prototype.toString = function() {
        var strs = [];
        var sentinel = this.shortcut;
        var curr = sentinel.prev;
        while (curr !== sentinel) {
          strs.push(JSON.stringify(curr, filterOutLinks));
          curr = curr === null || curr === void 0 ? void 0 : curr.prev;
        }
        return "[".concat(strs.join(", "), "]");
      };
      return List2;
    }();
    exports.default = List;
  }
});

// node_modules/@antv/graphlib/es/enum.js
var GraphEnum;
var init_enum = __esm({
  "node_modules/@antv/graphlib/es/enum.js"() {
    (function(GraphEnum2) {
      GraphEnum2["DEFAULT_EDGE_NAME"] = "\0";
      GraphEnum2["GRAPH_NODE"] = "\0";
      GraphEnum2["EDGE_KEY_DELIM"] = "";
    })(GraphEnum || (GraphEnum = {}));
  }
});

// node_modules/@antv/graphlib/es/util.js
function incrementOrInitEntry(map4, key) {
  var val = map4.get(key) || 0;
  map4.set(key, val + 1);
}
function decrementOrRemoveEntry(map4, key) {
  var val = map4.get(key);
  if (val !== void 0) {
    val = val - 1;
    if (val > 0) {
      map4.set(key, val);
    } else {
      map4.delete(key);
    }
  }
}
function edgeArgsToId(isDirected, v_, w_, name) {
  var v2 = String(v_);
  var w2 = String(w_);
  if (!isDirected && v2 > w2) {
    var tmp = v2;
    v2 = w2;
    w2 = tmp;
  }
  return v2 + GraphEnum.EDGE_KEY_DELIM + w2 + GraphEnum.EDGE_KEY_DELIM + (name === void 0 ? GraphEnum.DEFAULT_EDGE_NAME : name);
}
function edgeArgsToObj(isDirected, v2, w2, name) {
  var strV = String(v2);
  var strW = String(w2);
  var edgeObj = {
    v: v2,
    w: w2
  };
  if (!isDirected && strV > strW) {
    var tmp = edgeObj.v;
    edgeObj.v = edgeObj.w;
    edgeObj.w = tmp;
  }
  if (name !== void 0) {
    edgeObj.name = name;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
function isFunction(target) {
  return !!(target && target.constructor && target.call && target.apply);
}
var init_util = __esm({
  "node_modules/@antv/graphlib/es/util.js"() {
    init_enum();
  }
});

// node_modules/@antv/graphlib/es/Graph/toJSON.js
var nodeToJSON, edgeToJSON, write, read;
var init_toJSON = __esm({
  "node_modules/@antv/graphlib/es/Graph/toJSON.js"() {
    init_Graph();
    nodeToJSON = function nodeToJSON2(graph) {
      return graph.nodes().map(function(n2) {
        var value = graph.node(n2);
        var parent = graph.parent(n2);
        var node = {
          id: n2,
          value,
          parent
        };
        if (node.value === void 0) {
          delete node.value;
        }
        if (node.parent === void 0) {
          delete node.parent;
        }
        return node;
      });
    };
    edgeToJSON = function edgeToJSON2(graph) {
      return graph.edges().map(function(edge) {
        var value = graph.edge(edge);
        var e8 = {
          v: edge.v,
          w: edge.w,
          value,
          name: edge.name
        };
        if (e8.name === void 0) {
          delete e8.name;
        }
        if (e8.value === void 0) {
          delete e8.value;
        }
        return e8;
      });
    };
    write = function write2(graph) {
      var json = {
        options: {
          directed: graph.isDirected(),
          multigraph: graph.isMultigraph(),
          compound: graph.isCompound()
        },
        nodes: nodeToJSON(graph),
        edges: edgeToJSON(graph),
        value: graph.graph()
      };
      if (json.value === void 0) {
        delete json.value;
      }
      return json;
    };
    read = function read2(json) {
      var graph = new Graph2(json.options);
      if (json.value !== void 0) {
        graph.setGraph(json.value);
      }
      json.nodes.forEach(function(entry) {
        graph.setNode(entry.id, entry.value);
        if (entry.parent) {
          graph.setParent(entry.id, entry.parent);
        }
      });
      json.edges.forEach(function(entry) {
        graph.setEdge(entry.v, entry.w, entry.value, entry.name);
      });
      return graph;
    };
  }
});

// node_modules/@antv/graphlib/es/Graph/index.js
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var defaultOption, Graph2;
var init_Graph = __esm({
  "node_modules/@antv/graphlib/es/Graph/index.js"() {
    init_util();
    init_enum();
    init_util();
    init_toJSON();
    defaultOption = {
      compound: false,
      multigraph: false,
      directed: true
    };
    Graph2 = _createClass2(function Graph3() {
      var _this = this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck2(this, Graph3);
      this.directed = true;
      this.multigraph = false;
      this.compound = false;
      this.GRAPH_NODE = GraphEnum.GRAPH_NODE;
      this.label = void 0;
      this.nodeCountNum = 0;
      this.edgeCountNum = 0;
      this.defaultNodeLabelFn = function() {
        return void 0;
      };
      this.defaultEdgeLabelFn = function() {
        return void 0;
      };
      this.parentMap = void 0;
      this.childrenMap = void 0;
      this.nodesLabelMap = /* @__PURE__ */ new Map();
      this.inEdgesMap = /* @__PURE__ */ new Map();
      this.outEdgesMap = /* @__PURE__ */ new Map();
      this.predecessorsMap = /* @__PURE__ */ new Map();
      this.successorsMap = /* @__PURE__ */ new Map();
      this.edgesMap = /* @__PURE__ */ new Map();
      this.edgesLabelsMap = /* @__PURE__ */ new Map();
      this.isDirected = function() {
        return _this.directed;
      };
      this.isMultigraph = function() {
        return _this.multigraph;
      };
      this.isCompound = function() {
        return _this.compound;
      };
      this.setGraph = function(label) {
        _this.label = label;
        return _this;
      };
      this.graph = function() {
        return _this.label;
      };
      this.setDefaultNodeLabel = function(newDefault) {
        if (isFunction(newDefault)) {
          _this.defaultNodeLabelFn = newDefault;
        } else {
          _this.defaultNodeLabelFn = function() {
            return newDefault;
          };
        }
        return _this;
      };
      this.nodeCount = function() {
        return _this.nodeCountNum;
      };
      this.node = function(n2) {
        return _this.nodesLabelMap.get(n2);
      };
      this.nodes = function() {
        return Array.from(_this.nodesLabelMap.keys());
      };
      this.sources = function() {
        return _this.nodes().filter(function(n2) {
          var _this$inEdgesMap$get;
          return !((_this$inEdgesMap$get = _this.inEdgesMap.get(n2)) === null || _this$inEdgesMap$get === void 0 ? void 0 : _this$inEdgesMap$get.size);
        });
      };
      this.sinks = function() {
        return _this.nodes().filter(function(n2) {
          var _this$outEdgesMap$get;
          return !((_this$outEdgesMap$get = _this.outEdgesMap.get(n2)) === null || _this$outEdgesMap$get === void 0 ? void 0 : _this$outEdgesMap$get.size);
        });
      };
      this.setNode = function(node, value) {
        var nodesLabelMap = _this.nodesLabelMap, defaultNodeLabelFn = _this.defaultNodeLabelFn, isCompound = _this.isCompound, parentMap = _this.parentMap, childrenMap = _this.childrenMap, inEdgesMap = _this.inEdgesMap, outEdgesMap = _this.outEdgesMap, predecessorsMap = _this.predecessorsMap, successorsMap = _this.successorsMap;
        if (nodesLabelMap.has(node)) {
          if (value !== void 0) {
            nodesLabelMap.set(node, value);
          }
          return _this;
        }
        nodesLabelMap.set(node, value || defaultNodeLabelFn(node));
        if (isCompound()) {
          var _childrenMap$get;
          parentMap === null || parentMap === void 0 ? void 0 : parentMap.set(node, _this.GRAPH_NODE);
          childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(node, /* @__PURE__ */ new Map());
          if (!(childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.has(_this.GRAPH_NODE))) {
            childrenMap === null || childrenMap === void 0 ? void 0 : childrenMap.set(_this.GRAPH_NODE, /* @__PURE__ */ new Map());
          }
          childrenMap === null || childrenMap === void 0 ? void 0 : (_childrenMap$get = childrenMap.get(_this.GRAPH_NODE)) === null || _childrenMap$get === void 0 ? void 0 : _childrenMap$get.set(node, true);
        }
        [inEdgesMap, outEdgesMap, predecessorsMap, successorsMap].forEach(function(map4) {
          return map4.set(node, /* @__PURE__ */ new Map());
        });
        _this.nodeCountNum += 1;
        return _this;
      };
      this.setNodes = function(nodes, value) {
        nodes.map(function(node) {
          return _this.setNode(node, value);
        });
        return _this;
      };
      this.hasNode = function(node) {
        return _this.nodesLabelMap.has(node);
      };
      this.checkCompound = function() {
        if (!_this.isCompound()) {
          throw new Error("Cannot construct parent-children relations in a non-compound graph");
        }
      };
      this.parent = function(node) {
        if (_this.isCompound()) {
          var _this$parentMap;
          var parent = (_this$parentMap = _this.parentMap) === null || _this$parentMap === void 0 ? void 0 : _this$parentMap.get(node);
          if (parent !== _this.GRAPH_NODE) {
            return parent;
          }
        }
      };
      this.removeFromParentsChildList = function(node) {
        var targetParent = _this.parentMap.get(node);
        _this.childrenMap.get(targetParent).delete(node);
      };
      this.setParent = function(node, parent) {
        var _this$parentMap2, _this$childrenMap;
        _this.checkCompound();
        var realParent = parent === void 0 ? _this.GRAPH_NODE : parent;
        var checkNode = _this.parent(realParent);
        while (checkNode) {
          if (node === checkNode) {
            throw new Error("Setting " + parent + " as parent of " + node + " would create a cycle");
          }
          checkNode = _this.parent(checkNode);
        }
        if (parent) {
          _this.setNode(parent);
        }
        _this.setNode(node);
        _this.removeFromParentsChildList(node);
        (_this$parentMap2 = _this.parentMap) === null || _this$parentMap2 === void 0 ? void 0 : _this$parentMap2.set(node, realParent);
        var realParentChilren = _this.childrenMap.get(realParent);
        realParentChilren.set(node, true);
        (_this$childrenMap = _this.childrenMap) === null || _this$childrenMap === void 0 ? void 0 : _this$childrenMap.set(realParent, realParentChilren);
        return _this;
      };
      this.children = function(node) {
        var targetNode = node === void 0 ? _this.GRAPH_NODE : node;
        if (_this.isCompound()) {
          var _this$childrenMap2;
          var target = (_this$childrenMap2 = _this.childrenMap) === null || _this$childrenMap2 === void 0 ? void 0 : _this$childrenMap2.get(targetNode);
          if (target) {
            return Array.from(target.keys());
          }
          return void 0;
        }
        if (targetNode === _this.GRAPH_NODE) {
          return _this.nodes();
        }
        if (node && _this.hasNode(node)) {
          return [];
        }
      };
      this.predecessors = function(node) {
        var preds = _this.predecessorsMap.get(node);
        return preds ? Array.from(preds.keys()) : void 0;
      };
      this.successors = function(node) {
        var succs = _this.successorsMap.get(node);
        return succs ? Array.from(succs.keys()) : void 0;
      };
      this.neighbors = function(node) {
        var _this$predecessors;
        if (!_this.hasNode(node)) {
          return void 0;
        }
        return Array.from(new Set((_this$predecessors = _this.predecessors(node)) === null || _this$predecessors === void 0 ? void 0 : _this$predecessors.concat(_this.successors(node))));
      };
      this.isLeaf = function(node) {
        var _this$neighbors;
        if (_this.isDirected()) {
          var _this$successors;
          return !((_this$successors = _this.successors(node)) === null || _this$successors === void 0 ? void 0 : _this$successors.length);
        }
        return !((_this$neighbors = _this.neighbors(node)) === null || _this$neighbors === void 0 ? void 0 : _this$neighbors.length);
      };
      this.filterNodes = function(filter2) {
        var directed = _this.directed, multigraph = _this.multigraph, compound = _this.compound;
        var copyGraph = new Graph3({
          directed,
          multigraph,
          compound
        });
        copyGraph.setGraph(_this.graph());
        _this.nodes().forEach(function(n2) {
          if (filter2(n2)) {
            copyGraph.setNode(n2, _this.node(n2));
          }
        });
        _this.edges().forEach(function(edgeObj) {
          if (copyGraph.hasNode(edgeObj.v) && copyGraph.hasNode(edgeObj.w)) {
            copyGraph.setEdgeObj(edgeObj, _this.edge(edgeObj));
          }
        });
        if (compound) {
          var findParent = function findParent2(node) {
            var parent = _this.parent(node);
            while (parent !== void 0 && !copyGraph.hasNode(parent)) {
              parent = _this.parent(parent);
            }
            return parent;
          };
          copyGraph.nodes().forEach(function(node) {
            copyGraph.setParent(node, findParent(node));
          });
        }
        return copyGraph;
      };
      this.removeNode = function(node) {
        if (_this.hasNode(node)) {
          var cleanEdge = function cleanEdge2(edgeObj) {
            _this.removeEdge(edgeObj.v, edgeObj.w, edgeObj.name);
          };
          var inEdgesMap = _this.inEdgesMap, outEdgesMap = _this.outEdgesMap, predecessorsMap = _this.predecessorsMap, successorsMap = _this.successorsMap, nodesLabelMap = _this.nodesLabelMap;
          if (_this.isCompound()) {
            var _this$parentMap3, _this$children, _this$childrenMap3;
            _this.removeFromParentsChildList(node);
            (_this$parentMap3 = _this.parentMap) === null || _this$parentMap3 === void 0 ? void 0 : _this$parentMap3.delete(node);
            (_this$children = _this.children(node)) === null || _this$children === void 0 ? void 0 : _this$children.forEach(function(n2) {
              return _this.setParent(n2);
            });
            (_this$childrenMap3 = _this.childrenMap) === null || _this$childrenMap3 === void 0 ? void 0 : _this$childrenMap3.delete(node);
          }
          var inE = inEdgesMap.get(node);
          var outE = outEdgesMap.get(node);
          Array.from(inE.values()).forEach(function(edge) {
            return cleanEdge(edge);
          });
          Array.from(outE.values()).forEach(function(edge) {
            return cleanEdge(edge);
          });
          nodesLabelMap.delete(node);
          inEdgesMap.delete(node);
          outEdgesMap.delete(node);
          predecessorsMap.delete(node);
          successorsMap.delete(node);
          _this.nodeCountNum -= 1;
        }
        return _this;
      };
      this.setDefaultEdgeLabel = function(newDefault) {
        if (isFunction(newDefault)) {
          _this.defaultEdgeLabelFn = newDefault;
        } else {
          _this.defaultEdgeLabelFn = function() {
            return newDefault;
          };
        }
        return _this;
      };
      this.edgeCount = function() {
        return _this.edgeCountNum;
      };
      this.setEdge = function(v_, w_, value, name) {
        var _this$inEdgesMap$get2, _this$outEdgesMap$get2;
        var edgeObj = edgeArgsToObj(_this.isDirected(), v_, w_, name);
        var edgeId = edgeObjToId(_this.isDirected(), edgeObj);
        var v2 = edgeObj.v, w2 = edgeObj.w;
        if (_this.edgesLabelsMap.has(edgeId)) {
          _this.edgesLabelsMap.set(edgeId, value);
          return _this;
        }
        if (name !== void 0 && !_this.isMultigraph()) {
          throw new Error("Cannot set a named edge when isMultigraph = false");
        }
        _this.setNode(v2);
        _this.setNode(w2);
        _this.edgesLabelsMap.set(edgeId, value || _this.defaultEdgeLabelFn(v2, w2, name));
        Object.freeze(edgeObj);
        _this.edgesMap.set(edgeId, edgeObj);
        var preds = _this.predecessorsMap.get(w2);
        var succs = _this.successorsMap.get(v2);
        incrementOrInitEntry(preds, v2);
        incrementOrInitEntry(succs, w2);
        (_this$inEdgesMap$get2 = _this.inEdgesMap.get(w2)) === null || _this$inEdgesMap$get2 === void 0 ? void 0 : _this$inEdgesMap$get2.set(edgeId, edgeObj);
        (_this$outEdgesMap$get2 = _this.outEdgesMap.get(v2)) === null || _this$outEdgesMap$get2 === void 0 ? void 0 : _this$outEdgesMap$get2.set(edgeId, edgeObj);
        _this.edgeCountNum += 1;
        return _this;
      };
      this.setEdgeObj = function(edgeObj, value) {
        return _this.setEdge(edgeObj.v, edgeObj.w, value, edgeObj.name);
      };
      this.setPath = function(edges, value) {
        edges.reduce(function(v2, w2) {
          _this.setEdge(v2, w2, value);
          return w2;
        });
        return _this;
      };
      this.edgeFromArgs = function(v2, w2, name) {
        return _this.edge({
          v: v2,
          w: w2,
          name
        });
      };
      this.edge = function(edgeObj) {
        return _this.edgesLabelsMap.get(edgeObjToId(_this.isDirected(), edgeObj));
      };
      this.hasEdge = function(v2, w2, name) {
        return _this.edgesLabelsMap.has(edgeObjToId(_this.isDirected(), {
          v: v2,
          w: w2,
          name
        }));
      };
      this.removeEdge = function(v_, w_, name) {
        var edgeId = edgeArgsToId(_this.isDirected(), v_, w_, name);
        var edgeObj = _this.edgesMap.get(edgeId);
        if (edgeObj) {
          var _edgeArgsToObj = edgeArgsToObj(_this.isDirected(), v_, w_, name), v2 = _edgeArgsToObj.v, w2 = _edgeArgsToObj.w;
          _this.edgesLabelsMap.delete(edgeId);
          _this.edgesMap.delete(edgeId);
          var preds = _this.predecessorsMap.get(w2);
          var succs = _this.successorsMap.get(v2);
          decrementOrRemoveEntry(preds, v2);
          decrementOrRemoveEntry(succs, w2);
          _this.inEdgesMap.get(w2).delete(edgeId);
          _this.outEdgesMap.get(v2).delete(edgeId);
          _this.edgeCountNum -= 1;
        }
        return _this;
      };
      this.removeEdgeObj = function(_ref2) {
        var v2 = _ref2.v, w2 = _ref2.w, name = _ref2.name;
        return _this.removeEdge(v2, w2, name);
      };
      this.edges = function() {
        return Array.from(_this.edgesMap.values());
      };
      this.inEdges = function(v2, u2) {
        var inV = _this.inEdgesMap.get(v2);
        if (inV) {
          return Array.from(inV.values()).filter(function(e8) {
            return !u2 || e8.v === u2;
          });
        }
        return void 0;
      };
      this.outEdges = function(w2, u2) {
        var outW = _this.outEdgesMap.get(w2);
        if (outW) {
          return Array.from(outW.values()).filter(function(e8) {
            return !u2 || e8.w === u2;
          });
        }
        return void 0;
      };
      this.nodeEdges = function(v2, w2) {
        var _this$inEdges;
        if (!_this.hasNode(v2)) {
          return void 0;
        }
        return (_this$inEdges = _this.inEdges(v2, w2)) === null || _this$inEdges === void 0 ? void 0 : _this$inEdges.concat(_this.outEdges(v2, w2));
      };
      this.toJSON = function() {
        return write(_this);
      };
      var resultOptions = _objectSpread(_objectSpread({}, defaultOption), options);
      this.compound = resultOptions.compound;
      this.directed = resultOptions.directed;
      this.multigraph = resultOptions.multigraph;
      if (this.compound) {
        this.parentMap = /* @__PURE__ */ new Map();
        this.childrenMap = /* @__PURE__ */ new Map();
      }
    });
    Graph2.fromJSON = read;
  }
});

// node_modules/@antv/graphlib/es/PriorityQueue/index.js
function _defineProperties2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var PriorityQueue;
var init_PriorityQueue = __esm({
  "node_modules/@antv/graphlib/es/PriorityQueue/index.js"() {
    PriorityQueue = _createClass3(function PriorityQueue2() {
      var _this = this;
      _classCallCheck3(this, PriorityQueue2);
      this.arr = [];
      this.keyIndice = /* @__PURE__ */ new Map();
      this.size = function() {
        return _this.arr.length;
      };
      this.keys = function() {
        return _this.arr.map(function(e8) {
          return e8.key;
        });
      };
      this.has = function(key) {
        return _this.keyIndice.has(key);
      };
      this.priority = function(key) {
        var index = _this.keyIndice.get(key);
        if (index !== void 0) {
          return _this.arr[index].priority;
        }
      };
      this.swap = function(i2, j2) {
        var arr = _this.arr, keyIndice = _this.keyIndice;
        var _ref2 = [arr[i2], arr[j2]], originI = _ref2[0], originJ = _ref2[1];
        arr[i2] = originJ;
        arr[j2] = originI;
        keyIndice.set(originI.key, j2);
        keyIndice.set(originJ.key, i2);
      };
      this.innerDecrease = function(index) {
        var arr = _this.arr;
        var priority = arr[index].priority;
        var parent;
        var i2 = index;
        while (i2 !== 0) {
          var _arr$parent;
          parent = i2 >> 1;
          if (((_arr$parent = arr[parent]) === null || _arr$parent === void 0 ? void 0 : _arr$parent.priority) < priority) {
            break;
          }
          _this.swap(i2, parent);
          i2 = parent;
        }
      };
      this.heapify = function(i2) {
        var arr = _this.arr;
        var l2 = i2 << 1;
        var r2 = l2 + 1;
        var largest = i2;
        if (l2 < arr.length) {
          largest = arr[l2].priority < arr[largest].priority ? l2 : largest;
          if (r2 < arr.length) {
            largest = arr[r2].priority < arr[largest].priority ? r2 : largest;
          }
          if (largest !== i2) {
            _this.swap(i2, largest);
            _this.heapify(largest);
          }
        }
      };
      this.min = function() {
        if (_this.size() === 0) {
          throw new Error("Queue underflow");
        }
        return _this.arr[0].key;
      };
      this.add = function(key, priority) {
        var keyIndice = _this.keyIndice, arr = _this.arr;
        if (!keyIndice.has(key)) {
          var index = arr.length;
          keyIndice.set(key, index);
          arr.push({
            key,
            priority
          });
          _this.innerDecrease(index);
          return true;
        }
        return false;
      };
      this.removeMin = function() {
        _this.swap(0, _this.arr.length - 1);
        var min6 = _this.arr.pop();
        _this.keyIndice.delete(min6.key);
        _this.heapify(0);
        return min6.key;
      };
      this.decrease = function(key, priority) {
        if (!_this.has(key)) {
          throw new Error("There's no key named ".concat(key));
        }
        var index = _this.keyIndice.get(key);
        if (priority > _this.arr[index].priority) {
          throw new Error("New priority is greater than current priority.Key: ".concat(key, " Old: + ").concat(_this.arr[index].priority, " New: ").concat(priority));
        }
        _this.arr[index].priority = priority;
        _this.innerDecrease(index);
      };
    });
  }
});

// node_modules/@antv/graphlib/es/algorithm/prim.js
var prim, prim_default;
var init_prim = __esm({
  "node_modules/@antv/graphlib/es/algorithm/prim.js"() {
    init_Graph();
    init_PriorityQueue();
    prim = function prim2(graph, weightFn) {
      var result = new Graph2();
      var parents = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      function updateNeighbors(edge) {
        var w2 = edge.v === v2 ? edge.w : edge.v;
        var pri = pq.priority(w2);
        if (pri !== void 0) {
          var edgeWeight = weightFn(edge);
          if (edgeWeight < pri) {
            parents.set(w2, v2);
            pq.decrease(w2, edgeWeight);
          }
        }
      }
      if (graph.nodeCount() === 0) {
        return result;
      }
      graph.nodes().forEach(function(node) {
        pq.add(node, Number.POSITIVE_INFINITY);
        result.setNode(node);
      });
      pq.decrease(graph.nodes()[0], 0);
      var init = false;
      while (pq.size() > 0) {
        var _graph$nodeEdges;
        v2 = pq.removeMin();
        if (parents.has(v2)) {
          result.setEdge(v2, parents.get(v2));
        } else if (init) {
          throw new Error("Input graph is not connected: " + graph.graph());
        } else {
          init = true;
        }
        (_graph$nodeEdges = graph.nodeEdges(v2)) === null || _graph$nodeEdges === void 0 ? void 0 : _graph$nodeEdges.forEach(updateNeighbors);
      }
      return result;
    };
    prim_default = prim;
  }
});

// node_modules/@antv/graphlib/es/algorithm/components.js
var components, components_default;
var init_components = __esm({
  "node_modules/@antv/graphlib/es/algorithm/components.js"() {
    components = function components2(graph) {
      var visited = /* @__PURE__ */ new Set();
      var resultComponents = [];
      var nodes = graph.nodes();
      nodes.forEach(function(n2) {
        var componentsArr = [];
        var waitingList = [n2];
        while (waitingList.length > 0) {
          var node = waitingList.pop();
          if (!visited.has(node)) {
            var _graph$successors, _graph$predecessors;
            visited.add(node);
            componentsArr.push(node);
            (_graph$successors = graph.successors(node)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(n3) {
              return waitingList.push(n3);
            });
            (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(function(n3) {
              return waitingList.push(n3);
            });
          }
        }
        if (componentsArr.length) {
          resultComponents.push(componentsArr);
        }
      });
      return resultComponents;
    };
    components_default = components;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dfs.js
var doDFS, dfs, dfs_default;
var init_dfs = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dfs.js"() {
    doDFS = function doDFS2(graph, node, postorder3, visited, navigator2, result) {
      if (!visited.includes(node)) {
        visited.push(node);
        if (!postorder3) {
          result.push(node);
        }
        navigator2(node).forEach(function(n2) {
          return doDFS2(graph, n2, postorder3, visited, navigator2, result);
        });
        if (postorder3) {
          result.push(node);
        }
      }
    };
    dfs = function dfs2(graph, node, order) {
      var nodes = Array.isArray(node) ? node : [node];
      var navigator2 = function navigator3(n2) {
        return graph.isDirected() ? graph.successors(n2) : graph.neighbors(n2);
      };
      var results = [];
      var visited = [];
      nodes.forEach(function(node2) {
        if (!graph.hasNode(node2)) {
          throw new Error("Graph does not have node: " + node2);
        } else {
          doDFS(graph, node2, order === "post", visited, navigator2, results);
        }
      });
      return results;
    };
    dfs_default = dfs;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra.js
function _slicedToArray2(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i2) {
  var _i2 = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i2 == null)
    return;
  var _arr = [];
  var _n2 = true;
  var _d = false;
  var _s, _e2;
  try {
    for (_i2 = _i2.call(arr); !(_n2 = (_s = _i2.next()).done); _n2 = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n2 && _i2["return"] != null)
        _i2["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var DEFAULT_WEIGHT_FUNC, dijkstra3, runDijkstra, dijkstra_default2;
var init_dijkstra = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra.js"() {
    init_PriorityQueue();
    DEFAULT_WEIGHT_FUNC = function DEFAULT_WEIGHT_FUNC2() {
      return 1;
    };
    dijkstra3 = function dijkstra4(graph, source, weightFn, edgeFn) {
      return runDijkstra(graph, source, weightFn || DEFAULT_WEIGHT_FUNC, edgeFn || function(v2) {
        return graph.outEdges(v2);
      });
    };
    runDijkstra = function runDijkstra2(graph, source, weightFn, edgeFn) {
      var results = /* @__PURE__ */ new Map();
      var pq = new PriorityQueue();
      var v2;
      var vEntry;
      var updateNeighbors = function updateNeighbors2(edge) {
        var w2 = edge.v !== v2 ? edge.v : edge.w;
        var wEntry = results.get(w2);
        var weight = weightFn(edge);
        var distance11 = vEntry.distance + weight;
        if (weight < 0) {
          throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
        }
        if (distance11 < wEntry.distance) {
          wEntry.distance = distance11;
          wEntry.predecessor = v2;
          pq.decrease(w2, distance11);
        }
      };
      graph.nodes().forEach(function(v3) {
        var distance11 = v3 === source ? 0 : Number.POSITIVE_INFINITY;
        results.set(v3, {
          distance: distance11
        });
        pq.add(v3, distance11);
      });
      while (pq.size() > 0) {
        v2 = pq.removeMin();
        vEntry = results.get(v2);
        if (vEntry && vEntry.distance === Number.POSITIVE_INFINITY) {
          break;
        }
        edgeFn(v2).forEach(updateNeighbors);
      }
      var obj = {};
      Array.from(results.entries()).forEach(function(_ref2) {
        var _ref22 = _slicedToArray2(_ref2, 2), node = _ref22[0], e8 = _ref22[1];
        obj[String(node)] = e8;
        return obj;
      });
      return obj;
    };
    dijkstra_default2 = dijkstra3;
  }
});

// node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js
var dijkstraAll, dijkstra_all_default;
var init_dijkstra_all = __esm({
  "node_modules/@antv/graphlib/es/algorithm/dijkstra-all.js"() {
    init_dijkstra();
    dijkstraAll = function dijkstraAll2(graph, weightFn, edgeFn) {
      var map4 = {};
      graph.nodes().forEach(function(node) {
        map4[String(node)] = dijkstra_default2(graph, node, weightFn, edgeFn);
        return map4;
      });
      return map4;
    };
    dijkstra_all_default = dijkstraAll;
  }
});

// node_modules/@antv/graphlib/es/algorithm/tarjan.js
var tarjan, tarjan_default;
var init_tarjan = __esm({
  "node_modules/@antv/graphlib/es/algorithm/tarjan.js"() {
    tarjan = function tarjan2(graph) {
      var index = 0;
      var stack = [];
      var visited = /* @__PURE__ */ new Map();
      var results = [];
      function dfs3(v2) {
        var _graph$successors;
        var entry = {
          onStack: true,
          lowlink: index,
          index
        };
        visited.set(v2, entry);
        index += 1;
        stack.push(v2);
        (_graph$successors = graph.successors(v2)) === null || _graph$successors === void 0 ? void 0 : _graph$successors.forEach(function(w3) {
          var _visited$get;
          if (!visited.has(w3)) {
            dfs3(w3);
            var wEntry2 = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, wEntry2.lowlink);
          } else if ((_visited$get = visited.get(w3)) === null || _visited$get === void 0 ? void 0 : _visited$get.onStack) {
            var _wEntry = visited.get(w3);
            entry.lowlink = Math.min(entry.lowlink, _wEntry.index);
          }
        });
        if (entry.lowlink === entry.index) {
          var cmpt = [];
          var w2;
          do {
            w2 = stack.pop();
            var wEntry = visited.get(w2);
            wEntry.onStack = false;
            cmpt.push(w2);
          } while (v2 !== w2);
          results.push(cmpt);
        }
      }
      graph.nodes().forEach(function(v2) {
        if (!visited.has(v2)) {
          dfs3(v2);
        }
      });
      return results;
    };
    tarjan_default = tarjan;
  }
});

// node_modules/@antv/graphlib/es/algorithm/find-cycles.js
var findCycles, find_cycles_default;
var init_find_cycles = __esm({
  "node_modules/@antv/graphlib/es/algorithm/find-cycles.js"() {
    init_tarjan();
    findCycles = function findCycles2(graph) {
      return tarjan_default(graph).filter(function(cmpt) {
        return cmpt.length > 1 || cmpt.length === 1 && graph.hasEdge(cmpt[0], cmpt[0]);
      });
    };
    find_cycles_default = findCycles;
  }
});

// node_modules/@antv/graphlib/es/algorithm/topsort.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  return _typeof4 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof4(obj);
}
function _defineProperties3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function topsort(graph) {
  var visited = /* @__PURE__ */ new Set();
  var stack = /* @__PURE__ */ new Set();
  var results = [];
  function visit(node) {
    if (stack.has(node)) {
      throw new CycleException();
    }
    if (!visited.has(node)) {
      var _graph$predecessors;
      stack.add(node);
      visited.add(node);
      (_graph$predecessors = graph.predecessors(node)) === null || _graph$predecessors === void 0 ? void 0 : _graph$predecessors.forEach(visit);
      stack.delete(node);
      results.push(node);
    }
  }
  graph.sinks().forEach(visit);
  if (visited.size !== graph.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
var CycleException, topsort_default;
var init_topsort = __esm({
  "node_modules/@antv/graphlib/es/algorithm/topsort.js"() {
    CycleException = function(_Error) {
      _inherits(CycleException2, _Error);
      var _super = _createSuper(CycleException2);
      function CycleException2() {
        _classCallCheck4(this, CycleException2);
        return _super.apply(this, arguments);
      }
      return _createClass4(CycleException2);
    }(_wrapNativeSuper(Error));
    topsort_default = topsort;
  }
});

// node_modules/@antv/graphlib/es/algorithm/is-acyclic.js
var isAcyclic, is_acyclic_default;
var init_is_acyclic = __esm({
  "node_modules/@antv/graphlib/es/algorithm/is-acyclic.js"() {
    init_topsort();
    isAcyclic = function isAcyclic2(graph) {
      try {
        topsort_default(graph);
      } catch (e8) {
        if (e8 instanceof CycleException) {
          return false;
        }
        throw e8;
      }
      return true;
    };
    is_acyclic_default = isAcyclic;
  }
});

// node_modules/@antv/graphlib/es/algorithm/postorder.js
var postorder, postorder_default;
var init_postorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/postorder.js"() {
    init_dfs();
    postorder = function postorder2(graph, nodes) {
      return dfs_default(graph, nodes, "post");
    };
    postorder_default = postorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/preorder.js
var preorder, preorder_default;
var init_preorder = __esm({
  "node_modules/@antv/graphlib/es/algorithm/preorder.js"() {
    init_dfs();
    preorder = function preorder2(graph, nodes) {
      return dfs_default(graph, nodes, "pre");
    };
    preorder_default = preorder;
  }
});

// node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js
function floydWarshall5(graph, weightFn, edgeFn) {
  return runFloydWarshall(graph, weightFn || DEFAULT_WEIGHT_FUNC3, edgeFn || function(v2) {
    return graph.outEdges(v2);
  });
}
function runFloydWarshall(graph, weightFn, edgeFn) {
  var results = {};
  var nodes = graph.nodes();
  nodes.forEach(function(node) {
    var v2 = String(node);
    results[v2] = {};
    results[v2][v2] = {
      distance: 0
    };
    nodes.forEach(function(w2) {
      if (node !== w2) {
        results[v2][String(w2)] = {
          distance: Number.POSITIVE_INFINITY
        };
      }
    });
    edgeFn(node).forEach(function(edge) {
      var w2 = edge.v === node ? edge.w : edge.v;
      var d2 = weightFn(edge);
      results[v2][String(w2)] = {
        distance: d2,
        predecessor: node
      };
    });
  });
  nodes.forEach(function(nodek) {
    var k2 = String(nodek);
    var rowK = results[k2];
    nodes.forEach(function(nodei) {
      var i2 = String(nodei);
      var rowI = results[i2];
      nodes.forEach(function(nodej) {
        var j2 = String(nodej);
        var ik = rowI[k2];
        var kj = rowK[j2];
        var ij = rowI[j2];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
var DEFAULT_WEIGHT_FUNC3, floyd_warshall_default;
var init_floyd_warshall = __esm({
  "node_modules/@antv/graphlib/es/algorithm/floyd-warshall.js"() {
    DEFAULT_WEIGHT_FUNC3 = function DEFAULT_WEIGHT_FUNC4() {
      return 1;
    };
    floyd_warshall_default = floydWarshall5;
  }
});

// node_modules/@antv/graphlib/es/algorithm/index.js
var algorithm_exports = {};
__export(algorithm_exports, {
  components: () => components_default,
  dfs: () => dfs_default,
  dijkstra: () => dijkstra_default2,
  dijkstraAll: () => dijkstra_all_default,
  findCycles: () => find_cycles_default,
  floydWarshall: () => floyd_warshall_default,
  isAcyclic: () => is_acyclic_default,
  postorder: () => postorder_default,
  preorder: () => preorder_default,
  prim: () => prim_default,
  tarjan: () => tarjan_default,
  topsort: () => topsort_default
});
var init_algorithm = __esm({
  "node_modules/@antv/graphlib/es/algorithm/index.js"() {
    init_prim();
    init_components();
    init_dfs();
    init_dijkstra();
    init_dijkstra_all();
    init_find_cycles();
    init_is_acyclic();
    init_postorder();
    init_preorder();
    init_tarjan();
    init_topsort();
    init_floyd_warshall();
  }
});

// node_modules/@antv/graphlib/es/index.js
var es_exports2 = {};
__export(es_exports2, {
  Graph: () => Graph2,
  algorithm: () => algorithm_exports
});
var init_es = __esm({
  "node_modules/@antv/graphlib/es/index.js"() {
    init_Graph();
    init_algorithm();
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js
var require_greedy_fas = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/greedy-fas.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var list_1 = __importDefault(require_list());
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var List = function(_super) {
      __extends19(List2, _super);
      function List2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return List2;
    }(list_1.default);
    var StateGraph = function(_super) {
      __extends19(StateGraph2, _super);
      function StateGraph2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return StateGraph2;
    }(graphlib_1.Graph);
    var DEFAULT_WEIGHT_FN = function() {
      return 1;
    };
    var greedyFAS = function(g2, weightFn) {
      var _a2;
      if (g2.nodeCount() <= 1)
        return [];
      var state = buildState(g2, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return (_a2 = results.map(function(e8) {
        return g2.outEdges(e8.v, e8.w);
      })) === null || _a2 === void 0 ? void 0 : _a2.flat();
    };
    var doGreedyFAS = function(g2, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g2.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g2, buckets, zeroIdx, entry);
        }
        if (g2.nodeCount()) {
          for (var i2 = buckets.length - 2; i2 > 0; --i2) {
            entry = buckets[i2].dequeue();
            if (entry) {
              results = results.concat(removeNode(g2, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    };
    var removeNode = function(g2, buckets, zeroIdx, entry, collectPredecessors) {
      var _a2, _b;
      var results = [];
      (_a2 = g2.inEdges(entry.v)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(edge) {
        var weight = g2.edge(edge);
        var uEntry = g2.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w, in: 0, out: 0 });
        }
        if (uEntry.out === void 0)
          uEntry.out = 0;
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      (_b = g2.outEdges(entry.v)) === null || _b === void 0 ? void 0 : _b.forEach(function(edge) {
        var weight = g2.edge(edge);
        var w2 = edge.w;
        var wEntry = g2.node(w2);
        if (wEntry.in === void 0)
          wEntry.in = 0;
        wEntry.in -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g2.removeNode(entry.v);
      return collectPredecessors ? results : void 0;
    };
    var buildState = function(g2, weightFn) {
      var fasGraph = new StateGraph();
      var maxIn = 0;
      var maxOut = 0;
      g2.nodes().forEach(function(v2) {
        fasGraph.setNode(v2, { v: v2, in: 0, out: 0 });
      });
      g2.edges().forEach(function(e8) {
        var prevWeight = fasGraph.edge(e8) || 0;
        var weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e8)) || 1;
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e8.v, e8.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e8.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e8.w).in += weight);
      });
      var buckets = [];
      var rangeMax = maxOut + maxIn + 3;
      for (var i2 = 0; i2 < rangeMax; i2++) {
        buckets.push(new List());
      }
      var zeroIdx = maxIn + 1;
      fasGraph.nodes().forEach(function(v2) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v2));
      });
      return { buckets, zeroIdx, graph: fasGraph };
    };
    var assignBucket = function(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    };
    exports.default = greedyFAS;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js
var require_acyclic = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/acyclic.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var greedy_fas_1 = __importDefault(require_greedy_fas());
    var run = function(g2) {
      var weightFn = function(g3) {
        return function(e8) {
          var _a2;
          return ((_a2 = g3.edge(e8)) === null || _a2 === void 0 ? void 0 : _a2.weight) || 1;
        };
      };
      var fas = g2.graph().acyclicer === "greedy" ? (0, greedy_fas_1.default)(g2, weightFn(g2)) : dfsFAS(g2);
      fas === null || fas === void 0 ? void 0 : fas.forEach(function(e8) {
        var label = g2.edge(e8);
        g2.removeEdgeObj(e8);
        label.forwardName = e8.name;
        label.reversed = true;
        g2.setEdge(e8.w, e8.v, label, "rev-".concat(Math.random()));
      });
    };
    var dfsFAS = function(g2) {
      var fas = [];
      var stack = {};
      var visited = {};
      var dfs3 = function(v2) {
        var _a2;
        if (visited[v2]) {
          return;
        }
        visited[v2] = true;
        stack[v2] = true;
        (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          if (stack[e8.w]) {
            fas.push(e8);
          } else {
            dfs3(e8.w);
          }
        });
        delete stack[v2];
      };
      g2.nodes().forEach(dfs3);
      return fas;
    };
    var undo = function(g2) {
      g2.edges().forEach(function(e8) {
        var label = g2.edge(e8);
        if (label.reversed) {
          g2.removeEdgeObj(e8);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g2.setEdge(e8.w, e8.v, label, forwardName);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/graph.js
var require_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/graph.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Graph = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var Graph5 = function(_super) {
      __extends19(Graph6, _super);
      function Graph6() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return Graph6;
    }(graphlib_1.Graph);
    exports.Graph = Graph5;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/util.js
var require_util3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.minBy = exports.notime = exports.time = exports.partition = exports.maxRank = exports.addBorderNode = exports.removeEmptyRanks = exports.normalizeRanks = exports.buildLayerMatrix = exports.intersectRect = exports.predecessorWeights = exports.successorWeights = exports.zipObject = exports.asNonCompoundGraph = exports.simplify = exports.addDummyNode = void 0;
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var safeSort = function(valueA, valueB) {
      return Number(valueA) - Number(valueB);
    };
    var addDummyNode = function(g2, type, attrs, name) {
      var v2;
      do {
        v2 = "".concat(name).concat(Math.random());
      } while (g2.hasNode(v2));
      attrs.dummy = type;
      g2.setNode(v2, attrs);
      return v2;
    };
    exports.addDummyNode = addDummyNode;
    var simplify = function(g2) {
      var simplified = new graph_1.Graph().setGraph(g2.graph());
      g2.nodes().forEach(function(v2) {
        simplified.setNode(v2, g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var simpleLabel = simplified.edgeFromArgs(e8.v, e8.w) || { weight: 0, minlen: 1 };
        var label = g2.edge(e8);
        simplified.setEdge(e8.v, e8.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    };
    exports.simplify = simplify;
    var asNonCompoundGraph = function(g2) {
      var simplified = new graph_1.Graph({ multigraph: g2.isMultigraph() }).setGraph(g2.graph());
      g2.nodes().forEach(function(node) {
        var _a2;
        if (!((_a2 = g2.children(node)) === null || _a2 === void 0 ? void 0 : _a2.length)) {
          simplified.setNode(node, g2.node(node));
        }
      });
      g2.edges().forEach(function(edge) {
        simplified.setEdgeObj(edge, g2.edge(edge));
      });
      return simplified;
    };
    exports.asNonCompoundGraph = asNonCompoundGraph;
    var zipObject = function(keys2, values2) {
      return keys2 === null || keys2 === void 0 ? void 0 : keys2.reduce(function(obj, key, i2) {
        obj[key] = values2[i2];
        return obj;
      }, {});
    };
    exports.zipObject = zipObject;
    var successorWeights = function(g2) {
      var weightsMap = {};
      g2.nodes().forEach(function(node) {
        var _a2;
        var sucs = {};
        (_a2 = g2.outEdges(node)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var _a3;
          sucs[e8.w] = (sucs[e8.w] || 0) + (((_a3 = g2.edge(e8)) === null || _a3 === void 0 ? void 0 : _a3.weight) || 0);
        });
        weightsMap[node] = sucs;
      });
      return weightsMap;
    };
    exports.successorWeights = successorWeights;
    var predecessorWeights = function(g2) {
      var nodes = g2.nodes();
      var weightMap = nodes.map(function(v2) {
        var _a2;
        var preds = {};
        (_a2 = g2.inEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          preds[e8.v] = (preds[e8.v] || 0) + g2.edge(e8).weight;
        });
        return preds;
      });
      return (0, exports.zipObject)(nodes, weightMap);
    };
    exports.predecessorWeights = predecessorWeights;
    var intersectRect2 = function(rect2, point) {
      var x2 = Number(rect2.x);
      var y2 = Number(rect2.y);
      var dx = Number(point.x) - x2;
      var dy = Number(point.y) - y2;
      var w2 = Number(rect2.width) / 2;
      var h2 = Number(rect2.height) / 2;
      if (!dx && !dy) {
        return { x: 0, y: 0 };
      }
      var sx;
      var sy;
      if (Math.abs(dy) * w2 > Math.abs(dx) * h2) {
        if (dy < 0) {
          h2 = -h2;
        }
        sx = h2 * dx / dy;
        sy = h2;
      } else {
        if (dx < 0) {
          w2 = -w2;
        }
        sx = w2;
        sy = w2 * dy / dx;
      }
      return { x: x2 + sx, y: y2 + sy };
    };
    exports.intersectRect = intersectRect2;
    var buildLayerMatrix = function(g2) {
      var layeringNodes = [];
      var rankMax = (0, exports.maxRank)(g2) + 1;
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes.push([]);
      }
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        var rank = node.rank;
        if (rank !== void 0 && layeringNodes[rank]) {
          layeringNodes[rank].push(v2);
        }
      });
      for (var i2 = 0; i2 < rankMax; i2++) {
        layeringNodes[i2] = layeringNodes[i2].sort(function(va2, vb) {
          var _a2, _b;
          return safeSort((_a2 = g2.node(va2)) === null || _a2 === void 0 ? void 0 : _a2.order, (_b = g2.node(vb)) === null || _b === void 0 ? void 0 : _b.order);
        });
      }
      return layeringNodes;
    };
    exports.buildLayerMatrix = buildLayerMatrix;
    var normalizeRanks = function(g2) {
      var nodeRanks = g2.nodes().filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var min6 = Math.min.apply(Math, nodeRanks);
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.hasOwnProperty("rank") && min6 !== Infinity) {
          node.rank -= min6;
        }
      });
    };
    exports.normalizeRanks = normalizeRanks;
    var removeEmptyRanks = function(g2) {
      var nodes = g2.nodes();
      var nodeRanks = nodes.filter(function(v2) {
        var _a2;
        return ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) !== void 0;
      }).map(function(v2) {
        return g2.node(v2).rank;
      });
      var offset = Math.min.apply(Math, nodeRanks);
      var layers = [];
      nodes.forEach(function(v2) {
        var _a2;
        var rank = (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank) || 0) - offset;
        if (!layers[rank]) {
          layers[rank] = [];
        }
        layers[rank].push(v2);
      });
      var delta = 0;
      var nodeRankFactor = g2.graph().nodeRankFactor || 0;
      for (var i2 = 0; i2 < layers.length; i2++) {
        var vs = layers[i2];
        if (vs === void 0) {
          if (i2 % nodeRankFactor !== 0) {
            delta -= 1;
          }
        } else if (delta) {
          vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
            var node = g2.node(v2);
            if (node) {
              node.rank = node.rank || 0;
              node.rank += delta;
            }
          });
        }
      }
    };
    exports.removeEmptyRanks = removeEmptyRanks;
    var addBorderNode = function(g2, prefix, rank, order) {
      var node = {
        width: 0,
        height: 0
      };
      if ((0, util_1.isNumber)(rank) && (0, util_1.isNumber)(order)) {
        node.rank = rank;
        node.order = order;
      }
      return (0, exports.addDummyNode)(g2, "border", node, prefix);
    };
    exports.addBorderNode = addBorderNode;
    var maxRank = function(g2) {
      var maxRank2;
      g2.nodes().forEach(function(v2) {
        var _a2;
        var rank = (_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.rank;
        if (rank !== void 0) {
          if (maxRank2 === void 0 || rank > maxRank2) {
            maxRank2 = rank;
          }
        }
      });
      if (!maxRank2) {
        maxRank2 = 0;
      }
      return maxRank2;
    };
    exports.maxRank = maxRank;
    var partition = function(collection, fn2) {
      var result = { lhs: [], rhs: [] };
      collection === null || collection === void 0 ? void 0 : collection.forEach(function(value) {
        if (fn2(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    };
    exports.partition = partition;
    var time = function(name, fn2) {
      var start = Date.now();
      try {
        return fn2();
      } finally {
        console.log("".concat(name, " time: ").concat(Date.now() - start, "ms"));
      }
    };
    exports.time = time;
    var notime = function(name, fn2) {
      return fn2();
    };
    exports.notime = notime;
    var minBy = function(array, func) {
      return array.reduce(function(a2, b10) {
        var valA = func(a2);
        var valB = func(b10);
        return valA > valB ? b10 : a2;
      });
    };
    exports.minBy = minBy;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/normalize.js
var require_normalize = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/normalize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      g2.graph().dummyChains = [];
      g2.edges().forEach(function(edge) {
        return normalizeEdge(g2, edge);
      });
    };
    var normalizeEdge = function(g2, e8) {
      var v2 = e8.v;
      var vRank = g2.node(v2).rank;
      var w2 = e8.w;
      var wRank = g2.node(w2).rank;
      var name = e8.name;
      var edgeLabel = g2.edge(e8);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g2.removeEdgeObj(e8);
      var graph = g2.graph();
      var dummy;
      var attrs;
      var i2;
      for (i2 = 0, ++vRank; vRank < wRank; ++i2, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          edgeLabel,
          width: 0,
          height: 0,
          edgeObj: e8,
          rank: vRank
        };
        dummy = (0, util_1.addDummyNode)(g2, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g2.setEdge(v2, dummy, { weight: edgeLabel.weight }, name);
        if (i2 === 0) {
          if (!graph.dummyChains)
            graph.dummyChains = [];
          graph.dummyChains.push(dummy);
        }
        v2 = dummy;
      }
      g2.setEdge(v2, w2, { weight: edgeLabel.weight }, name);
    };
    var undo = function(g2) {
      var _a2;
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        var node = g2.node(v2);
        var origLabel = node.edgeLabel;
        var w2;
        if (node.edgeObj) {
          g2.setEdgeObj(node.edgeObj, origLabel);
        }
        var currentV = v2;
        while (node.dummy) {
          w2 = g2.successors(currentV)[0];
          g2.removeNode(currentV);
          origLabel.points.push({ x: node.x, y: node.y });
          if (node.dummy === "edge-label") {
            origLabel.x = node.x;
            origLabel.y = node.y;
            origLabel.width = node.width;
            origLabel.height = node.height;
          }
          currentV = w2;
          node = g2.node(currentV);
        }
      });
    };
    exports.default = { run, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js
var require_util4 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.slack = exports.longestPathWithLayer = exports.longestPath = void 0;
    var longestPath = function(g2) {
      var _a2;
      var visited = {};
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        return dfs3(source);
      });
    };
    exports.longestPath = longestPath;
    var longestPathWithLayer = function(g2) {
      var _a2;
      var visited = {};
      var minRank;
      var dfs3 = function(v2) {
        var _a3;
        var label = g2.node(v2);
        if (visited[v2]) {
          return label.rank;
        }
        visited[v2] = true;
        var rank;
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(edgeObj) {
          var wRank = dfs3(edgeObj.w);
          var minLen = g2.edge(edgeObj).minlen;
          var r2 = wRank - minLen;
          if (r2) {
            if (rank === void 0 || r2 < rank) {
              rank = r2;
            }
          }
        });
        if (!rank) {
          rank = 0;
        }
        if (minRank === void 0 || rank < minRank) {
          minRank = rank;
        }
        label.rank = rank;
        return rank;
      };
      (_a2 = g2.sources()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(source) {
        return dfs3(source);
      });
      if (minRank === void 0) {
        minRank = 0;
      }
      var dfsForward = function(v2, nextRank) {
        var _a3;
        var label = g2.node(v2);
        var currRank = !isNaN(label.layer) ? label.layer : nextRank;
        if (label.rank === void 0 || label.rank < currRank) {
          label.rank = currRank;
        }
        (_a3 = g2.outEdges(v2)) === null || _a3 === void 0 ? void 0 : _a3.map(function(e8) {
          dfsForward(e8.w, currRank + g2.edge(e8).minlen);
        });
      };
      g2.nodes().forEach(function(n2) {
        var label = g2.node(n2);
        if (!isNaN(label.layer)) {
          dfsForward(n2, label.layer);
        } else {
          label.rank -= minRank;
        }
      });
    };
    exports.longestPathWithLayer = longestPathWithLayer;
    var slack = function(g2, e8) {
      return g2.node(e8.w).rank - g2.node(e8.v).rank - g2.edge(e8).minlen;
    };
    exports.slack = slack;
    exports.default = {
      longestPath,
      longestPathWithLayer,
      slack
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js
var require_feasible_tree = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/feasible-tree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.feasibleTreeWithLayer = exports.feasibleTree = void 0;
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graph_1 = require_graph();
    var feasibleTree = function(g2) {
      var t4 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size2 = g2.nodeCount();
      t4.setNode(start, {});
      var edge;
      var delta;
      while (tightTree(t4, g2) < size2) {
        edge = findMinSlackEdge(t4, g2);
        delta = t4.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t4, g2, delta);
      }
      return t4;
    };
    exports.feasibleTree = feasibleTree;
    var tightTree = function(t4, g2) {
      var dfs3 = function(v2) {
        g2.nodeEdges(v2).forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t4.hasNode(w2) && !(0, util_1.slack)(g2, e8)) {
            t4.setNode(w2, {});
            t4.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t4.nodes().forEach(dfs3);
      return t4.nodeCount();
    };
    var feasibleTreeWithLayer = function(g2) {
      var t4 = new graph_1.Graph({ directed: false });
      var start = g2.nodes()[0];
      var size2 = g2.nodeCount();
      t4.setNode(start, {});
      var edge;
      var delta;
      while (tightTreeWithLayer(t4, g2) < size2) {
        edge = findMinSlackEdge(t4, g2);
        delta = t4.hasNode(edge.v) ? (0, util_1.slack)(g2, edge) : -(0, util_1.slack)(g2, edge);
        shiftRanks(t4, g2, delta);
      }
      return t4;
    };
    exports.feasibleTreeWithLayer = feasibleTreeWithLayer;
    var tightTreeWithLayer = function(t4, g2) {
      var dfs3 = function(v2) {
        var _a2;
        (_a2 = g2.nodeEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          var edgeV = e8.v;
          var w2 = v2 === edgeV ? e8.w : edgeV;
          if (!t4.hasNode(w2) && (g2.node(w2).layer !== void 0 || !(0, util_1.slack)(g2, e8))) {
            t4.setNode(w2, {});
            t4.setEdge(v2, w2, {});
            dfs3(w2);
          }
        });
      };
      t4.nodes().forEach(dfs3);
      return t4.nodeCount();
    };
    var findMinSlackEdge = function(t4, g2) {
      return (0, util_2.minBy)(g2.edges(), function(e8) {
        if (t4.hasNode(e8.v) !== t4.hasNode(e8.w)) {
          return (0, util_1.slack)(g2, e8);
        }
        return Infinity;
      });
    };
    var shiftRanks = function(t4, g2, delta) {
      t4.nodes().forEach(function(v2) {
        if (!g2.node(v2).rank)
          g2.node(v2).rank = 0;
        g2.node(v2).rank += delta;
      });
    };
    exports.default = {
      feasibleTree,
      feasibleTreeWithLayer
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js
var require_network_simplex = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/network-simplex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.exchangeEdges = exports.enterEdge = exports.leaveEdge = exports.initLowLimValues = exports.calcCutValue = exports.initCutValues = void 0;
    var feasible_tree_1 = require_feasible_tree();
    var util_1 = require_util4();
    var util_2 = require_util3();
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var preorder3 = graphlib_1.algorithm.preorder;
    var postorder3 = graphlib_1.algorithm.postorder;
    var networkSimplex = function(og) {
      var g2 = (0, util_2.simplify)(og);
      (0, util_1.longestPath)(g2);
      var t4 = (0, feasible_tree_1.feasibleTree)(g2);
      (0, exports.initLowLimValues)(t4);
      (0, exports.initCutValues)(t4, g2);
      var e8;
      var f2;
      while (e8 = (0, exports.leaveEdge)(t4)) {
        f2 = (0, exports.enterEdge)(t4, g2, e8);
        (0, exports.exchangeEdges)(t4, g2, e8, f2);
      }
    };
    var initCutValues = function(t4, g2) {
      var vs = postorder3(t4, t4.nodes());
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        assignCutValue(t4, g2, v2);
      });
    };
    exports.initCutValues = initCutValues;
    var assignCutValue = function(t4, g2, child) {
      var childLab = t4.node(child);
      var parent = childLab.parent;
      t4.edgeFromArgs(child, parent).cutvalue = (0, exports.calcCutValue)(t4, g2, child);
    };
    var calcCutValue = function(t4, g2, child) {
      var _a2;
      var childLab = t4.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g2.edgeFromArgs(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g2.edgeFromArgs(parent, child);
      }
      cutValue = graphEdge.weight;
      (_a2 = g2.nodeEdges(child)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var isOutEdge = e8.v === child;
        var other = isOutEdge ? e8.w : e8.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail;
          var otherWeight = g2.edge(e8).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t4, child, other)) {
            var otherCutValue = t4.edgeFromArgs(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    };
    exports.calcCutValue = calcCutValue;
    var initLowLimValues = function(tree, root) {
      if (root === void 0) {
        root = tree.nodes()[0];
      }
      dfsAssignLowLim(tree, {}, 1, root);
    };
    exports.initLowLimValues = initLowLimValues;
    var dfsAssignLowLim = function(tree, visited, nextLim, v2, parent) {
      var _a2;
      var low = nextLim;
      var useNextLim = nextLim;
      var label = tree.node(v2);
      visited[v2] = true;
      (_a2 = tree.neighbors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(w2) {
        if (!visited[w2]) {
          useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w2, v2);
        }
      });
      label.low = low;
      label.lim = useNextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return useNextLim;
    };
    var leaveEdge = function(tree) {
      return tree.edges().find(function(e8) {
        return tree.edge(e8).cutvalue < 0;
      });
    };
    exports.leaveEdge = leaveEdge;
    var enterEdge = function(t4, g2, edge) {
      var v2 = edge.v;
      var w2 = edge.w;
      if (!g2.hasEdge(v2, w2)) {
        v2 = edge.w;
        w2 = edge.v;
      }
      var vLabel = t4.node(v2);
      var wLabel = t4.node(w2);
      var tailLabel = vLabel;
      var flip = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
      }
      var candidates = g2.edges().filter(function(edge2) {
        return flip === isDescendant(t4, t4.node(edge2.v), tailLabel) && flip !== isDescendant(t4, t4.node(edge2.w), tailLabel);
      });
      return (0, util_2.minBy)(candidates, function(edge2) {
        return (0, util_1.slack)(g2, edge2);
      });
    };
    exports.enterEdge = enterEdge;
    var exchangeEdges = function(t4, g2, e8, f2) {
      var v2 = e8.v;
      var w2 = e8.w;
      t4.removeEdge(v2, w2);
      t4.setEdge(f2.v, f2.w, {});
      (0, exports.initLowLimValues)(t4);
      (0, exports.initCutValues)(t4, g2);
      updateRanks(t4, g2);
    };
    exports.exchangeEdges = exchangeEdges;
    var updateRanks = function(t4, g2) {
      var root = t4.nodes().find(function(v2) {
        var _a2;
        return !((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.parent);
      });
      var vs = preorder3(t4, root);
      vs = vs === null || vs === void 0 ? void 0 : vs.slice(1);
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var parent = t4.node(v2).parent;
        var edge = g2.edgeFromArgs(v2, parent);
        var flipped = false;
        if (!edge) {
          edge = g2.edgeFromArgs(parent, v2);
          flipped = true;
        }
        g2.node(v2).rank = g2.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    };
    var isTreeEdge = function(tree, u2, v2) {
      return tree.hasEdge(u2, v2);
    };
    var isDescendant = function(tree, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    };
    exports.default = networkSimplex;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js
var require_rank = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/rank/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util4();
    var feasible_tree_1 = require_feasible_tree();
    var network_simplex_1 = __importDefault(require_network_simplex());
    var rank = function(g2) {
      switch (g2.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g2);
          break;
        case "tight-tree":
          tightTreeRanker(g2);
          break;
        case "longest-path":
          longestPathRanker(g2);
          break;
        default:
          tightTreeRanker(g2);
      }
    };
    var longestPathRanker = util_1.longestPath;
    var tightTreeRanker = function(g2) {
      (0, util_1.longestPathWithLayer)(g2);
      (0, feasible_tree_1.feasibleTreeWithLayer)(g2);
    };
    var networkSimplexRanker = function(g2) {
      (0, network_simplex_1.default)(g2);
    };
    exports.default = rank;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js
var require_parent_dummy_chains = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/parent-dummy-chains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dfsBothOrder = function(g2) {
      var _a2;
      var result = {};
      var lim = 0;
      var dfs3 = function(v2) {
        var _a3;
        var low = lim;
        (_a3 = g2.children(v2)) === null || _a3 === void 0 ? void 0 : _a3.forEach(dfs3);
        result[v2] = { low, lim: lim++ };
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(dfs3);
      return result;
    };
    var findPath = function(g2, postorderNums, v2, w2) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v2].low, postorderNums[w2].low);
      var lim = Math.max(postorderNums[v2].lim, postorderNums[w2].lim);
      var parent;
      var lca;
      parent = v2;
      do {
        parent = g2.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w2;
      while (parent && parent !== lca) {
        wPath.push(parent);
        parent = g2.parent(parent);
      }
      return { lca, path: vPath.concat(wPath.reverse()) };
    };
    var parentDummyChains = function(g2) {
      var _a2;
      var postorderNums = dfsBothOrder(g2);
      (_a2 = g2.graph().dummyChains) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(startV) {
        var _a3, _b;
        var v2 = startV;
        var node = g2.node(v2);
        var edgeObj = node.edgeObj;
        if (!edgeObj)
          return;
        var pathData = findPath(g2, postorderNums, edgeObj.v, edgeObj.w);
        var path = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path[pathIdx];
        var ascending = true;
        while (v2 !== edgeObj.w) {
          node = g2.node(v2);
          if (ascending) {
            while (pathV !== lca && ((_a3 = g2.node(pathV)) === null || _a3 === void 0 ? void 0 : _a3.maxRank) < node.rank) {
              pathIdx++;
              pathV = path[pathIdx];
            }
            if (pathV === lca) {
              ascending = false;
            }
          }
          if (!ascending) {
            while (pathIdx < path.length - 1 && ((_b = g2.node(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.minRank) <= node.rank) {
              pathIdx++;
            }
            pathV = path[pathIdx];
          }
          g2.setParent(v2, pathV);
          v2 = g2.successors(v2)[0];
        }
      });
    };
    exports.default = parentDummyChains;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js
var require_nesting_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/nesting-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var run = function(g2) {
      var _a2;
      var root = (0, util_1.addDummyNode)(g2, "root", {}, "_root");
      var depths = treeDepths(g2);
      var maxDepth = Math.max.apply(Math, Object.values(depths));
      if (Math.abs(maxDepth) === Infinity) {
        maxDepth = 1;
      }
      var height = maxDepth - 1;
      var nodeSep = 2 * height + 1;
      g2.graph().nestingRoot = root;
      g2.edges().forEach(function(e8) {
        g2.edge(e8).minlen *= nodeSep;
      });
      var weight = sumWeights(g2) + 1;
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
      });
      g2.graph().nodeRankFactor = nodeSep;
    };
    var dfs3 = function(g2, root, nodeSep, weight, height, depths, v2) {
      var children = g2.children(v2);
      if (!(children === null || children === void 0 ? void 0 : children.length)) {
        if (v2 !== root) {
          g2.setEdge(root, v2, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top = (0, util_1.addBorderNode)(g2, "_bt");
      var bottom = (0, util_1.addBorderNode)(g2, "_bb");
      var label = g2.node(v2);
      g2.setParent(top, v2);
      label.borderTop = top;
      g2.setParent(bottom, v2);
      label.borderBottom = bottom;
      children === null || children === void 0 ? void 0 : children.forEach(function(child) {
        dfs3(g2, root, nodeSep, weight, height, depths, child);
        var childNode = g2.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height - depths[v2] + 1;
        g2.setEdge(top, childTop, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
        g2.setEdge(childBottom, bottom, {
          minlen,
          weight: thisWeight,
          nestingEdge: true
        });
      });
      if (!g2.parent(v2)) {
        g2.setEdge(root, top, { weight: 0, minlen: height + depths[v2] });
      }
    };
    var treeDepths = function(g2) {
      var _a2;
      var depths = {};
      var dfs4 = function(v2, depth) {
        var children = g2.children(v2);
        children === null || children === void 0 ? void 0 : children.forEach(function(child) {
          return dfs4(child, depth + 1);
        });
        depths[v2] = depth;
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        return dfs4(v2, 1);
      });
      return depths;
    };
    var sumWeights = function(g2) {
      var result = 0;
      g2.edges().forEach(function(e8) {
        result += g2.edge(e8).weight;
      });
      return result;
    };
    var cleanup = function(g2) {
      var graphLabel = g2.graph();
      graphLabel.nestingRoot && g2.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.nestingEdge) {
          g2.removeEdgeObj(e8);
        }
      });
    };
    exports.default = { run, cleanup };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js
var require_add_border_segments = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/add-border-segments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var addBorderSegments = function(g2) {
      var _a2;
      var dfs3 = function(v2) {
        var children = g2.children(v2);
        var node = g2.node(v2);
        if (children === null || children === void 0 ? void 0 : children.length) {
          children.forEach(function(child) {
            return dfs3(child);
          });
        }
        if (node.hasOwnProperty("minRank")) {
          node.borderLeft = [];
          node.borderRight = [];
          for (var rank = node.minRank, maxRank = node.maxRank + 1; rank < maxRank; rank += 1) {
            addBorderNode(g2, "borderLeft", "_bl", v2, node, rank);
            addBorderNode(g2, "borderRight", "_br", v2, node, rank);
          }
        }
      };
      (_a2 = g2.children()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        return dfs3(child);
      });
    };
    var addBorderNode = function(g2, prop, prefix, sg, sgNode, rank) {
      var label = { rank, borderType: prop, width: 0, height: 0 };
      var prev = sgNode[prop][rank - 1];
      var curr = (0, util_1.addDummyNode)(g2, "border", label, prefix);
      sgNode[prop][rank] = curr;
      g2.setParent(curr, sg);
      if (prev) {
        g2.setEdge(prev, curr, { weight: 1 });
      }
    };
    exports.default = addBorderSegments;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js
var require_coordinate_system = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/coordinate-system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var adjust = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g2);
      }
    };
    var undo = function(g2) {
      var _a2;
      var rankDir = (_a2 = g2.graph().rankdir) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g2);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g2);
        swapWidthHeight(g2);
      }
    };
    var swapWidthHeight = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapWidthHeightOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        swapWidthHeightOne(g2.edge(e8));
      });
    };
    var swapWidthHeightOne = function(attrs) {
      var w2 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w2;
    };
    var reverseY = function(g2) {
      g2.nodes().forEach(function(v2) {
        reverseYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return reverseYOne(point);
        });
        if (edge.hasOwnProperty("y")) {
          reverseYOne(edge);
        }
      });
    };
    var reverseYOne = function(attrs) {
      if (attrs === null || attrs === void 0 ? void 0 : attrs.y) {
        attrs.y = -attrs.y;
      }
    };
    var swapXY = function(g2) {
      g2.nodes().forEach(function(v2) {
        swapXYOne(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(point) {
          return swapXYOne(point);
        });
        if (edge.hasOwnProperty("x")) {
          swapXYOne(edge);
        }
      });
    };
    var swapXYOne = function(attrs) {
      var x2 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x2;
    };
    exports.default = { adjust, undo };
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js
var require_init_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var initOrder = function(g2) {
      var visited = {};
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var nodeRanks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = Math.max.apply(Math, nodeRanks);
      var layers = [];
      for (var i2 = 0; i2 < maxRank + 1; i2++) {
        layers.push([]);
      }
      var dfs3 = function(v2) {
        var _a2;
        if (visited.hasOwnProperty(v2))
          return;
        visited[v2] = true;
        var node = g2.node(v2);
        if (!isNaN(node.rank)) {
          layers[node.rank].push(v2);
        }
        (_a2 = g2.successors(v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
          return dfs3(child);
        });
      };
      var orderedVs = simpleNodes.sort(function(a2, b10) {
        return g2.node(a2).rank - g2.node(b10).rank;
      });
      var beforeSort = orderedVs.filter(function(n2) {
        return g2.node(n2).fixorder !== void 0;
      });
      var fixOrderNodes = beforeSort.sort(function(a2, b10) {
        return g2.node(a2).fixorder - g2.node(b10).fixorder;
      });
      fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach(function(n2) {
        if (!isNaN(g2.node(n2).rank)) {
          layers[g2.node(n2).rank].push(n2);
        }
        visited[n2] = true;
      });
      orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach(dfs3);
      return layers;
    };
    exports.default = initOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js
var require_cross_count = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/cross-count.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var twoLayerCrossCount = function(g2, northLayer, southLayer) {
      var southPos = (0, util_1.zipObject)(southLayer, southLayer.map(function(v2, i2) {
        return i2;
      }));
      var unflat = northLayer.map(function(v2) {
        var _a2;
        var unsort = (_a2 = g2.outEdges(v2)) === null || _a2 === void 0 ? void 0 : _a2.map(function(e8) {
          return { pos: southPos[e8.w] || 0, weight: g2.edge(e8).weight };
        });
        return unsort === null || unsort === void 0 ? void 0 : unsort.sort(function(a2, b10) {
          return a2.pos - b10.pos;
        });
      });
      var southEntries = unflat.flat().filter(function(entry) {
        return entry !== void 0;
      });
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree = Array(treeSize).fill(0, 0, treeSize);
      var cc2 = 0;
      southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach(function(entry) {
        if (entry) {
          var index = entry.pos + firstIndex;
          tree[index] += entry.weight;
          var weightSum = 0;
          while (index > 0) {
            if (index % 2) {
              weightSum += tree[index + 1];
            }
            index = index - 1 >> 1;
            tree[index] += entry.weight;
          }
          cc2 += entry.weight * weightSum;
        }
      });
      return cc2;
    };
    var crossCount = function(g2, layering) {
      var cc2 = 0;
      for (var i2 = 1; i2 < (layering === null || layering === void 0 ? void 0 : layering.length); i2 += 1) {
        cc2 += twoLayerCrossCount(g2, layering[i2 - 1], layering[i2]);
      }
      return cc2;
    };
    exports.default = crossCount;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js
var require_build_layer_graph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/build-layer-graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graph_1 = require_graph();
    var buildLayerGraph = function(g2, rank, relationship) {
      var root = createRootNode(g2);
      var result = new graph_1.Graph({ compound: true }).setGraph({ root }).setDefaultNodeLabel(function(v2) {
        return g2.node(v2);
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        var node = g2.node(v2);
        var parent = g2.parent(v2);
        if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
          result.setNode(v2);
          result.setParent(v2, parent || root);
          (_a2 = g2[relationship](v2)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
            var u2 = e8.v === v2 ? e8.w : e8.v;
            var edge = result.edgeFromArgs(u2, v2);
            var weight = edge !== void 0 ? edge.weight : 0;
            result.setEdge(u2, v2, { weight: g2.edge(e8).weight + weight });
          });
          if (node.hasOwnProperty("minRank")) {
            result.setNode(v2, {
              borderLeft: node.borderLeft[rank],
              borderRight: node.borderRight[rank]
            });
          }
        }
      });
      return result;
    };
    var createRootNode = function(g2) {
      var v2;
      while (g2.hasNode(v2 = "_root".concat(Math.random())))
        ;
      return v2;
    };
    exports.default = buildLayerGraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js
var require_add_subgraph_constraints = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/add-subgraph-constraints.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var addSubgraphConstraints = function(g2, cg, vs) {
      var prev = {};
      var rootPrev;
      vs === null || vs === void 0 ? void 0 : vs.forEach(function(v2) {
        var child = g2.parent(v2);
        var parent;
        var prevChild;
        while (child) {
          parent = g2.parent(child);
          if (parent) {
            prevChild = prev[parent];
            prev[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    };
    exports.default = addSubgraphConstraints;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js
var require_barycenter = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/barycenter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter = function(g2, movable) {
      return movable.map(function(v2) {
        var inV = g2.inEdges(v2);
        if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
          return { v: v2 };
        }
        {
          var result_1 = { sum: 0, weight: 0 };
          inV === null || inV === void 0 ? void 0 : inV.forEach(function(e8) {
            var edge = g2.edge(e8);
            var nodeU = g2.node(e8.v);
            result_1.sum += edge.weight * nodeU.order;
            result_1.weight += edge.weight;
          });
          return {
            v: v2,
            barycenter: result_1.sum / result_1.weight,
            weight: result_1.weight
          };
        }
      });
    };
    exports.default = barycenter;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js
var require_resolve_conflicts = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/resolve-conflicts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolveConflicts = function(entries, cg) {
      var _a2, _b, _c;
      var mappedEntries = {};
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry, i2) {
        mappedEntries[entry.v] = {
          i: i2,
          indegree: 0,
          in: [],
          out: [],
          vs: [entry.v]
        };
        var tmp = mappedEntries[entry.v];
        if (entry.barycenter !== void 0) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      (_a2 = cg.edges()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var entryV = mappedEntries[e8.v];
        var entryW = mappedEntries[e8.w];
        if (entryV !== void 0 && entryW !== void 0) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e8.w]);
        }
      });
      var sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts(sourceSet);
    };
    var doResolveConflicts = function(sourceSet) {
      var _a2, _b;
      var entries = [];
      var handleIn = function(vEntry) {
        return function(uEntry) {
          if (uEntry.merged)
            return;
          if (uEntry.barycenter === void 0 || vEntry.barycenter === void 0 || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      };
      var handleOut = function(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      };
      var _loop_1 = function() {
        var entry = sourceSet.pop();
        entries.push(entry);
        (_a2 = entry["in"].reverse()) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
          return handleIn(entry)(e8);
        });
        (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach(function(e8) {
          return handleOut(entry)(e8);
        });
      };
      while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
        _loop_1();
      }
      var filtered = entries.filter(function(entry) {
        return !entry.merged;
      });
      var keys2 = [
        "vs",
        "i",
        "barycenter",
        "weight"
      ];
      return filtered.map(function(entry) {
        var picked = {};
        keys2 === null || keys2 === void 0 ? void 0 : keys2.forEach(function(key) {
          if (entry[key] === void 0)
            return;
          picked[key] = entry[key];
        });
        return picked;
      });
    };
    var mergeEntries = function(target, source) {
      var _a2;
      var sum = 0;
      var weight = 0;
      if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = (_a2 = source.vs) === null || _a2 === void 0 ? void 0 : _a2.concat(target.vs);
      target.barycenter = sum / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    };
    exports.default = resolveConflicts;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js
var require_sort = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var sort = function(entries, biasRight, usePrev) {
      var parts = (0, util_1.partition)(entries, function(entry) {
        return entry.hasOwnProperty("fixorder") && !isNaN(entry.fixorder) || entry.hasOwnProperty("barycenter");
      });
      var sortable = parts.lhs;
      var unsortable = parts.rhs.sort(function(a2, b10) {
        return -a2.i - -b10.i;
      });
      var vs = [];
      var sum = 0;
      var weight = 0;
      var vsIndex = 0;
      sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      sortable === null || sortable === void 0 ? void 0 : sortable.forEach(function(entry) {
        var _a2;
        vsIndex += (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: vs.flat() };
      if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
      }
      return result;
    };
    var consumeUnsortable = function(vs, unsortable, index) {
      var iindex = index;
      var last2;
      while (unsortable.length && (last2 = unsortable[unsortable.length - 1]).i <= iindex) {
        unsortable.pop();
        vs === null || vs === void 0 ? void 0 : vs.push(last2.vs);
        iindex++;
      }
      return iindex;
    };
    var compareWithBias = function(bias, usePrev) {
      return function(entryV, entryW) {
        if (entryV.fixorder !== void 0 && entryW.fixorder !== void 0) {
          return entryV.fixorder - entryW.fixorder;
        }
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        }
        if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        if (usePrev && entryV.order !== void 0 && entryW.order !== void 0) {
          if (entryV.order < entryW.order) {
            return -1;
          }
          if (entryV.order > entryW.order) {
            return 1;
          }
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    };
    exports.default = sort;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js
var require_sort_subgraph = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/sort-subgraph.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var barycenter_1 = __importDefault(require_barycenter());
    var resolve_conflicts_1 = __importDefault(require_resolve_conflicts());
    var sort_1 = __importDefault(require_sort());
    var sortSubgraph = function(g2, v2, cg, biasRight, usePrev) {
      var _a2, _b, _c, _d;
      var movable = g2.children(v2);
      var node = g2.node(v2);
      var bl = node ? node.borderLeft : void 0;
      var br2 = node ? node.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = movable === null || movable === void 0 ? void 0 : movable.filter(function(w2) {
          return w2 !== bl && w2 !== br2;
        });
      }
      var barycenters = (0, barycenter_1.default)(g2, movable || []);
      barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach(function(entry) {
        var _a3;
        if ((_a3 = g2.children(entry.v)) === null || _a3 === void 0 ? void 0 : _a3.length) {
          var subgraphResult = sortSubgraph(g2, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (subgraphResult.hasOwnProperty("barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = (0, resolve_conflicts_1.default)(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      (_a2 = entries.filter(function(e8) {
        return e8.vs.length > 0;
      })) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(e8) {
        var node2 = g2.node(e8.vs[0]);
        if (node2) {
          e8.fixorder = node2.fixorder;
          e8.order = node2.order;
        }
      });
      var result = (0, sort_1.default)(entries, biasRight, usePrev);
      if (bl) {
        result.vs = [bl, result.vs, br2].flat();
        if ((_b = g2.predecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
          var blPred = g2.node(((_c = g2.predecessors(bl)) === null || _c === void 0 ? void 0 : _c[0]) || "");
          var brPred = g2.node(((_d = g2.predecessors(br2)) === null || _d === void 0 ? void 0 : _d[0]) || "");
          if (!result.hasOwnProperty("barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    };
    var expandSubgraphs = function(entries, subgraphs) {
      entries === null || entries === void 0 ? void 0 : entries.forEach(function(entry) {
        var _a2;
        var vss = (_a2 = entry.vs) === null || _a2 === void 0 ? void 0 : _a2.map(function(v2) {
          if (subgraphs[v2]) {
            return subgraphs[v2].vs;
          }
          return v2;
        });
        entry.vs = vss.flat();
      });
    };
    var mergeBarycenters = function(target, other) {
      if (target.barycenter !== void 0) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    };
    exports.default = sortSubgraph;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/index.js
var require_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var init_order_1 = __importDefault(require_init_order());
    var cross_count_1 = __importDefault(require_cross_count());
    var build_layer_graph_1 = __importDefault(require_build_layer_graph());
    var add_subgraph_constraints_1 = __importDefault(require_add_subgraph_constraints());
    var sort_subgraph_1 = __importDefault(require_sort_subgraph());
    var util_1 = require_util2();
    var graph_1 = require_graph();
    var util_2 = require_util3();
    var order = function(g2) {
      var mxRank = (0, util_2.maxRank)(g2);
      var range1 = [];
      var range2 = [];
      for (var i2 = 1; i2 < mxRank + 1; i2++)
        range1.push(i2);
      for (var i2 = mxRank - 1; i2 > -1; i2--)
        range2.push(i2);
      var downLayerGraphs = buildLayerGraphs(g2, range1, "inEdges");
      var upLayerGraphs = buildLayerGraphs(g2, range2, "outEdges");
      var layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      var bestCC = Number.POSITIVE_INFINITY;
      var best;
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      layering = (0, init_order_1.default)(g2);
      assignOrder(g2, layering);
      for (var i2 = 0, lastBest = 0; lastBest < 4; ++i2, ++lastBest) {
        sweepLayerGraphs(i2 % 2 ? downLayerGraphs : upLayerGraphs, i2 % 4 >= 2, true);
        layering = (0, util_2.buildLayerMatrix)(g2);
        var cc2 = (0, cross_count_1.default)(g2, layering);
        if (cc2 < bestCC) {
          lastBest = 0;
          best = (0, util_1.clone)(layering);
          bestCC = cc2;
        }
      }
      assignOrder(g2, best);
    };
    var buildLayerGraphs = function(g2, ranks, relationship) {
      return ranks.map(function(rank) {
        return (0, build_layer_graph_1.default)(g2, rank, relationship);
      });
    };
    var sweepLayerGraphs = function(layerGraphs, biasRight, usePrev) {
      var cg = new graph_1.Graph();
      layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach(function(lg) {
        var _a2;
        var root = lg.graph().root;
        var sorted = (0, sort_subgraph_1.default)(lg, root, cg, biasRight, usePrev);
        for (var i2 = 0; i2 < ((_a2 = sorted.vs) === null || _a2 === void 0 ? void 0 : _a2.length) || 0; i2++) {
          var lnode = lg.node(sorted.vs[i2]);
          if (lnode) {
            lnode.order = i2;
          }
        }
        (0, add_subgraph_constraints_1.default)(lg, cg, sorted.vs);
      });
    };
    var assignOrder = function(g2, layering) {
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          g2.node(v2).order = i2;
        });
      });
    };
    exports.default = order;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js
var require_bk = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/bk.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.width = exports.sep = exports.positionX = exports.balance = exports.alignCoordinates = exports.findSmallestWidthAlignment = exports.buildBlockGraph = exports.horizontalCompaction = exports.verticalAlignment = exports.hasConflict = exports.addConflict = exports.findOtherInnerSegmentNode = exports.findType2Conflicts = exports.findType1Conflicts = void 0;
    var graphlib_1 = (init_es(), __toCommonJS(es_exports2));
    var util_1 = require_util3();
    var BlockGraph = function(_super) {
      __extends19(BlockGraph2, _super);
      function BlockGraph2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return BlockGraph2;
    }(graphlib_1.Graph);
    var findType1Conflicts = function(g2, layering) {
      var conflicts = {};
      var visitLayer = function(prevLayer, layer) {
        var k0 = 0;
        var scanPos = 0;
        var prevLayerLength = prevLayer.length;
        var lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var w2 = (0, exports.findOtherInnerSegmentNode)(g2, v2);
          var k1 = w2 ? g2.node(w2).order : prevLayerLength;
          if (w2 || v2 === lastNode) {
            (_a2 = layer.slice(scanPos, i2 + 1)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(scanNode) {
              var _a3;
              (_a3 = g2.predecessors(scanNode)) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(u2) {
                var _a4;
                var uLabel = g2.node(u2);
                var uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && ((_a4 = g2.node(scanNode)) === null || _a4 === void 0 ? void 0 : _a4.dummy))) {
                  (0, exports.addConflict)(conflicts, u2, scanNode);
                }
              });
            });
            scanPos = i2 + 1;
            k0 = k1;
          }
        });
        return layer;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType1Conflicts = findType1Conflicts;
    var findType2Conflicts = function(g2, layering) {
      var conflicts = {};
      var scan = function(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var v2;
        var range = [];
        for (var i2 = southPos; i2 < southEnd; i2++) {
          range.push(i2);
        }
        range.forEach(function(i3) {
          var _a2, _b;
          v2 = south[i3];
          if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
            (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.forEach(function(u2) {
              var uNode = g2.node(u2);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                (0, exports.addConflict)(conflicts, u2, v2);
              }
            });
          }
        });
      };
      var visitLayer = function(north, south) {
        var prevNorthPos = -1;
        var nextNorthPos;
        var southPos = 0;
        south === null || south === void 0 ? void 0 : south.forEach(function(v2, southLookahead) {
          var _a2;
          if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
            var predecessors = g2.predecessors(v2) || [];
            if (predecessors.length) {
              nextNorthPos = g2.node(predecessors[0]).order;
              scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      };
      if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
      }
      return conflicts;
    };
    exports.findType2Conflicts = findType2Conflicts;
    var findOtherInnerSegmentNode = function(g2, v2) {
      var _a2, _b;
      if ((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) {
        return (_b = g2.predecessors(v2)) === null || _b === void 0 ? void 0 : _b.find(function(u2) {
          return g2.node(u2).dummy;
        });
      }
    };
    exports.findOtherInnerSegmentNode = findOtherInnerSegmentNode;
    var addConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = vv;
        vv = ww;
        ww = tmp;
      }
      var conflictsV = conflicts[vv];
      if (!conflictsV) {
        conflicts[vv] = conflictsV = {};
      }
      conflictsV[ww] = true;
    };
    exports.addConflict = addConflict;
    var hasConflict = function(conflicts, v2, w2) {
      var vv = v2;
      var ww = w2;
      if (vv > ww) {
        var tmp = v2;
        vv = ww;
        ww = tmp;
      }
      return !!conflicts[vv];
    };
    exports.hasConflict = hasConflict;
    var verticalAlignment = function(g2, layering, conflicts, neighborFn) {
      var root = {};
      var align = {};
      var pos = {};
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, order) {
          root[v2] = v2;
          align[v2] = v2;
          pos[v2] = order;
        });
      });
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var prevIdx = -1;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var ws = neighborFn(v2);
          if (ws.length) {
            ws = ws.sort(function(a2, b10) {
              return pos[a2] - pos[b10];
            });
            var mp = (ws.length - 1) / 2;
            for (var i2 = Math.floor(mp), il = Math.ceil(mp); i2 <= il; ++i2) {
              var w2 = ws[i2];
              if (align[v2] === v2 && prevIdx < pos[w2] && !(0, exports.hasConflict)(conflicts, v2, w2)) {
                align[w2] = v2;
                align[v2] = root[v2] = root[w2];
                prevIdx = pos[w2];
              }
            }
          }
        });
      });
      return { root, align };
    };
    exports.verticalAlignment = verticalAlignment;
    var horizontalCompaction = function(g2, layering, root, align, reverseSep) {
      var _a2;
      var xs = {};
      var blockG = (0, exports.buildBlockGraph)(g2, layering, root, reverseSep);
      var borderType = reverseSep ? "borderLeft" : "borderRight";
      var iterate = function(setXsFunc, nextNodesFunc) {
        var stack = blockG.nodes();
        var elem = stack.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack.push(elem);
            stack = stack.concat(nextNodesFunc(elem));
          }
          elem = stack.pop();
        }
      };
      var pass1 = function(elem) {
        xs[elem] = (blockG.inEdges(elem) || []).reduce(function(acc, e8) {
          return Math.max(acc, (xs[e8.v] || 0) + blockG.edge(e8));
        }, 0);
      };
      var pass2 = function(elem) {
        var min6 = (blockG.outEdges(elem) || []).reduce(function(acc, e8) {
          return Math.min(acc, (xs[e8.w] || 0) - blockG.edge(e8));
        }, Number.POSITIVE_INFINITY);
        var node = g2.node(elem);
        if (min6 !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min6);
        }
      };
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      (_a2 = Object.values(align)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
        xs[v2] = xs[root[v2]];
      });
      return xs;
    };
    exports.horizontalCompaction = horizontalCompaction;
    var buildBlockGraph = function(g2, layering, root, reverseSep) {
      var blockGraph = new BlockGraph();
      var graphLabel = g2.graph();
      var sepFn = (0, exports.sep)(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var u2;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          var vRoot = root[v2];
          blockGraph.setNode(vRoot);
          if (u2) {
            var uRoot = root[u2];
            var prevMax = blockGraph.edgeFromArgs(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g2, v2, u2), prevMax || 0));
          }
          u2 = v2;
        });
      });
      return blockGraph;
    };
    exports.buildBlockGraph = buildBlockGraph;
    var findSmallestWidthAlignment = function(g2, xss) {
      return (0, util_1.minBy)(Object.values(xss), function(xs) {
        var _a2;
        var max7 = Number.NEGATIVE_INFINITY;
        var min6 = Number.POSITIVE_INFINITY;
        (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(v2) {
          var x2 = xs[v2];
          var halfWidth = (0, exports.width)(g2, v2) / 2;
          max7 = Math.max(x2 + halfWidth, max7);
          min6 = Math.min(x2 - halfWidth, min6);
        });
        return max7 - min6;
      });
    };
    exports.findSmallestWidthAlignment = findSmallestWidthAlignment;
    function alignCoordinates(xss, alignTo) {
      var alignToVals = Object.values(alignTo);
      var alignToMin = Math.min.apply(Math, alignToVals);
      var alignToMax = Math.max.apply(Math, alignToVals);
      ["u", "d"].forEach(function(vert) {
        ["l", "r"].forEach(function(horiz) {
          var alignment = vert + horiz;
          var xs = xss[alignment];
          var delta;
          if (xs === alignTo)
            return;
          var xsVals = Object.values(xs);
          delta = horiz === "l" ? alignToMin - Math.min.apply(Math, xsVals) : alignToMax - Math.max.apply(Math, xsVals);
          if (delta) {
            xss[alignment] = {};
            Object.keys(xs).forEach(function(key) {
              xss[alignment][key] = xs[key] + delta;
            });
          }
        });
      });
    }
    exports.alignCoordinates = alignCoordinates;
    var balance = function(xss, align) {
      var result = {};
      Object.keys(xss.ul).forEach(function(key) {
        if (align) {
          result[key] = xss[align.toLowerCase()][key];
        } else {
          var values2 = Object.values(xss).map(function(x2) {
            return x2[key];
          });
          var xs = values2.sort(function(a2, b10) {
            return a2 - b10;
          });
          result[key] = (xs[1] + xs[2]) / 2;
        }
      });
      return result;
    };
    exports.balance = balance;
    var positionX = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, exports.findType1Conflicts)(g2, layering), (0, exports.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering;
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, exports.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, exports.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(key) {
              xs[key] = -xs[key];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, exports.findSmallestWidthAlignment)(g2, xss);
      alignCoordinates(xss, smallestWidth);
      return (0, exports.balance)(xss, g2.graph().align);
    };
    exports.positionX = positionX;
    var sep = function(nodeSep, edgeSep, reverseSep) {
      return function(g2, v2, w2) {
        var vLabel = g2.node(v2);
        var wLabel = g2.node(w2);
        var sum = 0;
        var delta;
        sum += vLabel.width / 2;
        if (vLabel.hasOwnProperty("labelpos")) {
          switch ((vLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.width / 2;
        if (wLabel.labelpos) {
          switch ((wLabel.labelpos || "").toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
      };
    };
    exports.sep = sep;
    var width = function(g2, v2) {
      return g2.node(v2).width || 0;
    };
    exports.width = width;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/position/index.js
var require_position = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/position/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util3();
    var bk_1 = require_bk();
    var positionY = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var rankSep = g2.graph().ranksep;
      var prevY = 0;
      layering === null || layering === void 0 ? void 0 : layering.forEach(function(layer) {
        var heights = layer.map(function(v2) {
          return g2.node(v2).height;
        });
        var maxHeight = Math.max.apply(Math, heights);
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2) {
          g2.node(v2).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    };
    var positionX = function(g2) {
      var layering = (0, util_1.buildLayerMatrix)(g2);
      var conflicts = Object.assign((0, bk_1.findType1Conflicts)(g2, layering), (0, bk_1.findType2Conflicts)(g2, layering));
      var xss = {};
      var adjustedLayering = [];
      ["u", "d"].forEach(function(vert) {
        adjustedLayering = vert === "u" ? layering : Object.values(layering).reverse();
        ["l", "r"].forEach(function(horiz) {
          if (horiz === "r") {
            adjustedLayering = adjustedLayering.map(function(inner) {
              return Object.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g2.predecessors : g2.successors).bind(g2);
          var align = (0, bk_1.verticalAlignment)(g2, adjustedLayering, conflicts, neighborFn);
          var xs = (0, bk_1.horizontalCompaction)(g2, adjustedLayering, align.root, align.align, horiz === "r");
          if (horiz === "r") {
            Object.keys(xs).forEach(function(xsKey) {
              return xs[xsKey] = -xs[xsKey];
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = (0, bk_1.findSmallestWidthAlignment)(g2, xss);
      smallestWidth && (0, bk_1.alignCoordinates)(xss, smallestWidth);
      return (0, bk_1.balance)(xss, g2.graph().align);
    };
    var position = function(g2) {
      var _a2;
      var ng = (0, util_1.asNonCompoundGraph)(g2);
      positionY(ng);
      var xs = positionX(ng);
      (_a2 = Object.keys(xs)) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(key) {
        ng.node(key).x = xs[key];
      });
    };
    exports.default = position;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js
var require_init_data_order = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/order/init-data-order.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var initDataOrder = function(g2, nodeOrder) {
      var simpleNodes = g2.nodes().filter(function(v2) {
        var _a2;
        return !((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length);
      });
      var ranks = simpleNodes.map(function(v2) {
        return g2.node(v2).rank;
      });
      var maxRank = Math.max.apply(Math, ranks);
      var layers = Array(maxRank + 1).fill([]);
      nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach(function(n2) {
        var node = g2.node(n2);
        if (!node || (node === null || node === void 0 ? void 0 : node.dummy)) {
          return;
        }
        if (!isNaN(node.rank)) {
          node.fixorder = layers[node.rank].length;
          layers[node.rank].push(n2);
        }
      });
    };
    exports.default = initDataOrder;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/src/layout.js
var require_layout = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/src/layout.js"(exports) {
    "use strict";
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var acyclic_1 = __importDefault(require_acyclic());
    var normalize_1 = __importDefault(require_normalize());
    var rank_1 = __importDefault(require_rank());
    var util_1 = require_util3();
    var parent_dummy_chains_1 = __importDefault(require_parent_dummy_chains());
    var nesting_graph_1 = __importDefault(require_nesting_graph());
    var add_border_segments_1 = __importDefault(require_add_border_segments());
    var coordinate_system_1 = __importDefault(require_coordinate_system());
    var order_1 = __importDefault(require_order());
    var position_1 = __importDefault(require_position());
    var init_data_order_1 = __importDefault(require_init_data_order());
    var graph_1 = require_graph();
    var layout2 = function(g2, opts) {
      var time = opts && opts.debugTiming ? util_1.time : util_1.notime;
      time("layout", function() {
        if (opts && !opts.keepNodeOrder && opts.prevGraph) {
          time("  inheritOrder", function() {
            inheritOrder(g2, opts.prevGraph);
          });
        }
        var layoutGraph = time("  buildLayoutGraph", function() {
          return buildLayoutGraph(g2);
        });
        if (!(opts && opts.edgeLabelSpace === false)) {
          time("  makeSpaceForEdgeLabels", function() {
            makeSpaceForEdgeLabels(layoutGraph);
          });
        }
        try {
          time("  runLayout", function() {
            runLayout(layoutGraph, time, opts);
          });
        } catch (e8) {
          if (e8.message === "Not possible to find intersection inside of the rectangle") {
            console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e8);
            return;
          }
          throw e8;
        }
        time("  updateInputGraph", function() {
          updateInputGraph(g2, layoutGraph);
        });
      });
    };
    var runLayout = function(g2, time, opts) {
      time("    removeSelfEdges", function() {
        removeSelfEdges(g2);
      });
      time("    acyclic", function() {
        acyclic_1.default.run(g2);
      });
      time("    nestingGraph.run", function() {
        nesting_graph_1.default.run(g2);
      });
      time("    rank", function() {
        (0, rank_1.default)((0, util_1.asNonCompoundGraph)(g2));
      });
      time("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g2);
      });
      time("    removeEmptyRanks", function() {
        (0, util_1.removeEmptyRanks)(g2);
      });
      time("    nestingGraph.cleanup", function() {
        nesting_graph_1.default.cleanup(g2);
      });
      time("    normalizeRanks", function() {
        (0, util_1.normalizeRanks)(g2);
      });
      time("    assignRankMinMax", function() {
        assignRankMinMax(g2);
      });
      time("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g2);
      });
      time("    normalize.run", function() {
        normalize_1.default.run(g2);
      });
      time("    parentDummyChains", function() {
        (0, parent_dummy_chains_1.default)(g2);
      });
      time("    addBorderSegments", function() {
        (0, add_border_segments_1.default)(g2);
      });
      if (opts && opts.keepNodeOrder) {
        time("    initDataOrder", function() {
          (0, init_data_order_1.default)(g2, opts.nodeOrder);
        });
      }
      time("    order", function() {
        (0, order_1.default)(g2);
      });
      time("    insertSelfEdges", function() {
        insertSelfEdges(g2);
      });
      time("    adjustCoordinateSystem", function() {
        coordinate_system_1.default.adjust(g2);
      });
      time("    position", function() {
        (0, position_1.default)(g2);
      });
      time("    positionSelfEdges", function() {
        positionSelfEdges(g2);
      });
      time("    removeBorderNodes", function() {
        removeBorderNodes(g2);
      });
      time("    normalize.undo", function() {
        normalize_1.default.undo(g2);
      });
      time("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g2);
      });
      time("    undoCoordinateSystem", function() {
        coordinate_system_1.default.undo(g2);
      });
      time("    translateGraph", function() {
        translateGraph(g2);
      });
      time("    assignNodeIntersects", function() {
        assignNodeIntersects(g2);
      });
      time("    reversePoints", function() {
        reversePointsForReversedEdges(g2);
      });
      time("    acyclic.undo", function() {
        acyclic_1.default.undo(g2);
      });
    };
    var inheritOrder = function(currG, prevG) {
      currG.nodes().forEach(function(n2) {
        var node = currG.node(n2);
        var prevNode = prevG.node(n2);
        if (prevNode !== void 0) {
          node.fixorder = prevNode._order;
          delete prevNode._order;
        } else {
          delete node.fixorder;
        }
      });
    };
    var updateInputGraph = function(inputGraph, layoutGraph) {
      inputGraph.nodes().forEach(function(v2) {
        var _a2;
        var inputLabel = inputGraph.node(v2);
        if (inputLabel) {
          var layoutLabel = layoutGraph.node(v2);
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          inputLabel._order = layoutLabel.order;
          inputLabel._rank = layoutLabel.rank;
          if ((_a2 = layoutGraph.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      inputGraph.edges().forEach(function(e8) {
        var inputLabel = inputGraph.edge(e8);
        var layoutLabel = layoutGraph.edge(e8);
        inputLabel.points = layoutLabel.points;
        if (layoutLabel.hasOwnProperty("x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    };
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height", "layer", "fixorder"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    var buildLayoutGraph = function(inputGraph) {
      var g2 = new graph_1.Graph({ multigraph: true, compound: true });
      var graph = canonicalize(inputGraph.graph());
      var pickedProperties = {};
      graphAttrs === null || graphAttrs === void 0 ? void 0 : graphAttrs.forEach(function(key) {
        if (graph[key] !== void 0)
          pickedProperties[key] = graph[key];
      });
      g2.setGraph(Object.assign({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), pickedProperties));
      inputGraph.nodes().forEach(function(v2) {
        var node = canonicalize(inputGraph.node(v2));
        var defaultNode = __assign16(__assign16({}, nodeDefaults), node);
        var defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
        g2.setNode(v2, defaultAttrs);
        g2.setParent(v2, inputGraph.parent(v2));
      });
      inputGraph.edges().forEach(function(e8) {
        var edge = canonicalize(inputGraph.edge(e8));
        var pickedProperties2 = {};
        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach(function(key) {
          if (edge[key] !== void 0)
            pickedProperties2[key] = edge[key];
        });
        g2.setEdgeObj(e8, Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties2));
      });
      return g2;
    };
    var makeSpaceForEdgeLabels = function(g2) {
      var graph = g2.graph();
      if (!graph.ranksep)
        graph.ranksep = 0;
      graph.ranksep /= 2;
      g2.nodes().forEach(function(n2) {
        var node = g2.node(n2);
        if (!isNaN(node.layer)) {
          if (!node.layer)
            node.layer = 0;
          else
            node.layer *= 2;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        edge.minlen *= 2;
        if (((_a2 = edge.labelpos) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) !== "c") {
          if (graph.rankdir === "TB" || graph.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    };
    var injectEdgeLabelProxies = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge.width && edge.height) {
          var v2 = g2.node(e8.v);
          var w2 = g2.node(e8.w);
          var label = {
            e: e8,
            rank: (w2.rank - v2.rank) / 2 + v2.rank
          };
          (0, util_1.addDummyNode)(g2, "edge-proxy", label, "_ep");
        }
      });
    };
    var assignRankMinMax = function(g2) {
      var maxRank = 0;
      g2.nodes().forEach(function(v2) {
        var _a2, _b;
        var node = g2.node(v2);
        if (node.borderTop) {
          node.minRank = (_a2 = g2.node(node.borderTop)) === null || _a2 === void 0 ? void 0 : _a2.rank;
          node.maxRank = (_b = g2.node(node.borderBottom)) === null || _b === void 0 ? void 0 : _b.rank;
          maxRank = Math.max(maxRank, node.maxRank || -Infinity);
        }
      });
      g2.graph().maxRank = maxRank;
    };
    var removeEdgeLabelProxies = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "edge-proxy") {
          g2.edge(node.e).labelRank = node.rank;
          g2.removeNode(v2);
        }
      });
    };
    var translateGraph = function(g2) {
      var minX;
      var maxX = 0;
      var minY;
      var maxY = 0;
      var graphLabel = g2.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      var getExtremes = function(attrs) {
        if (!attrs)
          return;
        var x2 = attrs.x;
        var y2 = attrs.y;
        var w2 = attrs.width;
        var h2 = attrs.height;
        if (!isNaN(x2) && !isNaN(w2)) {
          if (minX === void 0) {
            minX = x2 - w2 / 2;
          }
          minX = Math.min(minX, x2 - w2 / 2);
          maxX = Math.max(maxX, x2 + w2 / 2);
        }
        if (!isNaN(y2) && !isNaN(h2)) {
          if (minY === void 0) {
            minY = y2 - h2 / 2;
          }
          minY = Math.min(minY, y2 - h2 / 2);
          maxY = Math.max(maxY, y2 + h2 / 2);
        }
      };
      g2.nodes().forEach(function(v2) {
        getExtremes(g2.node(v2));
      });
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node) {
          node.x -= minX;
          node.y -= minY;
        }
      });
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(p2) {
          p2.x -= minX;
          p2.y -= minY;
        });
        if (edge.hasOwnProperty("x")) {
          edge.x -= minX;
        }
        if (edge.hasOwnProperty("y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY - minY + marginY;
    };
    var assignNodeIntersects = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        var nodeV = g2.node(e8.v);
        var nodeW = g2.node(e8.w);
        var p1;
        var p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift((0, util_1.intersectRect)(nodeV, p1));
        edge.points.push((0, util_1.intersectRect)(nodeW, p2));
      });
    };
    var fixupEdgeLabelCoords = function(g2) {
      g2.edges().forEach(function(e8) {
        var edge = g2.edge(e8);
        if (edge === null || edge === void 0 ? void 0 : edge.hasOwnProperty("x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    };
    var reversePointsForReversedEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        var _a2;
        var edge = g2.edge(e8);
        if (edge.reversed) {
          (_a2 = edge.points) === null || _a2 === void 0 ? void 0 : _a2.reverse();
        }
      });
    };
    var removeBorderNodes = function(g2) {
      g2.nodes().forEach(function(v2) {
        var _a2, _b, _c;
        if ((_a2 = g2.children(v2)) === null || _a2 === void 0 ? void 0 : _a2.length) {
          var node = g2.node(v2);
          var t4 = g2.node(node.borderTop);
          var b10 = g2.node(node.borderBottom);
          var l2 = g2.node(node.borderLeft[((_b = node.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
          var r2 = g2.node(node.borderRight[((_c = node.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
          node.width = Math.abs((r2 === null || r2 === void 0 ? void 0 : r2.x) - (l2 === null || l2 === void 0 ? void 0 : l2.x)) || 10;
          node.height = Math.abs((b10 === null || b10 === void 0 ? void 0 : b10.y) - (t4 === null || t4 === void 0 ? void 0 : t4.y)) || 10;
          node.x = ((l2 === null || l2 === void 0 ? void 0 : l2.x) || 0) + node.width / 2;
          node.y = ((t4 === null || t4 === void 0 ? void 0 : t4.y) || 0) + node.height / 2;
        }
      });
      g2.nodes().forEach(function(v2) {
        var _a2;
        if (((_a2 = g2.node(v2)) === null || _a2 === void 0 ? void 0 : _a2.dummy) === "border") {
          g2.removeNode(v2);
        }
      });
    };
    var removeSelfEdges = function(g2) {
      g2.edges().forEach(function(e8) {
        if (e8.v === e8.w) {
          var node = g2.node(e8.v);
          if (!node.selfEdges) {
            node.selfEdges = [];
          }
          node.selfEdges.push({ e: e8, label: g2.edge(e8) });
          g2.removeEdgeObj(e8);
        }
      });
    };
    var insertSelfEdges = function(g2) {
      var layers = (0, util_1.buildLayerMatrix)(g2);
      layers === null || layers === void 0 ? void 0 : layers.forEach(function(layer) {
        var orderShift = 0;
        layer === null || layer === void 0 ? void 0 : layer.forEach(function(v2, i2) {
          var _a2;
          var node = g2.node(v2);
          node.order = i2 + orderShift;
          (_a2 = node.selfEdges) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(selfEdge) {
            (0, util_1.addDummyNode)(g2, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node.rank,
              order: i2 + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node.selfEdges;
        });
      });
    };
    var positionSelfEdges = function(g2) {
      g2.nodes().forEach(function(v2) {
        var node = g2.node(v2);
        if (node.dummy === "selfedge") {
          var selfNode = g2.node(node.e.v);
          var x2 = selfNode.x + selfNode.width / 2;
          var y2 = selfNode.y;
          var dx = node.x - x2;
          var dy = selfNode.height / 2;
          g2.setEdgeObj(node.e, node.label);
          g2.removeNode(v2);
          node.label.points = [
            { x: x2 + 2 * dx / 3, y: y2 - dy },
            { x: x2 + 5 * dx / 6, y: y2 - dy },
            { y: y2, x: x2 + dx },
            { x: x2 + 5 * dx / 6, y: y2 + dy },
            { x: x2 + 2 * dx / 3, y: y2 + dy }
          ];
          node.label.x = node.x;
          node.label.y = node.y;
        }
      });
    };
    var selectNumberAttrs = function(obj, attrs) {
      var pickedProperties = {};
      attrs === null || attrs === void 0 ? void 0 : attrs.forEach(function(key) {
        if (obj[key] === void 0)
          return;
        pickedProperties[key] = +obj[key];
      });
      return pickedProperties;
    };
    var canonicalize = function(attrs) {
      if (attrs === void 0) {
        attrs = {};
      }
      var newAttrs = {};
      Object.keys(attrs).forEach(function(k2) {
        newAttrs[k2.toLowerCase()] = attrs[k2];
      });
      return newAttrs;
    };
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/dagre/index.js
var require_dagre = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var layout_1 = __importDefault(require_layout());
    var util_1 = require_util3();
    exports.default = {
      layout: layout_1.default,
      util: {
        time: util_1.time,
        notime: util_1.notime
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagre.js
var require_dagre2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagre.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreLayout = void 0;
    var index_1 = __importDefault(require_dagre());
    var util_1 = require_util2();
    var base_1 = require_base();
    var graph_1 = require_graph();
    var DagreLayout2 = function(_super) {
      __extends19(DagreLayout3, _super);
      function DagreLayout3(options) {
        var _this = _super.call(this) || this;
        _this.rankdir = "TB";
        _this.nodesep = 50;
        _this.ranksep = 50;
        _this.controlPoints = false;
        _this.sortByCombo = false;
        _this.edgeLabelSpace = true;
        _this.radial = false;
        _this.nodes = [];
        _this.edges = [];
        _this.onLayoutEnd = function() {
        };
        _this.layoutNode = function(nodeId) {
          var self2 = _this;
          var nodes = self2.nodes;
          var node = nodes.find(function(node2) {
            return node2.id === nodeId;
          });
          if (node) {
            var layout2 = node.layout !== false;
            return layout2;
          }
          return true;
        };
        _this.updateCfg(options);
        return _this;
      }
      DagreLayout3.prototype.getDefaultCfg = function() {
        return {
          rankdir: "TB",
          align: void 0,
          nodeSize: void 0,
          nodesepFunc: void 0,
          ranksepFunc: void 0,
          nodesep: 50,
          ranksep: 50,
          controlPoints: false,
          radial: false,
          focusNode: null
        };
      };
      DagreLayout3.prototype.execute = function() {
        var _this = this;
        var _a2;
        var self2 = this;
        var nodes = self2.nodes, nodeSize = self2.nodeSize, rankdir = self2.rankdir, combos = self2.combos, begin = self2.begin, radial = self2.radial;
        if (!nodes)
          return;
        var edges = self2.edges || [];
        var g2 = new graph_1.Graph({
          multigraph: true,
          compound: true
        });
        var nodeSizeFunc;
        if (!nodeSize) {
          nodeSizeFunc = function(d2) {
            if (d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                return d2.size;
              }
              if ((0, util_1.isObject)(d2.size)) {
                return [d2.size.width || 40, d2.size.height || 40];
              }
              return [d2.size, d2.size];
            }
            return [40, 40];
          };
        } else if ((0, util_1.isArray)(nodeSize)) {
          nodeSizeFunc = function() {
            return nodeSize;
          };
        } else {
          nodeSizeFunc = function() {
            return [nodeSize, nodeSize];
          };
        }
        var ranksepfunc = (0, util_1.getFunc)(self2.ranksep, 50, self2.ranksepFunc);
        var nodesepfunc = (0, util_1.getFunc)(self2.nodesep, 50, self2.nodesepFunc);
        var horisep = nodesepfunc;
        var vertisep = ranksepfunc;
        if (rankdir === "LR" || rankdir === "RL") {
          horisep = ranksepfunc;
          vertisep = nodesepfunc;
        }
        g2.setDefaultEdgeLabel(function() {
          return {};
        });
        g2.setGraph(self2);
        var comboMap = {};
        if (this.sortByCombo && combos) {
          combos.forEach(function(combo) {
            if (!combo.parentId)
              return;
            if (!comboMap[combo.parentId]) {
              comboMap[combo.parentId] = true;
              g2.setNode(combo.parentId, {});
            }
            g2.setParent(combo.id, combo.parentId);
          });
        }
        nodes.filter(function(node) {
          return node.layout !== false;
        }).forEach(function(node) {
          var size2 = nodeSizeFunc(node);
          var verti = vertisep(node);
          var hori = horisep(node);
          var width = size2[0] + 2 * hori;
          var height = size2[1] + 2 * verti;
          var layer = node.layer;
          if ((0, util_1.isNumber)(layer)) {
            g2.setNode(node.id, { width, height, layer });
          } else {
            g2.setNode(node.id, { width, height });
          }
          if (_this.sortByCombo && node.comboId) {
            if (!comboMap[node.comboId]) {
              comboMap[node.comboId] = true;
              g2.setNode(node.comboId, {});
            }
            g2.setParent(node.id, node.comboId);
          }
        });
        edges.forEach(function(edge) {
          var source = (0, util_1.getEdgeTerminal)(edge, "source");
          var target = (0, util_1.getEdgeTerminal)(edge, "target");
          if (_this.layoutNode(source) && _this.layoutNode(target)) {
            g2.setEdge(source, target, {
              weight: edge.weight || 1
            });
          }
        });
        var prevGraph = void 0;
        if (self2.preset) {
          prevGraph = new graph_1.Graph({
            multigraph: true,
            compound: true
          });
          self2.preset.nodes.forEach(function(node) {
            prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);
          });
        }
        index_1.default.layout(g2, {
          prevGraph,
          edgeLabelSpace: self2.edgeLabelSpace,
          keepNodeOrder: Boolean(!!self2.nodeOrder),
          nodeOrder: self2.nodeOrder
        });
        var dBegin = [0, 0];
        if (begin) {
          var minX_1 = Infinity;
          var minY_1 = Infinity;
          g2.nodes().forEach(function(node) {
            var coord = g2.node(node);
            if (minX_1 > coord.x)
              minX_1 = coord.x;
            if (minY_1 > coord.y)
              minY_1 = coord.y;
          });
          g2.edges().forEach(function(edge) {
            var _a3;
            var coord = g2.edge(edge);
            (_a3 = coord.points) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(point) {
              if (minX_1 > point.x)
                minX_1 = point.x;
              if (minY_1 > point.y)
                minY_1 = point.y;
            });
          });
          dBegin[0] = begin[0] - minX_1;
          dBegin[1] = begin[1] - minY_1;
        }
        if (radial) {
          var _b = this, focusNode = _b.focusNode, ranksep = _b.ranksep, getRadialPos_1 = _b.getRadialPos;
          var focusId = (0, util_1.isString)(focusNode) ? focusNode : focusNode === null || focusNode === void 0 ? void 0 : focusNode.id;
          var focusLayer_1 = focusId ? (_a2 = g2.node(focusId)) === null || _a2 === void 0 ? void 0 : _a2._rank : 0;
          var layers_1 = [];
          var isHorizontal = rankdir === "LR" || rankdir === "RL";
          var dim_1 = isHorizontal ? "y" : "x";
          var sizeDim_1 = isHorizontal ? "height" : "width";
          var min_1 = Infinity;
          var max_1 = -Infinity;
          g2.nodes().forEach(function(node) {
            var coord = g2.node(node);
            var i2 = nodes.findIndex(function(it2) {
              return it2.id === node;
            });
            if (!nodes[i2])
              return;
            var currentNodesep = nodesepfunc(nodes[i2]);
            if (focusLayer_1 === 0) {
              if (!layers_1[coord._rank])
                layers_1[coord._rank] = { nodes: [], totalWidth: 0, maxSize: -Infinity };
              layers_1[coord._rank].nodes.push(node);
              layers_1[coord._rank].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
              if (layers_1[coord._rank].maxSize < Math.max(coord.width, coord.height))
                layers_1[coord._rank].maxSize = Math.max(coord.width, coord.height);
            } else {
              var diffLayer = coord._rank - focusLayer_1;
              if (diffLayer === 0) {
                if (!layers_1[diffLayer])
                  layers_1[diffLayer] = { nodes: [], totalWidth: 0, maxSize: -Infinity };
                layers_1[diffLayer].nodes.push(node);
                layers_1[diffLayer].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                if (layers_1[diffLayer].maxSize < Math.max(coord.width, coord.height))
                  layers_1[diffLayer].maxSize = Math.max(coord.width, coord.height);
              } else {
                var diffLayerAbs = Math.abs(diffLayer);
                if (!layers_1[diffLayerAbs])
                  layers_1[diffLayerAbs] = { left: [], right: [], totalWidth: 0, maxSize: -Infinity };
                layers_1[diffLayerAbs].totalWidth += currentNodesep * 2 + coord[sizeDim_1];
                if (layers_1[diffLayerAbs].maxSize < Math.max(coord.width, coord.height))
                  layers_1[diffLayerAbs].maxSize = Math.max(coord.width, coord.height);
                if (diffLayer < 0) {
                  layers_1[diffLayerAbs].left.push(node);
                } else {
                  layers_1[diffLayerAbs].right.push(node);
                }
              }
            }
            var leftPos = coord[dim_1] - coord[sizeDim_1] / 2 - currentNodesep;
            var rightPos = coord[dim_1] + coord[sizeDim_1] / 2 + currentNodesep;
            if (leftPos < min_1)
              min_1 = leftPos;
            if (rightPos > max_1)
              max_1 = rightPos;
          });
          var radius_1 = ranksep || 50;
          var radiusMap_1 = {};
          var rangeLength_1 = (max_1 - min_1) / 0.9;
          var range_1 = [(min_1 + max_1 - rangeLength_1) * 0.5, (min_1 + max_1 + rangeLength_1) * 0.5];
          var processNodes_1 = function(layerNodes, radius, propsMaxRanksep, arcRange) {
            if (propsMaxRanksep === void 0) {
              propsMaxRanksep = -Infinity;
            }
            if (arcRange === void 0) {
              arcRange = [0, 1];
            }
            var maxRanksep = propsMaxRanksep;
            layerNodes.forEach(function(node) {
              var coord = g2.node(node);
              radiusMap_1[node] = radius;
              var _a3 = getRadialPos_1(coord[dim_1], range_1, rangeLength_1, radius, arcRange), newX = _a3.x, newY = _a3.y;
              var i2 = nodes.findIndex(function(it2) {
                return it2.id === node;
              });
              if (!nodes[i2])
                return;
              nodes[i2].x = newX + dBegin[0];
              nodes[i2].y = newY + dBegin[1];
              nodes[i2]._order = coord._order;
              var currentNodeRanksep = ranksepfunc(nodes[i2]);
              if (maxRanksep < currentNodeRanksep)
                maxRanksep = currentNodeRanksep;
            });
            return maxRanksep;
          };
          var isFirstLevel_1 = true;
          var lastLayerMaxNodeSize_1 = 0;
          layers_1.forEach(function(layerNodes) {
            var _a3, _b2, _c, _d, _e2, _f, _g;
            if (!((_a3 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.nodes) === null || _a3 === void 0 ? void 0 : _a3.length) && !((_b2 = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.left) === null || _b2 === void 0 ? void 0 : _b2.length) && !((_c = layerNodes === null || layerNodes === void 0 ? void 0 : layerNodes.right) === null || _c === void 0 ? void 0 : _c.length))
              return;
            if (isFirstLevel_1 && layerNodes.nodes.length === 1) {
              var i2 = nodes.findIndex(function(it2) {
                return it2.id === layerNodes.nodes[0];
              });
              nodes[i2].x = dBegin[0];
              nodes[i2].y = dBegin[1];
              radiusMap_1[layerNodes.nodes[0]] = 0;
              radius_1 = ranksepfunc(nodes[i2]);
              isFirstLevel_1 = false;
              return;
            }
            radius_1 = Math.max(radius_1, layerNodes.totalWidth / (2 * Math.PI));
            var maxRanksep = -Infinity;
            if (focusLayer_1 === 0 || ((_d = layerNodes.nodes) === null || _d === void 0 ? void 0 : _d.length)) {
              maxRanksep = processNodes_1(layerNodes.nodes, radius_1, maxRanksep, [0, 1]);
            } else {
              var leftRatio = ((_e2 = layerNodes.left) === null || _e2 === void 0 ? void 0 : _e2.length) / (((_f = layerNodes.left) === null || _f === void 0 ? void 0 : _f.length) + ((_g = layerNodes.right) === null || _g === void 0 ? void 0 : _g.length));
              maxRanksep = processNodes_1(layerNodes.left, radius_1, maxRanksep, [0, leftRatio]);
              maxRanksep = processNodes_1(layerNodes.right, radius_1, maxRanksep, [leftRatio + 0.05, 1]);
            }
            radius_1 += maxRanksep;
            isFirstLevel_1 = false;
            lastLayerMaxNodeSize_1 - layerNodes.maxSize;
          });
          g2.edges().forEach(function(edge) {
            var _a3, _b2, _c;
            var coord = g2.edge(edge);
            var i2 = edges.findIndex(function(it2) {
              var source = (0, util_1.getEdgeTerminal)(it2, "source");
              var target = (0, util_1.getEdgeTerminal)(it2, "target");
              return source === edge.v && target === edge.w;
            });
            if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
              var otherDim_1 = dim_1 === "x" ? "y" : "x";
              var controlPoints = (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.slice(1, coord.points.length - 1);
              var newControlPoints_1 = [];
              var sourceOtherDimValue_1 = (_b2 = g2.node(edge.v)) === null || _b2 === void 0 ? void 0 : _b2[otherDim_1];
              var otherDimDist_1 = sourceOtherDimValue_1 - ((_c = g2.node(edge.w)) === null || _c === void 0 ? void 0 : _c[otherDim_1]);
              var sourceRadius_1 = radiusMap_1[edge.v];
              var radiusDist_1 = sourceRadius_1 - radiusMap_1[edge.w];
              controlPoints === null || controlPoints === void 0 ? void 0 : controlPoints.forEach(function(point) {
                var cRadius = (point[otherDim_1] - sourceOtherDimValue_1) / otherDimDist_1 * radiusDist_1 + sourceRadius_1;
                var newPos = getRadialPos_1(point[dim_1], range_1, rangeLength_1, cRadius);
                newControlPoints_1.push({
                  x: newPos.x + dBegin[0],
                  y: newPos.y + dBegin[1]
                });
              });
              edges[i2].controlPoints = newControlPoints_1;
            }
          });
        } else {
          g2.nodes().forEach(function(node) {
            var coord = g2.node(node);
            var i2 = nodes.findIndex(function(it2) {
              return it2.id === node;
            });
            if (!nodes[i2])
              return;
            nodes[i2].x = coord.x + dBegin[0];
            nodes[i2].y = coord.y + dBegin[1];
            nodes[i2]._order = coord._order;
          });
          g2.edges().forEach(function(edge) {
            var _a3;
            var coord = g2.edge(edge);
            var i2 = edges.findIndex(function(it2) {
              var source = (0, util_1.getEdgeTerminal)(it2, "source");
              var target = (0, util_1.getEdgeTerminal)(it2, "target");
              return source === edge.v && target === edge.w;
            });
            if (self2.edgeLabelSpace && self2.controlPoints && edges[i2].type !== "loop") {
              edges[i2].controlPoints = (_a3 = coord === null || coord === void 0 ? void 0 : coord.points) === null || _a3 === void 0 ? void 0 : _a3.slice(1, coord.points.length - 1);
              edges[i2].controlPoints.forEach(function(point) {
                point.x += dBegin[0];
                point.y += dBegin[1];
              });
            }
          });
        }
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges
        };
      };
      DagreLayout3.prototype.getRadialPos = function(dimValue, range, rangeLength, radius, arcRange) {
        if (arcRange === void 0) {
          arcRange = [0, 1];
        }
        var dimRatio = (dimValue - range[0]) / rangeLength;
        dimRatio = dimRatio * (arcRange[1] - arcRange[0]) + arcRange[0];
        var angle3 = dimRatio * 2 * Math.PI;
        return {
          x: Math.cos(angle3) * radius,
          y: Math.sin(angle3) * radius
        };
      };
      DagreLayout3.prototype.getType = function() {
        return "dagre";
      };
      return DagreLayout3;
    }(base_1.Base);
    exports.DagreLayout = DagreLayout2;
  }
});

// node_modules/dagre-compound/dist/dagre-compound.es5.js
var dagre_compound_es5_exports = {};
__export(dagre_compound_es5_exports, {
  BRIDGE_GRAPH_NAME: () => o,
  GraphType: () => u,
  HierarchyNodeType: () => c,
  InclusionType: () => a,
  LAYOUT_CONFIG: () => e,
  NodeType: () => i,
  ROOT_NAME: () => r,
  buildGraph: () => rc,
  flatGraph: () => oc,
  getEdges: () => ic,
  mergeConfig: () => n
});
function n(n2 = {}, t4 = e) {
  var r2, o2, i2, a2;
  const u2 = JSON.parse(JSON.stringify(t4)), c2 = ((r2 = n2 == null ? void 0 : n2.graph) === null || r2 === void 0 ? void 0 : r2.meta) || {}, s2 = ((o2 = n2 == null ? void 0 : n2.subScene) === null || o2 === void 0 ? void 0 : o2.meta) || {}, d2 = ((i2 = n2 == null ? void 0 : n2.nodeSize) === null || i2 === void 0 ? void 0 : i2.meta) || {}, f2 = ((a2 = n2 == null ? void 0 : n2.nodeSize) === null || a2 === void 0 ? void 0 : a2.node) || {}, h2 = u2.nodeSize.bridge;
  return { graph: { meta: Object.assign(u2.graph.meta, c2) }, subScene: { meta: Object.assign(u2.subScene.meta, s2) }, nodeSize: { meta: Object.assign(u2.nodeSize.meta, d2), node: Object.assign(u2.nodeSize.node, f2), bridge: h2 } };
}
function t(e8) {
  return `\u25EC${e8}\u25EC`;
}
function d(e8, n2) {
  return e8(n2 = { exports: {} }, n2.exports), n2.exports;
}
function m(e8) {
  var n2 = -1, t4 = e8 == null ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function de(e8) {
  var n2 = -1, t4 = e8 == null ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function me(e8) {
  var n2 = -1, t4 = e8 == null ? 0 : e8.length;
  for (this.clear(); ++n2 < t4; ) {
    var r2 = e8[n2];
    this.set(r2[0], r2[1]);
  }
}
function _e(e8) {
  var n2 = this.__data__ = new w(e8);
  this.size = n2.size;
}
function mt(e8) {
  var n2 = -1, t4 = e8 == null ? 0 : e8.length;
  for (this.__data__ = new we(); ++n2 < t4; )
    this.add(e8[n2]);
}
function Vt(e8, n2) {
  if (typeof e8 != "function" || n2 != null && typeof n2 != "function")
    throw new TypeError("Expected a function");
  var t4 = function() {
    var r2 = arguments, o2 = n2 ? n2.apply(this, r2) : r2[0], i2 = t4.cache;
    if (i2.has(o2))
      return i2.get(o2);
    var a2 = e8.apply(this, r2);
    return t4.cache = i2.set(o2, a2) || i2, a2;
  };
  return t4.cache = new (Vt.Cache || we)(), t4;
}
function vo(e8) {
  this._isDirected = !ho.has(e8, "directed") || e8.directed, this._isMultigraph = !!ho.has(e8, "multigraph") && e8.multigraph, this._isCompound = !!ho.has(e8, "compound") && e8.compound, this._label = void 0, this._defaultNodeLabelFn = ho.constant(void 0), this._defaultEdgeLabelFn = ho.constant(void 0), this._nodes = {}, this._isCompound && (this._parent = {}, this._children = {}, this._children["\0"] = {}), this._in = {}, this._preds = {}, this._out = {}, this._sucs = {}, this._edgeObjs = {}, this._edgeLabels = {};
}
function po(e8, n2) {
  e8[n2] ? e8[n2]++ : e8[n2] = 1;
}
function go(e8, n2) {
  --e8[n2] || delete e8[n2];
}
function yo(e8, n2, t4, r2) {
  var o2 = "" + n2, i2 = "" + t4;
  if (!e8 && o2 > i2) {
    var a2 = o2;
    o2 = i2, i2 = a2;
  }
  return o2 + "" + i2 + "" + (ho.isUndefined(r2) ? "\0" : r2);
}
function bo(e8, n2, t4, r2) {
  var o2 = "" + n2, i2 = "" + t4;
  if (!e8 && o2 > i2) {
    var a2 = o2;
    o2 = i2, i2 = a2;
  }
  var u2 = { v: o2, w: i2 };
  return r2 && (u2.name = r2), u2;
}
function mo(e8, n2) {
  return yo(e8, n2.v, n2.w, n2.name);
}
function _o(e8) {
  return ho.map(e8.nodes(), function(n2) {
    var t4 = e8.node(n2), r2 = e8.parent(n2), o2 = { v: n2 };
    return ho.isUndefined(t4) || (o2.value = t4), ho.isUndefined(r2) || (o2.parent = r2), o2;
  });
}
function jo(e8) {
  return ho.map(e8.edges(), function(n2) {
    var t4 = e8.edge(n2), r2 = { v: n2.v, w: n2.w };
    return ho.isUndefined(n2.name) || (r2.name = n2.name), ho.isUndefined(t4) || (r2.value = t4), r2;
  });
}
function Oo() {
  this._arr = [], this._keyIndices = {};
}
function Lo(e8) {
  var n2 = {}, t4 = {}, r2 = [];
  if (ho.each(e8.sinks(), function o2(i2) {
    if (ho.has(t4, i2))
      throw new Ro();
    ho.has(n2, i2) || (t4[i2] = true, n2[i2] = true, ho.each(e8.predecessors(i2), o2), delete t4[i2], r2.push(i2));
  }), ho.size(n2) !== e8.nodeCount())
    throw new Ro();
  return r2;
}
function Ro() {
}
function Do(e8, n2, t4, r2, o2, i2) {
  ho.has(r2, n2) || (r2[n2] = true, t4 || i2.push(n2), ho.each(o2(n2), function(n3) {
    Do(e8, n3, t4, r2, o2, i2);
  }), t4 && i2.push(n2));
}
function qi() {
  var e8 = {};
  e8._next = e8._prev = e8, this._sentinel = e8;
}
function Yi(e8) {
  e8._prev._next = e8._next, e8._next._prev = e8._prev, delete e8._next, delete e8._prev;
}
function Ji(e8, n2) {
  if (e8 !== "_next" && e8 !== "_prev")
    return n2;
}
function Zi(e8, n2, t4, r2, o2) {
  var i2 = o2 ? [] : void 0;
  return Hi.forEach(e8.inEdges(r2.v), function(r3) {
    var a2 = e8.edge(r3), u2 = e8.node(r3.v);
    o2 && i2.push({ v: r3.v, w: r3.w }), u2.out -= a2, ea(n2, t4, u2);
  }), Hi.forEach(e8.outEdges(r2.v), function(r3) {
    var o3 = e8.edge(r3), i3 = r3.w, a2 = e8.node(i3);
    a2.in -= o3, ea(n2, t4, a2);
  }), e8.removeNode(r2.v), i2;
}
function ea(e8, n2, t4) {
  t4.out ? t4.in ? e8[t4.out - t4.in + n2].enqueue(t4) : e8[e8.length - 1].enqueue(t4) : e8[0].enqueue(t4);
}
function oa(e8, n2, t4, r2) {
  var o2;
  do {
    o2 = Hi.uniqueId(r2);
  } while (e8.hasNode(o2));
  return t4.dummy = n2, e8.setNode(o2, t4), o2;
}
function ia(e8) {
  return Hi.max(Hi.map(e8.nodes(), function(n2) {
    var t4 = e8.node(n2).rank;
    if (!Hi.isUndefined(t4))
      return t4;
  }));
}
function ha(e8, n2) {
  return Hi.forEach(e8.nodes(), function t4(r2) {
    Hi.forEach(n2.nodeEdges(r2), function(o2) {
      var i2 = o2.v, a2 = r2 === i2 ? o2.w : i2;
      e8.hasNode(a2) || da(n2, o2) || (e8.setNode(a2, {}), e8.setEdge(r2, a2, {}), t4(a2));
    });
  }), e8.nodeCount();
}
function la(e8, n2) {
  return Hi.minBy(n2.edges(), function(t4) {
    if (e8.hasNode(t4.v) !== e8.hasNode(t4.w))
      return da(n2, t4);
  });
}
function va(e8, n2, t4) {
  Hi.forEach(e8.nodes(), function(e9) {
    n2.node(e9).rank += t4;
  });
}
function Ea(e8) {
  e8 = ma(e8), ga(e8);
  var n2, t4 = fa(e8);
  for (xa(t4), _a(t4, e8); n2 = Oa(t4); )
    Ia(t4, e8, n2, ka(t4, e8, n2));
}
function _a(e8, n2) {
  var t4 = ba(e8, e8.nodes());
  t4 = t4.slice(0, t4.length - 1), Hi.forEach(t4, function(t5) {
    !function(e9, n3, t6) {
      var r2 = e9.node(t6).parent;
      e9.edge(t6, r2).cutvalue = ja(e9, n3, t6);
    }(e8, n2, t5);
  });
}
function ja(e8, n2, t4) {
  var r2 = e8.node(t4).parent, o2 = true, i2 = n2.edge(t4, r2), a2 = 0;
  return i2 || (o2 = false, i2 = n2.edge(r2, t4)), a2 = i2.weight, Hi.forEach(n2.nodeEdges(t4), function(i3) {
    var u2, c2, s2 = i3.v === t4, d2 = s2 ? i3.w : i3.v;
    if (d2 !== r2) {
      var f2 = s2 === o2, h2 = n2.edge(i3).weight;
      if (a2 += f2 ? h2 : -h2, u2 = t4, c2 = d2, e8.hasEdge(u2, c2)) {
        var l2 = e8.edge(t4, d2).cutvalue;
        a2 += f2 ? -l2 : l2;
      }
    }
  }), a2;
}
function xa(e8, n2) {
  arguments.length < 2 && (n2 = e8.nodes()[0]), Na(e8, {}, 1, n2);
}
function Na(e8, n2, t4, r2, o2) {
  var i2 = t4, a2 = e8.node(r2);
  return n2[r2] = true, Hi.forEach(e8.neighbors(r2), function(o3) {
    Hi.has(n2, o3) || (t4 = Na(e8, n2, t4, o3, r2));
  }), a2.low = i2, a2.lim = t4++, o2 ? a2.parent = o2 : delete a2.parent, t4;
}
function Oa(e8) {
  return Hi.find(e8.edges(), function(n2) {
    return e8.edge(n2).cutvalue < 0;
  });
}
function ka(e8, n2, t4) {
  var r2 = t4.v, o2 = t4.w;
  n2.hasEdge(r2, o2) || (r2 = t4.w, o2 = t4.v);
  var i2 = e8.node(r2), a2 = e8.node(o2), u2 = i2, c2 = false;
  i2.lim > a2.lim && (u2 = a2, c2 = true);
  var s2 = Hi.filter(n2.edges(), function(n3) {
    return c2 === Sa(e8, e8.node(n3.v), u2) && c2 !== Sa(e8, e8.node(n3.w), u2);
  });
  return Hi.minBy(s2, function(e9) {
    return pa(n2, e9);
  });
}
function Ia(e8, n2, t4, r2) {
  var o2 = t4.v, i2 = t4.w;
  e8.removeEdge(o2, i2), e8.setEdge(r2.v, r2.w, {}), xa(e8), _a(e8, n2), function(e9, n3) {
    var t5 = Hi.find(e9.nodes(), function(e11) {
      return !n3.node(e11).parent;
    }), r3 = ya(e9, t5);
    r3 = r3.slice(1), Hi.forEach(r3, function(t6) {
      var r4 = e9.node(t6).parent, o3 = n3.edge(t6, r4), i3 = false;
      o3 || (o3 = n3.edge(r4, t6), i3 = true), n3.node(t6).rank = n3.node(r4).rank + (i3 ? o3.minlen : -o3.minlen);
    });
  }(e8, n2);
}
function Sa(e8, n2, t4) {
  return t4.low <= n2.lim && n2.lim <= t4.lim;
}
function Ba(e8) {
  wa(e8);
}
function Ra(e8, n2, t4, r2, o2, i2, a2) {
  var u2 = e8.children(a2);
  if (u2.length) {
    var c2 = ra.addBorderNode(e8, "_bt"), s2 = ra.addBorderNode(e8, "_bb"), d2 = e8.node(a2);
    e8.setParent(c2, a2), d2.borderTop = c2, e8.setParent(s2, a2), d2.borderBottom = s2, Hi.forEach(u2, function(u3) {
      Ra(e8, n2, t4, r2, o2, i2, u3);
      var d3 = e8.node(u3), f2 = d3.borderTop ? d3.borderTop : u3, h2 = d3.borderBottom ? d3.borderBottom : u3, l2 = d3.borderTop ? r2 : 2 * r2, v2 = f2 !== h2 ? 1 : o2 - i2[a2] + 1;
      e8.setEdge(c2, f2, { weight: l2, minlen: v2, nestingEdge: true }), e8.setEdge(h2, s2, { weight: l2, minlen: v2, nestingEdge: true });
    }), e8.parent(a2) || e8.setEdge(n2, c2, { weight: 0, minlen: o2 + i2[a2] });
  } else
    a2 !== n2 && e8.setEdge(n2, a2, { weight: 0, minlen: t4 });
}
function Da(e8, n2, t4, r2, o2, i2) {
  var a2 = { width: 0, height: 0, rank: i2, borderType: n2 }, u2 = o2[n2][i2 - 1], c2 = ra.addDummyNode(e8, "border", a2, t4);
  o2[n2][i2] = c2, e8.setParent(c2, r2), u2 && e8.setEdge(u2, c2, { weight: 1 });
}
function za(e8) {
  Hi.forEach(e8.nodes(), function(n2) {
    Fa(e8.node(n2));
  }), Hi.forEach(e8.edges(), function(n2) {
    Fa(e8.edge(n2));
  });
}
function Fa(e8) {
  var n2 = e8.width;
  e8.width = e8.height, e8.height = n2;
}
function Ua(e8) {
  e8.y = -e8.y;
}
function Va(e8) {
  var n2 = e8.x;
  e8.x = e8.y, e8.y = n2;
}
function Wa(e8, n2, t4) {
  for (var r2 = Hi.zipObject(t4, Hi.map(t4, function(e9, n3) {
    return n3;
  })), o2 = Hi.flatten(Hi.map(n2, function(n3) {
    return Hi.sortBy(Hi.map(e8.outEdges(n3), function(n4) {
      return { pos: r2[n4.w], weight: e8.edge(n4).weight };
    }), "pos");
  }), true), i2 = 1; i2 < t4.length; )
    i2 <<= 1;
  var a2 = 2 * i2 - 1;
  i2 -= 1;
  var u2 = Hi.map(new Array(a2), function() {
    return 0;
  }), c2 = 0;
  return Hi.forEach(o2.forEach(function(e9) {
    var n3 = e9.pos + i2;
    u2[n3] += e9.weight;
    for (var t5 = 0; n3 > 0; )
      n3 % 2 && (t5 += u2[n3 + 1]), u2[n3 = n3 - 1 >> 1] += e9.weight;
    c2 += e9.weight * t5;
  })), c2;
}
function Xa(e8, n2, t4) {
  for (var r2; n2.length && (r2 = Hi.last(n2)).i <= t4; )
    n2.pop(), e8.push(r2.vs), t4++;
  return t4;
}
function ru(e8, n2, t4) {
  return Hi.map(n2, function(n3) {
    return Za(e8, n3, t4);
  });
}
function ou(e8, n2) {
  var t4 = new nu();
  Hi.forEach(e8, function(e9) {
    var r2 = e9.graph().root, o2 = Ka(e9, r2, t4, n2);
    Hi.forEach(o2.vs, function(n3, t5) {
      e9.node(n3).order = t5;
    }), eu(e9, t4, o2.vs);
  });
}
function iu(e8, n2) {
  Hi.forEach(n2, function(n3) {
    Hi.forEach(n3, function(n4, t4) {
      e8.node(n4).order = t4;
    });
  });
}
function cu(e8, n2) {
  var t4 = {};
  return Hi.reduce(n2, function(n3, r2) {
    var o2 = 0, i2 = 0, a2 = n3.length, u2 = Hi.last(r2);
    return Hi.forEach(r2, function(n4, c2) {
      var s2 = function(e9, n5) {
        if (e9.node(n5).dummy)
          return Hi.find(e9.predecessors(n5), function(n6) {
            return e9.node(n6).dummy;
          });
      }(e8, n4), d2 = s2 ? e8.node(s2).order : a2;
      (s2 || n4 === u2) && (Hi.forEach(r2.slice(i2, c2 + 1), function(n5) {
        Hi.forEach(e8.predecessors(n5), function(r3) {
          var i3 = e8.node(r3), a3 = i3.order;
          !(a3 < o2 || d2 < a3) || i3.dummy && e8.node(n5).dummy || du(t4, r3, n5);
        });
      }), i2 = c2 + 1, o2 = d2);
    }), r2;
  }), t4;
}
function su(e8, n2) {
  var t4 = {};
  function r2(n3, r3, o2, i2, a2) {
    var u2;
    Hi.forEach(Hi.range(r3, o2), function(r4) {
      u2 = n3[r4], e8.node(u2).dummy && Hi.forEach(e8.predecessors(u2), function(n4) {
        var r5 = e8.node(n4);
        r5.dummy && (r5.order < i2 || r5.order > a2) && du(t4, n4, u2);
      });
    });
  }
  return Hi.reduce(n2, function(n3, t5) {
    var o2, i2 = -1, a2 = 0;
    return Hi.forEach(t5, function(u2, c2) {
      if (e8.node(u2).dummy === "border") {
        var s2 = e8.predecessors(u2);
        s2.length && (o2 = e8.node(s2[0]).order, r2(t5, a2, c2, i2, o2), a2 = c2, i2 = o2);
      }
      r2(t5, a2, t5.length, o2, n3.length);
    }), t5;
  }), t4;
}
function du(e8, n2, t4) {
  if (n2 > t4) {
    var r2 = n2;
    n2 = t4, t4 = r2;
  }
  var o2 = e8[n2];
  o2 || (e8[n2] = o2 = {}), o2[t4] = true;
}
function fu(e8, n2, t4) {
  if (n2 > t4) {
    var r2 = n2;
    n2 = t4, t4 = r2;
  }
  return Hi.has(e8[n2], t4);
}
function hu(e8, n2, t4, r2) {
  var o2 = {}, i2 = {}, a2 = {};
  return Hi.forEach(n2, function(e9) {
    Hi.forEach(e9, function(e11, n3) {
      o2[e11] = e11, i2[e11] = e11, a2[e11] = n3;
    });
  }), Hi.forEach(n2, function(e9) {
    var n3 = -1;
    Hi.forEach(e9, function(e11) {
      var u2 = r2(e11);
      if (u2.length)
        for (var c2 = ((u2 = Hi.sortBy(u2, function(e12) {
          return a2[e12];
        })).length - 1) / 2, s2 = Math.floor(c2), d2 = Math.ceil(c2); s2 <= d2; ++s2) {
          var f2 = u2[s2];
          i2[e11] === e11 && n3 < a2[f2] && !fu(t4, e11, f2) && (i2[f2] = e11, i2[e11] = o2[e11] = o2[f2], n3 = a2[f2]);
        }
    });
  }), { root: o2, align: i2 };
}
function lu(e8, n2, t4, r2, o2) {
  var i2 = {}, a2 = function(e9, n3, t5, r3) {
    var o3 = new au(), i3 = e9.graph(), a3 = function(e11, n4, t6) {
      return function(r4, o4, i4) {
        var a4, u3 = r4.node(o4), c3 = r4.node(i4), s2 = 0;
        if (s2 += u3.width / 2, Hi.has(u3, "labelpos"))
          switch (u3.labelpos.toLowerCase()) {
            case "l":
              a4 = -u3.width / 2;
              break;
            case "r":
              a4 = u3.width / 2;
          }
        if (a4 && (s2 += t6 ? a4 : -a4), a4 = 0, s2 += (u3.dummy ? n4 : e11) / 2, s2 += (c3.dummy ? n4 : e11) / 2, s2 += c3.width / 2, Hi.has(c3, "labelpos"))
          switch (c3.labelpos.toLowerCase()) {
            case "l":
              a4 = c3.width / 2;
              break;
            case "r":
              a4 = -c3.width / 2;
          }
        return a4 && (s2 += t6 ? a4 : -a4), a4 = 0, s2;
      };
    }(i3.nodesep, i3.edgesep, r3);
    return Hi.forEach(n3, function(n4) {
      var r4;
      Hi.forEach(n4, function(n5) {
        var i4 = t5[n5];
        if (o3.setNode(i4), r4) {
          var u3 = t5[r4], c3 = o3.edge(u3, i4);
          o3.setEdge(u3, i4, Math.max(a3(e9, n5, r4), c3 || 0));
        }
        r4 = n5;
      });
    }), o3;
  }(e8, n2, t4, o2), u2 = o2 ? "borderLeft" : "borderRight";
  function c2(e9, n3) {
    for (var t5 = a2.nodes(), r3 = t5.pop(), o3 = {}; r3; )
      o3[r3] ? e9(r3) : (o3[r3] = true, t5.push(r3), t5 = t5.concat(n3(r3))), r3 = t5.pop();
  }
  return c2(function(e9) {
    i2[e9] = a2.inEdges(e9).reduce(function(e11, n3) {
      return Math.max(e11, i2[n3.v] + a2.edge(n3));
    }, 0);
  }, a2.predecessors.bind(a2)), c2(function(n3) {
    var t5 = a2.outEdges(n3).reduce(function(e9, n4) {
      return Math.min(e9, i2[n4.w] - a2.edge(n4));
    }, Number.POSITIVE_INFINITY), r3 = e8.node(n3);
    t5 !== Number.POSITIVE_INFINITY && r3.borderType !== u2 && (i2[n3] = Math.max(i2[n3], t5));
  }, a2.successors.bind(a2)), Hi.forEach(r2, function(e9) {
    i2[e9] = i2[t4[e9]];
  }), i2;
}
function vu(e8, n2) {
  return Hi.minBy(Hi.values(n2), function(n3) {
    var t4 = Number.NEGATIVE_INFINITY, r2 = Number.POSITIVE_INFINITY;
    return Hi.forIn(n3, function(n4, o2) {
      var i2 = function(e9, n5) {
        return e9.node(n5).width;
      }(e8, o2) / 2;
      t4 = Math.max(n4 + i2, t4), r2 = Math.min(n4 - i2, r2);
    }), t4 - r2;
  });
}
function pu(e8, n2) {
  var t4 = Hi.values(n2), r2 = Hi.min(t4), o2 = Hi.max(t4);
  Hi.forEach(["u", "d"], function(t5) {
    Hi.forEach(["l", "r"], function(i2) {
      var a2, u2 = t5 + i2, c2 = e8[u2];
      if (c2 !== n2) {
        var s2 = Hi.values(c2);
        (a2 = i2 === "l" ? r2 - Hi.min(s2) : o2 - Hi.max(s2)) && (e8[u2] = Hi.mapValues(c2, function(e9) {
          return e9 + a2;
        }));
      }
    });
  });
}
function gu(e8, n2) {
  return Hi.mapValues(e8.ul, function(t4, r2) {
    if (n2)
      return e8[n2.toLowerCase()][r2];
    var o2 = Hi.sortBy(Hi.map(e8, r2));
    return (o2[1] + o2[2]) / 2;
  });
}
function Gu(e8, n2) {
  return Hi.mapValues(Hi.pick(e8, n2), Number);
}
function Bu(e8) {
  var n2 = {};
  return Hi.forEach(e8, function(e9, t4) {
    n2[t4.toLowerCase()] = e9;
  }), n2;
}
function zu(e8) {
  const n2 = new Pu();
  return e8.nodes.map((e9) => new Du(e9)).forEach((e9) => {
    n2.nodes[e9.name] = e9, e9.inputs.forEach((t4) => {
      !function(e11, n3, t5) {
        t5.name !== n3.name && e11.edges.push(Object.assign(Object.assign({}, t5.attr), { v: t5.name, w: n3.name }));
      }(n2, e9, t4);
    });
  }), n2;
}
function Vu(e8, n2 = {}) {
  return new Fu(e8, n2);
}
function $u(e8, n2) {
  return new Uu(e8, n2);
}
function Hu(e8, n2, t4) {
  const r2 = t4 || {}, o2 = new Ru.Graph(r2);
  return o2.setGraph({ name: e8, rankdir: r2.rankdir, type: n2, align: r2.align }), o2;
}
function qu(e8, n2) {
  const { rankDirection: t4, align: r2 } = n2, o2 = new Wu({ rankdir: t4, align: r2 });
  return function(e9, n3) {
    Object.keys(n3.nodes).forEach((t5) => {
      const r3 = n3.nodes[t5], o3 = r3.path;
      let i2 = e9.root;
      i2.depth = Math.max(o3.length, i2.depth);
      for (let n4 = 0; n4 < o3.length && (i2.depth = Math.max(i2.depth, o3.length - n4), i2.cardinality += r3.cardinality, n4 !== o3.length - 1); n4++) {
        const t6 = o3[n4];
        let a2 = e9.node(t6);
        a2 || (a2 = Vu(t6, e9.graphOptions), a2.path = r3.path.slice(0, n4 + 1), a2.parentNode = i2, e9.setNode(t6, a2), i2.metaGraph.setNode(t6, a2)), i2 = a2;
      }
      e9.setNode(r3.name, r3), r3.parentNode = i2, i2.metaGraph.setNode(r3.name, r3);
    });
  }(o2, e8), function(e9, n3) {
    const t5 = e9.getNodeMap();
    let r3 = [], o3 = [];
    const i2 = (e11, n4) => {
      let t6 = 0;
      for (; e11; )
        n4[t6++] = e11.name, e11 = e11.parentNode;
      return t6 - 1;
    };
    n3.edges.forEach((a2) => {
      r3 = [], o3 = [];
      let u2 = i2(n3.nodes[a2.v], r3), c2 = i2(n3.nodes[a2.w], o3);
      for (; r3[u2] === o3[c2]; )
        if (u2--, c2--, u2 < 0 || c2 < 0)
          throw Error("No difference found between ancestor paths.");
      const s2 = t5[r3[u2 + 1]], d2 = r3[u2], f2 = o3[c2];
      let h2 = s2.metaGraph.edge(d2, f2);
      h2 || (h2 = $u(d2, f2), s2.metaGraph.setEdge(d2, f2, h2)), h2.addBaseEdge(a2, e9);
    });
  }(o2, e8), o2;
}
function Yu(e8, n2, t4, r2) {
  (t4 ? e8.inEdges(n2.name) : e8.outEdges(n2.name)).forEach((n3) => {
    const t5 = e8.edge(n3);
    r2.push(t5);
  });
}
function Zu(e8, t4) {
  e8.node.isGroupNode && function(e9, t5) {
    const r2 = n(t5);
    e9.coreGraph.nodes().map((n2) => e9.coreGraph.node(n2)).forEach((e11) => {
      var n2, o2, a2, u2, c2, s2;
      const { height: d2, width: f2 } = e11;
      switch (e11.node.type) {
        case i.NODE:
          Object.assign(e11, r2.nodeSize.node), e11.height = d2 || r2.nodeSize.node.height, e11.width = f2 || r2.nodeSize.node.width;
          break;
        case i.BRIDGE:
          Object.assign(e11, r2.nodeSize.bridge);
          break;
        case i.META:
          if (e11.expanded) {
            Zu(e11, t5);
          } else
            Object.assign(e11, r2.nodeSize.meta), e11.height = r2.nodeSize.meta.height, e11.width = r2.nodeSize.meta.width;
          break;
        default:
          throw Error("Unrecognized node type: " + e11.node.type);
      }
      if (!e11.expanded) {
        const r3 = e11.attr;
        !function(e12, n3 = false) {
          if (e12.coreBox.width = e12.width, e12.coreBox.height = e12.height, !n3) {
            const n4 = `${e12.displayName}`.length, t6 = 3;
            e12.width = Math.max(e12.coreBox.width, n4 * t6);
          }
        }(e11, t5 && (e11.node.type === 0 && !!((o2 = (n2 = t5 == null ? void 0 : t5.nodeSize) === null || n2 === void 0 ? void 0 : n2.meta) === null || o2 === void 0 ? void 0 : o2.width) || e11.node.type === 1 && (!!((u2 = (a2 = t5 == null ? void 0 : t5.nodeSize) === null || a2 === void 0 ? void 0 : a2.node) === null || u2 === void 0 ? void 0 : u2.width) || !!r3.width) || e11.node.type === 2 && !!((s2 = (c2 = t5 == null ? void 0 : t5.nodeSize) === null || c2 === void 0 ? void 0 : c2.bridge) === null || s2 === void 0 ? void 0 : s2.width)));
      }
    });
  }(e8, t4), e8.node.type === i.META && function(e9, t5) {
    const r2 = n(t5), o2 = r2.subScene.meta;
    Object.assign(e9, o2);
    const { nodeSep: a2, rankSep: u2, edgeSep: c2, align: s2 } = r2.graph.meta, d2 = { nodesep: a2, ranksep: u2, edgesep: c2, align: s2 };
    Object.assign(e9.coreBox, function(e11, n2) {
      const { ranksep: t6, nodesep: r3, edgesep: o3, align: a3 } = n2;
      Object.assign(e11.graph(), { ranksep: t6, nodesep: r3, edgesep: o3, align: a3 });
      const u3 = [];
      if (e11.nodes().forEach((n3) => {
        e11.node(n3).node.type !== i.BRIDGE && u3.push(n3);
      }), !u3.length)
        return { width: 0, height: 0 };
      Tu(e11);
      let c3 = 1 / 0, s3 = 1 / 0, d3 = -1 / 0, f3 = -1 / 0;
      return u3.forEach((n3) => {
        const t7 = e11.node(n3), r4 = 0.5 * t7.width, o4 = t7.x - r4, i2 = t7.x + r4;
        c3 = o4 < c3 ? o4 : c3, d3 = i2 > d3 ? i2 : d3;
        const a4 = 0.5 * t7.height, u4 = t7.y - a4, h3 = t7.y + a4;
        s3 = u4 < s3 ? u4 : s3, f3 = h3 > f3 ? h3 : f3;
      }), e11.edges().forEach((n3) => {
        const t7 = e11.edge(n3), r4 = e11.node(t7.metaEdge.v), o4 = e11.node(t7.metaEdge.w);
        if (t7.points.length === 3 && function(e12) {
          let n4 = ec(e12[0], e12[1]);
          for (let t8 = 1; t8 < e12.length - 1; t8++) {
            const r5 = ec(e12[t8], e12[t8 + 1]);
            if (Math.abs(r5 - n4) > 1)
              return false;
            n4 = r5;
          }
          return true;
        }(t7.points)) {
          if (r4 != null) {
            const e12 = r4.expanded ? r4.x : nc(r4);
            t7.points[0].x = e12;
          }
          if (o4 != null) {
            const e12 = o4.expanded ? o4.x : nc(o4);
            t7.points[2].x = e12;
          }
          t7.points = [t7.points[0], t7.points[1]];
        }
        const i2 = t7.points[t7.points.length - 2];
        o4 != null && (t7.points[t7.points.length - 1] = tc(i2, o4));
        const a4 = t7.points[1];
        r4 != null && (t7.points[0] = tc(a4, r4)), t7.points.forEach((e12) => {
          c3 = e12.x < c3 ? e12.x : c3, d3 = e12.x > d3 ? e12.x : d3, s3 = e12.y < s3 ? e12.y : s3, f3 = e12.y > f3 ? e12.y : f3;
        });
      }), e11.nodes().forEach((n3) => {
        const t7 = e11.node(n3);
        t7.x -= c3, t7.y -= s3;
      }), e11.edges().forEach((n3) => {
        e11.edge(n3).points.forEach((e12) => {
          e12.x -= c3, e12.y -= s3;
        });
      }), { width: d3 - c3, height: f3 - s3 };
    }(e9.coreGraph, d2));
    let f2 = 0;
    e9.coreGraph.nodeCount() > 0 && f2++;
    const h2 = f2 <= 1 ? 0 : f2;
    e9.coreBox.width += h2 + h2, e9.coreBox.height = o2.labelHeight + e9.coreBox.height, e9.width = e9.coreBox.width + o2.paddingLeft + o2.paddingRight, e9.height = e9.paddingTop + e9.coreBox.height + e9.paddingBottom;
  }(e8, t4);
}
function ec(e8, n2) {
  const t4 = n2.x - e8.x, r2 = n2.y - e8.y;
  return 180 * Math.atan(r2 / t4) / Math.PI;
}
function nc(e8) {
  if (e8.expanded)
    return e8.x;
  return e8.x - e8.width / 2 + 0 + e8.coreBox.width / 2;
}
function tc(e8, n2) {
  const t4 = n2.expanded ? n2.x : nc(n2), r2 = n2.y, o2 = e8.x - t4, i2 = e8.y - r2;
  let a2, u2, c2 = n2.expanded ? n2.width : n2.coreBox.width, s2 = n2.expanded ? n2.height : n2.coreBox.height;
  return Math.abs(i2) * c2 / 2 > Math.abs(o2) * s2 / 2 ? (i2 < 0 && (s2 = -s2), a2 = i2 === 0 ? 0 : s2 / 2 * o2 / i2, u2 = s2 / 2) : (o2 < 0 && (c2 = -c2), a2 = c2 / 2, u2 = o2 === 0 ? 0 : c2 / 2 * i2 / o2), { x: t4 + a2, y: r2 + u2 };
}
function rc(n2, t4, r2) {
  var o2, i2, a2, u2;
  const c2 = n2.nodes.filter((e8, n3, t5) => t5.findIndex((n4) => n4.id === e8.id) !== n3).map((e8) => e8.id);
  if (c2.length)
    throw new Error(`Duplicated ids found: ${c2.join(", ")}`);
  const s2 = function(e8) {
    const n3 = { nodes: [] }, t5 = e8.compound, r3 = Object.keys(t5 || {}), o3 = /* @__PURE__ */ new Map(), i3 = (e9, n4 = []) => {
      if (o3.has(e9))
        return o3.get(e9);
      for (let o4 = 0; o4 < r3.length; o4++) {
        let a4 = r3[o4];
        if (t5 && t5[a4].indexOf(e9) !== -1)
          return n4.unshift(a4), i3(a4, n4);
      }
      return n4.length === 0 && o3.set(e9, n4), n4;
    }, a3 = (n4) => e8.edges.filter((e9) => e9.w === n4).map((e9) => ({ name: e9.v }));
    return e8.nodes.forEach((e9) => {
      const t6 = e9.id, r4 = [...i3(t6), t6];
      let o4 = a3(t6);
      n3.nodes.push({ name: t6, path: r4, inputs: o4, width: e9.width, height: e9.height, attr: Object.assign({}, e9) });
    }), n3;
  }(n2), d2 = function(e8, n3) {
    const t5 = (e9, n4) => {
      for (let t6 of n4.values())
        if (t6.includes(e9))
          return true;
      return false;
    }, r3 = (e9, n4 = []) => {
      if (Object.keys(e9).length === 0)
        return [...new Set(n4)];
      const o3 = new Map(Object.keys(e9).map((n5) => [n5, e9[n5]])), i3 = {};
      for (let [e11, r4] of o3)
        t5(e11, o3) ? i3[e11] = r4 : n4 = n4.concat(e11, r4);
      return r3(i3, n4);
    };
    return r3(e8).filter((e9) => n3.includes(e9));
  }(n2.compound || {}, (t4 == null ? void 0 : t4.expanded) || []), f2 = function(e8, n3) {
    return function(e9) {
      return new Ju(e9);
    }(qu(zu(e8), n3));
  }(s2, { rankDirection: ((i2 = (o2 = r2 == null ? void 0 : r2.graph) === null || o2 === void 0 ? void 0 : o2.meta) === null || i2 === void 0 ? void 0 : i2.rankDir) || (t4 == null ? void 0 : t4.rankDirection) || e.graph.meta.rankDir, align: ((u2 = (a2 = r2 == null ? void 0 : r2.graph) === null || a2 === void 0 ? void 0 : a2.meta) === null || u2 === void 0 ? void 0 : u2.align) || e.graph.meta.align });
  return function(e8, n3) {
    n3.forEach((n4) => {
      const t5 = e8.getRenderInfoNodes().find((e9) => e9.displayName === n4);
      let r3 = t5 && t5.node && t5.node.name || "";
      const o3 = e8.getRenderNodeByName(r3);
      if (!o3)
        throw new Error(`No nodes found: ${r3}`);
      o3.expanded = true, e8.buildSubHierarchy(r3);
    });
  }(f2, d2), Zu(f2.root, r2), ac(f2.root);
}
function oc(e8, n2 = false) {
  const t4 = JSON.parse(JSON.stringify(e8)), o2 = { nodes: [t4], edges: [...t4.edges] };
  return t4.nodes.forEach(function e9(n3) {
    (n3.type === 0 || n3.type === 1) && o2.nodes.push(n3), n3.type === 0 && (o2.edges = o2.edges.concat(n3.edges)), Array.isArray(n3.nodes) && n3.nodes.forEach(e9);
  }), n2 && o2.nodes.forEach((e9) => {
    const n3 = o2.nodes.find((n4) => n4.id === e9.parentNodeName);
    if (n3) {
      const t5 = n3.x - n3.width / 2 + n3.paddingLeft, o3 = n3.y - n3.height / 2 + n3.labelHeight + n3.paddingTop;
      n3.id !== r && (e9.x += t5, e9.y += o3), e9.type === 0 && e9.edges.forEach((n4) => {
        n4.points.forEach((n5) => {
          n5.x += e9.x - e9.width / 2 + e9.paddingLeft, n5.y += e9.y - e9.height / 2 + e9.labelHeight + e9.paddingTop;
        });
      });
    }
  }), o2;
}
function ic(e8, n2, t4, o2) {
  var i2, a2;
  let u2 = [];
  const c2 = ((i2 = t4.find((n3) => n3.id === e8)) === null || i2 === void 0 ? void 0 : i2.path) || [], s2 = ((a2 = t4.find((e9) => e9.id === n2)) === null || a2 === void 0 ? void 0 : a2.path) || [], d2 = [r, ...c2].slice(0, c2.length).reverse(), f2 = [r, ...s2].slice(0, s2.length);
  return d2.forEach((r2) => {
    const i3 = t4.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t5) => t5.baseEdgeList.some((t6) => t6.v === ((o2 == null ? void 0 : o2.v) || e8) && t6.w === ((o2 == null ? void 0 : o2.w) || n2))));
  }), f2.filter((e9) => !d2.includes(e9)).forEach((r2) => {
    const i3 = t4.find((e9) => e9.id === r2);
    u2 = u2.concat(i3.edges.filter((t5) => t5.baseEdgeList.some((t6) => t6.v === ((o2 == null ? void 0 : o2.v) || e8) && t6.w === ((o2 == null ? void 0 : o2.w) || n2))));
  }), u2;
}
function ac(e8) {
  const n2 = e8.coreGraph.nodes().map((n3) => e8.coreGraph.node(n3));
  return Object.assign(Object.assign({}, uc(e8)), { expanded: e8.expanded, nodes: e8.expanded ? (t4 = n2, t4.map((e9) => e9.node.type === i.META ? ac(e9) : uc(e9))) : [], edges: e8.expanded ? cc(e8) : [] });
  var t4;
}
function uc(e8) {
  return { id: e8.node.name, name: e8.node.name, type: e8.node.type, cardinality: e8.node.cardinality, attr: e8.attr, parentNodeName: e8.node.parentNode ? e8.node.parentNode.name : null, coreBox: Object.assign({}, e8.coreBox), x: e8.x, y: e8.y, width: e8.width, height: e8.height, radius: e8.radius, labelHeight: e8.labelHeight, labelOffset: e8.labelOffset, outboxWidth: e8.outboxWidth, paddingLeft: e8.paddingLeft, paddingTop: e8.paddingTop, paddingRight: e8.paddingRight, paddingBottom: e8.paddingBottom, path: e8.node.path };
}
function cc(e8) {
  return e8.coreGraph.edges().map((n2) => ({ renderInfoEdge: e8.coreGraph.edge(n2), edge: n2 })).filter(({ renderInfoEdge: e9 }) => e9.metaEdge).map(({ edge: n2, renderInfoEdge: t4 }) => {
    const r2 = function(e9, n3) {
      const t5 = n3.points.map((e11) => Object.assign({}, e11));
      if (n3.adjoiningMetaEdge) {
        const r3 = n3.adjoiningMetaEdge.points, o2 = n3.metaEdge.inbound, i2 = o2 ? r3[r3.length - 1] : r3[0], a2 = t5[o2 ? 0 : t5.length - 1], u2 = e9.x - e9.width / 2, c2 = e9.y - e9.height / 2, s2 = i2.x - u2, d2 = i2.y - c2, f2 = -e9.paddingLeft, h2 = -(e9.paddingTop + e9.labelHeight);
        a2.x = s2 + f2, a2.y = d2 + h2;
      }
      return t5;
    }(e8, t4);
    return { adjoiningEdge: t4.adjoiningMetaEdge ? { w: t4.adjoiningMetaEdge.metaEdge.w, v: t4.adjoiningMetaEdge.metaEdge.v } : null, inbound: t4.metaEdge.inbound, w: n2.w, v: n2.v, points: r2, weight: t4.weight, baseEdgeList: t4.metaEdge.baseEdgeList, parentNodeName: e8.node.name };
  });
}
var e, r, o, i, a, u, c, s, f, h, l, v, p, g, y, b, w, E2, _, j, x, N, O, k, I, S, M, C2, G, B2, A2, L, R, T, D2, P, z, F, U, V, $, H, W, q, Y, J, X, K2, Q, Z, ee, ne, te, re, oe, ie, ae, ue, ce, se, fe, he, le, ve, pe, ge, ye, be, we, Ee, je, xe, Ne, Oe, ke, Ie, Se, Me, Ce, Ge, Be, Ae, Le, Re, Te, De, Pe, ze, Fe, Ue, Ve, $e, He, We, qe, Ye, Je, Xe, Ke, Qe, Ze, en, nn, tn, rn, on, an, un, cn, sn, dn, fn, hn, ln2, vn, pn, gn, yn, bn, mn, wn, En, _n, jn, xn, Nn, On, kn, In, Sn, Mn, Cn, Gn, Bn, An, Ln, Rn, Tn, Dn, Pn, zn, Fn, Un, Vn, $n, Hn, Wn, qn, Yn2, Jn, Xn2, Kn, Qn, Zn2, et, nt, tt, rt, ot, it, at, ut, ct, st, dt, ft, ht, lt, vt, pt, gt, yt, bt, wt, Et, _t, jt, xt, Nt, Ot, kt, It, St, Mt, Ct, Gt, Bt, At, Lt, Rt, Tt, Dt, Pt, zt, Ft, Ut, $t, Ht, Wt, qt, Yt, Jt, Xt, Kt, Qt, Zt, er, nr, tr, rr, or, ir, ar, ur, cr, sr, dr, fr, hr, lr, vr, pr, gr, yr, br, mr, wr, Er, _r, jr, xr, Nr, Or, kr, Ir, Sr, Mr, Cr, Gr, Br, Ar, Lr, Rr, Tr, Dr, Pr, zr, Fr, Ur, Vr, $r, Hr, Wr, qr, Yr, Jr, Xr, Kr, Qr, Zr, eo, no, to, ro, oo, io, ao, uo, co, so, fo, ho, lo, wo, Eo, xo, No, ko, Io, So, Mo, Co, Go, Bo, Ao, To, Po, zo, Fo, Uo, Vo, $o, Ho, Wo, qo, Yo, Jo, Xo, Ko, Qo, Zo, ei, ni, ti, ri, oi, ii, ai, ui, ci, si, di, fi, hi, li, vi, pi2, gi, yi, bi, mi, wi, Ei, _i, ji, xi, Ni, Oi, ki, Ii, Si, Mi, Ci, Gi, Bi, Ai, Li, Ri, Ti, Di, Pi, zi, Fi, Ui, Vi, $i, Hi, Wi, Xi, Ki, Qi, na, ta, ra, aa, ua, ca, sa, da, fa, pa, ga, ya, ba, ma, wa, Ma, Ca, Ga, Aa, La, Ta, Pa, $a, Ha, qa, Ya, Ja, Ka, Qa, Za, eu, nu, tu, au, uu, yu, bu, mu, wu, Eu, _u, ju, xu, Nu, Ou, ku, Iu, Su, Mu, Cu, Au, Lu, Ru, Tu, Du, Pu, Fu, Uu, Wu, Ju, Xu, Ku, Qu;
var init_dagre_compound_es5 = __esm({
  "node_modules/dagre-compound/dist/dagre-compound.es5.js"() {
    e = { graph: { meta: { rankDir: "TB", nodeSep: 50, rankSep: 50, edgeSep: 5, align: void 0 } }, subScene: { meta: { paddingTop: 20, paddingBottom: 20, paddingLeft: 20, paddingRight: 20, labelHeight: 20 } }, nodeSize: { meta: { width: 100, maxLabelWidth: 0, height: 20 }, node: { width: 80, height: 20, labelOffset: 10, maxLabelWidth: 40 }, bridge: { width: 5, height: 5, radius: 2, labelOffset: 0 } } };
    r = t("ROOT");
    o = t("BRIDGE_GRAPH");
    !function(e8) {
      e8[e8.META = 0] = "META", e8[e8.NODE = 1] = "NODE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(i || (i = {})), function(e8) {
      e8[e8.INCLUDE = 0] = "INCLUDE", e8[e8.EXCLUDE = 1] = "EXCLUDE", e8[e8.UNSPECIFIED = 2] = "UNSPECIFIED";
    }(a || (a = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.CORE = 1] = "CORE", e8[e8.BRIDGE = 2] = "BRIDGE";
    }(u || (u = {})), function(e8) {
      e8[e8.META = 0] = "META", e8[e8.OP = 1] = "OP", e8[e8.SERIES = 2] = "SERIES";
    }(c || (c = {}));
    s = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
    f = function() {
      this.__data__ = [], this.size = 0;
    };
    h = function(e8, n2) {
      return e8 === n2 || e8 != e8 && n2 != n2;
    };
    l = function(e8, n2) {
      for (var t4 = e8.length; t4--; )
        if (h(e8[t4][0], n2))
          return t4;
      return -1;
    };
    v = Array.prototype.splice;
    p = function(e8) {
      var n2 = this.__data__, t4 = l(n2, e8);
      return !(t4 < 0) && (t4 == n2.length - 1 ? n2.pop() : v.call(n2, t4, 1), --this.size, true);
    };
    g = function(e8) {
      var n2 = this.__data__, t4 = l(n2, e8);
      return t4 < 0 ? void 0 : n2[t4][1];
    };
    y = function(e8) {
      return l(this.__data__, e8) > -1;
    };
    b = function(e8, n2) {
      var t4 = this.__data__, r2 = l(t4, e8);
      return r2 < 0 ? (++this.size, t4.push([e8, n2])) : t4[r2][1] = n2, this;
    };
    m.prototype.clear = f, m.prototype.delete = p, m.prototype.get = g, m.prototype.has = y, m.prototype.set = b;
    w = m;
    E2 = function() {
      this.__data__ = new w(), this.size = 0;
    };
    _ = function(e8) {
      var n2 = this.__data__, t4 = n2.delete(e8);
      return this.size = n2.size, t4;
    };
    j = function(e8) {
      return this.__data__.get(e8);
    };
    x = function(e8) {
      return this.__data__.has(e8);
    };
    N = typeof s == "object" && s && s.Object === Object && s;
    O = typeof self == "object" && self && self.Object === Object && self;
    k = N || O || Function("return this")();
    I = k.Symbol;
    S = Object.prototype;
    M = S.hasOwnProperty;
    C2 = S.toString;
    G = I ? I.toStringTag : void 0;
    B2 = function(e8) {
      var n2 = M.call(e8, G), t4 = e8[G];
      try {
        e8[G] = void 0;
        var r2 = true;
      } catch (e9) {
      }
      var o2 = C2.call(e8);
      return r2 && (n2 ? e8[G] = t4 : delete e8[G]), o2;
    };
    A2 = Object.prototype.toString;
    L = function(e8) {
      return A2.call(e8);
    };
    R = I ? I.toStringTag : void 0;
    T = function(e8) {
      return e8 == null ? e8 === void 0 ? "[object Undefined]" : "[object Null]" : R && R in Object(e8) ? B2(e8) : L(e8);
    };
    D2 = function(e8) {
      var n2 = typeof e8;
      return e8 != null && (n2 == "object" || n2 == "function");
    };
    z = function(e8) {
      if (!D2(e8))
        return false;
      var n2 = T(e8);
      return n2 == "[object Function]" || n2 == "[object GeneratorFunction]" || n2 == "[object AsyncFunction]" || n2 == "[object Proxy]";
    };
    F = k["__core-js_shared__"];
    U = (P = /[^.]+$/.exec(F && F.keys && F.keys.IE_PROTO || "")) ? "Symbol(src)_1." + P : "";
    V = function(e8) {
      return !!U && U in e8;
    };
    $ = Function.prototype.toString;
    H = function(e8) {
      if (e8 != null) {
        try {
          return $.call(e8);
        } catch (e9) {
        }
        try {
          return e8 + "";
        } catch (e9) {
        }
      }
      return "";
    };
    W = /^\[object .+?Constructor\]$/;
    q = Function.prototype;
    Y = Object.prototype;
    J = q.toString;
    X = Y.hasOwnProperty;
    K2 = RegExp("^" + J.call(X).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    Q = function(e8) {
      return !(!D2(e8) || V(e8)) && (z(e8) ? K2 : W).test(H(e8));
    };
    Z = function(e8, n2) {
      return e8 == null ? void 0 : e8[n2];
    };
    ee = function(e8, n2) {
      var t4 = Z(e8, n2);
      return Q(t4) ? t4 : void 0;
    };
    ne = ee(k, "Map");
    te = ee(Object, "create");
    re = function() {
      this.__data__ = te ? te(null) : {}, this.size = 0;
    };
    oe = function(e8) {
      var n2 = this.has(e8) && delete this.__data__[e8];
      return this.size -= n2 ? 1 : 0, n2;
    };
    ie = Object.prototype.hasOwnProperty;
    ae = function(e8) {
      var n2 = this.__data__;
      if (te) {
        var t4 = n2[e8];
        return t4 === "__lodash_hash_undefined__" ? void 0 : t4;
      }
      return ie.call(n2, e8) ? n2[e8] : void 0;
    };
    ue = Object.prototype.hasOwnProperty;
    ce = function(e8) {
      var n2 = this.__data__;
      return te ? n2[e8] !== void 0 : ue.call(n2, e8);
    };
    se = function(e8, n2) {
      var t4 = this.__data__;
      return this.size += this.has(e8) ? 0 : 1, t4[e8] = te && n2 === void 0 ? "__lodash_hash_undefined__" : n2, this;
    };
    de.prototype.clear = re, de.prototype.delete = oe, de.prototype.get = ae, de.prototype.has = ce, de.prototype.set = se;
    fe = de;
    he = function() {
      this.size = 0, this.__data__ = { hash: new fe(), map: new (ne || w)(), string: new fe() };
    };
    le = function(e8) {
      var n2 = typeof e8;
      return n2 == "string" || n2 == "number" || n2 == "symbol" || n2 == "boolean" ? e8 !== "__proto__" : e8 === null;
    };
    ve = function(e8, n2) {
      var t4 = e8.__data__;
      return le(n2) ? t4[typeof n2 == "string" ? "string" : "hash"] : t4.map;
    };
    pe = function(e8) {
      var n2 = ve(this, e8).delete(e8);
      return this.size -= n2 ? 1 : 0, n2;
    };
    ge = function(e8) {
      return ve(this, e8).get(e8);
    };
    ye = function(e8) {
      return ve(this, e8).has(e8);
    };
    be = function(e8, n2) {
      var t4 = ve(this, e8), r2 = t4.size;
      return t4.set(e8, n2), this.size += t4.size == r2 ? 0 : 1, this;
    };
    me.prototype.clear = he, me.prototype.delete = pe, me.prototype.get = ge, me.prototype.has = ye, me.prototype.set = be;
    we = me;
    Ee = function(e8, n2) {
      var t4 = this.__data__;
      if (t4 instanceof w) {
        var r2 = t4.__data__;
        if (!ne || r2.length < 199)
          return r2.push([e8, n2]), this.size = ++t4.size, this;
        t4 = this.__data__ = new we(r2);
      }
      return t4.set(e8, n2), this.size = t4.size, this;
    };
    _e.prototype.clear = E2, _e.prototype.delete = _, _e.prototype.get = j, _e.prototype.has = x, _e.prototype.set = Ee;
    je = _e;
    xe = function(e8, n2) {
      for (var t4 = -1, r2 = e8 == null ? 0 : e8.length; ++t4 < r2 && n2(e8[t4], t4, e8) !== false; )
        ;
      return e8;
    };
    Ne = function() {
      try {
        var e8 = ee(Object, "defineProperty");
        return e8({}, "", {}), e8;
      } catch (e9) {
      }
    }();
    Oe = function(e8, n2, t4) {
      n2 == "__proto__" && Ne ? Ne(e8, n2, { configurable: true, enumerable: true, value: t4, writable: true }) : e8[n2] = t4;
    };
    ke = Object.prototype.hasOwnProperty;
    Ie = function(e8, n2, t4) {
      var r2 = e8[n2];
      ke.call(e8, n2) && h(r2, t4) && (t4 !== void 0 || n2 in e8) || Oe(e8, n2, t4);
    };
    Se = function(e8, n2, t4, r2) {
      var o2 = !t4;
      t4 || (t4 = {});
      for (var i2 = -1, a2 = n2.length; ++i2 < a2; ) {
        var u2 = n2[i2], c2 = r2 ? r2(t4[u2], e8[u2], u2, t4, e8) : void 0;
        c2 === void 0 && (c2 = e8[u2]), o2 ? Oe(t4, u2, c2) : Ie(t4, u2, c2);
      }
      return t4;
    };
    Me = function(e8, n2) {
      for (var t4 = -1, r2 = Array(e8); ++t4 < e8; )
        r2[t4] = n2(t4);
      return r2;
    };
    Ce = function(e8) {
      return e8 != null && typeof e8 == "object";
    };
    Ge = function(e8) {
      return Ce(e8) && T(e8) == "[object Arguments]";
    };
    Be = Object.prototype;
    Ae = Be.hasOwnProperty;
    Le = Be.propertyIsEnumerable;
    Re = Ge(function() {
      return arguments;
    }()) ? Ge : function(e8) {
      return Ce(e8) && Ae.call(e8, "callee") && !Le.call(e8, "callee");
    };
    Te = Array.isArray;
    De = function() {
      return false;
    };
    Pe = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 ? k.Buffer : void 0, i2 = (o2 ? o2.isBuffer : void 0) || De;
      e8.exports = i2;
    });
    ze = /^(?:0|[1-9]\d*)$/;
    Fe = function(e8, n2) {
      var t4 = typeof e8;
      return !!(n2 = n2 == null ? 9007199254740991 : n2) && (t4 == "number" || t4 != "symbol" && ze.test(e8)) && e8 > -1 && e8 % 1 == 0 && e8 < n2;
    };
    Ue = function(e8) {
      return typeof e8 == "number" && e8 > -1 && e8 % 1 == 0 && e8 <= 9007199254740991;
    };
    Ve = {};
    Ve["[object Float32Array]"] = Ve["[object Float64Array]"] = Ve["[object Int8Array]"] = Ve["[object Int16Array]"] = Ve["[object Int32Array]"] = Ve["[object Uint8Array]"] = Ve["[object Uint8ClampedArray]"] = Ve["[object Uint16Array]"] = Ve["[object Uint32Array]"] = true, Ve["[object Arguments]"] = Ve["[object Array]"] = Ve["[object ArrayBuffer]"] = Ve["[object Boolean]"] = Ve["[object DataView]"] = Ve["[object Date]"] = Ve["[object Error]"] = Ve["[object Function]"] = Ve["[object Map]"] = Ve["[object Number]"] = Ve["[object Object]"] = Ve["[object RegExp]"] = Ve["[object Set]"] = Ve["[object String]"] = Ve["[object WeakMap]"] = false;
    $e = function(e8) {
      return Ce(e8) && Ue(e8.length) && !!Ve[T(e8)];
    };
    He = function(e8) {
      return function(n2) {
        return e8(n2);
      };
    };
    We = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 && N.process, i2 = function() {
        try {
          var e9 = r2 && r2.require && r2.require("util").types;
          return e9 || o2 && o2.binding && o2.binding("util");
        } catch (e11) {
        }
      }();
      e8.exports = i2;
    });
    qe = We && We.isTypedArray;
    Ye = qe ? He(qe) : $e;
    Je = Object.prototype.hasOwnProperty;
    Xe = function(e8, n2) {
      var t4 = Te(e8), r2 = !t4 && Re(e8), o2 = !t4 && !r2 && Pe(e8), i2 = !t4 && !r2 && !o2 && Ye(e8), a2 = t4 || r2 || o2 || i2, u2 = a2 ? Me(e8.length, String) : [], c2 = u2.length;
      for (var s2 in e8)
        !n2 && !Je.call(e8, s2) || a2 && (s2 == "length" || o2 && (s2 == "offset" || s2 == "parent") || i2 && (s2 == "buffer" || s2 == "byteLength" || s2 == "byteOffset") || Fe(s2, c2)) || u2.push(s2);
      return u2;
    };
    Ke = Object.prototype;
    Qe = function(e8) {
      var n2 = e8 && e8.constructor;
      return e8 === (typeof n2 == "function" && n2.prototype || Ke);
    };
    Ze = function(e8, n2) {
      return function(t4) {
        return e8(n2(t4));
      };
    };
    en = Ze(Object.keys, Object);
    nn = Object.prototype.hasOwnProperty;
    tn = function(e8) {
      if (!Qe(e8))
        return en(e8);
      var n2 = [];
      for (var t4 in Object(e8))
        nn.call(e8, t4) && t4 != "constructor" && n2.push(t4);
      return n2;
    };
    rn = function(e8) {
      return e8 != null && Ue(e8.length) && !z(e8);
    };
    on = function(e8) {
      return rn(e8) ? Xe(e8) : tn(e8);
    };
    an = function(e8, n2) {
      return e8 && Se(n2, on(n2), e8);
    };
    un = function(e8) {
      var n2 = [];
      if (e8 != null)
        for (var t4 in Object(e8))
          n2.push(t4);
      return n2;
    };
    cn = Object.prototype.hasOwnProperty;
    sn = function(e8) {
      if (!D2(e8))
        return un(e8);
      var n2 = Qe(e8), t4 = [];
      for (var r2 in e8)
        (r2 != "constructor" || !n2 && cn.call(e8, r2)) && t4.push(r2);
      return t4;
    };
    dn = function(e8) {
      return rn(e8) ? Xe(e8, true) : sn(e8);
    };
    fn = function(e8, n2) {
      return e8 && Se(n2, dn(n2), e8);
    };
    hn = d(function(e8, n2) {
      var t4 = n2 && !n2.nodeType && n2, r2 = t4 && e8 && !e8.nodeType && e8, o2 = r2 && r2.exports === t4 ? k.Buffer : void 0, i2 = o2 ? o2.allocUnsafe : void 0;
      e8.exports = function(e9, n3) {
        if (n3)
          return e9.slice();
        var t5 = e9.length, r3 = i2 ? i2(t5) : new e9.constructor(t5);
        return e9.copy(r3), r3;
      };
    });
    ln2 = function(e8, n2) {
      var t4 = -1, r2 = e8.length;
      for (n2 || (n2 = Array(r2)); ++t4 < r2; )
        n2[t4] = e8[t4];
      return n2;
    };
    vn = function(e8, n2) {
      for (var t4 = -1, r2 = e8 == null ? 0 : e8.length, o2 = 0, i2 = []; ++t4 < r2; ) {
        var a2 = e8[t4];
        n2(a2, t4, e8) && (i2[o2++] = a2);
      }
      return i2;
    };
    pn = function() {
      return [];
    };
    gn = Object.prototype.propertyIsEnumerable;
    yn = Object.getOwnPropertySymbols;
    bn = yn ? function(e8) {
      return e8 == null ? [] : (e8 = Object(e8), vn(yn(e8), function(n2) {
        return gn.call(e8, n2);
      }));
    } : pn;
    mn = function(e8, n2) {
      return Se(e8, bn(e8), n2);
    };
    wn = function(e8, n2) {
      for (var t4 = -1, r2 = n2.length, o2 = e8.length; ++t4 < r2; )
        e8[o2 + t4] = n2[t4];
      return e8;
    };
    En = Ze(Object.getPrototypeOf, Object);
    _n = Object.getOwnPropertySymbols ? function(e8) {
      for (var n2 = []; e8; )
        wn(n2, bn(e8)), e8 = En(e8);
      return n2;
    } : pn;
    jn = function(e8, n2) {
      return Se(e8, _n(e8), n2);
    };
    xn = function(e8, n2, t4) {
      var r2 = n2(e8);
      return Te(e8) ? r2 : wn(r2, t4(e8));
    };
    Nn = function(e8) {
      return xn(e8, on, bn);
    };
    On = function(e8) {
      return xn(e8, dn, _n);
    };
    kn = ee(k, "DataView");
    In = ee(k, "Promise");
    Sn = ee(k, "Set");
    Mn = ee(k, "WeakMap");
    Cn = H(kn);
    Gn = H(ne);
    Bn = H(In);
    An = H(Sn);
    Ln = H(Mn);
    Rn = T;
    (kn && Rn(new kn(new ArrayBuffer(1))) != "[object DataView]" || ne && Rn(new ne()) != "[object Map]" || In && Rn(In.resolve()) != "[object Promise]" || Sn && Rn(new Sn()) != "[object Set]" || Mn && Rn(new Mn()) != "[object WeakMap]") && (Rn = function(e8) {
      var n2 = T(e8), t4 = n2 == "[object Object]" ? e8.constructor : void 0, r2 = t4 ? H(t4) : "";
      if (r2)
        switch (r2) {
          case Cn:
            return "[object DataView]";
          case Gn:
            return "[object Map]";
          case Bn:
            return "[object Promise]";
          case An:
            return "[object Set]";
          case Ln:
            return "[object WeakMap]";
        }
      return n2;
    });
    Tn = Rn;
    Dn = Object.prototype.hasOwnProperty;
    Pn = function(e8) {
      var n2 = e8.length, t4 = new e8.constructor(n2);
      return n2 && typeof e8[0] == "string" && Dn.call(e8, "index") && (t4.index = e8.index, t4.input = e8.input), t4;
    };
    zn = k.Uint8Array;
    Fn = function(e8) {
      var n2 = new e8.constructor(e8.byteLength);
      return new zn(n2).set(new zn(e8)), n2;
    };
    Un = function(e8, n2) {
      var t4 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t4, e8.byteOffset, e8.byteLength);
    };
    Vn = /\w*$/;
    $n = function(e8) {
      var n2 = new e8.constructor(e8.source, Vn.exec(e8));
      return n2.lastIndex = e8.lastIndex, n2;
    };
    Hn = I ? I.prototype : void 0;
    Wn = Hn ? Hn.valueOf : void 0;
    qn = function(e8) {
      return Wn ? Object(Wn.call(e8)) : {};
    };
    Yn2 = function(e8, n2) {
      var t4 = n2 ? Fn(e8.buffer) : e8.buffer;
      return new e8.constructor(t4, e8.byteOffset, e8.length);
    };
    Jn = function(e8, n2, t4) {
      var r2 = e8.constructor;
      switch (n2) {
        case "[object ArrayBuffer]":
          return Fn(e8);
        case "[object Boolean]":
        case "[object Date]":
          return new r2(+e8);
        case "[object DataView]":
          return Un(e8, t4);
        case "[object Float32Array]":
        case "[object Float64Array]":
        case "[object Int8Array]":
        case "[object Int16Array]":
        case "[object Int32Array]":
        case "[object Uint8Array]":
        case "[object Uint8ClampedArray]":
        case "[object Uint16Array]":
        case "[object Uint32Array]":
          return Yn2(e8, t4);
        case "[object Map]":
          return new r2();
        case "[object Number]":
        case "[object String]":
          return new r2(e8);
        case "[object RegExp]":
          return $n(e8);
        case "[object Set]":
          return new r2();
        case "[object Symbol]":
          return qn(e8);
      }
    };
    Xn2 = Object.create;
    Kn = function() {
      function e8() {
      }
      return function(n2) {
        if (!D2(n2))
          return {};
        if (Xn2)
          return Xn2(n2);
        e8.prototype = n2;
        var t4 = new e8();
        return e8.prototype = void 0, t4;
      };
    }();
    Qn = function(e8) {
      return typeof e8.constructor != "function" || Qe(e8) ? {} : Kn(En(e8));
    };
    Zn2 = function(e8) {
      return Ce(e8) && Tn(e8) == "[object Map]";
    };
    et = We && We.isMap;
    nt = et ? He(et) : Zn2;
    tt = function(e8) {
      return Ce(e8) && Tn(e8) == "[object Set]";
    };
    rt = We && We.isSet;
    ot = rt ? He(rt) : tt;
    it = {};
    it["[object Arguments]"] = it["[object Array]"] = it["[object ArrayBuffer]"] = it["[object DataView]"] = it["[object Boolean]"] = it["[object Date]"] = it["[object Float32Array]"] = it["[object Float64Array]"] = it["[object Int8Array]"] = it["[object Int16Array]"] = it["[object Int32Array]"] = it["[object Map]"] = it["[object Number]"] = it["[object Object]"] = it["[object RegExp]"] = it["[object Set]"] = it["[object String]"] = it["[object Symbol]"] = it["[object Uint8Array]"] = it["[object Uint8ClampedArray]"] = it["[object Uint16Array]"] = it["[object Uint32Array]"] = true, it["[object Error]"] = it["[object Function]"] = it["[object WeakMap]"] = false;
    at = function e2(n2, t4, r2, o2, i2, a2) {
      var u2, c2 = 1 & t4, s2 = 2 & t4, d2 = 4 & t4;
      if (r2 && (u2 = i2 ? r2(n2, o2, i2, a2) : r2(n2)), u2 !== void 0)
        return u2;
      if (!D2(n2))
        return n2;
      var f2 = Te(n2);
      if (f2) {
        if (u2 = Pn(n2), !c2)
          return ln2(n2, u2);
      } else {
        var h2 = Tn(n2), l2 = h2 == "[object Function]" || h2 == "[object GeneratorFunction]";
        if (Pe(n2))
          return hn(n2, c2);
        if (h2 == "[object Object]" || h2 == "[object Arguments]" || l2 && !i2) {
          if (u2 = s2 || l2 ? {} : Qn(n2), !c2)
            return s2 ? jn(n2, fn(u2, n2)) : mn(n2, an(u2, n2));
        } else {
          if (!it[h2])
            return i2 ? n2 : {};
          u2 = Jn(n2, h2, c2);
        }
      }
      a2 || (a2 = new je());
      var v2 = a2.get(n2);
      if (v2)
        return v2;
      a2.set(n2, u2), ot(n2) ? n2.forEach(function(o3) {
        u2.add(e2(o3, t4, r2, o3, n2, a2));
      }) : nt(n2) && n2.forEach(function(o3, i3) {
        u2.set(i3, e2(o3, t4, r2, i3, n2, a2));
      });
      var p2 = f2 ? void 0 : (d2 ? s2 ? On : Nn : s2 ? dn : on)(n2);
      return xe(p2 || n2, function(o3, i3) {
        p2 && (o3 = n2[i3 = o3]), Ie(u2, i3, e2(o3, t4, r2, i3, n2, a2));
      }), u2;
    };
    ut = function(e8) {
      return at(e8, 4);
    };
    ct = function(e8) {
      return function() {
        return e8;
      };
    };
    st = function(e8) {
      return function(n2, t4, r2) {
        for (var o2 = -1, i2 = Object(n2), a2 = r2(n2), u2 = a2.length; u2--; ) {
          var c2 = a2[e8 ? u2 : ++o2];
          if (t4(i2[c2], c2, i2) === false)
            break;
        }
        return n2;
      };
    }();
    dt = function(e8, n2) {
      return e8 && st(e8, n2, on);
    };
    ft = function(e8, n2) {
      return function(t4, r2) {
        if (t4 == null)
          return t4;
        if (!rn(t4))
          return e8(t4, r2);
        for (var o2 = t4.length, i2 = n2 ? o2 : -1, a2 = Object(t4); (n2 ? i2-- : ++i2 < o2) && r2(a2[i2], i2, a2) !== false; )
          ;
        return t4;
      };
    }(dt);
    ht = function(e8) {
      return e8;
    };
    lt = function(e8) {
      return typeof e8 == "function" ? e8 : ht;
    };
    vt = function(e8, n2) {
      return (Te(e8) ? xe : ft)(e8, lt(n2));
    };
    pt = vt;
    gt = function(e8, n2) {
      var t4 = [];
      return ft(e8, function(e9, r2, o2) {
        n2(e9, r2, o2) && t4.push(e9);
      }), t4;
    };
    yt = function(e8) {
      return this.__data__.set(e8, "__lodash_hash_undefined__"), this;
    };
    bt = function(e8) {
      return this.__data__.has(e8);
    };
    mt.prototype.add = mt.prototype.push = yt, mt.prototype.has = bt;
    wt = mt;
    Et = function(e8, n2) {
      for (var t4 = -1, r2 = e8 == null ? 0 : e8.length; ++t4 < r2; )
        if (n2(e8[t4], t4, e8))
          return true;
      return false;
    };
    _t = function(e8, n2) {
      return e8.has(n2);
    };
    jt = function(e8, n2, t4, r2, o2, i2) {
      var a2 = 1 & t4, u2 = e8.length, c2 = n2.length;
      if (u2 != c2 && !(a2 && c2 > u2))
        return false;
      var s2 = i2.get(e8), d2 = i2.get(n2);
      if (s2 && d2)
        return s2 == n2 && d2 == e8;
      var f2 = -1, h2 = true, l2 = 2 & t4 ? new wt() : void 0;
      for (i2.set(e8, n2), i2.set(n2, e8); ++f2 < u2; ) {
        var v2 = e8[f2], p2 = n2[f2];
        if (r2)
          var g2 = a2 ? r2(p2, v2, f2, n2, e8, i2) : r2(v2, p2, f2, e8, n2, i2);
        if (g2 !== void 0) {
          if (g2)
            continue;
          h2 = false;
          break;
        }
        if (l2) {
          if (!Et(n2, function(e9, n3) {
            if (!_t(l2, n3) && (v2 === e9 || o2(v2, e9, t4, r2, i2)))
              return l2.push(n3);
          })) {
            h2 = false;
            break;
          }
        } else if (v2 !== p2 && !o2(v2, p2, t4, r2, i2)) {
          h2 = false;
          break;
        }
      }
      return i2.delete(e8), i2.delete(n2), h2;
    };
    xt = function(e8) {
      var n2 = -1, t4 = Array(e8.size);
      return e8.forEach(function(e9, r2) {
        t4[++n2] = [r2, e9];
      }), t4;
    };
    Nt = function(e8) {
      var n2 = -1, t4 = Array(e8.size);
      return e8.forEach(function(e9) {
        t4[++n2] = e9;
      }), t4;
    };
    Ot = I ? I.prototype : void 0;
    kt = Ot ? Ot.valueOf : void 0;
    It = function(e8, n2, t4, r2, o2, i2, a2) {
      switch (t4) {
        case "[object DataView]":
          if (e8.byteLength != n2.byteLength || e8.byteOffset != n2.byteOffset)
            return false;
          e8 = e8.buffer, n2 = n2.buffer;
        case "[object ArrayBuffer]":
          return !(e8.byteLength != n2.byteLength || !i2(new zn(e8), new zn(n2)));
        case "[object Boolean]":
        case "[object Date]":
        case "[object Number]":
          return h(+e8, +n2);
        case "[object Error]":
          return e8.name == n2.name && e8.message == n2.message;
        case "[object RegExp]":
        case "[object String]":
          return e8 == n2 + "";
        case "[object Map]":
          var u2 = xt;
        case "[object Set]":
          var c2 = 1 & r2;
          if (u2 || (u2 = Nt), e8.size != n2.size && !c2)
            return false;
          var s2 = a2.get(e8);
          if (s2)
            return s2 == n2;
          r2 |= 2, a2.set(e8, n2);
          var d2 = jt(u2(e8), u2(n2), r2, o2, i2, a2);
          return a2.delete(e8), d2;
        case "[object Symbol]":
          if (kt)
            return kt.call(e8) == kt.call(n2);
      }
      return false;
    };
    St = Object.prototype.hasOwnProperty;
    Mt = function(e8, n2, t4, r2, o2, i2) {
      var a2 = 1 & t4, u2 = Nn(e8), c2 = u2.length;
      if (c2 != Nn(n2).length && !a2)
        return false;
      for (var s2 = c2; s2--; ) {
        var d2 = u2[s2];
        if (!(a2 ? d2 in n2 : St.call(n2, d2)))
          return false;
      }
      var f2 = i2.get(e8), h2 = i2.get(n2);
      if (f2 && h2)
        return f2 == n2 && h2 == e8;
      var l2 = true;
      i2.set(e8, n2), i2.set(n2, e8);
      for (var v2 = a2; ++s2 < c2; ) {
        var p2 = e8[d2 = u2[s2]], g2 = n2[d2];
        if (r2)
          var y2 = a2 ? r2(g2, p2, d2, n2, e8, i2) : r2(p2, g2, d2, e8, n2, i2);
        if (!(y2 === void 0 ? p2 === g2 || o2(p2, g2, t4, r2, i2) : y2)) {
          l2 = false;
          break;
        }
        v2 || (v2 = d2 == "constructor");
      }
      if (l2 && !v2) {
        var b10 = e8.constructor, m2 = n2.constructor;
        b10 == m2 || !("constructor" in e8) || !("constructor" in n2) || typeof b10 == "function" && b10 instanceof b10 && typeof m2 == "function" && m2 instanceof m2 || (l2 = false);
      }
      return i2.delete(e8), i2.delete(n2), l2;
    };
    Ct = Object.prototype.hasOwnProperty;
    Gt = function(e8, n2, t4, r2, o2, i2) {
      var a2 = Te(e8), u2 = Te(n2), c2 = a2 ? "[object Array]" : Tn(e8), s2 = u2 ? "[object Array]" : Tn(n2), d2 = (c2 = c2 == "[object Arguments]" ? "[object Object]" : c2) == "[object Object]", f2 = (s2 = s2 == "[object Arguments]" ? "[object Object]" : s2) == "[object Object]", h2 = c2 == s2;
      if (h2 && Pe(e8)) {
        if (!Pe(n2))
          return false;
        a2 = true, d2 = false;
      }
      if (h2 && !d2)
        return i2 || (i2 = new je()), a2 || Ye(e8) ? jt(e8, n2, t4, r2, o2, i2) : It(e8, n2, c2, t4, r2, o2, i2);
      if (!(1 & t4)) {
        var l2 = d2 && Ct.call(e8, "__wrapped__"), v2 = f2 && Ct.call(n2, "__wrapped__");
        if (l2 || v2) {
          var p2 = l2 ? e8.value() : e8, g2 = v2 ? n2.value() : n2;
          return i2 || (i2 = new je()), o2(p2, g2, t4, r2, i2);
        }
      }
      return !!h2 && (i2 || (i2 = new je()), Mt(e8, n2, t4, r2, o2, i2));
    };
    Bt = function e3(n2, t4, r2, o2, i2) {
      return n2 === t4 || (n2 == null || t4 == null || !Ce(n2) && !Ce(t4) ? n2 != n2 && t4 != t4 : Gt(n2, t4, r2, o2, e3, i2));
    };
    At = function(e8, n2, t4, r2) {
      var o2 = t4.length, i2 = o2, a2 = !r2;
      if (e8 == null)
        return !i2;
      for (e8 = Object(e8); o2--; ) {
        var u2 = t4[o2];
        if (a2 && u2[2] ? u2[1] !== e8[u2[0]] : !(u2[0] in e8))
          return false;
      }
      for (; ++o2 < i2; ) {
        var c2 = (u2 = t4[o2])[0], s2 = e8[c2], d2 = u2[1];
        if (a2 && u2[2]) {
          if (s2 === void 0 && !(c2 in e8))
            return false;
        } else {
          var f2 = new je();
          if (r2)
            var h2 = r2(s2, d2, c2, e8, n2, f2);
          if (!(h2 === void 0 ? Bt(d2, s2, 3, r2, f2) : h2))
            return false;
        }
      }
      return true;
    };
    Lt = function(e8) {
      return e8 == e8 && !D2(e8);
    };
    Rt = function(e8) {
      for (var n2 = on(e8), t4 = n2.length; t4--; ) {
        var r2 = n2[t4], o2 = e8[r2];
        n2[t4] = [r2, o2, Lt(o2)];
      }
      return n2;
    };
    Tt = function(e8, n2) {
      return function(t4) {
        return t4 != null && (t4[e8] === n2 && (n2 !== void 0 || e8 in Object(t4)));
      };
    };
    Dt = function(e8) {
      var n2 = Rt(e8);
      return n2.length == 1 && n2[0][2] ? Tt(n2[0][0], n2[0][1]) : function(t4) {
        return t4 === e8 || At(t4, e8, n2);
      };
    };
    Pt = function(e8) {
      return typeof e8 == "symbol" || Ce(e8) && T(e8) == "[object Symbol]";
    };
    zt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    Ft = /^\w*$/;
    Ut = function(e8, n2) {
      if (Te(e8))
        return false;
      var t4 = typeof e8;
      return !(t4 != "number" && t4 != "symbol" && t4 != "boolean" && e8 != null && !Pt(e8)) || (Ft.test(e8) || !zt.test(e8) || n2 != null && e8 in Object(n2));
    };
    Vt.Cache = we;
    $t = Vt;
    Ht = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    Wt = /\\(\\)?/g;
    qt = function(e8) {
      var n2 = $t(e8, function(e9) {
        return t4.size === 500 && t4.clear(), e9;
      }), t4 = n2.cache;
      return n2;
    }(function(e8) {
      var n2 = [];
      return e8.charCodeAt(0) === 46 && n2.push(""), e8.replace(Ht, function(e9, t4, r2, o2) {
        n2.push(r2 ? o2.replace(Wt, "$1") : t4 || e9);
      }), n2;
    });
    Yt = function(e8, n2) {
      for (var t4 = -1, r2 = e8 == null ? 0 : e8.length, o2 = Array(r2); ++t4 < r2; )
        o2[t4] = n2(e8[t4], t4, e8);
      return o2;
    };
    Jt = I ? I.prototype : void 0;
    Xt = Jt ? Jt.toString : void 0;
    Kt = function e4(n2) {
      if (typeof n2 == "string")
        return n2;
      if (Te(n2))
        return Yt(n2, e4) + "";
      if (Pt(n2))
        return Xt ? Xt.call(n2) : "";
      var t4 = n2 + "";
      return t4 == "0" && 1 / n2 == -Infinity ? "-0" : t4;
    };
    Qt = function(e8) {
      return e8 == null ? "" : Kt(e8);
    };
    Zt = function(e8, n2) {
      return Te(e8) ? e8 : Ut(e8, n2) ? [e8] : qt(Qt(e8));
    };
    er = function(e8) {
      if (typeof e8 == "string" || Pt(e8))
        return e8;
      var n2 = e8 + "";
      return n2 == "0" && 1 / e8 == -Infinity ? "-0" : n2;
    };
    nr = function(e8, n2) {
      for (var t4 = 0, r2 = (n2 = Zt(n2, e8)).length; e8 != null && t4 < r2; )
        e8 = e8[er(n2[t4++])];
      return t4 && t4 == r2 ? e8 : void 0;
    };
    tr = function(e8, n2, t4) {
      var r2 = e8 == null ? void 0 : nr(e8, n2);
      return r2 === void 0 ? t4 : r2;
    };
    rr = function(e8, n2) {
      return e8 != null && n2 in Object(e8);
    };
    or = function(e8, n2, t4) {
      for (var r2 = -1, o2 = (n2 = Zt(n2, e8)).length, i2 = false; ++r2 < o2; ) {
        var a2 = er(n2[r2]);
        if (!(i2 = e8 != null && t4(e8, a2)))
          break;
        e8 = e8[a2];
      }
      return i2 || ++r2 != o2 ? i2 : !!(o2 = e8 == null ? 0 : e8.length) && Ue(o2) && Fe(a2, o2) && (Te(e8) || Re(e8));
    };
    ir = function(e8, n2) {
      return e8 != null && or(e8, n2, rr);
    };
    ar = function(e8, n2) {
      return Ut(e8) && Lt(n2) ? Tt(er(e8), n2) : function(t4) {
        var r2 = tr(t4, e8);
        return r2 === void 0 && r2 === n2 ? ir(t4, e8) : Bt(n2, r2, 3);
      };
    };
    ur = function(e8) {
      return function(n2) {
        return n2 == null ? void 0 : n2[e8];
      };
    };
    cr = function(e8) {
      return function(n2) {
        return nr(n2, e8);
      };
    };
    sr = function(e8) {
      return Ut(e8) ? ur(er(e8)) : cr(e8);
    };
    dr = function(e8) {
      return typeof e8 == "function" ? e8 : e8 == null ? ht : typeof e8 == "object" ? Te(e8) ? ar(e8[0], e8[1]) : Dt(e8) : sr(e8);
    };
    fr = function(e8, n2) {
      return (Te(e8) ? vn : gt)(e8, dr(n2));
    };
    hr = Object.prototype.hasOwnProperty;
    lr = function(e8, n2) {
      return e8 != null && hr.call(e8, n2);
    };
    vr = function(e8, n2) {
      return e8 != null && or(e8, n2, lr);
    };
    pr = Object.prototype.hasOwnProperty;
    gr = function(e8) {
      if (e8 == null)
        return true;
      if (rn(e8) && (Te(e8) || typeof e8 == "string" || typeof e8.splice == "function" || Pe(e8) || Ye(e8) || Re(e8)))
        return !e8.length;
      var n2 = Tn(e8);
      if (n2 == "[object Map]" || n2 == "[object Set]")
        return !e8.size;
      if (Qe(e8))
        return !tn(e8).length;
      for (var t4 in e8)
        if (pr.call(e8, t4))
          return false;
      return true;
    };
    yr = function(e8) {
      return e8 === void 0;
    };
    br = function(e8, n2) {
      var t4 = -1, r2 = rn(e8) ? Array(e8.length) : [];
      return ft(e8, function(e9, o2, i2) {
        r2[++t4] = n2(e9, o2, i2);
      }), r2;
    };
    mr = function(e8, n2) {
      return (Te(e8) ? Yt : br)(e8, dr(n2));
    };
    wr = function(e8, n2, t4, r2) {
      var o2 = -1, i2 = e8 == null ? 0 : e8.length;
      for (r2 && i2 && (t4 = e8[++o2]); ++o2 < i2; )
        t4 = n2(t4, e8[o2], o2, e8);
      return t4;
    };
    Er = function(e8, n2, t4, r2, o2) {
      return o2(e8, function(e9, o3, i2) {
        t4 = r2 ? (r2 = false, e9) : n2(t4, e9, o3, i2);
      }), t4;
    };
    _r = function(e8, n2, t4) {
      var r2 = Te(e8) ? wr : Er, o2 = arguments.length < 3;
      return r2(e8, dr(n2), t4, o2, ft);
    };
    jr = function(e8) {
      return typeof e8 == "string" || !Te(e8) && Ce(e8) && T(e8) == "[object String]";
    };
    xr = ur("length");
    Nr = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
    Or = function(e8) {
      return Nr.test(e8);
    };
    kr = "[\\ud800-\\udfff]";
    Ir = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]";
    Sr = "\\ud83c[\\udffb-\\udfff]";
    Mr = "[^\\ud800-\\udfff]";
    Cr = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    Gr = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    Br = "(?:" + Ir + "|" + Sr + ")?";
    Ar = "[\\ufe0e\\ufe0f]?" + Br + ("(?:\\u200d(?:" + [Mr, Cr, Gr].join("|") + ")[\\ufe0e\\ufe0f]?" + Br + ")*");
    Lr = "(?:" + [Mr + Ir + "?", Ir, Cr, Gr, kr].join("|") + ")";
    Rr = RegExp(Sr + "(?=" + Sr + ")|" + Lr + Ar, "g");
    Tr = function(e8) {
      for (var n2 = Rr.lastIndex = 0; Rr.test(e8); )
        ++n2;
      return n2;
    };
    Dr = function(e8) {
      return Or(e8) ? Tr(e8) : xr(e8);
    };
    Pr = function(e8) {
      if (e8 == null)
        return 0;
      if (rn(e8))
        return jr(e8) ? Dr(e8) : e8.length;
      var n2 = Tn(e8);
      return n2 == "[object Map]" || n2 == "[object Set]" ? e8.size : tn(e8).length;
    };
    zr = function(e8, n2, t4) {
      var r2 = Te(e8), o2 = r2 || Pe(e8) || Ye(e8);
      if (n2 = dr(n2), t4 == null) {
        var i2 = e8 && e8.constructor;
        t4 = o2 ? r2 ? new i2() : [] : D2(e8) && z(i2) ? Kn(En(e8)) : {};
      }
      return (o2 ? xe : dt)(e8, function(e9, r3, o3) {
        return n2(t4, e9, r3, o3);
      }), t4;
    };
    Fr = I ? I.isConcatSpreadable : void 0;
    Ur = function(e8) {
      return Te(e8) || Re(e8) || !!(Fr && e8 && e8[Fr]);
    };
    Vr = function e5(n2, t4, r2, o2, i2) {
      var a2 = -1, u2 = n2.length;
      for (r2 || (r2 = Ur), i2 || (i2 = []); ++a2 < u2; ) {
        var c2 = n2[a2];
        t4 > 0 && r2(c2) ? t4 > 1 ? e5(c2, t4 - 1, r2, o2, i2) : wn(i2, c2) : o2 || (i2[i2.length] = c2);
      }
      return i2;
    };
    $r = function(e8, n2, t4) {
      switch (t4.length) {
        case 0:
          return e8.call(n2);
        case 1:
          return e8.call(n2, t4[0]);
        case 2:
          return e8.call(n2, t4[0], t4[1]);
        case 3:
          return e8.call(n2, t4[0], t4[1], t4[2]);
      }
      return e8.apply(n2, t4);
    };
    Hr = Math.max;
    Wr = function(e8, n2, t4) {
      return n2 = Hr(n2 === void 0 ? e8.length - 1 : n2, 0), function() {
        for (var r2 = arguments, o2 = -1, i2 = Hr(r2.length - n2, 0), a2 = Array(i2); ++o2 < i2; )
          a2[o2] = r2[n2 + o2];
        o2 = -1;
        for (var u2 = Array(n2 + 1); ++o2 < n2; )
          u2[o2] = r2[o2];
        return u2[n2] = t4(a2), $r(e8, this, u2);
      };
    };
    qr = Ne ? function(e8, n2) {
      return Ne(e8, "toString", { configurable: true, enumerable: false, value: ct(n2), writable: true });
    } : ht;
    Yr = Date.now;
    Jr = function(e8) {
      var n2 = 0, t4 = 0;
      return function() {
        var r2 = Yr(), o2 = 16 - (r2 - t4);
        if (t4 = r2, o2 > 0) {
          if (++n2 >= 800)
            return arguments[0];
        } else
          n2 = 0;
        return e8.apply(void 0, arguments);
      };
    }(qr);
    Xr = function(e8, n2) {
      return Jr(Wr(e8, n2, ht), e8 + "");
    };
    Kr = function(e8, n2, t4, r2) {
      for (var o2 = e8.length, i2 = t4 + (r2 ? 1 : -1); r2 ? i2-- : ++i2 < o2; )
        if (n2(e8[i2], i2, e8))
          return i2;
      return -1;
    };
    Qr = function(e8) {
      return e8 != e8;
    };
    Zr = function(e8, n2, t4) {
      for (var r2 = t4 - 1, o2 = e8.length; ++r2 < o2; )
        if (e8[r2] === n2)
          return r2;
      return -1;
    };
    eo = function(e8, n2, t4) {
      return n2 == n2 ? Zr(e8, n2, t4) : Kr(e8, Qr, t4);
    };
    no = function(e8, n2) {
      return !!(e8 == null ? 0 : e8.length) && eo(e8, n2, 0) > -1;
    };
    to = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8 == null ? 0 : e8.length; ++r2 < o2; )
        if (t4(n2, e8[r2]))
          return true;
      return false;
    };
    ro = function() {
    };
    oo = Sn && 1 / Nt(new Sn([, -0]))[1] == 1 / 0 ? function(e8) {
      return new Sn(e8);
    } : ro;
    io = function(e8, n2, t4) {
      var r2 = -1, o2 = no, i2 = e8.length, a2 = true, u2 = [], c2 = u2;
      if (t4)
        a2 = false, o2 = to;
      else if (i2 >= 200) {
        var s2 = n2 ? null : oo(e8);
        if (s2)
          return Nt(s2);
        a2 = false, o2 = _t, c2 = new wt();
      } else
        c2 = n2 ? [] : u2;
      e:
        for (; ++r2 < i2; ) {
          var d2 = e8[r2], f2 = n2 ? n2(d2) : d2;
          if (d2 = t4 || d2 !== 0 ? d2 : 0, a2 && f2 == f2) {
            for (var h2 = c2.length; h2--; )
              if (c2[h2] === f2)
                continue e;
            n2 && c2.push(f2), u2.push(d2);
          } else
            o2(c2, f2, t4) || (c2 !== u2 && c2.push(f2), u2.push(d2));
        }
      return u2;
    };
    ao = function(e8) {
      return Ce(e8) && rn(e8);
    };
    uo = Xr(function(e8) {
      return io(Vr(e8, 1, ao, true));
    });
    co = function(e8, n2) {
      return Yt(n2, function(n3) {
        return e8[n3];
      });
    };
    fo = function(e8) {
      return e8 == null ? [] : co(e8, on(e8));
    };
    try {
      so = { clone: ut, constant: ct, each: pt, filter: fr, has: vr, isArray: Te, isEmpty: gr, isFunction: z, isUndefined: yr, keys: on, map: mr, reduce: _r, size: Pr, transform: zr, union: uo, values: fo };
    } catch (e8) {
    }
    so || (so = window._);
    ho = so;
    lo = vo;
    vo.prototype._nodeCount = 0, vo.prototype._edgeCount = 0, vo.prototype.isDirected = function() {
      return this._isDirected;
    }, vo.prototype.isMultigraph = function() {
      return this._isMultigraph;
    }, vo.prototype.isCompound = function() {
      return this._isCompound;
    }, vo.prototype.setGraph = function(e8) {
      return this._label = e8, this;
    }, vo.prototype.graph = function() {
      return this._label;
    }, vo.prototype.setDefaultNodeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultNodeLabelFn = e8, this;
    }, vo.prototype.nodeCount = function() {
      return this._nodeCount;
    }, vo.prototype.nodes = function() {
      return ho.keys(this._nodes);
    }, vo.prototype.sources = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._in[n2]);
      });
    }, vo.prototype.sinks = function() {
      var e8 = this;
      return ho.filter(this.nodes(), function(n2) {
        return ho.isEmpty(e8._out[n2]);
      });
    }, vo.prototype.setNodes = function(e8, n2) {
      var t4 = arguments, r2 = this;
      return ho.each(e8, function(e9) {
        t4.length > 1 ? r2.setNode(e9, n2) : r2.setNode(e9);
      }), this;
    }, vo.prototype.setNode = function(e8, n2) {
      return ho.has(this._nodes, e8) ? (arguments.length > 1 && (this._nodes[e8] = n2), this) : (this._nodes[e8] = arguments.length > 1 ? n2 : this._defaultNodeLabelFn(e8), this._isCompound && (this._parent[e8] = "\0", this._children[e8] = {}, this._children["\0"][e8] = true), this._in[e8] = {}, this._preds[e8] = {}, this._out[e8] = {}, this._sucs[e8] = {}, ++this._nodeCount, this);
    }, vo.prototype.node = function(e8) {
      return this._nodes[e8];
    }, vo.prototype.hasNode = function(e8) {
      return ho.has(this._nodes, e8);
    }, vo.prototype.removeNode = function(e8) {
      var n2 = this;
      if (ho.has(this._nodes, e8)) {
        var t4 = function(e9) {
          n2.removeEdge(n2._edgeObjs[e9]);
        };
        delete this._nodes[e8], this._isCompound && (this._removeFromParentsChildList(e8), delete this._parent[e8], ho.each(this.children(e8), function(e9) {
          n2.setParent(e9);
        }), delete this._children[e8]), ho.each(ho.keys(this._in[e8]), t4), delete this._in[e8], delete this._preds[e8], ho.each(ho.keys(this._out[e8]), t4), delete this._out[e8], delete this._sucs[e8], --this._nodeCount;
      }
      return this;
    }, vo.prototype.setParent = function(e8, n2) {
      if (!this._isCompound)
        throw new Error("Cannot set parent in a non-compound graph");
      if (ho.isUndefined(n2))
        n2 = "\0";
      else {
        for (var t4 = n2 += ""; !ho.isUndefined(t4); t4 = this.parent(t4))
          if (t4 === e8)
            throw new Error("Setting " + n2 + " as parent of " + e8 + " would create a cycle");
        this.setNode(n2);
      }
      return this.setNode(e8), this._removeFromParentsChildList(e8), this._parent[e8] = n2, this._children[n2][e8] = true, this;
    }, vo.prototype._removeFromParentsChildList = function(e8) {
      delete this._children[this._parent[e8]][e8];
    }, vo.prototype.parent = function(e8) {
      if (this._isCompound) {
        var n2 = this._parent[e8];
        if (n2 !== "\0")
          return n2;
      }
    }, vo.prototype.children = function(e8) {
      if (ho.isUndefined(e8) && (e8 = "\0"), this._isCompound) {
        var n2 = this._children[e8];
        if (n2)
          return ho.keys(n2);
      } else {
        if (e8 === "\0")
          return this.nodes();
        if (this.hasNode(e8))
          return [];
      }
    }, vo.prototype.predecessors = function(e8) {
      var n2 = this._preds[e8];
      if (n2)
        return ho.keys(n2);
    }, vo.prototype.successors = function(e8) {
      var n2 = this._sucs[e8];
      if (n2)
        return ho.keys(n2);
    }, vo.prototype.neighbors = function(e8) {
      var n2 = this.predecessors(e8);
      if (n2)
        return ho.union(n2, this.successors(e8));
    }, vo.prototype.isLeaf = function(e8) {
      return (this.isDirected() ? this.successors(e8) : this.neighbors(e8)).length === 0;
    }, vo.prototype.filterNodes = function(e8) {
      var n2 = new this.constructor({ directed: this._isDirected, multigraph: this._isMultigraph, compound: this._isCompound });
      n2.setGraph(this.graph());
      var t4 = this;
      ho.each(this._nodes, function(t5, r3) {
        e8(r3) && n2.setNode(r3, t5);
      }), ho.each(this._edgeObjs, function(e9) {
        n2.hasNode(e9.v) && n2.hasNode(e9.w) && n2.setEdge(e9, t4.edge(e9));
      });
      var r2 = {};
      function o2(e9) {
        var i2 = t4.parent(e9);
        return i2 === void 0 || n2.hasNode(i2) ? (r2[e9] = i2, i2) : i2 in r2 ? r2[i2] : o2(i2);
      }
      return this._isCompound && ho.each(n2.nodes(), function(e9) {
        n2.setParent(e9, o2(e9));
      }), n2;
    }, vo.prototype.setDefaultEdgeLabel = function(e8) {
      return ho.isFunction(e8) || (e8 = ho.constant(e8)), this._defaultEdgeLabelFn = e8, this;
    }, vo.prototype.edgeCount = function() {
      return this._edgeCount;
    }, vo.prototype.edges = function() {
      return ho.values(this._edgeObjs);
    }, vo.prototype.setPath = function(e8, n2) {
      var t4 = this, r2 = arguments;
      return ho.reduce(e8, function(e9, o2) {
        return r2.length > 1 ? t4.setEdge(e9, o2, n2) : t4.setEdge(e9, o2), o2;
      }), this;
    }, vo.prototype.setEdge = function() {
      var e8, n2, t4, r2, o2 = false, i2 = arguments[0];
      typeof i2 == "object" && i2 !== null && "v" in i2 ? (e8 = i2.v, n2 = i2.w, t4 = i2.name, arguments.length === 2 && (r2 = arguments[1], o2 = true)) : (e8 = i2, n2 = arguments[1], t4 = arguments[3], arguments.length > 2 && (r2 = arguments[2], o2 = true)), e8 = "" + e8, n2 = "" + n2, ho.isUndefined(t4) || (t4 = "" + t4);
      var a2 = yo(this._isDirected, e8, n2, t4);
      if (ho.has(this._edgeLabels, a2))
        return o2 && (this._edgeLabels[a2] = r2), this;
      if (!ho.isUndefined(t4) && !this._isMultigraph)
        throw new Error("Cannot set a named edge when isMultigraph = false");
      this.setNode(e8), this.setNode(n2), this._edgeLabels[a2] = o2 ? r2 : this._defaultEdgeLabelFn(e8, n2, t4);
      var u2 = bo(this._isDirected, e8, n2, t4);
      return e8 = u2.v, n2 = u2.w, Object.freeze(u2), this._edgeObjs[a2] = u2, po(this._preds[n2], e8), po(this._sucs[e8], n2), this._in[n2][a2] = u2, this._out[e8][a2] = u2, this._edgeCount++, this;
    }, vo.prototype.edge = function(e8, n2, t4) {
      var r2 = arguments.length === 1 ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4);
      return this._edgeLabels[r2];
    }, vo.prototype.hasEdge = function(e8, n2, t4) {
      var r2 = arguments.length === 1 ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4);
      return ho.has(this._edgeLabels, r2);
    }, vo.prototype.removeEdge = function(e8, n2, t4) {
      var r2 = arguments.length === 1 ? mo(this._isDirected, arguments[0]) : yo(this._isDirected, e8, n2, t4), o2 = this._edgeObjs[r2];
      return o2 && (e8 = o2.v, n2 = o2.w, delete this._edgeLabels[r2], delete this._edgeObjs[r2], go(this._preds[n2], e8), go(this._sucs[e8], n2), delete this._in[n2][r2], delete this._out[e8][r2], this._edgeCount--), this;
    }, vo.prototype.inEdges = function(e8, n2) {
      var t4 = this._in[e8];
      if (t4) {
        var r2 = ho.values(t4);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.v === n2;
        }) : r2;
      }
    }, vo.prototype.outEdges = function(e8, n2) {
      var t4 = this._out[e8];
      if (t4) {
        var r2 = ho.values(t4);
        return n2 ? ho.filter(r2, function(e9) {
          return e9.w === n2;
        }) : r2;
      }
    }, vo.prototype.nodeEdges = function(e8, n2) {
      var t4 = this.inEdges(e8, n2);
      if (t4)
        return t4.concat(this.outEdges(e8, n2));
    };
    wo = { Graph: lo, version: "2.1.8" };
    Eo = { write: function(e8) {
      var n2 = { options: { directed: e8.isDirected(), multigraph: e8.isMultigraph(), compound: e8.isCompound() }, nodes: _o(e8), edges: jo(e8) };
      ho.isUndefined(e8.graph()) || (n2.value = ho.clone(e8.graph()));
      return n2;
    }, read: function(e8) {
      var n2 = new lo(e8.options).setGraph(e8.value);
      return ho.each(e8.nodes, function(e9) {
        n2.setNode(e9.v, e9.value), e9.parent && n2.setParent(e9.v, e9.parent);
      }), ho.each(e8.edges, function(e9) {
        n2.setEdge({ v: e9.v, w: e9.w, name: e9.name }, e9.value);
      }), n2;
    } };
    xo = function(e8) {
      var n2, t4 = {}, r2 = [];
      function o2(r3) {
        ho.has(t4, r3) || (t4[r3] = true, n2.push(r3), ho.each(e8.successors(r3), o2), ho.each(e8.predecessors(r3), o2));
      }
      return ho.each(e8.nodes(), function(e9) {
        n2 = [], o2(e9), n2.length && r2.push(n2);
      }), r2;
    };
    No = Oo;
    Oo.prototype.size = function() {
      return this._arr.length;
    }, Oo.prototype.keys = function() {
      return this._arr.map(function(e8) {
        return e8.key;
      });
    }, Oo.prototype.has = function(e8) {
      return ho.has(this._keyIndices, e8);
    }, Oo.prototype.priority = function(e8) {
      var n2 = this._keyIndices[e8];
      if (n2 !== void 0)
        return this._arr[n2].priority;
    }, Oo.prototype.min = function() {
      if (this.size() === 0)
        throw new Error("Queue underflow");
      return this._arr[0].key;
    }, Oo.prototype.add = function(e8, n2) {
      var t4 = this._keyIndices;
      if (e8 = String(e8), !ho.has(t4, e8)) {
        var r2 = this._arr, o2 = r2.length;
        return t4[e8] = o2, r2.push({ key: e8, priority: n2 }), this._decrease(o2), true;
      }
      return false;
    }, Oo.prototype.removeMin = function() {
      this._swap(0, this._arr.length - 1);
      var e8 = this._arr.pop();
      return delete this._keyIndices[e8.key], this._heapify(0), e8.key;
    }, Oo.prototype.decrease = function(e8, n2) {
      var t4 = this._keyIndices[e8];
      if (n2 > this._arr[t4].priority)
        throw new Error("New priority is greater than current priority. Key: " + e8 + " Old: " + this._arr[t4].priority + " New: " + n2);
      this._arr[t4].priority = n2, this._decrease(t4);
    }, Oo.prototype._heapify = function(e8) {
      var n2 = this._arr, t4 = 2 * e8, r2 = t4 + 1, o2 = e8;
      t4 < n2.length && (o2 = n2[t4].priority < n2[o2].priority ? t4 : o2, r2 < n2.length && (o2 = n2[r2].priority < n2[o2].priority ? r2 : o2), o2 !== e8 && (this._swap(e8, o2), this._heapify(o2)));
    }, Oo.prototype._decrease = function(e8) {
      for (var n2, t4 = this._arr, r2 = t4[e8].priority; e8 !== 0 && !(t4[n2 = e8 >> 1].priority < r2); )
        this._swap(e8, n2), e8 = n2;
    }, Oo.prototype._swap = function(e8, n2) {
      var t4 = this._arr, r2 = this._keyIndices, o2 = t4[e8], i2 = t4[n2];
      t4[e8] = i2, t4[n2] = o2, r2[i2.key] = e8, r2[o2.key] = n2;
    };
    ko = function(e8, n2, t4, r2) {
      return function(e9, n3, t5, r3) {
        var o2, i2, a2 = {}, u2 = new No(), c2 = function(e11) {
          var n4 = e11.v !== o2 ? e11.v : e11.w, r4 = a2[n4], c3 = t5(e11), s2 = i2.distance + c3;
          if (c3 < 0)
            throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + e11 + " Weight: " + c3);
          s2 < r4.distance && (r4.distance = s2, r4.predecessor = o2, u2.decrease(n4, s2));
        };
        e9.nodes().forEach(function(e11) {
          var t6 = e11 === n3 ? 0 : Number.POSITIVE_INFINITY;
          a2[e11] = { distance: t6 }, u2.add(e11, t6);
        });
        for (; u2.size() > 0 && (o2 = u2.removeMin(), (i2 = a2[o2]).distance !== Number.POSITIVE_INFINITY); )
          r3(o2).forEach(c2);
        return a2;
      }(e8, String(n2), t4 || Io, r2 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Io = ho.constant(1);
    So = function(e8, n2, t4) {
      return ho.transform(e8.nodes(), function(r2, o2) {
        r2[o2] = ko(e8, o2, n2, t4);
      }, {});
    };
    Mo = function(e8) {
      var n2 = 0, t4 = [], r2 = {}, o2 = [];
      function i2(a2) {
        var u2 = r2[a2] = { onStack: true, lowlink: n2, index: n2++ };
        if (t4.push(a2), e8.successors(a2).forEach(function(e9) {
          ho.has(r2, e9) ? r2[e9].onStack && (u2.lowlink = Math.min(u2.lowlink, r2[e9].index)) : (i2(e9), u2.lowlink = Math.min(u2.lowlink, r2[e9].lowlink));
        }), u2.lowlink === u2.index) {
          var c2, s2 = [];
          do {
            c2 = t4.pop(), r2[c2].onStack = false, s2.push(c2);
          } while (a2 !== c2);
          o2.push(s2);
        }
      }
      return e8.nodes().forEach(function(e9) {
        ho.has(r2, e9) || i2(e9);
      }), o2;
    };
    Co = function(e8) {
      return ho.filter(Mo(e8), function(n2) {
        return n2.length > 1 || n2.length === 1 && e8.hasEdge(n2[0], n2[0]);
      });
    };
    Go = function(e8, n2, t4) {
      return function(e9, n3, t5) {
        var r2 = {}, o2 = e9.nodes();
        return o2.forEach(function(e11) {
          r2[e11] = {}, r2[e11][e11] = { distance: 0 }, o2.forEach(function(n4) {
            e11 !== n4 && (r2[e11][n4] = { distance: Number.POSITIVE_INFINITY });
          }), t5(e11).forEach(function(t6) {
            var o3 = t6.v === e11 ? t6.w : t6.v, i2 = n3(t6);
            r2[e11][o3] = { distance: i2, predecessor: e11 };
          });
        }), o2.forEach(function(e11) {
          var n4 = r2[e11];
          o2.forEach(function(t6) {
            var i2 = r2[t6];
            o2.forEach(function(t7) {
              var r3 = i2[e11], o3 = n4[t7], a2 = i2[t7], u2 = r3.distance + o3.distance;
              u2 < a2.distance && (a2.distance = u2, a2.predecessor = o3.predecessor);
            });
          });
        }), r2;
      }(e8, n2 || Bo, t4 || function(n3) {
        return e8.outEdges(n3);
      });
    };
    Bo = ho.constant(1);
    Ao = Lo;
    Lo.CycleException = Ro, Ro.prototype = new Error();
    To = function(e8, n2, t4) {
      ho.isArray(n2) || (n2 = [n2]);
      var r2 = (e8.isDirected() ? e8.successors : e8.neighbors).bind(e8), o2 = [], i2 = {};
      return ho.each(n2, function(n3) {
        if (!e8.hasNode(n3))
          throw new Error("Graph does not have node: " + n3);
        Do(e8, n3, t4 === "post", i2, r2, o2);
      }), o2;
    };
    zo = { Graph: wo.Graph, json: Eo, alg: { components: xo, dijkstra: ko, dijkstraAll: So, findCycles: Co, floydWarshall: Go, isAcyclic: function(e8) {
      try {
        Ao(e8);
      } catch (e9) {
        if (e9 instanceof Ao.CycleException)
          return false;
        throw e9;
      }
      return true;
    }, postorder: function(e8, n2) {
      return To(e8, n2, "post");
    }, preorder: function(e8, n2) {
      return To(e8, n2, "pre");
    }, prim: function(e8, n2) {
      var t4, r2 = new lo(), o2 = {}, i2 = new No();
      function a2(e9) {
        var r3 = e9.v === t4 ? e9.w : e9.v, a3 = i2.priority(r3);
        if (a3 !== void 0) {
          var u3 = n2(e9);
          u3 < a3 && (o2[r3] = t4, i2.decrease(r3, u3));
        }
      }
      if (e8.nodeCount() === 0)
        return r2;
      ho.each(e8.nodes(), function(e9) {
        i2.add(e9, Number.POSITIVE_INFINITY), r2.setNode(e9);
      }), i2.decrease(e8.nodes()[0], 0);
      var u2 = false;
      for (; i2.size() > 0; ) {
        if (t4 = i2.removeMin(), ho.has(o2, t4))
          r2.setEdge(t4, o2[t4]);
        else {
          if (u2)
            throw new Error("Input graph is not connected: " + e8);
          u2 = true;
        }
        e8.nodeEdges(t4).forEach(a2);
      }
      return r2;
    }, tarjan: Mo, topsort: Ao }, version: wo.version };
    try {
      Po = zo;
    } catch (e8) {
    }
    Po || (Po = window.graphlib);
    Fo = Po;
    Uo = function(e8) {
      return at(e8, 5);
    };
    Vo = function(e8, n2, t4) {
      if (!D2(t4))
        return false;
      var r2 = typeof n2;
      return !!(r2 == "number" ? rn(t4) && Fe(n2, t4.length) : r2 == "string" && n2 in t4) && h(t4[n2], e8);
    };
    $o = Object.prototype;
    Ho = $o.hasOwnProperty;
    Wo = Xr(function(e8, n2) {
      e8 = Object(e8);
      var t4 = -1, r2 = n2.length, o2 = r2 > 2 ? n2[2] : void 0;
      for (o2 && Vo(n2[0], n2[1], o2) && (r2 = 1); ++t4 < r2; )
        for (var i2 = n2[t4], a2 = dn(i2), u2 = -1, c2 = a2.length; ++u2 < c2; ) {
          var s2 = a2[u2], d2 = e8[s2];
          (d2 === void 0 || h(d2, $o[s2]) && !Ho.call(e8, s2)) && (e8[s2] = i2[s2]);
        }
      return e8;
    });
    qo = function(e8) {
      return function(n2, t4, r2) {
        var o2 = Object(n2);
        if (!rn(n2)) {
          var i2 = dr(t4);
          n2 = on(n2), t4 = function(e9) {
            return i2(o2[e9], e9, o2);
          };
        }
        var a2 = e8(n2, t4, r2);
        return a2 > -1 ? o2[i2 ? n2[a2] : a2] : void 0;
      };
    };
    Yo = /^\s+|\s+$/g;
    Jo = /^[-+]0x[0-9a-f]+$/i;
    Xo = /^0b[01]+$/i;
    Ko = /^0o[0-7]+$/i;
    Qo = parseInt;
    Zo = function(e8) {
      if (typeof e8 == "number")
        return e8;
      if (Pt(e8))
        return NaN;
      if (D2(e8)) {
        var n2 = typeof e8.valueOf == "function" ? e8.valueOf() : e8;
        e8 = D2(n2) ? n2 + "" : n2;
      }
      if (typeof e8 != "string")
        return e8 === 0 ? e8 : +e8;
      e8 = e8.replace(Yo, "");
      var t4 = Xo.test(e8);
      return t4 || Ko.test(e8) ? Qo(e8.slice(2), t4 ? 2 : 8) : Jo.test(e8) ? NaN : +e8;
    };
    ei = function(e8) {
      return e8 ? (e8 = Zo(e8)) === Infinity || e8 === -Infinity ? 17976931348623157e292 * (e8 < 0 ? -1 : 1) : e8 == e8 ? e8 : 0 : e8 === 0 ? e8 : 0;
    };
    ni = function(e8) {
      var n2 = ei(e8), t4 = n2 % 1;
      return n2 == n2 ? t4 ? n2 - t4 : n2 : 0;
    };
    ti = Math.max;
    ri = qo(function(e8, n2, t4) {
      var r2 = e8 == null ? 0 : e8.length;
      if (!r2)
        return -1;
      var o2 = t4 == null ? 0 : ni(t4);
      return o2 < 0 && (o2 = ti(r2 + o2, 0)), Kr(e8, dr(n2), o2);
    });
    oi = function(e8) {
      return (e8 == null ? 0 : e8.length) ? Vr(e8, 1) : [];
    };
    ii = function(e8, n2) {
      return e8 == null ? e8 : st(e8, lt(n2), dn);
    };
    ai = function(e8) {
      var n2 = e8 == null ? 0 : e8.length;
      return n2 ? e8[n2 - 1] : void 0;
    };
    ui = function(e8, n2) {
      var t4 = {};
      return n2 = dr(n2), dt(e8, function(e9, r2, o2) {
        Oe(t4, r2, n2(e9, r2, o2));
      }), t4;
    };
    ci = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.length; ++r2 < o2; ) {
        var i2 = e8[r2], a2 = n2(i2);
        if (a2 != null && (u2 === void 0 ? a2 == a2 && !Pt(a2) : t4(a2, u2)))
          var u2 = a2, c2 = i2;
      }
      return c2;
    };
    si = function(e8, n2) {
      return e8 > n2;
    };
    di = function(e8) {
      return e8 && e8.length ? ci(e8, ht, si) : void 0;
    };
    fi = function(e8, n2, t4) {
      (t4 !== void 0 && !h(e8[n2], t4) || t4 === void 0 && !(n2 in e8)) && Oe(e8, n2, t4);
    };
    hi = Function.prototype;
    li = Object.prototype;
    vi = hi.toString;
    pi2 = li.hasOwnProperty;
    gi = vi.call(Object);
    yi = function(e8) {
      if (!Ce(e8) || T(e8) != "[object Object]")
        return false;
      var n2 = En(e8);
      if (n2 === null)
        return true;
      var t4 = pi2.call(n2, "constructor") && n2.constructor;
      return typeof t4 == "function" && t4 instanceof t4 && vi.call(t4) == gi;
    };
    bi = function(e8, n2) {
      if ((n2 !== "constructor" || typeof e8[n2] != "function") && n2 != "__proto__")
        return e8[n2];
    };
    mi = function(e8) {
      return Se(e8, dn(e8));
    };
    wi = function(e8, n2, t4, r2, o2, i2, a2) {
      var u2 = bi(e8, t4), c2 = bi(n2, t4), s2 = a2.get(c2);
      if (s2)
        fi(e8, t4, s2);
      else {
        var d2 = i2 ? i2(u2, c2, t4 + "", e8, n2, a2) : void 0, f2 = d2 === void 0;
        if (f2) {
          var h2 = Te(c2), l2 = !h2 && Pe(c2), v2 = !h2 && !l2 && Ye(c2);
          d2 = c2, h2 || l2 || v2 ? Te(u2) ? d2 = u2 : ao(u2) ? d2 = ln2(u2) : l2 ? (f2 = false, d2 = hn(c2, true)) : v2 ? (f2 = false, d2 = Yn2(c2, true)) : d2 = [] : yi(c2) || Re(c2) ? (d2 = u2, Re(u2) ? d2 = mi(u2) : D2(u2) && !z(u2) || (d2 = Qn(c2))) : f2 = false;
        }
        f2 && (a2.set(c2, d2), o2(d2, c2, r2, i2, a2), a2.delete(c2)), fi(e8, t4, d2);
      }
    };
    Ei = function e6(n2, t4, r2, o2, i2) {
      n2 !== t4 && st(t4, function(a2, u2) {
        if (i2 || (i2 = new je()), D2(a2))
          wi(n2, t4, u2, r2, e6, o2, i2);
        else {
          var c2 = o2 ? o2(bi(n2, u2), a2, u2 + "", n2, t4, i2) : void 0;
          c2 === void 0 && (c2 = a2), fi(n2, u2, c2);
        }
      }, dn);
    };
    _i = function(e8) {
      return Xr(function(n2, t4) {
        var r2 = -1, o2 = t4.length, i2 = o2 > 1 ? t4[o2 - 1] : void 0, a2 = o2 > 2 ? t4[2] : void 0;
        for (i2 = e8.length > 3 && typeof i2 == "function" ? (o2--, i2) : void 0, a2 && Vo(t4[0], t4[1], a2) && (i2 = o2 < 3 ? void 0 : i2, o2 = 1), n2 = Object(n2); ++r2 < o2; ) {
          var u2 = t4[r2];
          u2 && e8(n2, u2, r2, i2);
        }
        return n2;
      });
    }(function(e8, n2, t4) {
      Ei(e8, n2, t4);
    });
    ji = function(e8, n2) {
      return e8 < n2;
    };
    xi = function(e8) {
      return e8 && e8.length ? ci(e8, ht, ji) : void 0;
    };
    Ni = function(e8, n2) {
      return e8 && e8.length ? ci(e8, dr(n2), ji) : void 0;
    };
    Oi = function() {
      return k.Date.now();
    };
    ki = function(e8, n2, t4, r2) {
      if (!D2(e8))
        return e8;
      for (var o2 = -1, i2 = (n2 = Zt(n2, e8)).length, a2 = i2 - 1, u2 = e8; u2 != null && ++o2 < i2; ) {
        var c2 = er(n2[o2]), s2 = t4;
        if (c2 === "__proto__" || c2 === "constructor" || c2 === "prototype")
          return e8;
        if (o2 != a2) {
          var d2 = u2[c2];
          (s2 = r2 ? r2(d2, c2, u2) : void 0) === void 0 && (s2 = D2(d2) ? d2 : Fe(n2[o2 + 1]) ? [] : {});
        }
        Ie(u2, c2, s2), u2 = u2[c2];
      }
      return e8;
    };
    Ii = function(e8, n2, t4) {
      for (var r2 = -1, o2 = n2.length, i2 = {}; ++r2 < o2; ) {
        var a2 = n2[r2], u2 = nr(e8, a2);
        t4(u2, a2) && ki(i2, Zt(a2, e8), u2);
      }
      return i2;
    };
    Si = function(e8, n2) {
      return Ii(e8, n2, function(n3, t4) {
        return ir(e8, t4);
      });
    };
    Mi = function(e8) {
      return Jr(Wr(e8, void 0, oi), e8 + "");
    }(function(e8, n2) {
      return e8 == null ? {} : Si(e8, n2);
    });
    Ci = Math.ceil;
    Gi = Math.max;
    Bi = function(e8, n2, t4, r2) {
      for (var o2 = -1, i2 = Gi(Ci((n2 - e8) / (t4 || 1)), 0), a2 = Array(i2); i2--; )
        a2[r2 ? i2 : ++o2] = e8, e8 += t4;
      return a2;
    };
    Ai = function(e8) {
      return function(n2, t4, r2) {
        return r2 && typeof r2 != "number" && Vo(n2, t4, r2) && (t4 = r2 = void 0), n2 = ei(n2), t4 === void 0 ? (t4 = n2, n2 = 0) : t4 = ei(t4), r2 = r2 === void 0 ? n2 < t4 ? 1 : -1 : ei(r2), Bi(n2, t4, r2, e8);
      };
    }();
    Li = function(e8, n2) {
      var t4 = e8.length;
      for (e8.sort(n2); t4--; )
        e8[t4] = e8[t4].value;
      return e8;
    };
    Ri = function(e8, n2) {
      if (e8 !== n2) {
        var t4 = e8 !== void 0, r2 = e8 === null, o2 = e8 == e8, i2 = Pt(e8), a2 = n2 !== void 0, u2 = n2 === null, c2 = n2 == n2, s2 = Pt(n2);
        if (!u2 && !s2 && !i2 && e8 > n2 || i2 && a2 && c2 && !u2 && !s2 || r2 && a2 && c2 || !t4 && c2 || !o2)
          return 1;
        if (!r2 && !i2 && !s2 && e8 < n2 || s2 && t4 && o2 && !r2 && !i2 || u2 && t4 && o2 || !a2 && o2 || !c2)
          return -1;
      }
      return 0;
    };
    Ti = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.criteria, i2 = n2.criteria, a2 = o2.length, u2 = t4.length; ++r2 < a2; ) {
        var c2 = Ri(o2[r2], i2[r2]);
        if (c2)
          return r2 >= u2 ? c2 : c2 * (t4[r2] == "desc" ? -1 : 1);
      }
      return e8.index - n2.index;
    };
    Di = function(e8, n2, t4) {
      n2 = n2.length ? Yt(n2, function(e9) {
        return Te(e9) ? function(n3) {
          return nr(n3, e9.length === 1 ? e9[0] : e9);
        } : e9;
      }) : [ht];
      var r2 = -1;
      n2 = Yt(n2, He(dr));
      var o2 = br(e8, function(e9, t5, o3) {
        return { criteria: Yt(n2, function(n3) {
          return n3(e9);
        }), index: ++r2, value: e9 };
      });
      return Li(o2, function(e9, n3) {
        return Ti(e9, n3, t4);
      });
    };
    Pi = Xr(function(e8, n2) {
      if (e8 == null)
        return [];
      var t4 = n2.length;
      return t4 > 1 && Vo(e8, n2[0], n2[1]) ? n2 = [] : t4 > 2 && Vo(n2[0], n2[1], n2[2]) && (n2 = [n2[0]]), Di(e8, Vr(n2, 1), []);
    });
    zi = 0;
    Fi = function(e8) {
      var n2 = ++zi;
      return Qt(e8) + n2;
    };
    Ui = function(e8, n2, t4) {
      for (var r2 = -1, o2 = e8.length, i2 = n2.length, a2 = {}; ++r2 < o2; ) {
        var u2 = r2 < i2 ? n2[r2] : void 0;
        t4(a2, e8[r2], u2);
      }
      return a2;
    };
    $i = function(e8, n2) {
      return Ui(e8 || [], n2 || [], Ie);
    };
    try {
      Vi = { cloneDeep: Uo, constant: ct, defaults: Wo, each: pt, filter: fr, find: ri, flatten: oi, forEach: vt, forIn: ii, has: vr, isUndefined: yr, last: ai, map: mr, mapValues: ui, max: di, merge: _i, min: xi, minBy: Ni, now: Oi, pick: Mi, range: Ai, reduce: _r, sortBy: Pi, uniqueId: Fi, values: fo, zipObject: $i };
    } catch (e8) {
    }
    Vi || (Vi = window._);
    Hi = Vi;
    Wi = qi;
    qi.prototype.dequeue = function() {
      var e8 = this._sentinel, n2 = e8._prev;
      if (n2 !== e8)
        return Yi(n2), n2;
    }, qi.prototype.enqueue = function(e8) {
      var n2 = this._sentinel;
      e8._prev && e8._next && Yi(e8), e8._next = n2._next, n2._next._prev = e8, n2._next = e8, e8._prev = n2;
    }, qi.prototype.toString = function() {
      for (var e8 = [], n2 = this._sentinel, t4 = n2._prev; t4 !== n2; )
        e8.push(JSON.stringify(t4, Ji)), t4 = t4._prev;
      return "[" + e8.join(", ") + "]";
    };
    Xi = Fo.Graph;
    Ki = function(e8, n2) {
      if (e8.nodeCount() <= 1)
        return [];
      var t4 = function(e9, n3) {
        var t5 = new Xi(), r3 = 0, o2 = 0;
        Hi.forEach(e9.nodes(), function(e11) {
          t5.setNode(e11, { v: e11, in: 0, out: 0 });
        }), Hi.forEach(e9.edges(), function(e11) {
          var i3 = t5.edge(e11.v, e11.w) || 0, a3 = n3(e11), u2 = i3 + a3;
          t5.setEdge(e11.v, e11.w, u2), o2 = Math.max(o2, t5.node(e11.v).out += a3), r3 = Math.max(r3, t5.node(e11.w).in += a3);
        });
        var i2 = Hi.range(o2 + r3 + 3).map(function() {
          return new Wi();
        }), a2 = r3 + 1;
        return Hi.forEach(t5.nodes(), function(e11) {
          ea(i2, a2, t5.node(e11));
        }), { graph: t5, buckets: i2, zeroIdx: a2 };
      }(e8, n2 || Qi), r2 = function(e9, n3, t5) {
        var r3, o2 = [], i2 = n3[n3.length - 1], a2 = n3[0];
        for (; e9.nodeCount(); ) {
          for (; r3 = a2.dequeue(); )
            Zi(e9, n3, t5, r3);
          for (; r3 = i2.dequeue(); )
            Zi(e9, n3, t5, r3);
          if (e9.nodeCount()) {
            for (var u2 = n3.length - 2; u2 > 0; --u2)
              if (r3 = n3[u2].dequeue()) {
                o2 = o2.concat(Zi(e9, n3, t5, r3, true));
                break;
              }
          }
        }
        return o2;
      }(t4.graph, t4.buckets, t4.zeroIdx);
      return Hi.flatten(Hi.map(r2, function(n3) {
        return e8.outEdges(n3.v, n3.w);
      }), true);
    };
    Qi = Hi.constant(1);
    na = { run: function(e8) {
      var n2 = e8.graph().acyclicer === "greedy" ? Ki(e8, function(e9) {
        return function(n3) {
          return e9.edge(n3).weight;
        };
      }(e8)) : function(e9) {
        var n3 = [], t4 = {}, r2 = {};
        function o2(i2) {
          Hi.has(r2, i2) || (r2[i2] = true, t4[i2] = true, Hi.forEach(e9.outEdges(i2), function(e11) {
            Hi.has(t4, e11.w) ? n3.push(e11) : o2(e11.w);
          }), delete t4[i2]);
        }
        return Hi.forEach(e9.nodes(), o2), n3;
      }(e8);
      Hi.forEach(n2, function(n3) {
        var t4 = e8.edge(n3);
        e8.removeEdge(n3), t4.forwardName = n3.name, t4.reversed = true, e8.setEdge(n3.w, n3.v, t4, Hi.uniqueId("rev"));
      });
    }, undo: function(e8) {
      Hi.forEach(e8.edges(), function(n2) {
        var t4 = e8.edge(n2);
        if (t4.reversed) {
          e8.removeEdge(n2);
          var r2 = t4.forwardName;
          delete t4.reversed, delete t4.forwardName, e8.setEdge(n2.w, n2.v, t4, r2);
        }
      });
    } };
    ta = Fo.Graph;
    ra = { addDummyNode: oa, simplify: function(e8) {
      var n2 = new ta().setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t4) {
        n2.setNode(t4, e8.node(t4));
      }), Hi.forEach(e8.edges(), function(t4) {
        var r2 = n2.edge(t4.v, t4.w) || { weight: 0, minlen: 1 }, o2 = e8.edge(t4);
        n2.setEdge(t4.v, t4.w, { weight: r2.weight + o2.weight, minlen: Math.max(r2.minlen, o2.minlen) });
      }), n2;
    }, asNonCompoundGraph: function(e8) {
      var n2 = new ta({ multigraph: e8.isMultigraph() }).setGraph(e8.graph());
      return Hi.forEach(e8.nodes(), function(t4) {
        e8.children(t4).length || n2.setNode(t4, e8.node(t4));
      }), Hi.forEach(e8.edges(), function(t4) {
        n2.setEdge(t4, e8.edge(t4));
      }), n2;
    }, successorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t4 = {};
        return Hi.forEach(e8.outEdges(n3), function(n4) {
          t4[n4.w] = (t4[n4.w] || 0) + e8.edge(n4).weight;
        }), t4;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, predecessorWeights: function(e8) {
      var n2 = Hi.map(e8.nodes(), function(n3) {
        var t4 = {};
        return Hi.forEach(e8.inEdges(n3), function(n4) {
          t4[n4.v] = (t4[n4.v] || 0) + e8.edge(n4).weight;
        }), t4;
      });
      return Hi.zipObject(e8.nodes(), n2);
    }, intersectRect: function(e8, n2) {
      var t4, r2, o2 = e8.x, i2 = e8.y, a2 = n2.x - o2, u2 = n2.y - i2, c2 = e8.width / 2, s2 = e8.height / 2;
      if (!a2 && !u2)
        throw new Error("Not possible to find intersection inside of the rectangle");
      Math.abs(u2) * c2 > Math.abs(a2) * s2 ? (u2 < 0 && (s2 = -s2), t4 = s2 * a2 / u2, r2 = s2) : (a2 < 0 && (c2 = -c2), t4 = c2, r2 = c2 * u2 / a2);
      return { x: o2 + t4, y: i2 + r2 };
    }, buildLayerMatrix: function(e8) {
      var n2 = Hi.map(Hi.range(ia(e8) + 1), function() {
        return [];
      });
      return Hi.forEach(e8.nodes(), function(t4) {
        var r2 = e8.node(t4), o2 = r2.rank;
        Hi.isUndefined(o2) || (n2[o2][r2.order] = t4);
      }), n2;
    }, normalizeRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      }));
      Hi.forEach(e8.nodes(), function(t4) {
        var r2 = e8.node(t4);
        Hi.has(r2, "rank") && (r2.rank -= n2);
      });
    }, removeEmptyRanks: function(e8) {
      var n2 = Hi.min(Hi.map(e8.nodes(), function(n3) {
        return e8.node(n3).rank;
      })), t4 = [];
      Hi.forEach(e8.nodes(), function(r3) {
        var o3 = e8.node(r3).rank - n2;
        t4[o3] || (t4[o3] = []), t4[o3].push(r3);
      });
      var r2 = 0, o2 = e8.graph().nodeRankFactor;
      Hi.forEach(t4, function(n3, t5) {
        Hi.isUndefined(n3) && t5 % o2 != 0 ? --r2 : r2 && Hi.forEach(n3, function(n4) {
          e8.node(n4).rank += r2;
        });
      });
    }, addBorderNode: function(e8, n2, t4, r2) {
      var o2 = { width: 0, height: 0 };
      arguments.length >= 4 && (o2.rank = t4, o2.order = r2);
      return oa(e8, "border", o2, n2);
    }, maxRank: ia, partition: function(e8, n2) {
      var t4 = { lhs: [], rhs: [] };
      return Hi.forEach(e8, function(e9) {
        n2(e9) ? t4.lhs.push(e9) : t4.rhs.push(e9);
      }), t4;
    }, time: function(e8, n2) {
      var t4 = Hi.now();
      try {
        return n2();
      } finally {
        console.log(e8 + " time: " + (Hi.now() - t4) + "ms");
      }
    }, notime: function(e8, n2) {
      return n2();
    } };
    aa = { run: function(e8) {
      e8.graph().dummyChains = [], Hi.forEach(e8.edges(), function(n2) {
        !function(e9, n3) {
          var t4, r2, o2, i2 = n3.v, a2 = e9.node(i2).rank, u2 = n3.w, c2 = e9.node(u2).rank, s2 = n3.name, d2 = e9.edge(n3), f2 = d2.labelRank;
          if (c2 === a2 + 1)
            return;
          for (e9.removeEdge(n3), o2 = 0, ++a2; a2 < c2; ++o2, ++a2)
            d2.points = [], r2 = { width: 0, height: 0, edgeLabel: d2, edgeObj: n3, rank: a2 }, t4 = ra.addDummyNode(e9, "edge", r2, "_d"), a2 === f2 && (r2.width = d2.width, r2.height = d2.height, r2.dummy = "edge-label", r2.labelpos = d2.labelpos), e9.setEdge(i2, t4, { weight: d2.weight }, s2), o2 === 0 && e9.graph().dummyChains.push(t4), i2 = t4;
          e9.setEdge(i2, u2, { weight: d2.weight }, s2);
        }(e8, n2);
      });
    }, undo: function(e8) {
      Hi.forEach(e8.graph().dummyChains, function(n2) {
        var t4, r2 = e8.node(n2), o2 = r2.edgeLabel;
        for (e8.setEdge(r2.edgeObj, o2); r2.dummy; )
          t4 = e8.successors(n2)[0], e8.removeNode(n2), o2.points.push({ x: r2.x, y: r2.y }), r2.dummy === "edge-label" && (o2.x = r2.x, o2.y = r2.y, o2.width = r2.width, o2.height = r2.height), n2 = t4, r2 = e8.node(n2);
      });
    } };
    ua = function(e8) {
      var n2 = {};
      Hi.forEach(e8.sources(), function t4(r2) {
        var o2 = e8.node(r2);
        if (Hi.has(n2, r2))
          return o2.rank;
        n2[r2] = true;
        var i2 = Hi.min(Hi.map(e8.outEdges(r2), function(n3) {
          return t4(n3.w) - e8.edge(n3).minlen;
        }));
        return i2 !== Number.POSITIVE_INFINITY && i2 != null || (i2 = 0), o2.rank = i2;
      });
    };
    ca = function(e8, n2) {
      return e8.node(n2.w).rank - e8.node(n2.v).rank - e8.edge(n2).minlen;
    };
    sa = Fo.Graph;
    da = ca;
    fa = function(e8) {
      var n2, t4, r2 = new sa({ directed: false }), o2 = e8.nodes()[0], i2 = e8.nodeCount();
      r2.setNode(o2, {});
      for (; ha(r2, e8) < i2; )
        n2 = la(r2, e8), t4 = r2.hasNode(n2.v) ? da(e8, n2) : -da(e8, n2), va(r2, e8, t4);
      return r2;
    };
    pa = ca;
    ga = ua;
    ya = Fo.alg.preorder;
    ba = Fo.alg.postorder;
    ma = ra.simplify;
    wa = Ea;
    Ea.initLowLimValues = xa, Ea.initCutValues = _a, Ea.calcCutValue = ja, Ea.leaveEdge = Oa, Ea.enterEdge = ka, Ea.exchangeEdges = Ia;
    Ma = ua;
    Ca = function(e8) {
      switch (e8.graph().ranker) {
        case "network-simplex":
          Ba(e8);
          break;
        case "tight-tree":
          !function(e9) {
            Ma(e9), fa(e9);
          }(e8);
          break;
        case "longest-path":
          Ga(e8);
          break;
        default:
          Ba(e8);
      }
    };
    Ga = Ma;
    Aa = function(e8) {
      var n2 = function(e9) {
        var n3 = {}, t4 = 0;
        function r2(o2) {
          var i2 = t4;
          Hi.forEach(e9.children(o2), r2), n3[o2] = { low: i2, lim: t4++ };
        }
        return Hi.forEach(e9.children(), r2), n3;
      }(e8);
      Hi.forEach(e8.graph().dummyChains, function(t4) {
        for (var r2 = e8.node(t4), o2 = r2.edgeObj, i2 = function(e9, n3, t5, r3) {
          var o3, i3, a3 = [], u3 = [], c3 = Math.min(n3[t5].low, n3[r3].low), s3 = Math.max(n3[t5].lim, n3[r3].lim);
          o3 = t5;
          do {
            o3 = e9.parent(o3), a3.push(o3);
          } while (o3 && (n3[o3].low > c3 || s3 > n3[o3].lim));
          i3 = o3, o3 = r3;
          for (; (o3 = e9.parent(o3)) !== i3; )
            u3.push(o3);
          return { path: a3.concat(u3.reverse()), lca: i3 };
        }(e8, n2, o2.v, o2.w), a2 = i2.path, u2 = i2.lca, c2 = 0, s2 = a2[c2], d2 = true; t4 !== o2.w; ) {
          if (r2 = e8.node(t4), d2) {
            for (; (s2 = a2[c2]) !== u2 && e8.node(s2).maxRank < r2.rank; )
              c2++;
            s2 === u2 && (d2 = false);
          }
          if (!d2) {
            for (; c2 < a2.length - 1 && e8.node(s2 = a2[c2 + 1]).minRank <= r2.rank; )
              c2++;
            s2 = a2[c2];
          }
          e8.setParent(t4, s2), t4 = e8.successors(t4)[0];
        }
      });
    };
    La = { run: function(e8) {
      var n2 = ra.addDummyNode(e8, "root", {}, "_root"), t4 = function(e9) {
        var n3 = {};
        function t5(r3, o3) {
          var i3 = e9.children(r3);
          i3 && i3.length && Hi.forEach(i3, function(e11) {
            t5(e11, o3 + 1);
          }), n3[r3] = o3;
        }
        return Hi.forEach(e9.children(), function(e11) {
          t5(e11, 1);
        }), n3;
      }(e8), r2 = Hi.max(Hi.values(t4)) - 1, o2 = 2 * r2 + 1;
      e8.graph().nestingRoot = n2, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).minlen *= o2;
      });
      var i2 = function(e9) {
        return Hi.reduce(e9.edges(), function(n3, t5) {
          return n3 + e9.edge(t5).weight;
        }, 0);
      }(e8) + 1;
      Hi.forEach(e8.children(), function(a2) {
        Ra(e8, n2, o2, i2, r2, t4, a2);
      }), e8.graph().nodeRankFactor = o2;
    }, cleanup: function(e8) {
      var n2 = e8.graph();
      e8.removeNode(n2.nestingRoot), delete n2.nestingRoot, Hi.forEach(e8.edges(), function(n3) {
        e8.edge(n3).nestingEdge && e8.removeEdge(n3);
      });
    } };
    Ta = function(e8) {
      Hi.forEach(e8.children(), function n2(t4) {
        var r2 = e8.children(t4), o2 = e8.node(t4);
        if (r2.length && Hi.forEach(r2, n2), Hi.has(o2, "minRank")) {
          o2.borderLeft = [], o2.borderRight = [];
          for (var i2 = o2.minRank, a2 = o2.maxRank + 1; i2 < a2; ++i2)
            Da(e8, "borderLeft", "_bl", t4, o2, i2), Da(e8, "borderRight", "_br", t4, o2, i2);
        }
      });
    };
    Pa = { adjust: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      n2 !== "lr" && n2 !== "rl" || za(e8);
    }, undo: function(e8) {
      var n2 = e8.graph().rankdir.toLowerCase();
      n2 !== "bt" && n2 !== "rl" || function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Ua(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t4 = e9.edge(n3);
          Hi.forEach(t4.points, Ua), Hi.has(t4, "y") && Ua(t4);
        });
      }(e8);
      n2 !== "lr" && n2 !== "rl" || (!function(e9) {
        Hi.forEach(e9.nodes(), function(n3) {
          Va(e9.node(n3));
        }), Hi.forEach(e9.edges(), function(n3) {
          var t4 = e9.edge(n3);
          Hi.forEach(t4.points, Va), Hi.has(t4, "x") && Va(t4);
        });
      }(e8), za(e8));
    } };
    $a = function(e8) {
      var n2 = {}, t4 = Hi.filter(e8.nodes(), function(n3) {
        return !e8.children(n3).length;
      }), r2 = Hi.max(Hi.map(t4, function(n3) {
        return e8.node(n3).rank;
      })), o2 = Hi.map(Hi.range(r2 + 1), function() {
        return [];
      });
      function i2(t5) {
        if (!Hi.has(n2, t5)) {
          n2[t5] = true;
          var r3 = e8.node(t5);
          o2[r3.rank].push(t5), Hi.forEach(e8.successors(t5), i2);
        }
      }
      var a2 = Hi.sortBy(t4, function(n3) {
        return e8.node(n3).rank;
      });
      return Hi.forEach(a2, i2), o2;
    };
    Ha = function(e8, n2) {
      for (var t4 = 0, r2 = 1; r2 < n2.length; ++r2)
        t4 += Wa(e8, n2[r2 - 1], n2[r2]);
      return t4;
    };
    qa = function(e8, n2) {
      return Hi.map(n2, function(n3) {
        var t4 = e8.inEdges(n3);
        if (t4.length) {
          var r2 = Hi.reduce(t4, function(n4, t5) {
            var r3 = e8.edge(t5), o2 = e8.node(t5.v);
            return { sum: n4.sum + r3.weight * o2.order, weight: n4.weight + r3.weight };
          }, { sum: 0, weight: 0 });
          return { v: n3, barycenter: r2.sum / r2.weight, weight: r2.weight };
        }
        return { v: n3 };
      });
    };
    Ya = function(e8, n2) {
      var t4 = {};
      return Hi.forEach(e8, function(e9, n3) {
        var r2 = t4[e9.v] = { indegree: 0, in: [], out: [], vs: [e9.v], i: n3 };
        Hi.isUndefined(e9.barycenter) || (r2.barycenter = e9.barycenter, r2.weight = e9.weight);
      }), Hi.forEach(n2.edges(), function(e9) {
        var n3 = t4[e9.v], r2 = t4[e9.w];
        Hi.isUndefined(n3) || Hi.isUndefined(r2) || (r2.indegree++, n3.out.push(t4[e9.w]));
      }), function(e9) {
        var n3 = [];
        function t5(e11) {
          return function(n4) {
            n4.merged || (Hi.isUndefined(n4.barycenter) || Hi.isUndefined(e11.barycenter) || n4.barycenter >= e11.barycenter) && function(e12, n5) {
              var t6 = 0, r3 = 0;
              e12.weight && (t6 += e12.barycenter * e12.weight, r3 += e12.weight);
              n5.weight && (t6 += n5.barycenter * n5.weight, r3 += n5.weight);
              e12.vs = n5.vs.concat(e12.vs), e12.barycenter = t6 / r3, e12.weight = r3, e12.i = Math.min(n5.i, e12.i), n5.merged = true;
            }(e11, n4);
          };
        }
        function r2(n4) {
          return function(t6) {
            t6.in.push(n4), --t6.indegree == 0 && e9.push(t6);
          };
        }
        for (; e9.length; ) {
          var o2 = e9.pop();
          n3.push(o2), Hi.forEach(o2.in.reverse(), t5(o2)), Hi.forEach(o2.out, r2(o2));
        }
        return Hi.map(Hi.filter(n3, function(e11) {
          return !e11.merged;
        }), function(e11) {
          return Hi.pick(e11, ["vs", "i", "barycenter", "weight"]);
        });
      }(Hi.filter(t4, function(e9) {
        return !e9.indegree;
      }));
    };
    Ja = function(e8, n2) {
      var t4 = ra.partition(e8, function(e9) {
        return Hi.has(e9, "barycenter");
      }), r2 = t4.lhs, o2 = Hi.sortBy(t4.rhs, function(e9) {
        return -e9.i;
      }), i2 = [], a2 = 0, u2 = 0, c2 = 0;
      r2.sort((s2 = !!n2, function(e9, n3) {
        return e9.barycenter < n3.barycenter ? -1 : e9.barycenter > n3.barycenter ? 1 : s2 ? n3.i - e9.i : e9.i - n3.i;
      })), c2 = Xa(i2, o2, c2), Hi.forEach(r2, function(e9) {
        c2 += e9.vs.length, i2.push(e9.vs), a2 += e9.barycenter * e9.weight, u2 += e9.weight, c2 = Xa(i2, o2, c2);
      });
      var s2;
      var d2 = { vs: Hi.flatten(i2, true) };
      u2 && (d2.barycenter = a2 / u2, d2.weight = u2);
      return d2;
    };
    Ka = function e7(n2, t4, r2, o2) {
      var i2 = n2.children(t4), a2 = n2.node(t4), u2 = a2 ? a2.borderLeft : void 0, c2 = a2 ? a2.borderRight : void 0, s2 = {};
      u2 && (i2 = Hi.filter(i2, function(e8) {
        return e8 !== u2 && e8 !== c2;
      }));
      var d2 = qa(n2, i2);
      Hi.forEach(d2, function(t5) {
        if (n2.children(t5.v).length) {
          var i3 = e7(n2, t5.v, r2, o2);
          s2[t5.v] = i3, Hi.has(i3, "barycenter") && (a3 = t5, u3 = i3, Hi.isUndefined(a3.barycenter) ? (a3.barycenter = u3.barycenter, a3.weight = u3.weight) : (a3.barycenter = (a3.barycenter * a3.weight + u3.barycenter * u3.weight) / (a3.weight + u3.weight), a3.weight += u3.weight));
        }
        var a3, u3;
      });
      var f2 = Ya(d2, r2);
      !function(e8, n3) {
        Hi.forEach(e8, function(e9) {
          e9.vs = Hi.flatten(e9.vs.map(function(e11) {
            return n3[e11] ? n3[e11].vs : e11;
          }), true);
        });
      }(f2, s2);
      var h2 = Ja(f2, o2);
      if (u2 && (h2.vs = Hi.flatten([u2, h2.vs, c2], true), n2.predecessors(u2).length)) {
        var l2 = n2.node(n2.predecessors(u2)[0]), v2 = n2.node(n2.predecessors(c2)[0]);
        Hi.has(h2, "barycenter") || (h2.barycenter = 0, h2.weight = 0), h2.barycenter = (h2.barycenter * h2.weight + l2.order + v2.order) / (h2.weight + 2), h2.weight += 2;
      }
      return h2;
    };
    Qa = Fo.Graph;
    Za = function(e8, n2, t4) {
      var r2 = function(e9) {
        var n3;
        for (; e9.hasNode(n3 = Hi.uniqueId("_root")); )
          ;
        return n3;
      }(e8), o2 = new Qa({ compound: true }).setGraph({ root: r2 }).setDefaultNodeLabel(function(n3) {
        return e8.node(n3);
      });
      return Hi.forEach(e8.nodes(), function(i2) {
        var a2 = e8.node(i2), u2 = e8.parent(i2);
        (a2.rank === n2 || a2.minRank <= n2 && n2 <= a2.maxRank) && (o2.setNode(i2), o2.setParent(i2, u2 || r2), Hi.forEach(e8[t4](i2), function(n3) {
          var t5 = n3.v === i2 ? n3.w : n3.v, r3 = o2.edge(t5, i2), a3 = Hi.isUndefined(r3) ? 0 : r3.weight;
          o2.setEdge(t5, i2, { weight: e8.edge(n3).weight + a3 });
        }), Hi.has(a2, "minRank") && o2.setNode(i2, { borderLeft: a2.borderLeft[n2], borderRight: a2.borderRight[n2] }));
      }), o2;
    };
    eu = function(e8, n2, t4) {
      var r2, o2 = {};
      Hi.forEach(t4, function(t5) {
        for (var i2, a2, u2 = e8.parent(t5); u2; ) {
          if ((i2 = e8.parent(u2)) ? (a2 = o2[i2], o2[i2] = u2) : (a2 = r2, r2 = u2), a2 && a2 !== u2)
            return void n2.setEdge(a2, u2);
          u2 = i2;
        }
      });
    };
    nu = Fo.Graph;
    tu = function(e8) {
      var n2 = ra.maxRank(e8), t4 = ru(e8, Hi.range(1, n2 + 1), "inEdges"), r2 = ru(e8, Hi.range(n2 - 1, -1, -1), "outEdges"), o2 = $a(e8);
      iu(e8, o2);
      for (var i2, a2 = Number.POSITIVE_INFINITY, u2 = 0, c2 = 0; c2 < 4; ++u2, ++c2) {
        ou(u2 % 2 ? t4 : r2, u2 % 4 >= 2), o2 = ra.buildLayerMatrix(e8);
        var s2 = Ha(e8, o2);
        s2 < a2 && (c2 = 0, i2 = Hi.cloneDeep(o2), a2 = s2);
      }
      iu(e8, i2);
    };
    au = Fo.Graph;
    uu = function(e8) {
      var n2, t4 = ra.buildLayerMatrix(e8), r2 = Hi.merge(cu(e8, t4), su(e8, t4)), o2 = {};
      Hi.forEach(["u", "d"], function(i3) {
        n2 = i3 === "u" ? t4 : Hi.values(t4).reverse(), Hi.forEach(["l", "r"], function(t5) {
          t5 === "r" && (n2 = Hi.map(n2, function(e9) {
            return Hi.values(e9).reverse();
          }));
          var a2 = (i3 === "u" ? e8.predecessors : e8.successors).bind(e8), u2 = hu(e8, n2, r2, a2), c2 = lu(e8, n2, u2.root, u2.align, t5 === "r");
          t5 === "r" && (c2 = Hi.mapValues(c2, function(e9) {
            return -e9;
          })), o2[i3 + t5] = c2;
        });
      });
      var i2 = vu(e8, o2);
      return pu(o2, i2), gu(o2, e8.graph().align);
    };
    yu = uu;
    bu = function(e8) {
      (function(e9) {
        var n2 = ra.buildLayerMatrix(e9), t4 = e9.graph().ranksep, r2 = 0;
        Hi.forEach(n2, function(n3) {
          var o2 = Hi.max(Hi.map(n3, function(n4) {
            return e9.node(n4).height;
          }));
          Hi.forEach(n3, function(n4) {
            e9.node(n4).y = r2 + o2 / 2;
          }), r2 += o2 + t4;
        });
      })(e8 = ra.asNonCompoundGraph(e8)), Hi.forEach(yu(e8), function(n2, t4) {
        e8.node(t4).x = n2;
      });
    };
    mu = ra.normalizeRanks;
    wu = ra.removeEmptyRanks;
    Eu = ra;
    _u = Fo.Graph;
    ju = function(e8, n2) {
      var t4 = n2 && n2.debugTiming ? Eu.time : Eu.notime;
      t4("layout", function() {
        var n3 = t4("  buildLayoutGraph", function() {
          return function(e9) {
            var n4 = new _u({ multigraph: true, compound: true }), t5 = Bu(e9.graph());
            return n4.setGraph(Hi.merge({}, Nu, Gu(t5, xu), Hi.pick(t5, Ou))), Hi.forEach(e9.nodes(), function(t6) {
              var r2 = Bu(e9.node(t6));
              n4.setNode(t6, Hi.defaults(Gu(r2, ku), Iu)), n4.setParent(t6, e9.parent(t6));
            }), Hi.forEach(e9.edges(), function(t6) {
              var r2 = Bu(e9.edge(t6));
              n4.setEdge(t6, Hi.merge({}, Mu, Gu(r2, Su), Hi.pick(r2, Cu)));
            }), n4;
          }(e8);
        });
        t4("  runLayout", function() {
          !function(e9, n4) {
            n4("    makeSpaceForEdgeLabels", function() {
              !function(e11) {
                var n5 = e11.graph();
                n5.ranksep /= 2, Hi.forEach(e11.edges(), function(t5) {
                  var r2 = e11.edge(t5);
                  r2.minlen *= 2, r2.labelpos.toLowerCase() !== "c" && (n5.rankdir === "TB" || n5.rankdir === "BT" ? r2.width += r2.labeloffset : r2.height += r2.labeloffset);
                });
              }(e9);
            }), n4("    removeSelfEdges", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  if (n5.v === n5.w) {
                    var t5 = e11.node(n5.v);
                    t5.selfEdges || (t5.selfEdges = []), t5.selfEdges.push({ e: n5, label: e11.edge(n5) }), e11.removeEdge(n5);
                  }
                });
              }(e9);
            }), n4("    acyclic", function() {
              na.run(e9);
            }), n4("    nestingGraph.run", function() {
              La.run(e9);
            }), n4("    rank", function() {
              Ca(Eu.asNonCompoundGraph(e9));
            }), n4("    injectEdgeLabelProxies", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  if (t5.width && t5.height) {
                    var r2 = e11.node(n5.v), o2 = { rank: (e11.node(n5.w).rank - r2.rank) / 2 + r2.rank, e: n5 };
                    Eu.addDummyNode(e11, "edge-proxy", o2, "_ep");
                  }
                });
              }(e9);
            }), n4("    removeEmptyRanks", function() {
              wu(e9);
            }), n4("    nestingGraph.cleanup", function() {
              La.cleanup(e9);
            }), n4("    normalizeRanks", function() {
              mu(e9);
            }), n4("    assignRankMinMax", function() {
              !function(e11) {
                var n5 = 0;
                Hi.forEach(e11.nodes(), function(t5) {
                  var r2 = e11.node(t5);
                  r2.borderTop && (r2.minRank = e11.node(r2.borderTop).rank, r2.maxRank = e11.node(r2.borderBottom).rank, n5 = Hi.max(n5, r2.maxRank));
                }), e11.graph().maxRank = n5;
              }(e9);
            }), n4("    removeEdgeLabelProxies", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  var t5 = e11.node(n5);
                  t5.dummy === "edge-proxy" && (e11.edge(t5.e).labelRank = t5.rank, e11.removeNode(n5));
                });
              }(e9);
            }), n4("    normalize.run", function() {
              aa.run(e9);
            }), n4("    parentDummyChains", function() {
              Aa(e9);
            }), n4("    addBorderSegments", function() {
              Ta(e9);
            }), n4("    order", function() {
              tu(e9);
            }), n4("    insertSelfEdges", function() {
              !function(e11) {
                var n5 = Eu.buildLayerMatrix(e11);
                Hi.forEach(n5, function(n6) {
                  var t5 = 0;
                  Hi.forEach(n6, function(n7, r2) {
                    var o2 = e11.node(n7);
                    o2.order = r2 + t5, Hi.forEach(o2.selfEdges, function(n8) {
                      Eu.addDummyNode(e11, "selfedge", { width: n8.label.width, height: n8.label.height, rank: o2.rank, order: r2 + ++t5, e: n8.e, label: n8.label }, "_se");
                    }), delete o2.selfEdges;
                  });
                });
              }(e9);
            }), n4("    adjustCoordinateSystem", function() {
              Pa.adjust(e9);
            }), n4("    position", function() {
              bu(e9);
            }), n4("    positionSelfEdges", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  var t5 = e11.node(n5);
                  if (t5.dummy === "selfedge") {
                    var r2 = e11.node(t5.e.v), o2 = r2.x + r2.width / 2, i2 = r2.y, a2 = t5.x - o2, u2 = r2.height / 2;
                    e11.setEdge(t5.e, t5.label), e11.removeNode(n5), t5.label.points = [{ x: o2 + 2 * a2 / 3, y: i2 - u2 }, { x: o2 + 5 * a2 / 6, y: i2 - u2 }, { x: o2 + a2, y: i2 }, { x: o2 + 5 * a2 / 6, y: i2 + u2 }, { x: o2 + 2 * a2 / 3, y: i2 + u2 }], t5.label.x = t5.x, t5.label.y = t5.y;
                  }
                });
              }(e9);
            }), n4("    removeBorderNodes", function() {
              !function(e11) {
                Hi.forEach(e11.nodes(), function(n5) {
                  if (e11.children(n5).length) {
                    var t5 = e11.node(n5), r2 = e11.node(t5.borderTop), o2 = e11.node(t5.borderBottom), i2 = e11.node(Hi.last(t5.borderLeft)), a2 = e11.node(Hi.last(t5.borderRight));
                    t5.width = Math.abs(a2.x - i2.x), t5.height = Math.abs(o2.y - r2.y), t5.x = i2.x + t5.width / 2, t5.y = r2.y + t5.height / 2;
                  }
                }), Hi.forEach(e11.nodes(), function(n5) {
                  e11.node(n5).dummy === "border" && e11.removeNode(n5);
                });
              }(e9);
            }), n4("    normalize.undo", function() {
              aa.undo(e9);
            }), n4("    fixupEdgeLabelCoords", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  if (Hi.has(t5, "x"))
                    switch (t5.labelpos !== "l" && t5.labelpos !== "r" || (t5.width -= t5.labeloffset), t5.labelpos) {
                      case "l":
                        t5.x -= t5.width / 2 + t5.labeloffset;
                        break;
                      case "r":
                        t5.x += t5.width / 2 + t5.labeloffset;
                    }
                });
              }(e9);
            }), n4("    undoCoordinateSystem", function() {
              Pa.undo(e9);
            }), n4("    translateGraph", function() {
              !function(e11) {
                var n5 = Number.POSITIVE_INFINITY, t5 = 0, r2 = Number.POSITIVE_INFINITY, o2 = 0, i2 = e11.graph(), a2 = i2.marginx || 0, u2 = i2.marginy || 0;
                function c2(e12) {
                  var i3 = e12.x, a3 = e12.y, u3 = e12.width, c3 = e12.height;
                  n5 = Math.min(n5, i3 - u3 / 2), t5 = Math.max(t5, i3 + u3 / 2), r2 = Math.min(r2, a3 - c3 / 2), o2 = Math.max(o2, a3 + c3 / 2);
                }
                Hi.forEach(e11.nodes(), function(n6) {
                  c2(e11.node(n6));
                }), Hi.forEach(e11.edges(), function(n6) {
                  var t6 = e11.edge(n6);
                  Hi.has(t6, "x") && c2(t6);
                }), n5 -= a2, r2 -= u2, Hi.forEach(e11.nodes(), function(t6) {
                  var o3 = e11.node(t6);
                  o3.x -= n5, o3.y -= r2;
                }), Hi.forEach(e11.edges(), function(t6) {
                  var o3 = e11.edge(t6);
                  Hi.forEach(o3.points, function(e12) {
                    e12.x -= n5, e12.y -= r2;
                  }), Hi.has(o3, "x") && (o3.x -= n5), Hi.has(o3, "y") && (o3.y -= r2);
                }), i2.width = t5 - n5 + a2, i2.height = o2 - r2 + u2;
              }(e9);
            }), n4("    assignNodeIntersects", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5, r2, o2 = e11.edge(n5), i2 = e11.node(n5.v), a2 = e11.node(n5.w);
                  o2.points ? (t5 = o2.points[0], r2 = o2.points[o2.points.length - 1]) : (o2.points = [], t5 = a2, r2 = i2), o2.points.unshift(Eu.intersectRect(i2, t5)), o2.points.push(Eu.intersectRect(a2, r2));
                });
              }(e9);
            }), n4("    reversePoints", function() {
              !function(e11) {
                Hi.forEach(e11.edges(), function(n5) {
                  var t5 = e11.edge(n5);
                  t5.reversed && t5.points.reverse();
                });
              }(e9);
            }), n4("    acyclic.undo", function() {
              na.undo(e9);
            });
          }(n3, t4);
        }), t4("  updateInputGraph", function() {
          !function(e9, n4) {
            Hi.forEach(e9.nodes(), function(t5) {
              var r2 = e9.node(t5), o2 = n4.node(t5);
              r2 && (r2.x = o2.x, r2.y = o2.y, n4.children(t5).length && (r2.width = o2.width, r2.height = o2.height));
            }), Hi.forEach(e9.edges(), function(t5) {
              var r2 = e9.edge(t5), o2 = n4.edge(t5);
              r2.points = o2.points, Hi.has(o2, "x") && (r2.x = o2.x, r2.y = o2.y);
            }), e9.graph().width = n4.graph().width, e9.graph().height = n4.graph().height;
          }(e8, n3);
        });
      });
    };
    xu = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    Nu = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    Ou = ["acyclicer", "ranker", "rankdir", "align"];
    ku = ["width", "height"];
    Iu = { width: 0, height: 0 };
    Su = ["minlen", "weight", "width", "height", "labeloffset"];
    Mu = { minlen: 1, weight: 1, width: 0, height: 0, labeloffset: 10, labelpos: "r" };
    Cu = ["labelpos"];
    Au = Fo.Graph;
    Lu = { graphlib: Fo, layout: ju, debug: { debugOrdering: function(e8) {
      var n2 = ra.buildLayerMatrix(e8), t4 = new Au({ compound: true, multigraph: true }).setGraph({});
      return Hi.forEach(e8.nodes(), function(n3) {
        t4.setNode(n3, { label: n3 }), t4.setParent(n3, "layer" + e8.node(n3).rank);
      }), Hi.forEach(e8.edges(), function(e9) {
        t4.setEdge(e9.v, e9.w, {}, e9.name);
      }), Hi.forEach(n2, function(e9, n3) {
        var r2 = "layer" + n3;
        t4.setNode(r2, { rank: "same" }), Hi.reduce(e9, function(e11, n4) {
          return t4.setEdge(e11, n4, { style: "invis" }), n4;
        });
      }), t4;
    } }, util: { time: ra.time, notime: ra.notime }, version: "0.8.5" };
    Ru = Lu.graphlib;
    Tu = Lu.layout;
    Du = class {
      constructor(e8) {
        this.cardinality = 1, this.include = a.UNSPECIFIED, this.isGroupNode = false, this.parentNode = null, this.type = i.NODE, this.name = e8.name, this.attr = e8.attr || {}, this.inputs = e8.inputs, this.path = e8.path || [], this.width = e8.width, this.height = e8.height;
      }
    };
    Pu = class {
      constructor() {
        this.nodes = {}, this.edges = [], this.nodes = {}, this.edges = [];
      }
    };
    Fu = class {
      constructor(e8, n2 = {}) {
        this.attr = null, this.bridgeGraph = null, this.cardinality = 0, this.depth = 1, this.include = a.UNSPECIFIED, this.isGroupNode = true, this.parentNode = null, this.type = i.META, this.path = [], this.name = e8, this.metaGraph = Hu(e8, u.META, n2);
      }
      getFirstChild() {
        return this.metaGraph.node(this.metaGraph.nodes()[0]);
      }
      getChildren() {
        return this.metaGraph.nodes().map((e8) => this.metaGraph.node(e8));
      }
      leaves() {
        let e8, n2 = [], t4 = [this];
        for (; t4.length; ) {
          let r2 = t4.shift();
          r2.isGroupNode ? (e8 = r2.metaGraph, e8.nodes().forEach((n3) => t4.push(e8.node(n3)))) : n2.push(r2.name);
        }
        return n2;
      }
    };
    Uu = class {
      constructor(e8, n2) {
        this.v = e8, this.w = n2, this.baseEdgeList = [], this.inbound = null, this.name = null;
      }
      addBaseEdge(e8, n2) {
        this.baseEdgeList.push(e8);
      }
    };
    Wu = class {
      constructor(e8 = {}) {
        this.graphOptions = e8, this.index = {}, this.graphOptions.compound = true, this.root = Vu(r, this.graphOptions), this.index[r] = this.root;
      }
      getNodeMap() {
        return this.index;
      }
      node(e8) {
        return this.index[e8];
      }
      setNode(e8, n2) {
        this.index[e8] = n2;
      }
      getBridgeGraph(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node in hierarchy: " + e8);
        if (!("metaGraph" in n2))
          return null;
        const t4 = n2;
        if (t4.bridgeGraph)
          return t4.bridgeGraph;
        const r2 = Hu(o, u.BRIDGE, this.graphOptions);
        if (t4.bridgeGraph = r2, !n2.parentNode || !("metaGraph" in n2.parentNode))
          return r2;
        const i2 = n2.parentNode;
        return [i2.metaGraph, this.getBridgeGraph(i2.name)].forEach((n3) => {
          n3.edges().filter((n4) => n4.v === e8 || n4.w === e8).forEach((t5) => {
            const o2 = t5.w === e8;
            n3.edge(t5).baseEdgeList.forEach((n4) => {
              const [i3, a2] = o2 ? [n4.w, t5.v] : [n4.v, t5.w], u2 = this.getChildName(e8, i3), c2 = { v: o2 ? a2 : u2, w: o2 ? u2 : a2 };
              let s2 = r2.edge(c2);
              s2 || (s2 = $u(c2.v, c2.w), s2.inbound = o2, r2.setEdge(c2.v, c2.w, s2)), s2.addBaseEdge(n4, this);
            });
          });
        }), r2;
      }
      getChildName(e8, n2) {
        let t4 = this.index[n2];
        for (; t4; ) {
          if (t4.parentNode && t4.parentNode.name === e8)
            return t4.name;
          t4 = t4.parentNode;
        }
        throw Error("Could not find immediate child for descendant: " + n2);
      }
      getPredecessors(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, true);
      }
      getSuccessors(e8) {
        const n2 = this.index[e8];
        if (!n2)
          throw Error("Could not find node with name: " + e8);
        return this.getOneWayEdges(n2, false);
      }
      getOneWayEdges(e8, n2) {
        const t4 = [];
        if (!e8.parentNode || !e8.parentNode.isGroupNode)
          return t4;
        const r2 = e8.parentNode, o2 = r2.metaGraph, i2 = this.getBridgeGraph(r2.name);
        return Yu(o2, e8, n2, t4), Yu(i2, e8, n2, t4), t4;
      }
    };
    Ju = class {
      constructor(e8) {
        this.hierarchy = e8, this.index = {}, this.hasSubHierarchy = {}, this.root = new Qu(this.hierarchy.root, this.hierarchy.graphOptions), this.index[e8.root.name] = this.root, this.buildSubHierarchy(e8.root.name), this.root.expanded = true;
      }
      getRenderInfoNodes() {
        return Object.values(this.index);
      }
      getSubHierarchy() {
        return this.hasSubHierarchy;
      }
      buildSubHierarchy(e8) {
        if (e8 in this.hasSubHierarchy)
          return;
        this.hasSubHierarchy[e8] = true;
        const n2 = this.index[e8];
        if (n2.node.type !== i.META)
          return;
        const t4 = n2, r2 = t4.node.metaGraph, o2 = t4.coreGraph;
        r2.nodes().forEach((e9) => {
          const n3 = this.getOrCreateRenderNodeByName(e9);
          o2.setNode(e9, n3);
        }), r2.edges().forEach((e9) => {
          const n3 = r2.edge(e9), t5 = new Ku(n3);
          o2.setEdge(e9.v, e9.w, t5);
        });
        const u2 = t4.node.parentNode;
        if (!u2)
          return;
        const c2 = this.getRenderNodeByName(u2.name), s2 = (e9, ...n3) => n3.concat([e9 ? "IN" : "OUT"]).join("~~"), d2 = this.hierarchy.getBridgeGraph(e8);
        d2.edges().forEach((n3) => {
          const t5 = d2.edge(n3), f2 = !!r2.node(n3.w), [h2, l2] = f2 ? [n3.w, n3.v] : [n3.v, n3.w], v2 = (n4) => {
            const t6 = f2 ? { v: n4, w: e8 } : { v: e8, w: n4 };
            return c2.coreGraph.edge(t6);
          };
          let p2 = v2(l2);
          p2 || (p2 = v2(s2(f2, l2, u2.name)));
          const g2 = s2(f2, e8), y2 = s2(f2, l2, e8);
          let b10 = o2.node(y2);
          if (!b10) {
            let e9 = o2.node(g2);
            if (!e9) {
              const n5 = { name: g2, type: i.BRIDGE, isGroupNode: false, cardinality: 0, parentNode: null, include: a.UNSPECIFIED, inbound: f2, attr: {} };
              e9 = new Xu(n5), this.index[g2] = e9, o2.setNode(g2, e9);
            }
            const n4 = { name: y2, type: i.BRIDGE, isGroupNode: false, cardinality: 1, parentNode: null, include: a.UNSPECIFIED, inbound: f2, attr: {} };
            b10 = new Xu(n4), this.index[y2] = b10, o2.setNode(y2, b10), o2.setParent(y2, g2), e9.node.cardinality++;
          }
          const m2 = new Ku(t5);
          m2.adjoiningMetaEdge = p2, f2 ? o2.setEdge(y2, h2, m2) : o2.setEdge(h2, y2, m2);
        });
      }
      getOrCreateRenderNodeByName(e8) {
        if (!e8)
          return null;
        if (e8 in this.index)
          return this.index[e8];
        const n2 = this.getNodeByName(e8);
        return n2 ? (this.index[e8] = n2.isGroupNode ? new Qu(n2, this.hierarchy.graphOptions) : new Xu(n2), this.index[e8]) : null;
      }
      getRenderNodeByName(e8) {
        return this.index[e8];
      }
      getNodeByName(e8) {
        return this.hierarchy.node(e8);
      }
    };
    Xu = class {
      constructor(e8) {
        this.node = e8, this.expanded = false, this.x = 0, this.y = 0, this.coreBox = { width: 0, height: 0 }, this.outboxWidth = 0, this.labelOffset = 0, this.radius = 0, this.labelHeight = 0, this.paddingTop = 0, this.paddingLeft = 0, this.paddingRight = 0, this.paddingBottom = 0, this.width = e8.width || 0, this.height = e8.height || 0, this.displayName = e8.name, this.attr = e8.attr;
      }
    };
    Ku = class {
      constructor(e8) {
        this.metaEdge = e8, this.adjoiningMetaEdge = null, this.weight = 1, this.points = [];
      }
    };
    Qu = class extends Xu {
      constructor(e8, n2) {
        super(e8);
        const t4 = e8.metaGraph.graph();
        n2.compound = true, this.coreGraph = Hu(t4.name, u.CORE, n2);
      }
    };
  }
});

// node_modules/@antv/layout/lib/layout/dagreCompound.js
var require_dagreCompound = __commonJS({
  "node_modules/@antv/layout/lib/layout/dagreCompound.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    var __spreadArray8 = exports && exports.__spreadArray || function(to2, from, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
          if (ar2 || !(i2 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i2);
            ar2[i2] = from[i2];
          }
        }
      return to2.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DagreCompoundLayout = void 0;
    var base_1 = require_base();
    var dagre_compound_1 = (init_dagre_compound_es5(), __toCommonJS(dagre_compound_es5_exports));
    var util_1 = require_util2();
    var DagreCompoundLayout2 = function(_super) {
      __extends19(DagreCompoundLayout3, _super);
      function DagreCompoundLayout3(options) {
        var _this = _super.call(this) || this;
        _this.rankdir = "TB";
        _this.nodesep = 50;
        _this.edgesep = 5;
        _this.ranksep = 50;
        _this.controlPoints = true;
        _this.anchorPoint = true;
        _this.nodes = [];
        _this.edges = [];
        _this.combos = [];
        _this.onLayoutEnd = function() {
        };
        _this.updateCfg(options);
        return _this;
      }
      DagreCompoundLayout3.prototype.getDefaultCfg = function() {
        return {
          rankdir: "TB",
          align: void 0,
          begin: void 0,
          nodeSize: void 0,
          nodesep: 50,
          ranksep: 50,
          controlPoints: true,
          anchorPoint: true
        };
      };
      DagreCompoundLayout3.prototype.init = function(data) {
        var hiddenNodes = data.hiddenNodes || [];
        var hiddenEdges = data.hiddenEdges || [];
        var hiddenCombos = data.hiddenCombos || [];
        this.nodes = this.getDataByOrder((data.nodes || []).concat(hiddenNodes));
        this.edges = this.getDataByOrder((data.edges || []).concat(hiddenEdges));
        this.combos = (data.combos || []).concat(hiddenCombos.map(function(hc) {
          return __assign16(__assign16({}, hc), { collapsed: true });
        }));
      };
      DagreCompoundLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges;
        if (!nodes)
          return;
        var _a2 = self2.getLayoutConfig(), graphDef = _a2.graphDef, graphOption = _a2.graphOption, graphSettings = _a2.graphSettings;
        var renderInfo = (0, dagre_compound_1.buildGraph)(graphDef, graphOption, graphSettings);
        var flattenedRenderInfo = (0, dagre_compound_1.flatGraph)(renderInfo, true);
        this.updatePosition(flattenedRenderInfo);
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges
        };
      };
      DagreCompoundLayout3.prototype.getNodePath = function(nodeId) {
        var self2 = this;
        var nodes = self2.nodes, combos = self2.combos;
        var targetNode = nodes.find(function(n2) {
          return n2.id === nodeId;
        });
        var findPath = function(comboId, fullPath) {
          if (fullPath === void 0) {
            fullPath = [];
          }
          var combo = combos.find(function(c2) {
            return c2.id === comboId;
          });
          if (combo) {
            fullPath.unshift(comboId);
            if (combo.parentId) {
              return findPath(combo.parentId, fullPath);
            }
            return fullPath;
          }
          return fullPath;
        };
        if (targetNode && targetNode.comboId) {
          return findPath(targetNode.comboId, [nodeId]);
        }
        return [nodeId];
      };
      DagreCompoundLayout3.prototype.getLayoutConfig = function() {
        var _a2, _b, _c;
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, nodeSize = self2.nodeSize, rankdir = self2.rankdir, align = self2.align, edgesep = self2.edgesep, nodesep = self2.nodesep, ranksep = self2.ranksep, settings = self2.settings;
        var compound = (combos || []).reduce(function(pre, cur) {
          var matchedNodes = nodes.filter(function(n2) {
            return n2.comboId === cur.id;
          }).map(function(n2) {
            return n2.id;
          });
          var matchedCombos = (combos || []).filter(function(n2) {
            return n2.parentId === cur.id;
          }).map(function(n2) {
            return n2.id;
          });
          if (matchedNodes.length || matchedCombos.length) {
            pre[cur.id] = __spreadArray8(__spreadArray8([], matchedNodes, true), matchedCombos, true);
          }
          return pre;
        }, {});
        var nodeSizeFunc;
        if (!nodeSize) {
          nodeSizeFunc = function(d2) {
            if (d2 && d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                return d2.size;
              }
              if ((0, util_1.isObject)(d2.size)) {
                return [d2.size.width || 40, d2.size.height || 40];
              }
              return [d2.size, d2.size];
            }
            return [40, 40];
          };
        } else if ((0, util_1.isArray)(nodeSize)) {
          nodeSizeFunc = function() {
            return nodeSize;
          };
        } else {
          nodeSizeFunc = function() {
            return [nodeSize, nodeSize];
          };
        }
        var comboSizeFunc = function(d2) {
          if (d2 && d2.size) {
            if ((0, util_1.isArray)(d2.size)) {
              return d2.size;
            }
            return [d2.size, d2.size];
          }
          return [80, 40];
        };
        var _d = comboSizeFunc(combos === null || combos === void 0 ? void 0 : combos[0]), metaWidth = _d[0], metaHeight = _d[1];
        var subSceneMeta = (_b = (_a2 = self2.graphSettings) === null || _a2 === void 0 ? void 0 : _a2.subScene) === null || _b === void 0 ? void 0 : _b.meta;
        var _e2 = ((_c = combos.find(function(c2) {
          return !c2.collapsed;
        })) === null || _c === void 0 ? void 0 : _c.padding) || [20, 20, 20, 20], paddingTop = _e2[0], paddingRight = _e2[1], paddingBottom = _e2[2], paddingLeft = _e2[3];
        var graphDef = {
          compound,
          nodes: __spreadArray8([], (nodes || []).map(function(n2) {
            var size2 = nodeSizeFunc(n2);
            var width = size2[0];
            var height = size2[1];
            return __assign16(__assign16({}, n2), { width, height });
          }), true),
          edges: __spreadArray8([], (edges || []).map(function(e8) {
            return __assign16(__assign16({}, e8), { v: e8.source, w: e8.target });
          }), true)
        };
        var graphOption = {
          expanded: (combos || []).filter(function(c2) {
            return !c2.collapsed;
          }).map(function(c2) {
            return c2.id;
          })
        };
        var graphMetaConfig = {
          graph: {
            meta: {
              align,
              rankDir: rankdir,
              nodeSep: nodesep,
              edgeSep: edgesep,
              rankSep: ranksep
            }
          },
          subScene: {
            meta: {
              paddingTop: paddingTop || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop) || 20,
              paddingRight: paddingRight || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight) || 20,
              paddingBottom: paddingBottom || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom) || 20,
              paddingLeft: paddingLeft || (subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft) || 20,
              labelHeight: 0
            }
          },
          nodeSize: {
            meta: {
              width: metaWidth,
              height: metaHeight
            }
          }
        };
        var graphSettings = (0, dagre_compound_1.mergeConfig)(settings, __assign16({}, (0, dagre_compound_1.mergeConfig)(graphMetaConfig, dagre_compound_1.LAYOUT_CONFIG)));
        self2.graphSettings = graphSettings;
        return {
          graphDef,
          graphOption,
          graphSettings
        };
      };
      DagreCompoundLayout3.prototype.updatePosition = function(flattenedGraph) {
        var nodes = flattenedGraph.nodes, edges = flattenedGraph.edges;
        this.updateNodePosition(nodes, edges);
        this.updateEdgePosition(nodes, edges);
      };
      DagreCompoundLayout3.prototype.getBegin = function(flattenedNodes, flattenedEdges) {
        var self2 = this;
        var begin = self2.begin;
        var dBegin = [0, 0];
        if (begin) {
          var minX_1 = Infinity;
          var minY_1 = Infinity;
          flattenedNodes.forEach(function(node) {
            if (minX_1 > node.x)
              minX_1 = node.x;
            if (minY_1 > node.y)
              minY_1 = node.y;
          });
          flattenedEdges.forEach(function(edge) {
            edge.points.forEach(function(point) {
              if (minX_1 > point.x)
                minX_1 = point.x;
              if (minY_1 > point.y)
                minY_1 = point.y;
            });
          });
          dBegin[0] = begin[0] - minX_1;
          dBegin[1] = begin[1] - minY_1;
        }
        return dBegin;
      };
      DagreCompoundLayout3.prototype.updateNodePosition = function(flattenedNodes, flattenedEdges) {
        var self2 = this;
        var combos = self2.combos, nodes = self2.nodes, edges = self2.edges, anchorPoint = self2.anchorPoint, graphSettings = self2.graphSettings;
        var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
        flattenedNodes.forEach(function(node) {
          var _a2;
          var x2 = node.x, y2 = node.y, id2 = node.id, type = node.type, coreBox = node.coreBox;
          if (type === dagre_compound_1.HierarchyNodeType.META && id2 !== dagre_compound_1.ROOT_NAME) {
            var i2 = combos.findIndex(function(item) {
              return item.id === id2;
            });
            var subSceneMeta = (_a2 = graphSettings === null || graphSettings === void 0 ? void 0 : graphSettings.subScene) === null || _a2 === void 0 ? void 0 : _a2.meta;
            combos[i2].offsetX = x2 + dBegin[0];
            combos[i2].offsetY = y2 + dBegin[1];
            combos[i2].fixSize = [coreBox.width, coreBox.height];
            combos[i2].fixCollapseSize = [coreBox.width, coreBox.height];
            if (!node.expanded) {
              combos[i2].padding = [0, 0, 0, 0];
            } else {
              combos[i2].padding = [
                subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingTop,
                subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingRight,
                subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingBottom,
                subSceneMeta === null || subSceneMeta === void 0 ? void 0 : subSceneMeta.paddingLeft
              ];
            }
          } else if (type === dagre_compound_1.HierarchyNodeType.OP) {
            var i2 = nodes.findIndex(function(item) {
              return item.id === id2;
            });
            nodes[i2].x = x2 + dBegin[0];
            nodes[i2].y = y2 + dBegin[1];
            if (anchorPoint) {
              var anchorPoints_1 = [];
              var outEdges = flattenedEdges.filter(function(e8) {
                return e8.v === id2;
              });
              var inEdges = flattenedEdges.filter(function(e8) {
                return e8.w === id2;
              });
              if (outEdges.length > 0) {
                outEdges.forEach(function(outEdge) {
                  var firstPoint = outEdge.points[0];
                  var anchorPointX = (firstPoint.x - x2) / node.width + 0.5;
                  var anchorPointY = (firstPoint.y - y2) / node.height + 0.5;
                  anchorPoints_1.push([anchorPointX, anchorPointY]);
                  outEdge.baseEdgeList.forEach(function(baseEdge) {
                    var edge = edges.find(function(e8) {
                      return e8.source === baseEdge.v && e8.target === baseEdge.w;
                    });
                    if (edge) {
                      edge.sourceAnchor = anchorPoints_1.length - 1;
                    }
                  });
                });
              }
              if (inEdges.length > 0) {
                inEdges.forEach(function(inEdge) {
                  var lastPoint = inEdge.points[inEdge.points.length - 1];
                  var anchorPointX = (lastPoint.x - x2) / node.width + 0.5;
                  var anchorPointY = (lastPoint.y - y2) / node.height + 0.5;
                  anchorPoints_1.push([anchorPointX, anchorPointY]);
                  inEdge.baseEdgeList.forEach(function(baseEdge) {
                    var edge = edges.find(function(e8) {
                      return e8.source === baseEdge.v && e8.target === baseEdge.w;
                    });
                    if (edge) {
                      edge.targetAnchor = anchorPoints_1.length - 1;
                    }
                  });
                });
              }
              nodes[i2].anchorPoints = anchorPoints_1.length > 0 ? anchorPoints_1 : nodes[i2].anchorPoints || [];
            }
          }
        });
      };
      DagreCompoundLayout3.prototype.updateEdgePosition = function(flattenedNodes, flattenedEdges) {
        var self2 = this;
        var combos = self2.combos, edges = self2.edges, controlPoints = self2.controlPoints;
        var dBegin = this.getBegin(flattenedNodes, flattenedEdges);
        if (controlPoints) {
          combos.forEach(function(combo) {
            combo.inEdges = [];
            combo.outEdges = [];
          });
          edges.forEach(function(sourceEdge) {
            var _a2, _b, _c, _d;
            var sourceNode = flattenedNodes.find(function(v2) {
              return v2.id === sourceEdge.source;
            });
            var targetNode = flattenedNodes.find(function(v2) {
              return v2.id === sourceEdge.target;
            });
            var points = [];
            var sortedEdges = [];
            if (sourceNode && targetNode) {
              sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes);
            } else if (!sourceNode || !targetNode) {
              var sourceNodePath = self2.getNodePath(sourceEdge.source);
              var targetNodePath = self2.getNodePath(sourceEdge.target);
              var lastExistingSource_1 = sourceNodePath.reverse().slice(!sourceNode ? 1 : 0).find(function(parentId) {
                return flattenedNodes.find(function(fNode) {
                  return fNode.id === parentId;
                });
              });
              var lastExistingTarget_1 = targetNodePath.reverse().slice(!targetNode ? 1 : 0).find(function(parentId) {
                return flattenedNodes.find(function(fNode) {
                  return fNode.id === parentId;
                });
              });
              sourceNode = flattenedNodes.find(function(v2) {
                return v2.id === lastExistingSource_1;
              });
              targetNode = flattenedNodes.find(function(v2) {
                return v2.id === lastExistingTarget_1;
              });
              sortedEdges = (0, dagre_compound_1.getEdges)(sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id, targetNode === null || targetNode === void 0 ? void 0 : targetNode.id, flattenedNodes, { v: sourceEdge.source, w: sourceEdge.target });
            }
            points = sortedEdges.reduce(function(pre, cur) {
              return __spreadArray8(__spreadArray8([], pre, true), cur.points.map(function(p2) {
                return __assign16(__assign16({}, p2), { x: p2.x + dBegin[0], y: p2.y + dBegin[1] });
              }), true);
            }, []);
            points = points.slice(1, -1);
            sourceEdge.controlPoints = points;
            if ((targetNode === null || targetNode === void 0 ? void 0 : targetNode.type) === dagre_compound_1.NodeType.META) {
              var i2 = combos.findIndex(function(item) {
                return item.id === (targetNode === null || targetNode === void 0 ? void 0 : targetNode.id);
              });
              if (!combos[i2] || ((_a2 = combos[i2].inEdges) === null || _a2 === void 0 ? void 0 : _a2.some(function(inEdge) {
                return inEdge.source === sourceNode.id && inEdge.target === targetNode.id;
              }))) {
                return;
              }
              (_b = combos[i2].inEdges) === null || _b === void 0 ? void 0 : _b.push({
                source: sourceNode.id,
                target: targetNode.id,
                controlPoints: points
              });
            }
            if ((sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.type) === dagre_compound_1.NodeType.META) {
              var i2 = combos.findIndex(function(item) {
                return item.id === (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.id);
              });
              if (!combos[i2] || ((_c = combos[i2].outEdges) === null || _c === void 0 ? void 0 : _c.some(function(oedge) {
                return oedge.source === sourceNode.id && oedge.target === targetNode.id;
              }))) {
                return;
              }
              (_d = combos[i2].outEdges) === null || _d === void 0 ? void 0 : _d.push({
                source: sourceNode.id,
                target: targetNode.id,
                controlPoints: points
              });
            }
          });
        }
      };
      DagreCompoundLayout3.prototype.getType = function() {
        return "dagreCompound";
      };
      DagreCompoundLayout3.prototype.getDataByOrder = function(list) {
        if (list.every(function(n2) {
          return n2.layoutOrder !== void 0;
        })) {
        } else {
          list.forEach(function(n2, i2) {
            n2.layoutOrder = i2;
          });
        }
        return list.sort(function(pre, cur) {
          return pre.layoutOrder - cur.layoutOrder;
        });
      };
      return DagreCompoundLayout3;
    }(base_1.Base);
    exports.DagreCompoundLayout = DagreCompoundLayout2;
  }
});

// node_modules/is-any-array/lib-esm/index.js
function isAnyArray(value) {
  return toString3.call(value).endsWith("Array]");
}
var toString3;
var init_lib_esm = __esm({
  "node_modules/is-any-array/lib-esm/index.js"() {
    toString3 = Object.prototype.toString;
  }
});

// node_modules/ml-array-max/lib-es6/index.js
function max4(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var maxValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] > maxValue)
      maxValue = input[i2];
  }
  return maxValue;
}
var init_lib_es6 = __esm({
  "node_modules/ml-array-max/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-min/lib-es6/index.js
function min4(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  }
  if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var _options$fromIndex = options.fromIndex, fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex, _options$toIndex = options.toIndex, toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;
  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error("fromIndex must be a positive integer smaller than length");
  }
  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");
  }
  var minValue = input[fromIndex];
  for (var i2 = fromIndex + 1; i2 < toIndex; i2++) {
    if (input[i2] < minValue)
      minValue = input[i2];
  }
  return minValue;
}
var init_lib_es62 = __esm({
  "node_modules/ml-array-min/lib-es6/index.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-array-rescale/lib-es6/index.js
function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!isAnyArray(input)) {
    throw new TypeError("input must be an array");
  } else if (input.length === 0) {
    throw new TypeError("input must not be empty");
  }
  var output;
  if (options.output !== void 0) {
    if (!isAnyArray(options.output)) {
      throw new TypeError("output option must be an array if specified");
    }
    output = options.output;
  } else {
    output = new Array(input.length);
  }
  var currentMin = min4(input);
  var currentMax = max4(input);
  if (currentMin === currentMax) {
    throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");
  }
  var _options$min = options.min, minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min, _options$max = options.max, maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;
  if (minValue >= maxValue) {
    throw new RangeError("min option must be smaller than max option");
  }
  var factor = (maxValue - minValue) / (currentMax - currentMin);
  for (var i2 = 0; i2 < input.length; i2++) {
    output[i2] = (input[i2] - currentMin) * factor + minValue;
  }
  return output;
}
var init_lib_es63 = __esm({
  "node_modules/ml-array-rescale/lib-es6/index.js"() {
    init_lib_esm();
    init_lib_es6();
    init_lib_es62();
  }
});

// node_modules/ml-matrix/src/inspect.js
function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}
function inspectMatrixWithOptions(matrix, options = {}) {
  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}
function inspectData(matrix, maxRows, maxColumns, maxNumSize) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];
  for (let i2 = 0; i2 < maxI; i2++) {
    let line = [];
    for (let j2 = 0; j2 < maxJ; j2++) {
      line.push(formatNumber(matrix.get(i2, j2), maxNumSize));
    }
    result.push(`${line.join(" ")}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`
${indentData}`);
}
function formatNumber(num, maxNumSize) {
  const numStr = String(num);
  if (numStr.length <= maxNumSize) {
    return numStr.padEnd(maxNumSize, " ");
  }
  const precise = num.toPrecision(maxNumSize - 2);
  if (precise.length <= maxNumSize) {
    return precise;
  }
  const exponential2 = num.toExponential(maxNumSize - 2);
  const eIndex = exponential2.indexOf("e");
  const e8 = exponential2.slice(eIndex);
  return exponential2.slice(0, maxNumSize - e8.length) + e8;
}
var indent, indentData;
var init_inspect = __esm({
  "node_modules/ml-matrix/src/inspect.js"() {
    indent = " ".repeat(2);
    indentData = " ".repeat(4);
  }
});

// node_modules/ml-matrix/src/mathOperations.js
function installMathOperations(AbstractMatrix2, Matrix2) {
  AbstractMatrix2.prototype.add = function add7(value) {
    if (typeof value === "number")
      return this.addS(value);
    return this.addM(value);
  };
  AbstractMatrix2.prototype.addS = function addS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.addM = function addM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) + matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.add = function add7(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.add(value);
  };
  AbstractMatrix2.prototype.sub = function sub6(value) {
    if (typeof value === "number")
      return this.subS(value);
    return this.subM(value);
  };
  AbstractMatrix2.prototype.subS = function subS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.subM = function subM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) - matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.sub = function sub6(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix2.prototype.subtract = AbstractMatrix2.prototype.sub;
  AbstractMatrix2.prototype.subtractS = AbstractMatrix2.prototype.subS;
  AbstractMatrix2.prototype.subtractM = AbstractMatrix2.prototype.subM;
  AbstractMatrix2.subtract = AbstractMatrix2.sub;
  AbstractMatrix2.prototype.mul = function mul7(value) {
    if (typeof value === "number")
      return this.mulS(value);
    return this.mulM(value);
  };
  AbstractMatrix2.prototype.mulS = function mulS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.mulM = function mulM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) * matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mul = function mul7(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix2.prototype.multiply = AbstractMatrix2.prototype.mul;
  AbstractMatrix2.prototype.multiplyS = AbstractMatrix2.prototype.mulS;
  AbstractMatrix2.prototype.multiplyM = AbstractMatrix2.prototype.mulM;
  AbstractMatrix2.multiply = AbstractMatrix2.mul;
  AbstractMatrix2.prototype.div = function div4(value) {
    if (typeof value === "number")
      return this.divS(value);
    return this.divM(value);
  };
  AbstractMatrix2.prototype.divS = function divS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.divM = function divM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) / matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.div = function div4(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix2.prototype.divide = AbstractMatrix2.prototype.div;
  AbstractMatrix2.prototype.divideS = AbstractMatrix2.prototype.divS;
  AbstractMatrix2.prototype.divideM = AbstractMatrix2.prototype.divM;
  AbstractMatrix2.divide = AbstractMatrix2.div;
  AbstractMatrix2.prototype.mod = function mod3(value) {
    if (typeof value === "number")
      return this.modS(value);
    return this.modM(value);
  };
  AbstractMatrix2.prototype.modS = function modS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.modM = function modM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) % matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.mod = function mod3(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix2.prototype.modulus = AbstractMatrix2.prototype.mod;
  AbstractMatrix2.prototype.modulusS = AbstractMatrix2.prototype.modS;
  AbstractMatrix2.prototype.modulusM = AbstractMatrix2.prototype.modM;
  AbstractMatrix2.modulus = AbstractMatrix2.mod;
  AbstractMatrix2.prototype.and = function and(value) {
    if (typeof value === "number")
      return this.andS(value);
    return this.andM(value);
  };
  AbstractMatrix2.prototype.andS = function andS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.andM = function andM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) & matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.and = function and(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.and(value);
  };
  AbstractMatrix2.prototype.or = function or2(value) {
    if (typeof value === "number")
      return this.orS(value);
    return this.orM(value);
  };
  AbstractMatrix2.prototype.orS = function orS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.orM = function orM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) | matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.or = function or2(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.or(value);
  };
  AbstractMatrix2.prototype.xor = function xor(value) {
    if (typeof value === "number")
      return this.xorS(value);
    return this.xorM(value);
  };
  AbstractMatrix2.prototype.xorS = function xorS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.xorM = function xorM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) ^ matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.xor = function xor(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.xor(value);
  };
  AbstractMatrix2.prototype.leftShift = function leftShift(value) {
    if (typeof value === "number")
      return this.leftShiftS(value);
    return this.leftShiftM(value);
  };
  AbstractMatrix2.prototype.leftShiftS = function leftShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) << matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.leftShift(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === "number")
      return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };
  AbstractMatrix2.prototype.rightShift = function rightShift(value) {
    if (typeof value === "number")
      return this.rightShiftS(value);
    return this.rightShiftM(value);
  };
  AbstractMatrix2.prototype.rightShiftS = function rightShiftS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> value);
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, this.get(i2, j2) >>> matrix.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix2.prototype.zeroFillRightShift = AbstractMatrix2.prototype.rightShift;
  AbstractMatrix2.prototype.zeroFillRightShiftS = AbstractMatrix2.prototype.rightShiftS;
  AbstractMatrix2.prototype.zeroFillRightShiftM = AbstractMatrix2.prototype.rightShiftM;
  AbstractMatrix2.zeroFillRightShift = AbstractMatrix2.rightShift;
  AbstractMatrix2.prototype.not = function not() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, ~this.get(i2, j2));
      }
    }
    return this;
  };
  AbstractMatrix2.not = function not(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.not();
  };
  AbstractMatrix2.prototype.abs = function abs3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.abs(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.abs = function abs3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.abs();
  };
  AbstractMatrix2.prototype.acos = function acos() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acos = function acos(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acos();
  };
  AbstractMatrix2.prototype.acosh = function acosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.acosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.acosh = function acosh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.acosh();
  };
  AbstractMatrix2.prototype.asin = function asin() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asin = function asin(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asin();
  };
  AbstractMatrix2.prototype.asinh = function asinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.asinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.asinh = function asinh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.asinh();
  };
  AbstractMatrix2.prototype.atan = function atan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atan = function atan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atan();
  };
  AbstractMatrix2.prototype.atanh = function atanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.atanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.atanh = function atanh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.atanh();
  };
  AbstractMatrix2.prototype.cbrt = function cbrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cbrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cbrt();
  };
  AbstractMatrix2.prototype.ceil = function ceil4() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.ceil(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.ceil = function ceil4(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.ceil();
  };
  AbstractMatrix2.prototype.clz32 = function clz32() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.clz32(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.clz32();
  };
  AbstractMatrix2.prototype.cos = function cos3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cos(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cos = function cos3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cos();
  };
  AbstractMatrix2.prototype.cosh = function cosh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.cosh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.cosh = function cosh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.cosh();
  };
  AbstractMatrix2.prototype.exp = function exp2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.exp(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.exp = function exp2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.exp();
  };
  AbstractMatrix2.prototype.expm1 = function expm1() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.expm1(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.expm1();
  };
  AbstractMatrix2.prototype.floor = function floor4() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.floor(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.floor = function floor4(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.floor();
  };
  AbstractMatrix2.prototype.fround = function fround() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.fround(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.fround = function fround(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.fround();
  };
  AbstractMatrix2.prototype.log = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log = function log2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log();
  };
  AbstractMatrix2.prototype.log1p = function log1p() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log1p(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log1p = function log1p(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log1p();
  };
  AbstractMatrix2.prototype.log10 = function log10() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log10(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log10 = function log10(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log10();
  };
  AbstractMatrix2.prototype.log2 = function log2() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.log2(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.log2 = function log2(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.log2();
  };
  AbstractMatrix2.prototype.round = function round5() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.round(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.round = function round5(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.round();
  };
  AbstractMatrix2.prototype.sign = function sign() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sign(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sign = function sign(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sign();
  };
  AbstractMatrix2.prototype.sin = function sin3() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sin(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sin = function sin3(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sin();
  };
  AbstractMatrix2.prototype.sinh = function sinh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sinh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sinh = function sinh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sinh();
  };
  AbstractMatrix2.prototype.sqrt = function sqrt() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.sqrt(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.sqrt();
  };
  AbstractMatrix2.prototype.tan = function tan() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tan(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tan = function tan(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tan();
  };
  AbstractMatrix2.prototype.tanh = function tanh() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.tanh(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.tanh = function tanh(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.tanh();
  };
  AbstractMatrix2.prototype.trunc = function trunc() {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.trunc(this.get(i2, j2)));
      }
    }
    return this;
  };
  AbstractMatrix2.trunc = function trunc(matrix) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.trunc();
  };
  AbstractMatrix2.pow = function pow2(matrix, arg0) {
    const newMatrix = new Matrix2(matrix);
    return newMatrix.pow(arg0);
  };
  AbstractMatrix2.prototype.pow = function pow2(value) {
    if (typeof value === "number")
      return this.powS(value);
    return this.powM(value);
  };
  AbstractMatrix2.prototype.powS = function powS(value) {
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), value));
      }
    }
    return this;
  };
  AbstractMatrix2.prototype.powM = function powM(matrix) {
    matrix = Matrix2.checkMatrix(matrix);
    if (this.rows !== matrix.rows || this.columns !== matrix.columns) {
      throw new RangeError("Matrices dimensions must be equal");
    }
    for (let i2 = 0; i2 < this.rows; i2++) {
      for (let j2 = 0; j2 < this.columns; j2++) {
        this.set(i2, j2, Math.pow(this.get(i2, j2), matrix.get(i2, j2)));
      }
    }
    return this;
  };
}
var init_mathOperations = __esm({
  "node_modules/ml-matrix/src/mathOperations.js"() {
  }
});

// node_modules/ml-matrix/src/util.js
function checkRowIndex(matrix, index, outer) {
  let max7 = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max7) {
    throw new RangeError("Row index out of range");
  }
}
function checkColumnIndex(matrix, index, outer) {
  let max7 = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max7) {
    throw new RangeError("Column index out of range");
  }
}
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError("vector size must be the same as the number of columns");
  }
  return vector;
}
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError("vector size must be the same as the number of rows");
  }
  return vector;
}
function checkRowIndices(matrix, rowIndices) {
  if (!isAnyArray(rowIndices)) {
    throw new TypeError("row indices must be an array");
  }
  for (let i2 = 0; i2 < rowIndices.length; i2++) {
    if (rowIndices[i2] < 0 || rowIndices[i2] >= matrix.rows) {
      throw new RangeError("row indices are out of range");
    }
  }
}
function checkColumnIndices(matrix, columnIndices) {
  if (!isAnyArray(columnIndices)) {
    throw new TypeError("column indices must be an array");
  }
  for (let i2 = 0; i2 < columnIndices.length; i2++) {
    if (columnIndices[i2] < 0 || columnIndices[i2] >= matrix.columns) {
      throw new RangeError("column indices are out of range");
    }
  }
}
function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError("expected 4 arguments");
  }
  checkNumber("startRow", startRow);
  checkNumber("endRow", endRow);
  checkNumber("startColumn", startColumn);
  checkNumber("endColumn", endColumn);
  if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {
    throw new RangeError("Submatrix indices are out of range");
  }
}
function newArray(length5, value = 0) {
  let array = [];
  for (let i2 = 0; i2 < length5; i2++) {
    array.push(value);
  }
  return array;
}
function checkNumber(name, value) {
  if (typeof value !== "number") {
    throw new TypeError(`${name} must be a number`);
  }
}
function checkNonEmpty(matrix) {
  if (matrix.isEmpty()) {
    throw new Error("Empty matrix has no elements to index");
  }
}
var init_util2 = __esm({
  "node_modules/ml-matrix/src/util.js"() {
    init_lib_esm();
  }
});

// node_modules/ml-matrix/src/stat.js
function sumByRow(matrix) {
  let sum = newArray(matrix.rows);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumByColumn(matrix) {
  let sum = newArray(matrix.columns);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] += matrix.get(i2, j2);
    }
  }
  return sum;
}
function sumAll(matrix) {
  let v2 = 0;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 += matrix.get(i2, j2);
    }
  }
  return v2;
}
function productByRow(matrix) {
  let sum = newArray(matrix.rows, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[i2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productByColumn(matrix) {
  let sum = newArray(matrix.columns, 1);
  for (let i2 = 0; i2 < matrix.rows; ++i2) {
    for (let j2 = 0; j2 < matrix.columns; ++j2) {
      sum[j2] *= matrix.get(i2, j2);
    }
  }
  return sum;
}
function productAll(matrix) {
  let v2 = 1;
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      v2 *= matrix.get(i2, j2);
    }
  }
  return v2;
}
function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let i2 = 0; i2 < rows; i2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x2 = 0;
    for (let j2 = 0; j2 < cols; j2++) {
      x2 = matrix.get(i2, j2) - mean[i2];
      sum1 += x2;
      sum2 += x2 * x2;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / cols) / (cols - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / cols) / cols);
    }
  }
  return variance;
}
function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];
  for (let j2 = 0; j2 < cols; j2++) {
    let sum1 = 0;
    let sum2 = 0;
    let x2 = 0;
    for (let i2 = 0; i2 < rows; i2++) {
      x2 = matrix.get(i2, j2) - mean[j2];
      sum1 += x2;
      sum2 += x2 * x2;
    }
    if (unbiased) {
      variance.push((sum2 - sum1 * sum1 / rows) / (rows - 1));
    } else {
      variance.push((sum2 - sum1 * sum1 / rows) / rows);
    }
  }
  return variance;
}
function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size2 = rows * cols;
  let sum1 = 0;
  let sum2 = 0;
  let x2 = 0;
  for (let i2 = 0; i2 < rows; i2++) {
    for (let j2 = 0; j2 < cols; j2++) {
      x2 = matrix.get(i2, j2) - mean;
      sum1 += x2;
      sum2 += x2 * x2;
    }
  }
  if (unbiased) {
    return (sum2 - sum1 * sum1 / size2) / (size2 - 1);
  } else {
    return (sum2 - sum1 * sum1 / size2) / size2;
  }
}
function centerByRow(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[i2]);
    }
  }
}
function centerByColumn(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean[j2]);
    }
  }
}
function centerAll(matrix, mean) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) - mean);
    }
  }
}
function getScaleByRow(matrix) {
  const scale9 = [];
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    let sum = 0;
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.columns - 1);
    }
    scale9.push(Math.sqrt(sum));
  }
  return scale9;
}
function scaleByRow(matrix, scale9) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale9[i2]);
    }
  }
}
function getScaleByColumn(matrix) {
  const scale9 = [];
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    let sum = 0;
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / (matrix.rows - 1);
    }
    scale9.push(Math.sqrt(sum));
  }
  return scale9;
}
function scaleByColumn(matrix, scale9) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale9[j2]);
    }
  }
}
function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j2 = 0; j2 < matrix.columns; j2++) {
    for (let i2 = 0; i2 < matrix.rows; i2++) {
      sum += Math.pow(matrix.get(i2, j2), 2) / divider;
    }
  }
  return Math.sqrt(sum);
}
function scaleAll(matrix, scale9) {
  for (let i2 = 0; i2 < matrix.rows; i2++) {
    for (let j2 = 0; j2 < matrix.columns; j2++) {
      matrix.set(i2, j2, matrix.get(i2, j2) / scale9);
    }
  }
}
var init_stat = __esm({
  "node_modules/ml-matrix/src/stat.js"() {
    init_util2();
  }
});

// node_modules/ml-matrix/src/matrix.js
function compareNumbers(a2, b10) {
  return a2 - b10;
}
var AbstractMatrix, Matrix;
var init_matrix = __esm({
  "node_modules/ml-matrix/src/matrix.js"() {
    init_lib_esm();
    init_lib_es63();
    init_inspect();
    init_mathOperations();
    init_stat();
    init_util2();
    AbstractMatrix = class {
      static from1DArray(newRows, newColumns, newData) {
        let length5 = newRows * newColumns;
        if (length5 !== newData.length) {
          throw new RangeError("data length does not match given dimensions");
        }
        let newMatrix = new Matrix(newRows, newColumns);
        for (let row = 0; row < newRows; row++) {
          for (let column = 0; column < newColumns; column++) {
            newMatrix.set(row, column, newData[row * newColumns + column]);
          }
        }
        return newMatrix;
      }
      static rowVector(newData) {
        let vector = new Matrix(1, newData.length);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(0, i2, newData[i2]);
        }
        return vector;
      }
      static columnVector(newData) {
        let vector = new Matrix(newData.length, 1);
        for (let i2 = 0; i2 < newData.length; i2++) {
          vector.set(i2, 0, newData[i2]);
        }
        return vector;
      }
      static zeros(rows, columns) {
        return new Matrix(rows, columns);
      }
      static ones(rows, columns) {
        return new Matrix(rows, columns).fill(1);
      }
      static rand(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { random: random5 = Math.random } = options;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.set(i2, j2, random5());
          }
        }
        return matrix;
      }
      static randInt(rows, columns, options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max7 = 1e3, random: random5 = Math.random } = options;
        if (!Number.isInteger(min6))
          throw new TypeError("min must be an integer");
        if (!Number.isInteger(max7))
          throw new TypeError("max must be an integer");
        if (min6 >= max7)
          throw new RangeError("min must be smaller than max");
        let interval2 = max7 - min6;
        let matrix = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            let value = min6 + Math.round(random5() * interval2);
            matrix.set(i2, j2, value);
          }
        }
        return matrix;
      }
      static eye(rows, columns, value) {
        if (columns === void 0)
          columns = rows;
        if (value === void 0)
          value = 1;
        let min6 = Math.min(rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min6; i2++) {
          matrix.set(i2, i2, value);
        }
        return matrix;
      }
      static diag(data, rows, columns) {
        let l2 = data.length;
        if (rows === void 0)
          rows = l2;
        if (columns === void 0)
          columns = rows;
        let min6 = Math.min(l2, rows, columns);
        let matrix = this.zeros(rows, columns);
        for (let i2 = 0; i2 < min6; i2++) {
          matrix.set(i2, i2, data[i2]);
        }
        return matrix;
      }
      static min(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.min(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static max(matrix1, matrix2) {
        matrix1 = this.checkMatrix(matrix1);
        matrix2 = this.checkMatrix(matrix2);
        let rows = matrix1.rows;
        let columns = matrix1.columns;
        let result = new this(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            result.set(i2, j2, Math.max(matrix1.get(i2, j2), matrix2.get(i2, j2)));
          }
        }
        return result;
      }
      static checkMatrix(value) {
        return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
      }
      static isMatrix(value) {
        return value != null && value.klass === "Matrix";
      }
      get size() {
        return this.rows * this.columns;
      }
      apply(callback) {
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            callback.call(this, i2, j2);
          }
        }
        return this;
      }
      to1DArray() {
        let array = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            array.push(this.get(i2, j2));
          }
        }
        return array;
      }
      to2DArray() {
        let copy8 = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          copy8.push([]);
          for (let j2 = 0; j2 < this.columns; j2++) {
            copy8[i2].push(this.get(i2, j2));
          }
        }
        return copy8;
      }
      toJSON() {
        return this.to2DArray();
      }
      isRowVector() {
        return this.rows === 1;
      }
      isColumnVector() {
        return this.columns === 1;
      }
      isVector() {
        return this.rows === 1 || this.columns === 1;
      }
      isSquare() {
        return this.rows === this.columns;
      }
      isEmpty() {
        return this.rows === 0 || this.columns === 0;
      }
      isSymmetric() {
        if (this.isSquare()) {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 <= i2; j2++) {
              if (this.get(i2, j2) !== this.get(j2, i2)) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      isEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isEchelonForm = false;
              checked = true;
            }
          }
          i2++;
        }
        return isEchelonForm;
      }
      isReducedEchelonForm() {
        let i2 = 0;
        let j2 = 0;
        let previousColumn = -1;
        let isReducedEchelonForm = true;
        let checked = false;
        while (i2 < this.rows && isReducedEchelonForm) {
          j2 = 0;
          checked = false;
          while (j2 < this.columns && checked === false) {
            if (this.get(i2, j2) === 0) {
              j2++;
            } else if (this.get(i2, j2) === 1 && j2 > previousColumn) {
              checked = true;
              previousColumn = j2;
            } else {
              isReducedEchelonForm = false;
              checked = true;
            }
          }
          for (let k2 = j2 + 1; k2 < this.rows; k2++) {
            if (this.get(i2, k2) !== 0) {
              isReducedEchelonForm = false;
            }
          }
          i2++;
        }
        return isReducedEchelonForm;
      }
      echelonForm() {
        let result = this.clone();
        let h2 = 0;
        let k2 = 0;
        while (h2 < result.rows && k2 < result.columns) {
          let iMax = h2;
          for (let i2 = h2; i2 < result.rows; i2++) {
            if (result.get(i2, k2) > result.get(iMax, k2)) {
              iMax = i2;
            }
          }
          if (result.get(iMax, k2) === 0) {
            k2++;
          } else {
            result.swapRows(h2, iMax);
            let tmp = result.get(h2, k2);
            for (let j2 = k2; j2 < result.columns; j2++) {
              result.set(h2, j2, result.get(h2, j2) / tmp);
            }
            for (let i2 = h2 + 1; i2 < result.rows; i2++) {
              let factor = result.get(i2, k2) / result.get(h2, k2);
              result.set(i2, k2, 0);
              for (let j2 = k2 + 1; j2 < result.columns; j2++) {
                result.set(i2, j2, result.get(i2, j2) - result.get(h2, j2) * factor);
              }
            }
            h2++;
            k2++;
          }
        }
        return result;
      }
      reducedEchelonForm() {
        let result = this.echelonForm();
        let m2 = result.columns;
        let n2 = result.rows;
        let h2 = n2 - 1;
        while (h2 >= 0) {
          if (result.maxRow(h2) === 0) {
            h2--;
          } else {
            let p2 = 0;
            let pivot = false;
            while (p2 < n2 && pivot === false) {
              if (result.get(h2, p2) === 1) {
                pivot = true;
              } else {
                p2++;
              }
            }
            for (let i2 = 0; i2 < h2; i2++) {
              let factor = result.get(i2, p2);
              for (let j2 = p2; j2 < m2; j2++) {
                let tmp = result.get(i2, j2) - factor * result.get(h2, j2);
                result.set(i2, j2, tmp);
              }
            }
            h2--;
          }
        }
        return result;
      }
      set() {
        throw new Error("set method is unimplemented");
      }
      get() {
        throw new Error("get method is unimplemented");
      }
      repeat(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { rows = 1, columns = 1 } = options;
        if (!Number.isInteger(rows) || rows <= 0) {
          throw new TypeError("rows must be a positive integer");
        }
        if (!Number.isInteger(columns) || columns <= 0) {
          throw new TypeError("columns must be a positive integer");
        }
        let matrix = new Matrix(this.rows * rows, this.columns * columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            matrix.setSubMatrix(this, this.rows * i2, this.columns * j2);
          }
        }
        return matrix;
      }
      fill(value) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, value);
          }
        }
        return this;
      }
      neg() {
        return this.mulS(-1);
      }
      getRow(index) {
        checkRowIndex(this, index);
        let row = [];
        for (let i2 = 0; i2 < this.columns; i2++) {
          row.push(this.get(index, i2));
        }
        return row;
      }
      getRowVector(index) {
        return Matrix.rowVector(this.getRow(index));
      }
      setRow(index, array) {
        checkRowIndex(this, index);
        array = checkRowVector(this, array);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index, i2, array[i2]);
        }
        return this;
      }
      swapRows(row1, row2) {
        checkRowIndex(this, row1);
        checkRowIndex(this, row2);
        for (let i2 = 0; i2 < this.columns; i2++) {
          let temp = this.get(row1, i2);
          this.set(row1, i2, this.get(row2, i2));
          this.set(row2, i2, temp);
        }
        return this;
      }
      getColumn(index) {
        checkColumnIndex(this, index);
        let column = [];
        for (let i2 = 0; i2 < this.rows; i2++) {
          column.push(this.get(i2, index));
        }
        return column;
      }
      getColumnVector(index) {
        return Matrix.columnVector(this.getColumn(index));
      }
      setColumn(index, array) {
        checkColumnIndex(this, index);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index, array[i2]);
        }
        return this;
      }
      swapColumns(column1, column2) {
        checkColumnIndex(this, column1);
        checkColumnIndex(this, column2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          let temp = this.get(i2, column1);
          this.set(i2, column1, this.get(i2, column2));
          this.set(i2, column2, temp);
        }
        return this;
      }
      addRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[j2]);
          }
        }
        return this;
      }
      subRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[j2]);
          }
        }
        return this;
      }
      mulRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[j2]);
          }
        }
        return this;
      }
      divRowVector(vector) {
        vector = checkRowVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[j2]);
          }
        }
        return this;
      }
      addColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) + vector[i2]);
          }
        }
        return this;
      }
      subColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) - vector[i2]);
          }
        }
        return this;
      }
      mulColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) * vector[i2]);
          }
        }
        return this;
      }
      divColumnVector(vector) {
        vector = checkColumnVector(this, vector);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            this.set(i2, j2, this.get(i2, j2) / vector[i2]);
          }
        }
        return this;
      }
      mulRow(index, value) {
        checkRowIndex(this, index);
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.set(index, i2, this.get(index, i2) * value);
        }
        return this;
      }
      mulColumn(index, value) {
        checkColumnIndex(this, index);
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.set(i2, index, this.get(i2, index) * value);
        }
        return this;
      }
      max() {
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      maxIndex() {
        checkNonEmpty(this);
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) > v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      min() {
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, 0);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
            }
          }
        }
        return v2;
      }
      minIndex() {
        checkNonEmpty(this);
        let v2 = this.get(0, 0);
        let idx = [0, 0];
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            if (this.get(i2, j2) < v2) {
              v2 = this.get(i2, j2);
              idx[0] = i2;
              idx[1] = j2;
            }
          }
        }
        return idx;
      }
      maxRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      maxRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) > v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      minRow(row) {
        checkRowIndex(this, row);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(row, 0);
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
          }
        }
        return v2;
      }
      minRowIndex(row) {
        checkRowIndex(this, row);
        checkNonEmpty(this);
        let v2 = this.get(row, 0);
        let idx = [row, 0];
        for (let i2 = 1; i2 < this.columns; i2++) {
          if (this.get(row, i2) < v2) {
            v2 = this.get(row, i2);
            idx[1] = i2;
          }
        }
        return idx;
      }
      maxColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      maxColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) > v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      minColumn(column) {
        checkColumnIndex(this, column);
        if (this.isEmpty()) {
          return NaN;
        }
        let v2 = this.get(0, column);
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
          }
        }
        return v2;
      }
      minColumnIndex(column) {
        checkColumnIndex(this, column);
        checkNonEmpty(this);
        let v2 = this.get(0, column);
        let idx = [0, column];
        for (let i2 = 1; i2 < this.rows; i2++) {
          if (this.get(i2, column) < v2) {
            v2 = this.get(i2, column);
            idx[0] = i2;
          }
        }
        return idx;
      }
      diag() {
        let min6 = Math.min(this.rows, this.columns);
        let diag = [];
        for (let i2 = 0; i2 < min6; i2++) {
          diag.push(this.get(i2, i2));
        }
        return diag;
      }
      norm(type = "frobenius") {
        let result = 0;
        if (type === "max") {
          return this.max();
        } else if (type === "frobenius") {
          for (let i2 = 0; i2 < this.rows; i2++) {
            for (let j2 = 0; j2 < this.columns; j2++) {
              result = result + this.get(i2, j2) * this.get(i2, j2);
            }
          }
          return Math.sqrt(result);
        } else {
          throw new RangeError(`unknown norm type: ${type}`);
        }
      }
      cumulativeSum() {
        let sum = 0;
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            sum += this.get(i2, j2);
            this.set(i2, j2, sum);
          }
        }
        return this;
      }
      dot(vector2) {
        if (AbstractMatrix.isMatrix(vector2))
          vector2 = vector2.to1DArray();
        let vector1 = this.to1DArray();
        if (vector1.length !== vector2.length) {
          throw new RangeError("vectors do not have the same size");
        }
        let dot6 = 0;
        for (let i2 = 0; i2 < vector1.length; i2++) {
          dot6 += vector1[i2] * vector2[i2];
        }
        return dot6;
      }
      mmul(other) {
        other = Matrix.checkMatrix(other);
        let m2 = this.rows;
        let n2 = this.columns;
        let p2 = other.columns;
        let result = new Matrix(m2, p2);
        let Bcolj = new Float64Array(n2);
        for (let j2 = 0; j2 < p2; j2++) {
          for (let k2 = 0; k2 < n2; k2++) {
            Bcolj[k2] = other.get(k2, j2);
          }
          for (let i2 = 0; i2 < m2; i2++) {
            let s2 = 0;
            for (let k2 = 0; k2 < n2; k2++) {
              s2 += this.get(i2, k2) * Bcolj[k2];
            }
            result.set(i2, j2, s2);
          }
        }
        return result;
      }
      strassen2x2(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(2, 2);
        const a11 = this.get(0, 0);
        const b11 = other.get(0, 0);
        const a12 = this.get(0, 1);
        const b12 = other.get(0, 1);
        const a21 = this.get(1, 0);
        const b21 = other.get(1, 0);
        const a22 = this.get(1, 1);
        const b22 = other.get(1, 1);
        const m1 = (a11 + a22) * (b11 + b22);
        const m2 = (a21 + a22) * b11;
        const m3 = a11 * (b12 - b22);
        const m4 = a22 * (b21 - b11);
        const m5 = (a11 + a12) * b22;
        const m6 = (a21 - a11) * (b11 + b12);
        const m7 = (a12 - a22) * (b21 + b22);
        const c00 = m1 + m4 - m5 + m7;
        const c01 = m3 + m5;
        const c10 = m2 + m4;
        const c11 = m1 - m2 + m3 + m6;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        return result;
      }
      strassen3x3(other) {
        other = Matrix.checkMatrix(other);
        let result = new Matrix(3, 3);
        const a00 = this.get(0, 0);
        const a01 = this.get(0, 1);
        const a02 = this.get(0, 2);
        const a10 = this.get(1, 0);
        const a11 = this.get(1, 1);
        const a12 = this.get(1, 2);
        const a20 = this.get(2, 0);
        const a21 = this.get(2, 1);
        const a22 = this.get(2, 2);
        const b00 = other.get(0, 0);
        const b01 = other.get(0, 1);
        const b02 = other.get(0, 2);
        const b10 = other.get(1, 0);
        const b11 = other.get(1, 1);
        const b12 = other.get(1, 2);
        const b20 = other.get(2, 0);
        const b21 = other.get(2, 1);
        const b22 = other.get(2, 2);
        const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
        const m2 = (a00 - a10) * (-b01 + b11);
        const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
        const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
        const m5 = (a10 + a11) * (-b00 + b01);
        const m6 = a00 * b00;
        const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
        const m8 = (-a00 + a20) * (b02 - b12);
        const m9 = (a20 + a21) * (-b00 + b02);
        const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
        const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
        const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
        const m13 = (a02 - a22) * (b11 - b21);
        const m14 = a02 * b20;
        const m15 = (a21 + a22) * (-b20 + b21);
        const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
        const m17 = (a02 - a12) * (b12 - b22);
        const m18 = (a11 + a12) * (-b20 + b22);
        const m19 = a01 * b10;
        const m20 = a12 * b21;
        const m21 = a10 * b02;
        const m22 = a20 * b01;
        const m23 = a22 * b22;
        const c00 = m6 + m14 + m19;
        const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
        const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
        const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
        const c11 = m2 + m4 + m5 + m6 + m20;
        const c12 = m14 + m16 + m17 + m18 + m21;
        const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
        const c21 = m12 + m13 + m14 + m15 + m22;
        const c22 = m6 + m7 + m8 + m9 + m23;
        result.set(0, 0, c00);
        result.set(0, 1, c01);
        result.set(0, 2, c02);
        result.set(1, 0, c10);
        result.set(1, 1, c11);
        result.set(1, 2, c12);
        result.set(2, 0, c20);
        result.set(2, 1, c21);
        result.set(2, 2, c22);
        return result;
      }
      mmulStrassen(y2) {
        y2 = Matrix.checkMatrix(y2);
        let x2 = this.clone();
        let r1 = x2.rows;
        let c1 = x2.columns;
        let r2 = y2.rows;
        let c2 = y2.columns;
        if (c1 !== r2) {
          console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);
        }
        function embed(mat, rows, cols) {
          let r4 = mat.rows;
          let c4 = mat.columns;
          if (r4 === rows && c4 === cols) {
            return mat;
          } else {
            let resultat = AbstractMatrix.zeros(rows, cols);
            resultat = resultat.setSubMatrix(mat, 0, 0);
            return resultat;
          }
        }
        let r3 = Math.max(r1, r2);
        let c3 = Math.max(c1, c2);
        x2 = embed(x2, r3, c3);
        y2 = embed(y2, r3, c3);
        function blockMult(a2, b10, rows, cols) {
          if (rows <= 512 || cols <= 512) {
            return a2.mmul(b10);
          }
          if (rows % 2 === 1 && cols % 2 === 1) {
            a2 = embed(a2, rows + 1, cols + 1);
            b10 = embed(b10, rows + 1, cols + 1);
          } else if (rows % 2 === 1) {
            a2 = embed(a2, rows + 1, cols);
            b10 = embed(b10, rows + 1, cols);
          } else if (cols % 2 === 1) {
            a2 = embed(a2, rows, cols + 1);
            b10 = embed(b10, rows, cols + 1);
          }
          let halfRows = parseInt(a2.rows / 2, 10);
          let halfCols = parseInt(a2.columns / 2, 10);
          let a11 = a2.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let b11 = b10.subMatrix(0, halfRows - 1, 0, halfCols - 1);
          let a12 = a2.subMatrix(0, halfRows - 1, halfCols, a2.columns - 1);
          let b12 = b10.subMatrix(0, halfRows - 1, halfCols, b10.columns - 1);
          let a21 = a2.subMatrix(halfRows, a2.rows - 1, 0, halfCols - 1);
          let b21 = b10.subMatrix(halfRows, b10.rows - 1, 0, halfCols - 1);
          let a22 = a2.subMatrix(halfRows, a2.rows - 1, halfCols, a2.columns - 1);
          let b22 = b10.subMatrix(halfRows, b10.rows - 1, halfCols, b10.columns - 1);
          let m1 = blockMult(AbstractMatrix.add(a11, a22), AbstractMatrix.add(b11, b22), halfRows, halfCols);
          let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
          let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
          let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
          let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
          let m6 = blockMult(AbstractMatrix.sub(a21, a11), AbstractMatrix.add(b11, b12), halfRows, halfCols);
          let m7 = blockMult(AbstractMatrix.sub(a12, a22), AbstractMatrix.add(b21, b22), halfRows, halfCols);
          let c11 = AbstractMatrix.add(m1, m4);
          c11.sub(m5);
          c11.add(m7);
          let c12 = AbstractMatrix.add(m3, m5);
          let c21 = AbstractMatrix.add(m2, m4);
          let c22 = AbstractMatrix.sub(m1, m2);
          c22.add(m3);
          c22.add(m6);
          let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
          resultat = resultat.setSubMatrix(c11, 0, 0);
          resultat = resultat.setSubMatrix(c12, c11.rows, 0);
          resultat = resultat.setSubMatrix(c21, 0, c11.columns);
          resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);
          return resultat.subMatrix(0, rows - 1, 0, cols - 1);
        }
        return blockMult(x2, y2, r3, c3);
      }
      scaleRows(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max7 = 1 } = options;
        if (!Number.isFinite(min6))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max7))
          throw new TypeError("max must be a number");
        if (min6 >= max7)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const row = this.getRow(i2);
          if (row.length > 0) {
            rescale(row, { min: min6, max: max7, output: row });
          }
          newMatrix.setRow(i2, row);
        }
        return newMatrix;
      }
      scaleColumns(options = {}) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { min: min6 = 0, max: max7 = 1 } = options;
        if (!Number.isFinite(min6))
          throw new TypeError("min must be a number");
        if (!Number.isFinite(max7))
          throw new TypeError("max must be a number");
        if (min6 >= max7)
          throw new RangeError("min must be smaller than max");
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let i2 = 0; i2 < this.columns; i2++) {
          const column = this.getColumn(i2);
          if (column.length) {
            rescale(column, {
              min: min6,
              max: max7,
              output: column
            });
          }
          newMatrix.setColumn(i2, column);
        }
        return newMatrix;
      }
      flipRows() {
        const middle = Math.ceil(this.columns / 2);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < middle; j2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(i2, this.columns - 1 - j2);
            this.set(i2, j2, last2);
            this.set(i2, this.columns - 1 - j2, first);
          }
        }
        return this;
      }
      flipColumns() {
        const middle = Math.ceil(this.rows / 2);
        for (let j2 = 0; j2 < this.columns; j2++) {
          for (let i2 = 0; i2 < middle; i2++) {
            let first = this.get(i2, j2);
            let last2 = this.get(this.rows - 1 - i2, j2);
            this.set(i2, j2, last2);
            this.set(this.rows - 1 - i2, j2, first);
          }
        }
        return this;
      }
      kroneckerProduct(other) {
        other = Matrix.checkMatrix(other);
        let m2 = this.rows;
        let n2 = this.columns;
        let p2 = other.rows;
        let q2 = other.columns;
        let result = new Matrix(m2 * p2, n2 * q2);
        for (let i2 = 0; i2 < m2; i2++) {
          for (let j2 = 0; j2 < n2; j2++) {
            for (let k2 = 0; k2 < p2; k2++) {
              for (let l2 = 0; l2 < q2; l2++) {
                result.set(p2 * i2 + k2, q2 * j2 + l2, this.get(i2, j2) * other.get(k2, l2));
              }
            }
          }
        }
        return result;
      }
      kroneckerSum(other) {
        other = Matrix.checkMatrix(other);
        if (!this.isSquare() || !other.isSquare()) {
          throw new Error("Kronecker Sum needs two Square Matrices");
        }
        let m2 = this.rows;
        let n2 = other.rows;
        let AxI = this.kroneckerProduct(Matrix.eye(n2, n2));
        let IxB = Matrix.eye(m2, m2).kroneckerProduct(other);
        return AxI.add(IxB);
      }
      transpose() {
        let result = new Matrix(this.columns, this.rows);
        for (let i2 = 0; i2 < this.rows; i2++) {
          for (let j2 = 0; j2 < this.columns; j2++) {
            result.set(j2, i2, this.get(i2, j2));
          }
        }
        return result;
      }
      sortRows(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.rows; i2++) {
          this.setRow(i2, this.getRow(i2).sort(compareFunction));
        }
        return this;
      }
      sortColumns(compareFunction = compareNumbers) {
        for (let i2 = 0; i2 < this.columns; i2++) {
          this.setColumn(i2, this.getColumn(i2).sort(compareFunction));
        }
        return this;
      }
      subMatrix(startRow, endRow, startColumn, endColumn) {
        checkRange(this, startRow, endRow, startColumn, endColumn);
        let newMatrix = new Matrix(endRow - startRow + 1, endColumn - startColumn + 1);
        for (let i2 = startRow; i2 <= endRow; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            newMatrix.set(i2 - startRow, j2 - startColumn, this.get(i2, j2));
          }
        }
        return newMatrix;
      }
      subMatrixRow(indices, startColumn, endColumn) {
        if (startColumn === void 0)
          startColumn = 0;
        if (endColumn === void 0)
          endColumn = this.columns - 1;
        if (startColumn > endColumn || startColumn < 0 || startColumn >= this.columns || endColumn < 0 || endColumn >= this.columns) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startColumn; j2 <= endColumn; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.rows) {
              throw new RangeError(`Row index out of range: ${indices[i2]}`);
            }
            newMatrix.set(i2, j2 - startColumn, this.get(indices[i2], j2));
          }
        }
        return newMatrix;
      }
      subMatrixColumn(indices, startRow, endRow) {
        if (startRow === void 0)
          startRow = 0;
        if (endRow === void 0)
          endRow = this.rows - 1;
        if (startRow > endRow || startRow < 0 || startRow >= this.rows || endRow < 0 || endRow >= this.rows) {
          throw new RangeError("Argument out of range");
        }
        let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
        for (let i2 = 0; i2 < indices.length; i2++) {
          for (let j2 = startRow; j2 <= endRow; j2++) {
            if (indices[i2] < 0 || indices[i2] >= this.columns) {
              throw new RangeError(`Column index out of range: ${indices[i2]}`);
            }
            newMatrix.set(j2 - startRow, i2, this.get(j2, indices[i2]));
          }
        }
        return newMatrix;
      }
      setSubMatrix(matrix, startRow, startColumn) {
        matrix = Matrix.checkMatrix(matrix);
        if (matrix.isEmpty()) {
          return this;
        }
        let endRow = startRow + matrix.rows - 1;
        let endColumn = startColumn + matrix.columns - 1;
        checkRange(this, startRow, endRow, startColumn, endColumn);
        for (let i2 = 0; i2 < matrix.rows; i2++) {
          for (let j2 = 0; j2 < matrix.columns; j2++) {
            this.set(startRow + i2, startColumn + j2, matrix.get(i2, j2));
          }
        }
        return this;
      }
      selection(rowIndices, columnIndices) {
        checkRowIndices(this, rowIndices);
        checkColumnIndices(this, columnIndices);
        let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
        for (let i2 = 0; i2 < rowIndices.length; i2++) {
          let rowIndex = rowIndices[i2];
          for (let j2 = 0; j2 < columnIndices.length; j2++) {
            let columnIndex = columnIndices[j2];
            newMatrix.set(i2, j2, this.get(rowIndex, columnIndex));
          }
        }
        return newMatrix;
      }
      trace() {
        let min6 = Math.min(this.rows, this.columns);
        let trace = 0;
        for (let i2 = 0; i2 < min6; i2++) {
          trace += this.get(i2, i2);
        }
        return trace;
      }
      clone() {
        let newMatrix = new Matrix(this.rows, this.columns);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            newMatrix.set(row, column, this.get(row, column));
          }
        }
        return newMatrix;
      }
      sum(by) {
        switch (by) {
          case "row":
            return sumByRow(this);
          case "column":
            return sumByColumn(this);
          case void 0:
            return sumAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      product(by) {
        switch (by) {
          case "row":
            return productByRow(this);
          case "column":
            return productByColumn(this);
          case void 0:
            return productAll(this);
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      mean(by) {
        const sum = this.sum(by);
        switch (by) {
          case "row": {
            for (let i2 = 0; i2 < this.rows; i2++) {
              sum[i2] /= this.columns;
            }
            return sum;
          }
          case "column": {
            for (let i2 = 0; i2 < this.columns; i2++) {
              sum[i2] /= this.rows;
            }
            return sum;
          }
          case void 0:
            return sum / this.size;
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      variance(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { unbiased = true, mean = this.mean(by) } = options;
        if (typeof unbiased !== "boolean") {
          throw new TypeError("unbiased must be a boolean");
        }
        switch (by) {
          case "row": {
            if (!isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByRow(this, unbiased, mean);
          }
          case "column": {
            if (!isAnyArray(mean)) {
              throw new TypeError("mean must be an array");
            }
            return varianceByColumn(this, unbiased, mean);
          }
          case void 0: {
            if (typeof mean !== "number") {
              throw new TypeError("mean must be a number");
            }
            return varianceAll(this, unbiased, mean);
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      standardDeviation(by, options) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        const variance = this.variance(by, options);
        if (by === void 0) {
          return Math.sqrt(variance);
        } else {
          for (let i2 = 0; i2 < variance.length; i2++) {
            variance[i2] = Math.sqrt(variance[i2]);
          }
          return variance;
        }
      }
      center(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        const { center = this.mean(by) } = options;
        switch (by) {
          case "row": {
            if (!isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByRow(this, center);
            return this;
          }
          case "column": {
            if (!isAnyArray(center)) {
              throw new TypeError("center must be an array");
            }
            centerByColumn(this, center);
            return this;
          }
          case void 0: {
            if (typeof center !== "number") {
              throw new TypeError("center must be a number");
            }
            centerAll(this, center);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      scale(by, options = {}) {
        if (typeof by === "object") {
          options = by;
          by = void 0;
        }
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        let scale9 = options.scale;
        switch (by) {
          case "row": {
            if (scale9 === void 0) {
              scale9 = getScaleByRow(this);
            } else if (!isAnyArray(scale9)) {
              throw new TypeError("scale must be an array");
            }
            scaleByRow(this, scale9);
            return this;
          }
          case "column": {
            if (scale9 === void 0) {
              scale9 = getScaleByColumn(this);
            } else if (!isAnyArray(scale9)) {
              throw new TypeError("scale must be an array");
            }
            scaleByColumn(this, scale9);
            return this;
          }
          case void 0: {
            if (scale9 === void 0) {
              scale9 = getScaleAll(this);
            } else if (typeof scale9 !== "number") {
              throw new TypeError("scale must be a number");
            }
            scaleAll(this, scale9);
            return this;
          }
          default:
            throw new Error(`invalid option: ${by}`);
        }
      }
      toString(options) {
        return inspectMatrixWithOptions(this, options);
      }
    };
    AbstractMatrix.prototype.klass = "Matrix";
    if (typeof Symbol !== "undefined") {
      AbstractMatrix.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspectMatrix;
    }
    AbstractMatrix.random = AbstractMatrix.rand;
    AbstractMatrix.randomInt = AbstractMatrix.randInt;
    AbstractMatrix.diagonal = AbstractMatrix.diag;
    AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
    AbstractMatrix.identity = AbstractMatrix.eye;
    AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
    AbstractMatrix.prototype.tensorProduct = AbstractMatrix.prototype.kroneckerProduct;
    Matrix = class extends AbstractMatrix {
      constructor(nRows, nColumns) {
        super();
        if (Matrix.isMatrix(nRows)) {
          return nRows.clone();
        } else if (Number.isInteger(nRows) && nRows >= 0) {
          this.data = [];
          if (Number.isInteger(nColumns) && nColumns >= 0) {
            for (let i2 = 0; i2 < nRows; i2++) {
              this.data.push(new Float64Array(nColumns));
            }
          } else {
            throw new TypeError("nColumns must be a positive integer");
          }
        } else if (isAnyArray(nRows)) {
          const arrayData = nRows;
          nRows = arrayData.length;
          nColumns = nRows ? arrayData[0].length : 0;
          if (typeof nColumns !== "number") {
            throw new TypeError("Data must be a 2D array with at least one element");
          }
          this.data = [];
          for (let i2 = 0; i2 < nRows; i2++) {
            if (arrayData[i2].length !== nColumns) {
              throw new RangeError("Inconsistent array dimensions");
            }
            this.data.push(Float64Array.from(arrayData[i2]));
          }
        } else {
          throw new TypeError("First argument must be a positive number or an array");
        }
        this.rows = nRows;
        this.columns = nColumns;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
      removeRow(index) {
        checkRowIndex(this, index);
        this.data.splice(index, 1);
        this.rows -= 1;
        return this;
      }
      addRow(index, array) {
        if (array === void 0) {
          array = index;
          index = this.rows;
        }
        checkRowIndex(this, index, true);
        array = Float64Array.from(checkRowVector(this, array));
        this.data.splice(index, 0, array);
        this.rows += 1;
        return this;
      }
      removeColumn(index) {
        checkColumnIndex(this, index);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns - 1);
          for (let j2 = 0; j2 < index; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          for (let j2 = index + 1; j2 < this.columns; j2++) {
            newRow[j2 - 1] = this.data[i2][j2];
          }
          this.data[i2] = newRow;
        }
        this.columns -= 1;
        return this;
      }
      addColumn(index, array) {
        if (typeof array === "undefined") {
          array = index;
          index = this.columns;
        }
        checkColumnIndex(this, index, true);
        array = checkColumnVector(this, array);
        for (let i2 = 0; i2 < this.rows; i2++) {
          const newRow = new Float64Array(this.columns + 1);
          let j2 = 0;
          for (; j2 < index; j2++) {
            newRow[j2] = this.data[i2][j2];
          }
          newRow[j2++] = array[i2];
          for (; j2 < this.columns + 1; j2++) {
            newRow[j2] = this.data[i2][j2 - 1];
          }
          this.data[i2] = newRow;
        }
        this.columns += 1;
        return this;
      }
    };
    installMathOperations(AbstractMatrix, Matrix);
  }
});

// node_modules/ml-matrix/src/views/base.js
var BaseView;
var init_base = __esm({
  "node_modules/ml-matrix/src/views/base.js"() {
    init_matrix();
    BaseView = class extends AbstractMatrix {
      constructor(matrix, rows, columns) {
        super();
        this.matrix = matrix;
        this.rows = rows;
        this.columns = columns;
      }
    };
  }
});

// node_modules/ml-matrix/src/views/column.js
var MatrixColumnView;
var init_column = __esm({
  "node_modules/ml-matrix/src/views/column.js"() {
    init_util2();
    init_base();
    MatrixColumnView = class extends BaseView {
      constructor(matrix, column) {
        checkColumnIndex(matrix, column);
        super(matrix, matrix.rows, 1);
        this.column = column;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.column, value);
        return this;
      }
      get(rowIndex) {
        return this.matrix.get(rowIndex, this.column);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/columnSelection.js
var MatrixColumnSelectionView;
var init_columnSelection = __esm({
  "node_modules/ml-matrix/src/views/columnSelection.js"() {
    init_util2();
    init_base();
    MatrixColumnSelectionView = class extends BaseView {
      constructor(matrix, columnIndices) {
        checkColumnIndices(matrix, columnIndices);
        super(matrix, matrix.rows, columnIndices.length);
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/flipColumn.js
var MatrixFlipColumnView;
var init_flipColumn = __esm({
  "node_modules/ml-matrix/src/views/flipColumn.js"() {
    init_base();
    MatrixFlipColumnView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/flipRow.js
var MatrixFlipRowView;
var init_flipRow = __esm({
  "node_modules/ml-matrix/src/views/flipRow.js"() {
    init_base();
    MatrixFlipRowView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.rows, matrix.columns);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/row.js
var MatrixRowView;
var init_row = __esm({
  "node_modules/ml-matrix/src/views/row.js"() {
    init_util2();
    init_base();
    MatrixRowView = class extends BaseView {
      constructor(matrix, row) {
        checkRowIndex(matrix, row);
        super(matrix, 1, matrix.columns);
        this.row = row;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.row, columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.row, columnIndex);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/rowSelection.js
var MatrixRowSelectionView;
var init_rowSelection = __esm({
  "node_modules/ml-matrix/src/views/rowSelection.js"() {
    init_util2();
    init_base();
    MatrixRowSelectionView = class extends BaseView {
      constructor(matrix, rowIndices) {
        checkRowIndices(matrix, rowIndices);
        super(matrix, rowIndices.length, matrix.columns);
        this.rowIndices = rowIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/selection.js
var MatrixSelectionView;
var init_selection = __esm({
  "node_modules/ml-matrix/src/views/selection.js"() {
    init_util2();
    init_base();
    MatrixSelectionView = class extends BaseView {
      constructor(matrix, rowIndices, columnIndices) {
        checkRowIndices(matrix, rowIndices);
        checkColumnIndices(matrix, columnIndices);
        super(matrix, rowIndices.length, columnIndices.length);
        this.rowIndices = rowIndices;
        this.columnIndices = columnIndices;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.rowIndices[rowIndex], this.columnIndices[columnIndex], value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.rowIndices[rowIndex], this.columnIndices[columnIndex]);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/sub.js
var MatrixSubView;
var init_sub = __esm({
  "node_modules/ml-matrix/src/views/sub.js"() {
    init_util2();
    init_base();
    MatrixSubView = class extends BaseView {
      constructor(matrix, startRow, endRow, startColumn, endColumn) {
        checkRange(matrix, startRow, endRow, startColumn, endColumn);
        super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
        this.startRow = startRow;
        this.startColumn = startColumn;
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(this.startRow + rowIndex, this.startColumn + columnIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(this.startRow + rowIndex, this.startColumn + columnIndex);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/transpose.js
var MatrixTransposeView;
var init_transpose = __esm({
  "node_modules/ml-matrix/src/views/transpose.js"() {
    init_base();
    MatrixTransposeView = class extends BaseView {
      constructor(matrix) {
        super(matrix, matrix.columns, matrix.rows);
      }
      set(rowIndex, columnIndex, value) {
        this.matrix.set(columnIndex, rowIndex, value);
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.matrix.get(columnIndex, rowIndex);
      }
    };
  }
});

// node_modules/ml-matrix/src/views/index.js
var init_views = __esm({
  "node_modules/ml-matrix/src/views/index.js"() {
    init_column();
    init_columnSelection();
    init_flipColumn();
    init_flipRow();
    init_row();
    init_rowSelection();
    init_selection();
    init_sub();
    init_transpose();
  }
});

// node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js
var WrapperMatrix1D;
var init_WrapperMatrix1D = __esm({
  "node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js"() {
    init_matrix();
    WrapperMatrix1D = class extends AbstractMatrix {
      constructor(data, options = {}) {
        const { rows = 1 } = options;
        if (data.length % rows !== 0) {
          throw new Error("the data length is not divisible by the number of rows");
        }
        super();
        this.rows = rows;
        this.columns = data.length / rows;
        this.data = data;
      }
      set(rowIndex, columnIndex, value) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        this.data[index] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        let index = this._calculateIndex(rowIndex, columnIndex);
        return this.data[index];
      }
      _calculateIndex(row, column) {
        return row * this.columns + column;
      }
    };
  }
});

// node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js
var WrapperMatrix2D;
var init_WrapperMatrix2D = __esm({
  "node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js"() {
    init_matrix();
    WrapperMatrix2D = class extends AbstractMatrix {
      constructor(data) {
        super();
        this.data = data;
        this.rows = data.length;
        this.columns = data[0].length;
      }
      set(rowIndex, columnIndex, value) {
        this.data[rowIndex][columnIndex] = value;
        return this;
      }
      get(rowIndex, columnIndex) {
        return this.data[rowIndex][columnIndex];
      }
    };
  }
});

// node_modules/ml-matrix/src/wrap/wrap.js
function wrap(array, options) {
  if (isAnyArray(array)) {
    if (array[0] && isAnyArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error("the argument is not an array");
  }
}
var init_wrap = __esm({
  "node_modules/ml-matrix/src/wrap/wrap.js"() {
    init_lib_esm();
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
  }
});

// node_modules/ml-matrix/src/dc/lu.js
var LuDecomposition;
var init_lu = __esm({
  "node_modules/ml-matrix/src/dc/lu.js"() {
    init_matrix();
    init_WrapperMatrix2D();
    LuDecomposition = class {
      constructor(matrix) {
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        let lu2 = matrix.clone();
        let rows = lu2.rows;
        let columns = lu2.columns;
        let pivotVector = new Float64Array(rows);
        let pivotSign = 1;
        let i2, j2, k2, p2, s2, t4, v2;
        let LUcolj, kmax;
        for (i2 = 0; i2 < rows; i2++) {
          pivotVector[i2] = i2;
        }
        LUcolj = new Float64Array(rows);
        for (j2 = 0; j2 < columns; j2++) {
          for (i2 = 0; i2 < rows; i2++) {
            LUcolj[i2] = lu2.get(i2, j2);
          }
          for (i2 = 0; i2 < rows; i2++) {
            kmax = Math.min(i2, j2);
            s2 = 0;
            for (k2 = 0; k2 < kmax; k2++) {
              s2 += lu2.get(i2, k2) * LUcolj[k2];
            }
            LUcolj[i2] -= s2;
            lu2.set(i2, j2, LUcolj[i2]);
          }
          p2 = j2;
          for (i2 = j2 + 1; i2 < rows; i2++) {
            if (Math.abs(LUcolj[i2]) > Math.abs(LUcolj[p2])) {
              p2 = i2;
            }
          }
          if (p2 !== j2) {
            for (k2 = 0; k2 < columns; k2++) {
              t4 = lu2.get(p2, k2);
              lu2.set(p2, k2, lu2.get(j2, k2));
              lu2.set(j2, k2, t4);
            }
            v2 = pivotVector[p2];
            pivotVector[p2] = pivotVector[j2];
            pivotVector[j2] = v2;
            pivotSign = -pivotSign;
          }
          if (j2 < rows && lu2.get(j2, j2) !== 0) {
            for (i2 = j2 + 1; i2 < rows; i2++) {
              lu2.set(i2, j2, lu2.get(i2, j2) / lu2.get(j2, j2));
            }
          }
        }
        this.LU = lu2;
        this.pivotVector = pivotVector;
        this.pivotSign = pivotSign;
      }
      isSingular() {
        let data = this.LU;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          if (data.get(j2, j2) === 0) {
            return true;
          }
        }
        return false;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let lu2 = this.LU;
        let rows = lu2.rows;
        if (rows !== value.rows) {
          throw new Error("Invalid matrix dimensions");
        }
        if (this.isSingular()) {
          throw new Error("LU matrix is singular");
        }
        let count = value.columns;
        let X2 = value.subMatrixRow(this.pivotVector, 0, count - 1);
        let columns = lu2.columns;
        let i2, j2, k2;
        for (k2 = 0; k2 < columns; k2++) {
          for (i2 = k2 + 1; i2 < columns; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / lu2.get(k2, k2));
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * lu2.get(i2, k2));
            }
          }
        }
        return X2;
      }
      get determinant() {
        let data = this.LU;
        if (!data.isSquare()) {
          throw new Error("Matrix must be square");
        }
        let determinant4 = this.pivotSign;
        let col = data.columns;
        for (let j2 = 0; j2 < col; j2++) {
          determinant4 *= data.get(j2, j2);
        }
        return determinant4;
      }
      get lowerTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 > j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, 1);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get upperTriangularMatrix() {
        let data = this.LU;
        let rows = data.rows;
        let columns = data.columns;
        let X2 = new Matrix(rows, columns);
        for (let i2 = 0; i2 < rows; i2++) {
          for (let j2 = 0; j2 < columns; j2++) {
            if (i2 <= j2) {
              X2.set(i2, j2, data.get(i2, j2));
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get pivotPermutationVector() {
        return Array.from(this.pivotVector);
      }
    };
  }
});

// node_modules/ml-matrix/src/dc/util.js
function hypotenuse(a2, b10) {
  let r2 = 0;
  if (Math.abs(a2) > Math.abs(b10)) {
    r2 = b10 / a2;
    return Math.abs(a2) * Math.sqrt(1 + r2 * r2);
  }
  if (b10 !== 0) {
    r2 = a2 / b10;
    return Math.abs(b10) * Math.sqrt(1 + r2 * r2);
  }
  return 0;
}
var init_util3 = __esm({
  "node_modules/ml-matrix/src/dc/util.js"() {
  }
});

// node_modules/ml-matrix/src/dc/qr.js
var QrDecomposition;
var init_qr = __esm({
  "node_modules/ml-matrix/src/dc/qr.js"() {
    init_matrix();
    init_WrapperMatrix2D();
    init_util3();
    QrDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let qr2 = value.clone();
        let m2 = value.rows;
        let n2 = value.columns;
        let rdiag = new Float64Array(n2);
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          let nrm = 0;
          for (i2 = k2; i2 < m2; i2++) {
            nrm = hypotenuse(nrm, qr2.get(i2, k2));
          }
          if (nrm !== 0) {
            if (qr2.get(k2, k2) < 0) {
              nrm = -nrm;
            }
            for (i2 = k2; i2 < m2; i2++) {
              qr2.set(i2, k2, qr2.get(i2, k2) / nrm);
            }
            qr2.set(k2, k2, qr2.get(k2, k2) + 1);
            for (j2 = k2 + 1; j2 < n2; j2++) {
              s2 = 0;
              for (i2 = k2; i2 < m2; i2++) {
                s2 += qr2.get(i2, k2) * qr2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < m2; i2++) {
                qr2.set(i2, j2, qr2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
          rdiag[k2] = -nrm;
        }
        this.QR = qr2;
        this.Rdiag = rdiag;
      }
      solve(value) {
        value = Matrix.checkMatrix(value);
        let qr2 = this.QR;
        let m2 = qr2.rows;
        if (value.rows !== m2) {
          throw new Error("Matrix row dimensions must agree");
        }
        if (!this.isFullRank()) {
          throw new Error("Matrix is rank deficient");
        }
        let count = value.columns;
        let X2 = value.clone();
        let n2 = qr2.columns;
        let i2, j2, k2, s2;
        for (k2 = 0; k2 < n2; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            s2 = 0;
            for (i2 = k2; i2 < m2; i2++) {
              s2 += qr2.get(i2, k2) * X2.get(i2, j2);
            }
            s2 = -s2 / qr2.get(k2, k2);
            for (i2 = k2; i2 < m2; i2++) {
              X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
            }
          }
        }
        for (k2 = n2 - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            X2.set(k2, j2, X2.get(k2, j2) / this.Rdiag[k2]);
          }
          for (i2 = 0; i2 < k2; i2++) {
            for (j2 = 0; j2 < count; j2++) {
              X2.set(i2, j2, X2.get(i2, j2) - X2.get(k2, j2) * qr2.get(i2, k2));
            }
          }
        }
        return X2.subMatrix(0, n2 - 1, 0, count - 1);
      }
      isFullRank() {
        let columns = this.QR.columns;
        for (let i2 = 0; i2 < columns; i2++) {
          if (this.Rdiag[i2] === 0) {
            return false;
          }
        }
        return true;
      }
      get upperTriangularMatrix() {
        let qr2 = this.QR;
        let n2 = qr2.columns;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            if (i2 < j2) {
              X2.set(i2, j2, qr2.get(i2, j2));
            } else if (i2 === j2) {
              X2.set(i2, j2, this.Rdiag[i2]);
            } else {
              X2.set(i2, j2, 0);
            }
          }
        }
        return X2;
      }
      get orthogonalMatrix() {
        let qr2 = this.QR;
        let rows = qr2.rows;
        let columns = qr2.columns;
        let X2 = new Matrix(rows, columns);
        let i2, j2, k2, s2;
        for (k2 = columns - 1; k2 >= 0; k2--) {
          for (i2 = 0; i2 < rows; i2++) {
            X2.set(i2, k2, 0);
          }
          X2.set(k2, k2, 1);
          for (j2 = k2; j2 < columns; j2++) {
            if (qr2.get(k2, k2) !== 0) {
              s2 = 0;
              for (i2 = k2; i2 < rows; i2++) {
                s2 += qr2.get(i2, k2) * X2.get(i2, j2);
              }
              s2 = -s2 / qr2.get(k2, k2);
              for (i2 = k2; i2 < rows; i2++) {
                X2.set(i2, j2, X2.get(i2, j2) + s2 * qr2.get(i2, k2));
              }
            }
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/ml-matrix/src/dc/svd.js
var SingularValueDecomposition;
var init_svd = __esm({
  "node_modules/ml-matrix/src/dc/svd.js"() {
    init_matrix();
    init_WrapperMatrix2D();
    init_util3();
    SingularValueDecomposition = class {
      constructor(value, options = {}) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (value.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let m2 = value.rows;
        let n2 = value.columns;
        const {
          computeLeftSingularVectors = true,
          computeRightSingularVectors = true,
          autoTranspose = false
        } = options;
        let wantu = Boolean(computeLeftSingularVectors);
        let wantv = Boolean(computeRightSingularVectors);
        let swapped = false;
        let a2;
        if (m2 < n2) {
          if (!autoTranspose) {
            a2 = value.clone();
            console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");
          } else {
            a2 = value.transpose();
            m2 = a2.rows;
            n2 = a2.columns;
            swapped = true;
            let aux = wantu;
            wantu = wantv;
            wantv = aux;
          }
        } else {
          a2 = value.clone();
        }
        let nu2 = Math.min(m2, n2);
        let ni2 = Math.min(m2 + 1, n2);
        let s2 = new Float64Array(ni2);
        let U2 = new Matrix(m2, nu2);
        let V2 = new Matrix(n2, n2);
        let e8 = new Float64Array(n2);
        let work = new Float64Array(m2);
        let si2 = new Float64Array(ni2);
        for (let i2 = 0; i2 < ni2; i2++)
          si2[i2] = i2;
        let nct = Math.min(m2 - 1, n2);
        let nrt = Math.max(0, Math.min(n2 - 2, m2));
        let mrc = Math.max(nct, nrt);
        for (let k2 = 0; k2 < mrc; k2++) {
          if (k2 < nct) {
            s2[k2] = 0;
            for (let i2 = k2; i2 < m2; i2++) {
              s2[k2] = hypotenuse(s2[k2], a2.get(i2, k2));
            }
            if (s2[k2] !== 0) {
              if (a2.get(k2, k2) < 0) {
                s2[k2] = -s2[k2];
              }
              for (let i2 = k2; i2 < m2; i2++) {
                a2.set(i2, k2, a2.get(i2, k2) / s2[k2]);
              }
              a2.set(k2, k2, a2.get(k2, k2) + 1);
            }
            s2[k2] = -s2[k2];
          }
          for (let j2 = k2 + 1; j2 < n2; j2++) {
            if (k2 < nct && s2[k2] !== 0) {
              let t4 = 0;
              for (let i2 = k2; i2 < m2; i2++) {
                t4 += a2.get(i2, k2) * a2.get(i2, j2);
              }
              t4 = -t4 / a2.get(k2, k2);
              for (let i2 = k2; i2 < m2; i2++) {
                a2.set(i2, j2, a2.get(i2, j2) + t4 * a2.get(i2, k2));
              }
            }
            e8[j2] = a2.get(k2, j2);
          }
          if (wantu && k2 < nct) {
            for (let i2 = k2; i2 < m2; i2++) {
              U2.set(i2, k2, a2.get(i2, k2));
            }
          }
          if (k2 < nrt) {
            e8[k2] = 0;
            for (let i2 = k2 + 1; i2 < n2; i2++) {
              e8[k2] = hypotenuse(e8[k2], e8[i2]);
            }
            if (e8[k2] !== 0) {
              if (e8[k2 + 1] < 0) {
                e8[k2] = 0 - e8[k2];
              }
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                e8[i2] /= e8[k2];
              }
              e8[k2 + 1] += 1;
            }
            e8[k2] = -e8[k2];
            if (k2 + 1 < m2 && e8[k2] !== 0) {
              for (let i2 = k2 + 1; i2 < m2; i2++) {
                work[i2] = 0;
              }
              for (let i2 = k2 + 1; i2 < m2; i2++) {
                for (let j2 = k2 + 1; j2 < n2; j2++) {
                  work[i2] += e8[j2] * a2.get(i2, j2);
                }
              }
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t4 = -e8[j2] / e8[k2 + 1];
                for (let i2 = k2 + 1; i2 < m2; i2++) {
                  a2.set(i2, j2, a2.get(i2, j2) + t4 * work[i2]);
                }
              }
            }
            if (wantv) {
              for (let i2 = k2 + 1; i2 < n2; i2++) {
                V2.set(i2, k2, e8[i2]);
              }
            }
          }
        }
        let p2 = Math.min(n2, m2 + 1);
        if (nct < n2) {
          s2[nct] = a2.get(nct, nct);
        }
        if (m2 < p2) {
          s2[p2 - 1] = 0;
        }
        if (nrt + 1 < p2) {
          e8[nrt] = a2.get(nrt, p2 - 1);
        }
        e8[p2 - 1] = 0;
        if (wantu) {
          for (let j2 = nct; j2 < nu2; j2++) {
            for (let i2 = 0; i2 < m2; i2++) {
              U2.set(i2, j2, 0);
            }
            U2.set(j2, j2, 1);
          }
          for (let k2 = nct - 1; k2 >= 0; k2--) {
            if (s2[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < nu2; j2++) {
                let t4 = 0;
                for (let i2 = k2; i2 < m2; i2++) {
                  t4 += U2.get(i2, k2) * U2.get(i2, j2);
                }
                t4 = -t4 / U2.get(k2, k2);
                for (let i2 = k2; i2 < m2; i2++) {
                  U2.set(i2, j2, U2.get(i2, j2) + t4 * U2.get(i2, k2));
                }
              }
              for (let i2 = k2; i2 < m2; i2++) {
                U2.set(i2, k2, -U2.get(i2, k2));
              }
              U2.set(k2, k2, 1 + U2.get(k2, k2));
              for (let i2 = 0; i2 < k2 - 1; i2++) {
                U2.set(i2, k2, 0);
              }
            } else {
              for (let i2 = 0; i2 < m2; i2++) {
                U2.set(i2, k2, 0);
              }
              U2.set(k2, k2, 1);
            }
          }
        }
        if (wantv) {
          for (let k2 = n2 - 1; k2 >= 0; k2--) {
            if (k2 < nrt && e8[k2] !== 0) {
              for (let j2 = k2 + 1; j2 < n2; j2++) {
                let t4 = 0;
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  t4 += V2.get(i2, k2) * V2.get(i2, j2);
                }
                t4 = -t4 / V2.get(k2 + 1, k2);
                for (let i2 = k2 + 1; i2 < n2; i2++) {
                  V2.set(i2, j2, V2.get(i2, j2) + t4 * V2.get(i2, k2));
                }
              }
            }
            for (let i2 = 0; i2 < n2; i2++) {
              V2.set(i2, k2, 0);
            }
            V2.set(k2, k2, 1);
          }
        }
        let pp = p2 - 1;
        let iter = 0;
        let eps2 = Number.EPSILON;
        while (p2 > 0) {
          let k2, kase;
          for (k2 = p2 - 2; k2 >= -1; k2--) {
            if (k2 === -1) {
              break;
            }
            const alpha = Number.MIN_VALUE + eps2 * Math.abs(s2[k2] + Math.abs(s2[k2 + 1]));
            if (Math.abs(e8[k2]) <= alpha || Number.isNaN(e8[k2])) {
              e8[k2] = 0;
              break;
            }
          }
          if (k2 === p2 - 2) {
            kase = 4;
          } else {
            let ks;
            for (ks = p2 - 1; ks >= k2; ks--) {
              if (ks === k2) {
                break;
              }
              let t4 = (ks !== p2 ? Math.abs(e8[ks]) : 0) + (ks !== k2 + 1 ? Math.abs(e8[ks - 1]) : 0);
              if (Math.abs(s2[ks]) <= eps2 * t4) {
                s2[ks] = 0;
                break;
              }
            }
            if (ks === k2) {
              kase = 3;
            } else if (ks === p2 - 1) {
              kase = 1;
            } else {
              kase = 2;
              k2 = ks;
            }
          }
          k2++;
          switch (kase) {
            case 1: {
              let f2 = e8[p2 - 2];
              e8[p2 - 2] = 0;
              for (let j2 = p2 - 2; j2 >= k2; j2--) {
                let t4 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t4;
                let sn2 = f2 / t4;
                s2[j2] = t4;
                if (j2 !== k2) {
                  f2 = -sn2 * e8[j2 - 1];
                  e8[j2 - 1] = cs * e8[j2 - 1];
                }
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, p2 - 1);
                    V2.set(i2, p2 - 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, p2 - 1));
                    V2.set(i2, j2, t4);
                  }
                }
              }
              break;
            }
            case 2: {
              let f2 = e8[k2 - 1];
              e8[k2 - 1] = 0;
              for (let j2 = k2; j2 < p2; j2++) {
                let t4 = hypotenuse(s2[j2], f2);
                let cs = s2[j2] / t4;
                let sn2 = f2 / t4;
                s2[j2] = t4;
                f2 = -sn2 * e8[j2];
                e8[j2] = cs * e8[j2];
                if (wantu) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t4 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, k2 - 1);
                    U2.set(i2, k2 - 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, k2 - 1));
                    U2.set(i2, j2, t4);
                  }
                }
              }
              break;
            }
            case 3: {
              const scale9 = Math.max(Math.abs(s2[p2 - 1]), Math.abs(s2[p2 - 2]), Math.abs(e8[p2 - 2]), Math.abs(s2[k2]), Math.abs(e8[k2]));
              const sp = s2[p2 - 1] / scale9;
              const spm1 = s2[p2 - 2] / scale9;
              const epm1 = e8[p2 - 2] / scale9;
              const sk = s2[k2] / scale9;
              const ek = e8[k2] / scale9;
              const b10 = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
              const c2 = sp * epm1 * (sp * epm1);
              let shift = 0;
              if (b10 !== 0 || c2 !== 0) {
                if (b10 < 0) {
                  shift = 0 - Math.sqrt(b10 * b10 + c2);
                } else {
                  shift = Math.sqrt(b10 * b10 + c2);
                }
                shift = c2 / (b10 + shift);
              }
              let f2 = (sk + sp) * (sk - sp) + shift;
              let g2 = sk * ek;
              for (let j2 = k2; j2 < p2 - 1; j2++) {
                let t4 = hypotenuse(f2, g2);
                if (t4 === 0)
                  t4 = Number.MIN_VALUE;
                let cs = f2 / t4;
                let sn2 = g2 / t4;
                if (j2 !== k2) {
                  e8[j2 - 1] = t4;
                }
                f2 = cs * s2[j2] + sn2 * e8[j2];
                e8[j2] = cs * e8[j2] - sn2 * s2[j2];
                g2 = sn2 * s2[j2 + 1];
                s2[j2 + 1] = cs * s2[j2 + 1];
                if (wantv) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = cs * V2.get(i2, j2) + sn2 * V2.get(i2, j2 + 1);
                    V2.set(i2, j2 + 1, -sn2 * V2.get(i2, j2) + cs * V2.get(i2, j2 + 1));
                    V2.set(i2, j2, t4);
                  }
                }
                t4 = hypotenuse(f2, g2);
                if (t4 === 0)
                  t4 = Number.MIN_VALUE;
                cs = f2 / t4;
                sn2 = g2 / t4;
                s2[j2] = t4;
                f2 = cs * e8[j2] + sn2 * s2[j2 + 1];
                s2[j2 + 1] = -sn2 * e8[j2] + cs * s2[j2 + 1];
                g2 = sn2 * e8[j2 + 1];
                e8[j2 + 1] = cs * e8[j2 + 1];
                if (wantu && j2 < m2 - 1) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t4 = cs * U2.get(i2, j2) + sn2 * U2.get(i2, j2 + 1);
                    U2.set(i2, j2 + 1, -sn2 * U2.get(i2, j2) + cs * U2.get(i2, j2 + 1));
                    U2.set(i2, j2, t4);
                  }
                }
              }
              e8[p2 - 2] = f2;
              iter = iter + 1;
              break;
            }
            case 4: {
              if (s2[k2] <= 0) {
                s2[k2] = s2[k2] < 0 ? -s2[k2] : 0;
                if (wantv) {
                  for (let i2 = 0; i2 <= pp; i2++) {
                    V2.set(i2, k2, -V2.get(i2, k2));
                  }
                }
              }
              while (k2 < pp) {
                if (s2[k2] >= s2[k2 + 1]) {
                  break;
                }
                let t4 = s2[k2];
                s2[k2] = s2[k2 + 1];
                s2[k2 + 1] = t4;
                if (wantv && k2 < n2 - 1) {
                  for (let i2 = 0; i2 < n2; i2++) {
                    t4 = V2.get(i2, k2 + 1);
                    V2.set(i2, k2 + 1, V2.get(i2, k2));
                    V2.set(i2, k2, t4);
                  }
                }
                if (wantu && k2 < m2 - 1) {
                  for (let i2 = 0; i2 < m2; i2++) {
                    t4 = U2.get(i2, k2 + 1);
                    U2.set(i2, k2 + 1, U2.get(i2, k2));
                    U2.set(i2, k2, t4);
                  }
                }
                k2++;
              }
              iter = 0;
              p2--;
              break;
            }
          }
        }
        if (swapped) {
          let tmp = V2;
          V2 = U2;
          U2 = tmp;
        }
        this.m = m2;
        this.n = n2;
        this.s = s2;
        this.U = U2;
        this.V = V2;
      }
      solve(value) {
        let Y2 = value;
        let e8 = this.threshold;
        let scols = this.s.length;
        let Ls = Matrix.zeros(scols, scols);
        for (let i2 = 0; i2 < scols; i2++) {
          if (Math.abs(this.s[i2]) <= e8) {
            Ls.set(i2, i2, 0);
          } else {
            Ls.set(i2, i2, 1 / this.s[i2]);
          }
        }
        let U2 = this.U;
        let V2 = this.rightSingularVectors;
        let VL = V2.mmul(Ls);
        let vrows = V2.rows;
        let urows = U2.rows;
        let VLU = Matrix.zeros(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < scols; k2++) {
              sum += VL.get(i2, k2) * U2.get(j2, k2);
            }
            VLU.set(i2, j2, sum);
          }
        }
        return VLU.mmul(Y2);
      }
      solveForDiagonal(value) {
        return this.solve(Matrix.diag(value));
      }
      inverse() {
        let V2 = this.V;
        let e8 = this.threshold;
        let vrows = V2.rows;
        let vcols = V2.columns;
        let X2 = new Matrix(vrows, this.s.length);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < vcols; j2++) {
            if (Math.abs(this.s[j2]) > e8) {
              X2.set(i2, j2, V2.get(i2, j2) / this.s[j2]);
            }
          }
        }
        let U2 = this.U;
        let urows = U2.rows;
        let ucols = U2.columns;
        let Y2 = new Matrix(vrows, urows);
        for (let i2 = 0; i2 < vrows; i2++) {
          for (let j2 = 0; j2 < urows; j2++) {
            let sum = 0;
            for (let k2 = 0; k2 < ucols; k2++) {
              sum += X2.get(i2, k2) * U2.get(j2, k2);
            }
            Y2.set(i2, j2, sum);
          }
        }
        return Y2;
      }
      get condition() {
        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
      }
      get norm2() {
        return this.s[0];
      }
      get rank() {
        let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
        let r2 = 0;
        let s2 = this.s;
        for (let i2 = 0, ii2 = s2.length; i2 < ii2; i2++) {
          if (s2[i2] > tol) {
            r2++;
          }
        }
        return r2;
      }
      get diagonal() {
        return Array.from(this.s);
      }
      get threshold() {
        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];
      }
      get leftSingularVectors() {
        return this.U;
      }
      get rightSingularVectors() {
        return this.V;
      }
      get diagonalMatrix() {
        return Matrix.diag(this.s);
      }
    };
  }
});

// node_modules/ml-matrix/src/decompositions.js
function inverse4(matrix, useSVD = false) {
  matrix = WrapperMatrix2D.checkMatrix(matrix);
  if (useSVD) {
    return new SingularValueDecomposition(matrix).inverse();
  } else {
    return solve(matrix, Matrix.eye(matrix.rows));
  }
}
function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}
var init_decompositions = __esm({
  "node_modules/ml-matrix/src/decompositions.js"() {
    init_lu();
    init_qr();
    init_svd();
    init_matrix();
    init_WrapperMatrix2D();
  }
});

// node_modules/ml-matrix/src/determinant.js
function determinant3(matrix) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isSquare()) {
    if (matrix.columns === 0) {
      return 1;
    }
    let a2, b10, c2, d2;
    if (matrix.columns === 2) {
      a2 = matrix.get(0, 0);
      b10 = matrix.get(0, 1);
      c2 = matrix.get(1, 0);
      d2 = matrix.get(1, 1);
      return a2 * d2 - b10 * c2;
    } else if (matrix.columns === 3) {
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
      a2 = matrix.get(0, 0);
      b10 = matrix.get(0, 1);
      c2 = matrix.get(0, 2);
      return a2 * determinant3(subMatrix0) - b10 * determinant3(subMatrix1) + c2 * determinant3(subMatrix2);
    } else {
      return new LuDecomposition(matrix).determinant;
    }
  } else {
    throw Error("determinant can only be calculated for a square matrix");
  }
}
var init_determinant = __esm({
  "node_modules/ml-matrix/src/determinant.js"() {
    init_lu();
    init_matrix();
    init_selection();
  }
});

// node_modules/ml-matrix/src/linearDependencies.js
function xrange(n2, exception) {
  let range = [];
  for (let i2 = 0; i2 < n2; i2++) {
    if (i2 !== exception) {
      range.push(i2);
    }
  }
  return range;
}
function dependenciesOneRow(error, matrix, index, thresholdValue = 1e-9, thresholdError = 1e-9) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index, [0]);
    for (let i2 = 0; i2 < returnArray.rows; i2++) {
      if (Math.abs(returnArray.get(i2, 0)) < thresholdValue) {
        returnArray.set(i2, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}
function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 1e-9, thresholdError = 1e-9 } = options;
  matrix = Matrix.checkMatrix(matrix);
  let n2 = matrix.rows;
  let results = new Matrix(n2, n2);
  for (let i2 = 0; i2 < n2; i2++) {
    let b10 = Matrix.columnVector(matrix.getRow(i2));
    let Abis = matrix.subMatrixRow(xrange(n2, i2)).transpose();
    let svd = new SingularValueDecomposition(Abis);
    let x2 = svd.solve(b10);
    let error = Matrix.sub(b10, Abis.mmul(x2)).abs().max();
    results.setRow(i2, dependenciesOneRow(error, x2, i2, thresholdValue, thresholdError));
  }
  return results;
}
var init_linearDependencies = __esm({
  "node_modules/ml-matrix/src/linearDependencies.js"() {
    init_svd();
    init_matrix();
  }
});

// node_modules/ml-matrix/src/pseudoInverse.js
function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isEmpty()) {
    return matrix.transpose();
  }
  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });
  let U2 = svdSolution.leftSingularVectors;
  let V2 = svdSolution.rightSingularVectors;
  let s2 = svdSolution.diagonal;
  for (let i2 = 0; i2 < s2.length; i2++) {
    if (Math.abs(s2[i2]) > threshold) {
      s2[i2] = 1 / s2[i2];
    } else {
      s2[i2] = 0;
    }
  }
  return V2.mmul(Matrix.diag(s2).mmul(U2.transpose()));
}
var init_pseudoInverse = __esm({
  "node_modules/ml-matrix/src/pseudoInverse.js"() {
    init_svd();
    init_matrix();
  }
});

// node_modules/ml-matrix/src/covariance.js
function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !isAnyArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center("column");
    if (!yIsSame) {
      yMatrix = yMatrix.center("column");
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < cov.rows; i2++) {
    for (let j2 = 0; j2 < cov.columns; j2++) {
      cov.set(i2, j2, cov.get(i2, j2) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}
var init_covariance = __esm({
  "node_modules/ml-matrix/src/covariance.js"() {
    init_lib_esm();
    init_matrix();
  }
});

// node_modules/ml-matrix/src/correlation.js
function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (typeof yMatrix === "object" && !Matrix.isMatrix(yMatrix) && !isAnyArray(yMatrix)) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError("Both matrices must have the same number of rows");
  }
  const { center = true, scale: scale9 = true } = options;
  if (center) {
    xMatrix.center("column");
    if (!yIsSame) {
      yMatrix.center("column");
    }
  }
  if (scale9) {
    xMatrix.scale("column");
    if (!yIsSame) {
      yMatrix.scale("column");
    }
  }
  const sdx = xMatrix.standardDeviation("column", { unbiased: true });
  const sdy = yIsSame ? sdx : yMatrix.standardDeviation("column", { unbiased: true });
  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i2 = 0; i2 < corr.rows; i2++) {
    for (let j2 = 0; j2 < corr.columns; j2++) {
      corr.set(i2, j2, corr.get(i2, j2) * (1 / (sdx[i2] * sdy[j2])) * (1 / (xMatrix.rows - 1)));
    }
  }
  return corr;
}
var init_correlation = __esm({
  "node_modules/ml-matrix/src/correlation.js"() {
    init_lib_esm();
    init_matrix();
  }
});

// node_modules/ml-matrix/src/dc/evd.js
function tred2(n2, e8, d2, V2) {
  let f2, g2, h2, i2, j2, k2, hh, scale9;
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
  }
  for (i2 = n2 - 1; i2 > 0; i2--) {
    scale9 = 0;
    h2 = 0;
    for (k2 = 0; k2 < i2; k2++) {
      scale9 = scale9 + Math.abs(d2[k2]);
    }
    if (scale9 === 0) {
      e8[i2] = d2[i2 - 1];
      for (j2 = 0; j2 < i2; j2++) {
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
        V2.set(j2, i2, 0);
      }
    } else {
      for (k2 = 0; k2 < i2; k2++) {
        d2[k2] /= scale9;
        h2 += d2[k2] * d2[k2];
      }
      f2 = d2[i2 - 1];
      g2 = Math.sqrt(h2);
      if (f2 > 0) {
        g2 = -g2;
      }
      e8[i2] = scale9 * g2;
      h2 = h2 - f2 * g2;
      d2[i2 - 1] = f2 - g2;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] = 0;
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        V2.set(j2, i2, f2);
        g2 = e8[j2] + V2.get(j2, j2) * f2;
        for (k2 = j2 + 1; k2 <= i2 - 1; k2++) {
          g2 += V2.get(k2, j2) * d2[k2];
          e8[k2] += V2.get(k2, j2) * f2;
        }
        e8[j2] = g2;
      }
      f2 = 0;
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] /= h2;
        f2 += e8[j2] * d2[j2];
      }
      hh = f2 / (h2 + h2);
      for (j2 = 0; j2 < i2; j2++) {
        e8[j2] -= hh * d2[j2];
      }
      for (j2 = 0; j2 < i2; j2++) {
        f2 = d2[j2];
        g2 = e8[j2];
        for (k2 = j2; k2 <= i2 - 1; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - (f2 * e8[k2] + g2 * d2[k2]));
        }
        d2[j2] = V2.get(i2 - 1, j2);
        V2.set(i2, j2, 0);
      }
    }
    d2[i2] = h2;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    V2.set(n2 - 1, i2, V2.get(i2, i2));
    V2.set(i2, i2, 1);
    h2 = d2[i2 + 1];
    if (h2 !== 0) {
      for (k2 = 0; k2 <= i2; k2++) {
        d2[k2] = V2.get(k2, i2 + 1) / h2;
      }
      for (j2 = 0; j2 <= i2; j2++) {
        g2 = 0;
        for (k2 = 0; k2 <= i2; k2++) {
          g2 += V2.get(k2, i2 + 1) * V2.get(k2, j2);
        }
        for (k2 = 0; k2 <= i2; k2++) {
          V2.set(k2, j2, V2.get(k2, j2) - g2 * d2[k2]);
        }
      }
    }
    for (k2 = 0; k2 <= i2; k2++) {
      V2.set(k2, i2 + 1, 0);
    }
  }
  for (j2 = 0; j2 < n2; j2++) {
    d2[j2] = V2.get(n2 - 1, j2);
    V2.set(n2 - 1, j2, 0);
  }
  V2.set(n2 - 1, n2 - 1, 1);
  e8[0] = 0;
}
function tql2(n2, e8, d2, V2) {
  let g2, h2, i2, j2, k2, l2, m2, p2, r2, dl1, c2, c22, c3, el1, s2, s22, iter;
  for (i2 = 1; i2 < n2; i2++) {
    e8[i2 - 1] = e8[i2];
  }
  e8[n2 - 1] = 0;
  let f2 = 0;
  let tst1 = 0;
  let eps2 = Number.EPSILON;
  for (l2 = 0; l2 < n2; l2++) {
    tst1 = Math.max(tst1, Math.abs(d2[l2]) + Math.abs(e8[l2]));
    m2 = l2;
    while (m2 < n2) {
      if (Math.abs(e8[m2]) <= eps2 * tst1) {
        break;
      }
      m2++;
    }
    if (m2 > l2) {
      iter = 0;
      do {
        iter = iter + 1;
        g2 = d2[l2];
        p2 = (d2[l2 + 1] - g2) / (2 * e8[l2]);
        r2 = hypotenuse(p2, 1);
        if (p2 < 0) {
          r2 = -r2;
        }
        d2[l2] = e8[l2] / (p2 + r2);
        d2[l2 + 1] = e8[l2] * (p2 + r2);
        dl1 = d2[l2 + 1];
        h2 = g2 - d2[l2];
        for (i2 = l2 + 2; i2 < n2; i2++) {
          d2[i2] -= h2;
        }
        f2 = f2 + h2;
        p2 = d2[m2];
        c2 = 1;
        c22 = c2;
        c3 = c2;
        el1 = e8[l2 + 1];
        s2 = 0;
        s22 = 0;
        for (i2 = m2 - 1; i2 >= l2; i2--) {
          c3 = c22;
          c22 = c2;
          s22 = s2;
          g2 = c2 * e8[i2];
          h2 = c2 * p2;
          r2 = hypotenuse(p2, e8[i2]);
          e8[i2 + 1] = s2 * r2;
          s2 = e8[i2] / r2;
          c2 = p2 / r2;
          p2 = c2 * d2[i2] - s2 * g2;
          d2[i2 + 1] = h2 + s2 * (c2 * g2 + s2 * d2[i2]);
          for (k2 = 0; k2 < n2; k2++) {
            h2 = V2.get(k2, i2 + 1);
            V2.set(k2, i2 + 1, s2 * V2.get(k2, i2) + c2 * h2);
            V2.set(k2, i2, c2 * V2.get(k2, i2) - s2 * h2);
          }
        }
        p2 = -s2 * s22 * c3 * el1 * e8[l2] / dl1;
        e8[l2] = s2 * p2;
        d2[l2] = c2 * p2;
      } while (Math.abs(e8[l2]) > eps2 * tst1);
    }
    d2[l2] = d2[l2] + f2;
    e8[l2] = 0;
  }
  for (i2 = 0; i2 < n2 - 1; i2++) {
    k2 = i2;
    p2 = d2[i2];
    for (j2 = i2 + 1; j2 < n2; j2++) {
      if (d2[j2] < p2) {
        k2 = j2;
        p2 = d2[j2];
      }
    }
    if (k2 !== i2) {
      d2[k2] = d2[i2];
      d2[i2] = p2;
      for (j2 = 0; j2 < n2; j2++) {
        p2 = V2.get(j2, i2);
        V2.set(j2, i2, V2.get(j2, k2));
        V2.set(j2, k2, p2);
      }
    }
  }
}
function orthes(n2, H2, ort, V2) {
  let low = 0;
  let high = n2 - 1;
  let f2, g2, h2, i2, j2, m2;
  let scale9;
  for (m2 = low + 1; m2 <= high - 1; m2++) {
    scale9 = 0;
    for (i2 = m2; i2 <= high; i2++) {
      scale9 = scale9 + Math.abs(H2.get(i2, m2 - 1));
    }
    if (scale9 !== 0) {
      h2 = 0;
      for (i2 = high; i2 >= m2; i2--) {
        ort[i2] = H2.get(i2, m2 - 1) / scale9;
        h2 += ort[i2] * ort[i2];
      }
      g2 = Math.sqrt(h2);
      if (ort[m2] > 0) {
        g2 = -g2;
      }
      h2 = h2 - ort[m2] * g2;
      ort[m2] = ort[m2] - g2;
      for (j2 = m2; j2 < n2; j2++) {
        f2 = 0;
        for (i2 = high; i2 >= m2; i2--) {
          f2 += ort[i2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (i2 = m2; i2 <= high; i2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[i2]);
        }
      }
      for (i2 = 0; i2 <= high; i2++) {
        f2 = 0;
        for (j2 = high; j2 >= m2; j2--) {
          f2 += ort[j2] * H2.get(i2, j2);
        }
        f2 = f2 / h2;
        for (j2 = m2; j2 <= high; j2++) {
          H2.set(i2, j2, H2.get(i2, j2) - f2 * ort[j2]);
        }
      }
      ort[m2] = scale9 * ort[m2];
      H2.set(m2, m2 - 1, scale9 * g2);
    }
  }
  for (i2 = 0; i2 < n2; i2++) {
    for (j2 = 0; j2 < n2; j2++) {
      V2.set(i2, j2, i2 === j2 ? 1 : 0);
    }
  }
  for (m2 = high - 1; m2 >= low + 1; m2--) {
    if (H2.get(m2, m2 - 1) !== 0) {
      for (i2 = m2 + 1; i2 <= high; i2++) {
        ort[i2] = H2.get(i2, m2 - 1);
      }
      for (j2 = m2; j2 <= high; j2++) {
        g2 = 0;
        for (i2 = m2; i2 <= high; i2++) {
          g2 += ort[i2] * V2.get(i2, j2);
        }
        g2 = g2 / ort[m2] / H2.get(m2, m2 - 1);
        for (i2 = m2; i2 <= high; i2++) {
          V2.set(i2, j2, V2.get(i2, j2) + g2 * ort[i2]);
        }
      }
    }
  }
}
function hqr2(nn2, e8, d2, V2, H2) {
  let n2 = nn2 - 1;
  let low = 0;
  let high = nn2 - 1;
  let eps2 = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p2 = 0;
  let q2 = 0;
  let r2 = 0;
  let s2 = 0;
  let z2 = 0;
  let iter = 0;
  let i2, j2, k2, l2, m2, t4, w2, x2, y2;
  let ra2, sa2, vr2, vi2;
  let notlast, cdivres;
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      d2[i2] = H2.get(i2, i2);
      e8[i2] = 0;
    }
    for (j2 = Math.max(i2 - 1, 0); j2 < nn2; j2++) {
      norm = norm + Math.abs(H2.get(i2, j2));
    }
  }
  while (n2 >= low) {
    l2 = n2;
    while (l2 > low) {
      s2 = Math.abs(H2.get(l2 - 1, l2 - 1)) + Math.abs(H2.get(l2, l2));
      if (s2 === 0) {
        s2 = norm;
      }
      if (Math.abs(H2.get(l2, l2 - 1)) < eps2 * s2) {
        break;
      }
      l2--;
    }
    if (l2 === n2) {
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      d2[n2] = H2.get(n2, n2);
      e8[n2] = 0;
      n2--;
      iter = 0;
    } else if (l2 === n2 - 1) {
      w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      p2 = (H2.get(n2 - 1, n2 - 1) - H2.get(n2, n2)) / 2;
      q2 = p2 * p2 + w2;
      z2 = Math.sqrt(Math.abs(q2));
      H2.set(n2, n2, H2.get(n2, n2) + exshift);
      H2.set(n2 - 1, n2 - 1, H2.get(n2 - 1, n2 - 1) + exshift);
      x2 = H2.get(n2, n2);
      if (q2 >= 0) {
        z2 = p2 >= 0 ? p2 + z2 : p2 - z2;
        d2[n2 - 1] = x2 + z2;
        d2[n2] = d2[n2 - 1];
        if (z2 !== 0) {
          d2[n2] = x2 - w2 / z2;
        }
        e8[n2 - 1] = 0;
        e8[n2] = 0;
        x2 = H2.get(n2, n2 - 1);
        s2 = Math.abs(x2) + Math.abs(z2);
        p2 = x2 / s2;
        q2 = z2 / s2;
        r2 = Math.sqrt(p2 * p2 + q2 * q2);
        p2 = p2 / r2;
        q2 = q2 / r2;
        for (j2 = n2 - 1; j2 < nn2; j2++) {
          z2 = H2.get(n2 - 1, j2);
          H2.set(n2 - 1, j2, q2 * z2 + p2 * H2.get(n2, j2));
          H2.set(n2, j2, q2 * H2.get(n2, j2) - p2 * z2);
        }
        for (i2 = 0; i2 <= n2; i2++) {
          z2 = H2.get(i2, n2 - 1);
          H2.set(i2, n2 - 1, q2 * z2 + p2 * H2.get(i2, n2));
          H2.set(i2, n2, q2 * H2.get(i2, n2) - p2 * z2);
        }
        for (i2 = low; i2 <= high; i2++) {
          z2 = V2.get(i2, n2 - 1);
          V2.set(i2, n2 - 1, q2 * z2 + p2 * V2.get(i2, n2));
          V2.set(i2, n2, q2 * V2.get(i2, n2) - p2 * z2);
        }
      } else {
        d2[n2 - 1] = x2 + p2;
        d2[n2] = x2 + p2;
        e8[n2 - 1] = z2;
        e8[n2] = -z2;
      }
      n2 = n2 - 2;
      iter = 0;
    } else {
      x2 = H2.get(n2, n2);
      y2 = 0;
      w2 = 0;
      if (l2 < n2) {
        y2 = H2.get(n2 - 1, n2 - 1);
        w2 = H2.get(n2, n2 - 1) * H2.get(n2 - 1, n2);
      }
      if (iter === 10) {
        exshift += x2;
        for (i2 = low; i2 <= n2; i2++) {
          H2.set(i2, i2, H2.get(i2, i2) - x2);
        }
        s2 = Math.abs(H2.get(n2, n2 - 1)) + Math.abs(H2.get(n2 - 1, n2 - 2));
        x2 = y2 = 0.75 * s2;
        w2 = -0.4375 * s2 * s2;
      }
      if (iter === 30) {
        s2 = (y2 - x2) / 2;
        s2 = s2 * s2 + w2;
        if (s2 > 0) {
          s2 = Math.sqrt(s2);
          if (y2 < x2) {
            s2 = -s2;
          }
          s2 = x2 - w2 / ((y2 - x2) / 2 + s2);
          for (i2 = low; i2 <= n2; i2++) {
            H2.set(i2, i2, H2.get(i2, i2) - s2);
          }
          exshift += s2;
          x2 = y2 = w2 = 0.964;
        }
      }
      iter = iter + 1;
      m2 = n2 - 2;
      while (m2 >= l2) {
        z2 = H2.get(m2, m2);
        r2 = x2 - z2;
        s2 = y2 - z2;
        p2 = (r2 * s2 - w2) / H2.get(m2 + 1, m2) + H2.get(m2, m2 + 1);
        q2 = H2.get(m2 + 1, m2 + 1) - z2 - r2 - s2;
        r2 = H2.get(m2 + 2, m2 + 1);
        s2 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
        p2 = p2 / s2;
        q2 = q2 / s2;
        r2 = r2 / s2;
        if (m2 === l2) {
          break;
        }
        if (Math.abs(H2.get(m2, m2 - 1)) * (Math.abs(q2) + Math.abs(r2)) < eps2 * (Math.abs(p2) * (Math.abs(H2.get(m2 - 1, m2 - 1)) + Math.abs(z2) + Math.abs(H2.get(m2 + 1, m2 + 1))))) {
          break;
        }
        m2--;
      }
      for (i2 = m2 + 2; i2 <= n2; i2++) {
        H2.set(i2, i2 - 2, 0);
        if (i2 > m2 + 2) {
          H2.set(i2, i2 - 3, 0);
        }
      }
      for (k2 = m2; k2 <= n2 - 1; k2++) {
        notlast = k2 !== n2 - 1;
        if (k2 !== m2) {
          p2 = H2.get(k2, k2 - 1);
          q2 = H2.get(k2 + 1, k2 - 1);
          r2 = notlast ? H2.get(k2 + 2, k2 - 1) : 0;
          x2 = Math.abs(p2) + Math.abs(q2) + Math.abs(r2);
          if (x2 !== 0) {
            p2 = p2 / x2;
            q2 = q2 / x2;
            r2 = r2 / x2;
          }
        }
        if (x2 === 0) {
          break;
        }
        s2 = Math.sqrt(p2 * p2 + q2 * q2 + r2 * r2);
        if (p2 < 0) {
          s2 = -s2;
        }
        if (s2 !== 0) {
          if (k2 !== m2) {
            H2.set(k2, k2 - 1, -s2 * x2);
          } else if (l2 !== m2) {
            H2.set(k2, k2 - 1, -H2.get(k2, k2 - 1));
          }
          p2 = p2 + s2;
          x2 = p2 / s2;
          y2 = q2 / s2;
          z2 = r2 / s2;
          q2 = q2 / p2;
          r2 = r2 / p2;
          for (j2 = k2; j2 < nn2; j2++) {
            p2 = H2.get(k2, j2) + q2 * H2.get(k2 + 1, j2);
            if (notlast) {
              p2 = p2 + r2 * H2.get(k2 + 2, j2);
              H2.set(k2 + 2, j2, H2.get(k2 + 2, j2) - p2 * z2);
            }
            H2.set(k2, j2, H2.get(k2, j2) - p2 * x2);
            H2.set(k2 + 1, j2, H2.get(k2 + 1, j2) - p2 * y2);
          }
          for (i2 = 0; i2 <= Math.min(n2, k2 + 3); i2++) {
            p2 = x2 * H2.get(i2, k2) + y2 * H2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * H2.get(i2, k2 + 2);
              H2.set(i2, k2 + 2, H2.get(i2, k2 + 2) - p2 * r2);
            }
            H2.set(i2, k2, H2.get(i2, k2) - p2);
            H2.set(i2, k2 + 1, H2.get(i2, k2 + 1) - p2 * q2);
          }
          for (i2 = low; i2 <= high; i2++) {
            p2 = x2 * V2.get(i2, k2) + y2 * V2.get(i2, k2 + 1);
            if (notlast) {
              p2 = p2 + z2 * V2.get(i2, k2 + 2);
              V2.set(i2, k2 + 2, V2.get(i2, k2 + 2) - p2 * r2);
            }
            V2.set(i2, k2, V2.get(i2, k2) - p2);
            V2.set(i2, k2 + 1, V2.get(i2, k2 + 1) - p2 * q2);
          }
        }
      }
    }
  }
  if (norm === 0) {
    return;
  }
  for (n2 = nn2 - 1; n2 >= 0; n2--) {
    p2 = d2[n2];
    q2 = e8[n2];
    if (q2 === 0) {
      l2 = n2;
      H2.set(n2, n2, 1);
      for (i2 = n2 - 1; i2 >= 0; i2--) {
        w2 = H2.get(i2, i2) - p2;
        r2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          r2 = r2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        if (e8[i2] < 0) {
          z2 = w2;
          s2 = r2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            H2.set(i2, n2, w2 !== 0 ? -r2 / w2 : -r2 / (eps2 * norm));
          } else {
            x2 = H2.get(i2, i2 + 1);
            y2 = H2.get(i2 + 1, i2);
            q2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2];
            t4 = (x2 * s2 - z2 * r2) / q2;
            H2.set(i2, n2, t4);
            H2.set(i2 + 1, n2, Math.abs(x2) > Math.abs(z2) ? (-r2 - w2 * t4) / x2 : (-s2 - y2 * t4) / z2);
          }
          t4 = Math.abs(H2.get(i2, n2));
          if (eps2 * t4 * t4 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2, H2.get(j2, n2) / t4);
            }
          }
        }
      }
    } else if (q2 < 0) {
      l2 = n2 - 1;
      if (Math.abs(H2.get(n2, n2 - 1)) > Math.abs(H2.get(n2 - 1, n2))) {
        H2.set(n2 - 1, n2 - 1, q2 / H2.get(n2, n2 - 1));
        H2.set(n2 - 1, n2, -(H2.get(n2, n2) - p2) / H2.get(n2, n2 - 1));
      } else {
        cdivres = cdiv(0, -H2.get(n2 - 1, n2), H2.get(n2 - 1, n2 - 1) - p2, q2);
        H2.set(n2 - 1, n2 - 1, cdivres[0]);
        H2.set(n2 - 1, n2, cdivres[1]);
      }
      H2.set(n2, n2 - 1, 0);
      H2.set(n2, n2, 1);
      for (i2 = n2 - 2; i2 >= 0; i2--) {
        ra2 = 0;
        sa2 = 0;
        for (j2 = l2; j2 <= n2; j2++) {
          ra2 = ra2 + H2.get(i2, j2) * H2.get(j2, n2 - 1);
          sa2 = sa2 + H2.get(i2, j2) * H2.get(j2, n2);
        }
        w2 = H2.get(i2, i2) - p2;
        if (e8[i2] < 0) {
          z2 = w2;
          r2 = ra2;
          s2 = sa2;
        } else {
          l2 = i2;
          if (e8[i2] === 0) {
            cdivres = cdiv(-ra2, -sa2, w2, q2);
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
          } else {
            x2 = H2.get(i2, i2 + 1);
            y2 = H2.get(i2 + 1, i2);
            vr2 = (d2[i2] - p2) * (d2[i2] - p2) + e8[i2] * e8[i2] - q2 * q2;
            vi2 = (d2[i2] - p2) * 2 * q2;
            if (vr2 === 0 && vi2 === 0) {
              vr2 = eps2 * norm * (Math.abs(w2) + Math.abs(q2) + Math.abs(x2) + Math.abs(y2) + Math.abs(z2));
            }
            cdivres = cdiv(x2 * r2 - z2 * ra2 + q2 * sa2, x2 * s2 - z2 * sa2 - q2 * ra2, vr2, vi2);
            H2.set(i2, n2 - 1, cdivres[0]);
            H2.set(i2, n2, cdivres[1]);
            if (Math.abs(x2) > Math.abs(z2) + Math.abs(q2)) {
              H2.set(i2 + 1, n2 - 1, (-ra2 - w2 * H2.get(i2, n2 - 1) + q2 * H2.get(i2, n2)) / x2);
              H2.set(i2 + 1, n2, (-sa2 - w2 * H2.get(i2, n2) - q2 * H2.get(i2, n2 - 1)) / x2);
            } else {
              cdivres = cdiv(-r2 - y2 * H2.get(i2, n2 - 1), -s2 - y2 * H2.get(i2, n2), z2, q2);
              H2.set(i2 + 1, n2 - 1, cdivres[0]);
              H2.set(i2 + 1, n2, cdivres[1]);
            }
          }
          t4 = Math.max(Math.abs(H2.get(i2, n2 - 1)), Math.abs(H2.get(i2, n2)));
          if (eps2 * t4 * t4 > 1) {
            for (j2 = i2; j2 <= n2; j2++) {
              H2.set(j2, n2 - 1, H2.get(j2, n2 - 1) / t4);
              H2.set(j2, n2, H2.get(j2, n2) / t4);
            }
          }
        }
      }
    }
  }
  for (i2 = 0; i2 < nn2; i2++) {
    if (i2 < low || i2 > high) {
      for (j2 = i2; j2 < nn2; j2++) {
        V2.set(i2, j2, H2.get(i2, j2));
      }
    }
  }
  for (j2 = nn2 - 1; j2 >= low; j2--) {
    for (i2 = low; i2 <= high; i2++) {
      z2 = 0;
      for (k2 = low; k2 <= Math.min(j2, high); k2++) {
        z2 = z2 + V2.get(i2, k2) * H2.get(k2, j2);
      }
      V2.set(i2, j2, z2);
    }
  }
}
function cdiv(xr2, xi2, yr2, yi2) {
  let r2, d2;
  if (Math.abs(yr2) > Math.abs(yi2)) {
    r2 = yi2 / yr2;
    d2 = yr2 + r2 * yi2;
    return [(xr2 + r2 * xi2) / d2, (xi2 - r2 * xr2) / d2];
  } else {
    r2 = yr2 / yi2;
    d2 = yi2 + r2 * yr2;
    return [(r2 * xr2 + xi2) / d2, (r2 * xi2 - xr2) / d2];
  }
}
var EigenvalueDecomposition;
var init_evd = __esm({
  "node_modules/ml-matrix/src/dc/evd.js"() {
    init_matrix();
    init_WrapperMatrix2D();
    init_util3();
    EigenvalueDecomposition = class {
      constructor(matrix, options = {}) {
        const { assumeSymmetric = false } = options;
        matrix = WrapperMatrix2D.checkMatrix(matrix);
        if (!matrix.isSquare()) {
          throw new Error("Matrix is not a square matrix");
        }
        if (matrix.isEmpty()) {
          throw new Error("Matrix must be non-empty");
        }
        let n2 = matrix.columns;
        let V2 = new Matrix(n2, n2);
        let d2 = new Float64Array(n2);
        let e8 = new Float64Array(n2);
        let value = matrix;
        let i2, j2;
        let isSymmetric = false;
        if (assumeSymmetric) {
          isSymmetric = true;
        } else {
          isSymmetric = matrix.isSymmetric();
        }
        if (isSymmetric) {
          for (i2 = 0; i2 < n2; i2++) {
            for (j2 = 0; j2 < n2; j2++) {
              V2.set(i2, j2, value.get(i2, j2));
            }
          }
          tred2(n2, e8, d2, V2);
          tql2(n2, e8, d2, V2);
        } else {
          let H2 = new Matrix(n2, n2);
          let ort = new Float64Array(n2);
          for (j2 = 0; j2 < n2; j2++) {
            for (i2 = 0; i2 < n2; i2++) {
              H2.set(i2, j2, value.get(i2, j2));
            }
          }
          orthes(n2, H2, ort, V2);
          hqr2(n2, e8, d2, V2, H2);
        }
        this.n = n2;
        this.e = e8;
        this.d = d2;
        this.V = V2;
      }
      get realEigenvalues() {
        return Array.from(this.d);
      }
      get imaginaryEigenvalues() {
        return Array.from(this.e);
      }
      get eigenvectorMatrix() {
        return this.V;
      }
      get diagonalMatrix() {
        let n2 = this.n;
        let e8 = this.e;
        let d2 = this.d;
        let X2 = new Matrix(n2, n2);
        let i2, j2;
        for (i2 = 0; i2 < n2; i2++) {
          for (j2 = 0; j2 < n2; j2++) {
            X2.set(i2, j2, 0);
          }
          X2.set(i2, i2, d2[i2]);
          if (e8[i2] > 0) {
            X2.set(i2, i2 + 1, e8[i2]);
          } else if (e8[i2] < 0) {
            X2.set(i2, i2 - 1, e8[i2]);
          }
        }
        return X2;
      }
    };
  }
});

// node_modules/ml-matrix/src/dc/cholesky.js
var CholeskyDecomposition;
var init_cholesky = __esm({
  "node_modules/ml-matrix/src/dc/cholesky.js"() {
    init_matrix();
    init_WrapperMatrix2D();
    CholeskyDecomposition = class {
      constructor(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        if (!value.isSymmetric()) {
          throw new Error("Matrix is not symmetric");
        }
        let a2 = value;
        let dimension = a2.rows;
        let l2 = new Matrix(dimension, dimension);
        let positiveDefinite = true;
        let i2, j2, k2;
        for (j2 = 0; j2 < dimension; j2++) {
          let d2 = 0;
          for (k2 = 0; k2 < j2; k2++) {
            let s2 = 0;
            for (i2 = 0; i2 < k2; i2++) {
              s2 += l2.get(k2, i2) * l2.get(j2, i2);
            }
            s2 = (a2.get(j2, k2) - s2) / l2.get(k2, k2);
            l2.set(j2, k2, s2);
            d2 = d2 + s2 * s2;
          }
          d2 = a2.get(j2, j2) - d2;
          positiveDefinite &= d2 > 0;
          l2.set(j2, j2, Math.sqrt(Math.max(d2, 0)));
          for (k2 = j2 + 1; k2 < dimension; k2++) {
            l2.set(j2, k2, 0);
          }
        }
        this.L = l2;
        this.positiveDefinite = Boolean(positiveDefinite);
      }
      isPositiveDefinite() {
        return this.positiveDefinite;
      }
      solve(value) {
        value = WrapperMatrix2D.checkMatrix(value);
        let l2 = this.L;
        let dimension = l2.rows;
        if (value.rows !== dimension) {
          throw new Error("Matrix dimensions do not match");
        }
        if (this.isPositiveDefinite() === false) {
          throw new Error("Matrix is not positive definite");
        }
        let count = value.columns;
        let B3 = value.clone();
        let i2, j2, k2;
        for (k2 = 0; k2 < dimension; k2++) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = 0; i2 < k2; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l2.get(k2, i2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l2.get(k2, k2));
          }
        }
        for (k2 = dimension - 1; k2 >= 0; k2--) {
          for (j2 = 0; j2 < count; j2++) {
            for (i2 = k2 + 1; i2 < dimension; i2++) {
              B3.set(k2, j2, B3.get(k2, j2) - B3.get(i2, j2) * l2.get(i2, k2));
            }
            B3.set(k2, j2, B3.get(k2, j2) / l2.get(k2, k2));
          }
        }
        return B3;
      }
      get lowerTriangularMatrix() {
        return this.L;
      }
    };
  }
});

// node_modules/ml-matrix/src/dc/nipals.js
var nipals;
var init_nipals = __esm({
  "node_modules/ml-matrix/src/dc/nipals.js"() {
    init_lib_esm();
    init_matrix();
    init_WrapperMatrix2D();
    nipals = class {
      constructor(X2, options = {}) {
        X2 = WrapperMatrix2D.checkMatrix(X2);
        let { Y: Y2 } = options;
        const {
          scaleScores = false,
          maxIterations = 1e3,
          terminationCriteria = 1e-10
        } = options;
        let u2;
        if (Y2) {
          if (isAnyArray(Y2) && typeof Y2[0] === "number") {
            Y2 = Matrix.columnVector(Y2);
          } else {
            Y2 = WrapperMatrix2D.checkMatrix(Y2);
          }
          if (Y2.rows !== X2.rows) {
            throw new Error("Y should have the same number of rows as X");
          }
          u2 = Y2.getColumnVector(0);
        } else {
          u2 = X2.getColumnVector(0);
        }
        let diff = 1;
        let t4, q2, w2, tOld;
        for (let counter = 0; counter < maxIterations && diff > terminationCriteria; counter++) {
          w2 = X2.transpose().mmul(u2).div(u2.transpose().mmul(u2).get(0, 0));
          w2 = w2.div(w2.norm());
          t4 = X2.mmul(w2).div(w2.transpose().mmul(w2).get(0, 0));
          if (counter > 0) {
            diff = t4.clone().sub(tOld).pow(2).sum();
          }
          tOld = t4.clone();
          if (Y2) {
            q2 = Y2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
            q2 = q2.div(q2.norm());
            u2 = Y2.mmul(q2).div(q2.transpose().mmul(q2).get(0, 0));
          } else {
            u2 = t4;
          }
        }
        if (Y2) {
          let p2 = X2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
          p2 = p2.div(p2.norm());
          let xResidual = X2.clone().sub(t4.clone().mmul(p2.transpose()));
          let residual = u2.transpose().mmul(t4).div(t4.transpose().mmul(t4).get(0, 0));
          let yResidual = Y2.clone().sub(t4.clone().mulS(residual.get(0, 0)).mmul(q2.transpose()));
          this.t = t4;
          this.p = p2.transpose();
          this.w = w2.transpose();
          this.q = q2;
          this.u = u2;
          this.s = t4.transpose().mmul(t4);
          this.xResidual = xResidual;
          this.yResidual = yResidual;
          this.betas = residual;
        } else {
          this.w = w2.transpose();
          this.s = t4.transpose().mmul(t4).sqrt();
          if (scaleScores) {
            this.t = t4.clone().div(this.s.get(0, 0));
          } else {
            this.t = t4;
          }
          this.xResidual = X2.sub(t4.mmul(w2.transpose()));
        }
      }
    };
  }
});

// node_modules/ml-matrix/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  AbstractMatrix: () => AbstractMatrix,
  CHO: () => CholeskyDecomposition,
  CholeskyDecomposition: () => CholeskyDecomposition,
  EVD: () => EigenvalueDecomposition,
  EigenvalueDecomposition: () => EigenvalueDecomposition,
  LU: () => LuDecomposition,
  LuDecomposition: () => LuDecomposition,
  Matrix: () => Matrix,
  MatrixColumnSelectionView: () => MatrixColumnSelectionView,
  MatrixColumnView: () => MatrixColumnView,
  MatrixFlipColumnView: () => MatrixFlipColumnView,
  MatrixFlipRowView: () => MatrixFlipRowView,
  MatrixRowSelectionView: () => MatrixRowSelectionView,
  MatrixRowView: () => MatrixRowView,
  MatrixSelectionView: () => MatrixSelectionView,
  MatrixSubView: () => MatrixSubView,
  MatrixTransposeView: () => MatrixTransposeView,
  NIPALS: () => nipals,
  Nipals: () => nipals,
  QR: () => QrDecomposition,
  QrDecomposition: () => QrDecomposition,
  SVD: () => SingularValueDecomposition,
  SingularValueDecomposition: () => SingularValueDecomposition,
  WrapperMatrix1D: () => WrapperMatrix1D,
  WrapperMatrix2D: () => WrapperMatrix2D,
  correlation: () => correlation,
  covariance: () => covariance,
  default: () => Matrix,
  determinant: () => determinant3,
  inverse: () => inverse4,
  linearDependencies: () => linearDependencies,
  pseudoInverse: () => pseudoInverse,
  solve: () => solve,
  wrap: () => wrap
});
var init_src2 = __esm({
  "node_modules/ml-matrix/src/index.js"() {
    init_matrix();
    init_views();
    init_wrap();
    init_WrapperMatrix1D();
    init_WrapperMatrix2D();
    init_decompositions();
    init_determinant();
    init_linearDependencies();
    init_pseudoInverse();
    init_covariance();
    init_correlation();
    init_svd();
    init_evd();
    init_cholesky();
    init_lu();
    init_qr();
    init_nipals();
  }
});

// node_modules/@antv/layout/lib/layout/radial/mds.js
var require_mds = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/mds.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ml_matrix_1 = (init_src2(), __toCommonJS(src_exports4));
    var MDS = function() {
      function MDS2(params) {
        this.distances = params.distances;
        this.dimension = params.dimension || 2;
        this.linkDistance = params.linkDistance;
      }
      MDS2.prototype.layout = function() {
        var self2 = this;
        var dimension = self2.dimension, distances = self2.distances, linkDistance = self2.linkDistance;
        try {
          var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
          var rowMeans = M2.mean("row");
          var colMeans = M2.mean("column");
          var totalMean = M2.mean();
          M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
          var ret = new ml_matrix_1.SingularValueDecomposition(M2);
          var eigenValues_1 = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
          return ret.leftSingularVectors.toJSON().map(function(row) {
            return ml_matrix_1.Matrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);
          });
        } catch (_a2) {
          var res = [];
          for (var i2 = 0; i2 < distances.length; i2++) {
            var x2 = Math.random() * linkDistance;
            var y2 = Math.random() * linkDistance;
            res.push([x2, y2]);
          }
          return res;
        }
      };
      return MDS2;
    }();
    exports.default = MDS;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js
var require_radialNonoverlapForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radialNonoverlapForce.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SPEED_DIVISOR = 800;
    var RadialNonoverlapForce = function() {
      function RadialNonoverlapForce2(params) {
        this.disp = [];
        this.positions = params.positions;
        this.adjMatrix = params.adjMatrix;
        this.focusID = params.focusID;
        this.radii = params.radii;
        this.iterations = params.iterations || 10;
        this.height = params.height || 10;
        this.width = params.width || 10;
        this.speed = params.speed || 100;
        this.gravity = params.gravity || 10;
        this.nodeSizeFunc = params.nodeSizeFunc;
        this.k = params.k || 5;
        this.strictRadial = params.strictRadial;
        this.nodes = params.nodes;
      }
      RadialNonoverlapForce2.prototype.layout = function() {
        var self2 = this;
        var positions = self2.positions;
        var disp = [];
        var iterations = self2.iterations;
        var maxDisplace = self2.width / 10;
        self2.maxDisplace = maxDisplace;
        self2.disp = disp;
        for (var i2 = 0; i2 < iterations; i2++) {
          positions.forEach(function(_2, k2) {
            disp[k2] = { x: 0, y: 0 };
          });
          self2.getRepulsion();
          self2.updatePositions();
        }
        return positions;
      };
      RadialNonoverlapForce2.prototype.getRepulsion = function() {
        var self2 = this;
        var positions = self2.positions;
        var nodes = self2.nodes;
        var disp = self2.disp;
        var k2 = self2.k;
        var radii = self2.radii || [];
        positions.forEach(function(v2, i2) {
          disp[i2] = { x: 0, y: 0 };
          positions.forEach(function(u2, j2) {
            if (i2 === j2) {
              return;
            }
            if (radii[i2] !== radii[j2]) {
              return;
            }
            var vecx = v2[0] - u2[0];
            var vecy = v2[1] - u2[1];
            var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
            if (vecLength === 0) {
              vecLength = 1;
              var sign = i2 > j2 ? 1 : -1;
              vecx = 0.01 * sign;
              vecy = 0.01 * sign;
            }
            if (vecLength < self2.nodeSizeFunc(nodes[i2]) / 2 + self2.nodeSizeFunc(nodes[j2]) / 2) {
              var common = k2 * k2 / vecLength;
              disp[i2].x += vecx / vecLength * common;
              disp[i2].y += vecy / vecLength * common;
            }
          });
        });
      };
      RadialNonoverlapForce2.prototype.updatePositions = function() {
        var self2 = this;
        var positions = self2.positions;
        var disp = self2.disp;
        var speed = self2.speed;
        var strictRadial = self2.strictRadial;
        var f2 = self2.focusID;
        var maxDisplace = self2.maxDisplace || self2.width / 10;
        if (strictRadial) {
          disp.forEach(function(di2, i2) {
            var vx = positions[i2][0] - positions[f2][0];
            var vy = positions[i2][1] - positions[f2][1];
            var vLength = Math.sqrt(vx * vx + vy * vy);
            var vpx = vy / vLength;
            var vpy = -vx / vLength;
            var diLength = Math.sqrt(di2.x * di2.x + di2.y * di2.y);
            var alpha = Math.acos((vpx * di2.x + vpy * di2.y) / diLength);
            if (alpha > Math.PI / 2) {
              alpha -= Math.PI / 2;
              vpx *= -1;
              vpy *= -1;
            }
            var tdispLength = Math.cos(alpha) * diLength;
            di2.x = vpx * tdispLength;
            di2.y = vpy * tdispLength;
          });
        }
        var radii = self2.radii;
        positions.forEach(function(n2, i2) {
          if (i2 === f2) {
            return;
          }
          var distLength = Math.sqrt(disp[i2].x * disp[i2].x + disp[i2].y * disp[i2].y);
          if (distLength > 0 && i2 !== f2) {
            var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
            n2[0] += disp[i2].x / distLength * limitedDist;
            n2[1] += disp[i2].y / distLength * limitedDist;
            if (strictRadial) {
              var vx = n2[0] - positions[f2][0];
              var vy = n2[1] - positions[f2][1];
              var nfDis = Math.sqrt(vx * vx + vy * vy);
              vx = vx / nfDis * radii[i2];
              vy = vy / nfDis * radii[i2];
              n2[0] = positions[f2][0] + vx;
              n2[1] = positions[f2][1] + vy;
            }
          }
        });
      };
      return RadialNonoverlapForce2;
    }();
    exports.default = RadialNonoverlapForce;
  }
});

// node_modules/@antv/layout/lib/layout/radial/radial.js
var require_radial = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/radial.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RadialLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var mds_1 = __importDefault(require_mds());
    var radialNonoverlapForce_1 = __importDefault(require_radialNonoverlapForce());
    function getWeightMatrix(M2) {
      var rows = M2.length;
      var cols = M2[0].length;
      var result = [];
      for (var i2 = 0; i2 < rows; i2++) {
        var row = [];
        for (var j2 = 0; j2 < cols; j2++) {
          if (M2[i2][j2] !== 0) {
            row.push(1 / (M2[i2][j2] * M2[i2][j2]));
          } else {
            row.push(0);
          }
        }
        result.push(row);
      }
      return result;
    }
    function getIndexById(array, id2) {
      var index = -1;
      array.forEach(function(a2, i2) {
        if (a2.id === id2) {
          index = i2;
        }
      });
      return index;
    }
    function getEDistance(p1, p2) {
      return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));
    }
    var RadialLayout2 = function(_super) {
      __extends19(RadialLayout3, _super);
      function RadialLayout3(options) {
        var _this = _super.call(this) || this;
        _this.maxIteration = 1e3;
        _this.focusNode = null;
        _this.unitRadius = null;
        _this.linkDistance = 50;
        _this.preventOverlap = false;
        _this.strictRadial = true;
        _this.maxPreventOverlapIteration = 200;
        _this.sortStrength = 10;
        _this.nodes = [];
        _this.edges = [];
        _this.updateCfg(options);
        return _this;
      }
      RadialLayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 1e3,
          focusNode: null,
          unitRadius: null,
          linkDistance: 50,
          preventOverlap: false,
          nodeSize: void 0,
          nodeSpacing: void 0,
          strictRadial: true,
          maxPreventOverlapIteration: 200,
          sortBy: void 0,
          sortStrength: 10
        };
      };
      RadialLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var edges = self2.edges || [];
        if (!nodes || nodes.length === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (!self2.center) {
          self2.center = [self2.width / 2, self2.height / 2];
        }
        var center = self2.center;
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        var linkDistance = self2.linkDistance;
        var focusNode = null;
        if ((0, util_1.isString)(self2.focusNode)) {
          var found = false;
          for (var i2 = 0; i2 < nodes.length; i2++) {
            if (nodes[i2].id === self2.focusNode) {
              focusNode = nodes[i2];
              self2.focusNode = focusNode;
              found = true;
              i2 = nodes.length;
            }
          }
          if (!found) {
            focusNode = null;
          }
        } else {
          focusNode = self2.focusNode;
        }
        if (!focusNode) {
          focusNode = nodes[0];
          self2.focusNode = focusNode;
        }
        var focusIndex = getIndexById(nodes, focusNode.id);
        if (focusIndex < 0)
          focusIndex = 0;
        self2.focusIndex = focusIndex;
        var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
        var D3 = (0, util_1.floydWarshall)(adjMatrix3);
        var maxDistance = self2.maxToFocus(D3, focusIndex);
        self2.handleInfinity(D3, focusIndex, maxDistance + 1);
        self2.distances = D3;
        var focusNodeD = D3[focusIndex];
        var width = self2.width || 500;
        var height = self2.height || 500;
        var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];
        var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
        if (semiWidth === 0) {
          semiWidth = width / 2;
        }
        if (semiHeight === 0) {
          semiHeight = height / 2;
        }
        var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;
        var maxD = Math.max.apply(Math, focusNodeD);
        var radii = [];
        focusNodeD.forEach(function(value, i3) {
          if (!self2.unitRadius) {
            self2.unitRadius = maxRadius / maxD;
          }
          radii[i3] = value * self2.unitRadius;
        });
        self2.radii = radii;
        var eIdealD = self2.eIdealDisMatrix();
        self2.eIdealDistances = eIdealD;
        var W2 = getWeightMatrix(eIdealD);
        self2.weights = W2;
        var mds = new mds_1.default({ linkDistance, distances: eIdealD });
        var positions = mds.layout();
        positions.forEach(function(p2) {
          if ((0, util_1.isNaN)(p2[0])) {
            p2[0] = Math.random() * linkDistance;
          }
          if ((0, util_1.isNaN)(p2[1])) {
            p2[1] = Math.random() * linkDistance;
          }
        });
        self2.positions = positions;
        positions.forEach(function(p2, i3) {
          nodes[i3].x = p2[0] + center[0];
          nodes[i3].y = p2[1] + center[1];
        });
        positions.forEach(function(p2) {
          p2[0] -= positions[focusIndex][0];
          p2[1] -= positions[focusIndex][1];
        });
        self2.run();
        var preventOverlap = self2.preventOverlap;
        var nodeSize = self2.nodeSize;
        var nodeSizeFunc;
        var strictRadial = self2.strictRadial;
        if (preventOverlap) {
          var nodeSpacing_1 = self2.nodeSpacing;
          var nodeSpacingFunc_1;
          if ((0, util_1.isNumber)(nodeSpacing_1)) {
            nodeSpacingFunc_1 = function() {
              return nodeSpacing_1;
            };
          } else if ((0, util_1.isFunction)(nodeSpacing_1)) {
            nodeSpacingFunc_1 = nodeSpacing_1;
          } else {
            nodeSpacingFunc_1 = function() {
              return 0;
            };
          }
          if (!nodeSize) {
            nodeSizeFunc = function(d2) {
              if (d2.size) {
                if ((0, util_1.isArray)(d2.size)) {
                  var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                  return res + nodeSpacingFunc_1(d2);
                }
                if ((0, util_1.isObject)(d2.size)) {
                  var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                  return res + nodeSpacingFunc_1(d2);
                }
                return d2.size + nodeSpacingFunc_1(d2);
              }
              return 10 + nodeSpacingFunc_1(d2);
            };
          } else if ((0, util_1.isArray)(nodeSize)) {
            nodeSizeFunc = function(d2) {
              var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
              return res + nodeSpacingFunc_1(d2);
            };
          } else {
            nodeSizeFunc = function(d2) {
              return nodeSize + nodeSpacingFunc_1(d2);
            };
          }
          var nonoverlapForceParams = {
            nodes,
            nodeSizeFunc,
            adjMatrix: adjMatrix3,
            positions,
            radii,
            height,
            width,
            strictRadial,
            focusID: focusIndex,
            iterations: self2.maxPreventOverlapIteration || 200,
            k: positions.length / 4.5
          };
          var nonoverlapForce = new radialNonoverlapForce_1.default(nonoverlapForceParams);
          positions = nonoverlapForce.layout();
        }
        positions.forEach(function(p2, i3) {
          nodes[i3].x = p2[0] + center[0];
          nodes[i3].y = p2[1] + center[1];
        });
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges
        };
      };
      RadialLayout3.prototype.run = function() {
        var self2 = this;
        var maxIteration = self2.maxIteration;
        var positions = self2.positions || [];
        var W2 = self2.weights || [];
        var eIdealDis = self2.eIdealDistances || [];
        var radii = self2.radii || [];
        for (var i2 = 0; i2 <= maxIteration; i2++) {
          var param = i2 / maxIteration;
          self2.oneIteration(param, positions, radii, eIdealDis, W2);
        }
      };
      RadialLayout3.prototype.oneIteration = function(param, positions, radii, D3, W2) {
        var self2 = this;
        var vparam = 1 - param;
        var focusIndex = self2.focusIndex;
        positions.forEach(function(v2, i2) {
          var originDis = getEDistance(v2, [0, 0]);
          var reciODis = originDis === 0 ? 0 : 1 / originDis;
          if (i2 === focusIndex) {
            return;
          }
          var xMolecule = 0;
          var yMolecule = 0;
          var denominator = 0;
          positions.forEach(function(u2, j2) {
            if (i2 === j2) {
              return;
            }
            var edis = getEDistance(v2, u2);
            var reciEdis = edis === 0 ? 0 : 1 / edis;
            var idealDis = D3[j2][i2];
            denominator += W2[i2][j2];
            xMolecule += W2[i2][j2] * (u2[0] + idealDis * (v2[0] - u2[0]) * reciEdis);
            yMolecule += W2[i2][j2] * (u2[1] + idealDis * (v2[1] - u2[1]) * reciEdis);
          });
          var reciR = radii[i2] === 0 ? 0 : 1 / radii[i2];
          denominator *= vparam;
          denominator += param * reciR * reciR;
          xMolecule *= vparam;
          xMolecule += param * reciR * v2[0] * reciODis;
          v2[0] = xMolecule / denominator;
          yMolecule *= vparam;
          yMolecule += param * reciR * v2[1] * reciODis;
          v2[1] = yMolecule / denominator;
        });
      };
      RadialLayout3.prototype.eIdealDisMatrix = function() {
        var self2 = this;
        var nodes = self2.nodes;
        if (!nodes)
          return [];
        var D3 = self2.distances;
        var linkDis = self2.linkDistance;
        var radii = self2.radii || [];
        var unitRadius = self2.unitRadius || 50;
        var result = [];
        if (D3) {
          D3.forEach(function(row, i2) {
            var newRow = [];
            row.forEach(function(v2, j2) {
              if (i2 === j2) {
                newRow.push(0);
              } else if (radii[i2] === radii[j2]) {
                if (self2.sortBy === "data") {
                  newRow.push(v2 * (Math.abs(i2 - j2) * self2.sortStrength) / (radii[i2] / unitRadius));
                } else if (self2.sortBy) {
                  var iValue = nodes[i2][self2.sortBy] || 0;
                  var jValue = nodes[j2][self2.sortBy] || 0;
                  if ((0, util_1.isString)(iValue)) {
                    iValue = iValue.charCodeAt(0);
                  }
                  if ((0, util_1.isString)(jValue)) {
                    jValue = jValue.charCodeAt(0);
                  }
                  newRow.push(v2 * (Math.abs(iValue - jValue) * self2.sortStrength) / (radii[i2] / unitRadius));
                } else {
                  newRow.push(v2 * linkDis / (radii[i2] / unitRadius));
                }
              } else {
                var link = (linkDis + unitRadius) / 2;
                newRow.push(v2 * link);
              }
            });
            result.push(newRow);
          });
        }
        return result;
      };
      RadialLayout3.prototype.handleInfinity = function(matrix, focusIndex, step) {
        var length5 = matrix.length;
        for (var i2 = 0; i2 < length5; i2++) {
          if (matrix[focusIndex][i2] === Infinity) {
            matrix[focusIndex][i2] = step;
            matrix[i2][focusIndex] = step;
            for (var j2 = 0; j2 < length5; j2++) {
              if (matrix[i2][j2] !== Infinity && matrix[focusIndex][j2] === Infinity) {
                matrix[focusIndex][j2] = step + matrix[i2][j2];
                matrix[j2][focusIndex] = step + matrix[i2][j2];
              }
            }
          }
        }
        for (var i2 = 0; i2 < length5; i2++) {
          if (i2 === focusIndex) {
            continue;
          }
          for (var j2 = 0; j2 < length5; j2++) {
            if (matrix[i2][j2] === Infinity) {
              var minus = Math.abs(matrix[focusIndex][i2] - matrix[focusIndex][j2]);
              minus = minus === 0 ? 1 : minus;
              matrix[i2][j2] = minus;
            }
          }
        }
      };
      RadialLayout3.prototype.maxToFocus = function(matrix, focusIndex) {
        var max7 = 0;
        for (var i2 = 0; i2 < matrix[focusIndex].length; i2++) {
          if (matrix[focusIndex][i2] === Infinity) {
            continue;
          }
          max7 = matrix[focusIndex][i2] > max7 ? matrix[focusIndex][i2] : max7;
        }
        return max7;
      };
      RadialLayout3.prototype.getType = function() {
        return "radial";
      };
      return RadialLayout3;
    }(base_1.Base);
    exports.RadialLayout = RadialLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/radial/index.js
var require_radial2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/radial/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_radial(), exports);
  }
});

// node_modules/@antv/layout/lib/layout/concentric.js
var require_concentric = __commonJS({
  "node_modules/@antv/layout/lib/layout/concentric.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConcentricLayout = void 0;
    var util_1 = require_util2();
    var base_1 = require_base();
    var ConcentricLayout2 = function(_super) {
      __extends19(ConcentricLayout3, _super);
      function ConcentricLayout3(options) {
        var _this = _super.call(this) || this;
        _this.nodeSize = 30;
        _this.minNodeSpacing = 10;
        _this.nodeSpacing = 10;
        _this.preventOverlap = false;
        _this.equidistant = false;
        _this.startAngle = 3 / 2 * Math.PI;
        _this.clockwise = true;
        _this.sortBy = "degree";
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.onLayoutEnd = function() {
        };
        _this.updateCfg(options);
        return _this;
      }
      ConcentricLayout3.prototype.getDefaultCfg = function() {
        return {
          nodeSize: 30,
          minNodeSpacing: 10,
          nodeSpacing: 10,
          preventOverlap: false,
          sweep: void 0,
          equidistant: false,
          startAngle: 3 / 2 * Math.PI,
          clockwise: true,
          maxLevelDiff: void 0,
          sortBy: "degree"
        };
      };
      ConcentricLayout3.prototype.execute = function() {
        var _a2, _b;
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges;
        var n2 = nodes.length;
        if (n2 === 0) {
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return;
        }
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (!self2.center) {
          self2.center = [self2.width / 2, self2.height / 2];
        }
        var center = self2.center;
        if (n2 === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
          return;
        }
        var nodeSize = self2.nodeSize, nodeSpacing = self2.nodeSpacing;
        var layoutNodes = [];
        var maxNodeSize;
        var maxNodeSpacing = 0;
        if ((0, util_1.isArray)(nodeSize)) {
          maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
        } else {
          maxNodeSize = nodeSize;
        }
        if ((0, util_1.isArray)(nodeSpacing)) {
          maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
        } else if ((0, util_1.isNumber)(nodeSpacing)) {
          maxNodeSpacing = nodeSpacing;
        }
        nodes.forEach(function(node) {
          layoutNodes.push(node);
          var nodeSize2 = maxNodeSize;
          if ((0, util_1.isArray)(node.size)) {
            nodeSize2 = Math.max(node.size[0], node.size[1]);
          } else if ((0, util_1.isNumber)(node.size)) {
            nodeSize2 = node.size;
          } else if ((0, util_1.isObject)(node.size)) {
            nodeSize2 = Math.max(node.size.width, node.size.height);
          }
          maxNodeSize = Math.max(maxNodeSize, nodeSize2);
          if ((0, util_1.isFunction)(nodeSpacing)) {
            maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
          }
        });
        self2.clockwise = self2.counterclockwise !== void 0 ? !self2.counterclockwise : self2.clockwise;
        var nodeMap = {};
        var indexMap = {};
        layoutNodes.forEach(function(node, i3) {
          nodeMap[node.id] = node;
          indexMap[node.id] = i3;
        });
        if (self2.sortBy === "degree" || !(0, util_1.isString)(self2.sortBy) || layoutNodes[0][self2.sortBy] === void 0) {
          self2.sortBy = "degree";
          if (!(0, util_1.isNumber)(nodes[0].degree)) {
            var values_1 = (0, util_1.getDegree)(nodes.length, indexMap, edges);
            layoutNodes.forEach(function(node, i3) {
              node.degree = values_1[i3];
            });
          }
        }
        layoutNodes.sort(function(n1, n22) {
          return n22[self2.sortBy] - n1[self2.sortBy];
        });
        self2.maxValueNode = layoutNodes[0];
        self2.maxLevelDiff = self2.maxLevelDiff || self2.maxValueNode[self2.sortBy] / 4;
        var levels = [[]];
        var currentLevel = levels[0];
        layoutNodes.forEach(function(node) {
          if (currentLevel.length > 0) {
            var diff = Math.abs(currentLevel[0][self2.sortBy] - node[self2.sortBy]);
            if (self2.maxLevelDiff && diff >= self2.maxLevelDiff) {
              currentLevel = [];
              levels.push(currentLevel);
            }
          }
          currentLevel.push(node);
        });
        var minDist = maxNodeSize + (maxNodeSpacing || self2.minNodeSpacing);
        if (!self2.preventOverlap) {
          var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
          var maxR = Math.min(self2.width, self2.height) / 2 - minDist;
          var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
          minDist = Math.min(minDist, rStep);
        }
        var r2 = 0;
        levels.forEach(function(level2) {
          var sweep = self2.sweep;
          if (sweep === void 0) {
            sweep = 2 * Math.PI - 2 * Math.PI / level2.length;
          }
          var dTheta = level2.dTheta = sweep / Math.max(1, level2.length - 1);
          if (level2.length > 1 && self2.preventOverlap) {
            var dcos = Math.cos(dTheta) - Math.cos(0);
            var dsin = Math.sin(dTheta) - Math.sin(0);
            var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin));
            r2 = Math.max(rMin, r2);
          }
          level2.r = r2;
          r2 += minDist;
        });
        if (self2.equidistant) {
          var rDeltaMax_1 = 0;
          var rr_1 = 0;
          for (var i2 = 0; i2 < levels.length; i2++) {
            var level = levels[i2];
            var rDelta = level.r - rr_1;
            rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);
          }
          rr_1 = 0;
          levels.forEach(function(level2, i3) {
            if (i3 === 0) {
              rr_1 = level2.r;
            }
            level2.r = rr_1;
            rr_1 += rDeltaMax_1;
          });
        }
        levels.forEach(function(level2) {
          var dTheta = level2.dTheta;
          var rr2 = level2.r;
          level2.forEach(function(node, j2) {
            var theta = self2.startAngle + (self2.clockwise ? 1 : -1) * dTheta * j2;
            node.x = center[0] + rr2 * Math.cos(theta);
            node.y = center[1] + rr2 * Math.sin(theta);
          });
        });
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges
        };
      };
      ConcentricLayout3.prototype.getType = function() {
        return "concentric";
      };
      return ConcentricLayout3;
    }(base_1.Base);
    exports.ConcentricLayout = ConcentricLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/mds.js
var require_mds2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/mds.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MDSLayout = void 0;
    var ml_matrix_1 = (init_src2(), __toCommonJS(src_exports4));
    var util_1 = require_util2();
    var base_1 = require_base();
    var MDSLayout2 = function(_super) {
      __extends19(MDSLayout3, _super);
      function MDSLayout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.linkDistance = 50;
        _this.nodes = [];
        _this.edges = [];
        _this.onLayoutEnd = function() {
        };
        _this.updateCfg(options);
        return _this;
      }
      MDSLayout3.prototype.getDefaultCfg = function() {
        return {
          center: [0, 0],
          linkDistance: 50
        };
      };
      MDSLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes, _a2 = self2.edges, edges = _a2 === void 0 ? [] : _a2;
        var center = self2.center;
        if (!nodes || nodes.length === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        var linkDistance = self2.linkDistance;
        var adjMatrix3 = (0, util_1.getAdjMatrix)({ nodes, edges }, false);
        var distances = (0, util_1.floydWarshall)(adjMatrix3);
        self2.handleInfinity(distances);
        var scaledD = (0, util_1.scaleMatrix)(distances, linkDistance);
        self2.scaledDistances = scaledD;
        var positions = self2.runMDS();
        self2.positions = positions;
        positions.forEach(function(p2, i2) {
          nodes[i2].x = p2[0] + center[0];
          nodes[i2].y = p2[1] + center[1];
        });
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
        return {
          nodes,
          edges
        };
      };
      MDSLayout3.prototype.runMDS = function() {
        var self2 = this;
        var dimension = 2;
        var distances = self2.scaledDistances;
        var M2 = ml_matrix_1.Matrix.mul(ml_matrix_1.Matrix.pow(distances, 2), -0.5);
        var rowMeans = M2.mean("row");
        var colMeans = M2.mean("column");
        var totalMean = M2.mean();
        M2.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
        var ret = new ml_matrix_1.SingularValueDecomposition(M2);
        var eigenValues = ml_matrix_1.Matrix.sqrt(ret.diagonalMatrix).diagonal();
        return ret.leftSingularVectors.toJSON().map(function(row) {
          return ml_matrix_1.Matrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);
        });
      };
      MDSLayout3.prototype.handleInfinity = function(distances) {
        var maxDistance = -999999;
        distances.forEach(function(row) {
          row.forEach(function(value) {
            if (value === Infinity) {
              return;
            }
            if (maxDistance < value) {
              maxDistance = value;
            }
          });
        });
        distances.forEach(function(row, i2) {
          row.forEach(function(value, j2) {
            if (value === Infinity) {
              distances[i2][j2] = maxDistance;
            }
          });
        });
      };
      MDSLayout3.prototype.getType = function() {
        return "mds";
      };
      return MDSLayout3;
    }(base_1.Base);
    exports.MDSLayout = MDSLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/fruchterman.js
var require_fruchterman = __commonJS({
  "node_modules/@antv/layout/lib/layout/fruchterman.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var SPEED_DIVISOR = 800;
    var FruchtermanLayout2 = function(_super) {
      __extends19(FruchtermanLayout3, _super);
      function FruchtermanLayout3(options) {
        var _this = _super.call(this) || this;
        _this.maxIteration = 1e3;
        _this.workerEnabled = false;
        _this.gravity = 10;
        _this.speed = 5;
        _this.clustering = false;
        _this.clusterGravity = 10;
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.nodeMap = {};
        _this.nodeIdxMap = {};
        _this.onLayoutEnd = function() {
        };
        _this.tick = function() {
        };
        _this.animate = true;
        _this.updateCfg(options);
        return _this;
      }
      FruchtermanLayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 1e3,
          gravity: 10,
          speed: 1,
          clustering: false,
          clusterGravity: 10,
          animate: true
        };
      };
      FruchtermanLayout3.prototype.execute = function() {
        var _this = this;
        var _a2, _b;
        var self2 = this;
        var nodes = self2.nodes;
        if (self2.timeInterval !== void 0 && typeof window !== "undefined") {
          window.clearInterval(self2.timeInterval);
        }
        if (!nodes || nodes.length === 0) {
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
          return;
        }
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        if (!self2.center) {
          self2.center = [self2.width / 2, self2.height / 2];
        }
        var center = self2.center;
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          (_b = self2.onLayoutEnd) === null || _b === void 0 ? void 0 : _b.call(self2);
          return;
        }
        var nodeMap = {};
        var nodeIdxMap = {};
        nodes.forEach(function(node, i2) {
          if (!(0, util_1.isNumber)(node.x))
            node.x = Math.random() * _this.width;
          if (!(0, util_1.isNumber)(node.y))
            node.y = Math.random() * _this.height;
          nodeMap[node.id] = node;
          nodeIdxMap[node.id] = i2;
        });
        self2.nodeMap = nodeMap;
        self2.nodeIdxMap = nodeIdxMap;
        return self2.run();
      };
      FruchtermanLayout3.prototype.run = function() {
        var _a2;
        var self2 = this;
        var nodes = self2.nodes;
        if (!nodes)
          return;
        var edges = self2.edges, maxIteration = self2.maxIteration, workerEnabled = self2.workerEnabled, clustering = self2.clustering, animate = self2.animate;
        var clusterMap = {};
        if (clustering) {
          nodes.forEach(function(n2) {
            if (clusterMap[n2.cluster] === void 0) {
              clusterMap[n2.cluster] = {
                name: n2.cluster,
                cx: 0,
                cy: 0,
                count: 0
              };
            }
          });
        }
        if (workerEnabled || !animate) {
          for (var i2 = 0; i2 < maxIteration; i2++) {
            self2.runOneStep(clusterMap);
          }
          (_a2 = self2.onLayoutEnd) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
        } else {
          if (typeof window === "undefined")
            return;
          var iter_1 = 0;
          this.timeInterval = window.setInterval(function() {
            var _a3;
            self2.runOneStep(clusterMap);
            iter_1++;
            if (iter_1 >= maxIteration) {
              (_a3 = self2.onLayoutEnd) === null || _a3 === void 0 ? void 0 : _a3.call(self2);
              window.clearInterval(self2.timeInterval);
            }
          }, 0);
        }
        return {
          nodes,
          edges
        };
      };
      FruchtermanLayout3.prototype.runOneStep = function(clusterMap) {
        var _a2;
        var self2 = this;
        var nodes = self2.nodes;
        if (!nodes)
          return;
        var edges = self2.edges, center = self2.center, gravity = self2.gravity, speed = self2.speed, clustering = self2.clustering;
        var area = self2.height * self2.width;
        var maxDisplace = Math.sqrt(area) / 10;
        var k2 = area / (nodes.length + 1);
        var k3 = Math.sqrt(k2);
        var displacements = [];
        nodes.forEach(function(_2, j2) {
          displacements[j2] = { x: 0, y: 0 };
        });
        self2.applyCalculate(nodes, edges, displacements, k3, k2);
        if (clustering) {
          for (var key in clusterMap) {
            clusterMap[key].cx = 0;
            clusterMap[key].cy = 0;
            clusterMap[key].count = 0;
          }
          nodes.forEach(function(n2) {
            var c2 = clusterMap[n2.cluster];
            if ((0, util_1.isNumber)(n2.x)) {
              c2.cx += n2.x;
            }
            if ((0, util_1.isNumber)(n2.y)) {
              c2.cy += n2.y;
            }
            c2.count++;
          });
          for (var key in clusterMap) {
            clusterMap[key].cx /= clusterMap[key].count;
            clusterMap[key].cy /= clusterMap[key].count;
          }
          var clusterGravity_1 = self2.clusterGravity || gravity;
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            var c2 = clusterMap[n2.cluster];
            var distLength = Math.sqrt((n2.x - c2.cx) * (n2.x - c2.cx) + (n2.y - c2.cy) * (n2.y - c2.cy));
            var gravityForce = k3 * clusterGravity_1;
            displacements[j2].x -= gravityForce * (n2.x - c2.cx) / distLength;
            displacements[j2].y -= gravityForce * (n2.y - c2.cy) / distLength;
          });
        }
        nodes.forEach(function(n2, j2) {
          if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
            return;
          var gravityForce = 0.01 * k3 * gravity;
          displacements[j2].x -= gravityForce * (n2.x - center[0]);
          displacements[j2].y -= gravityForce * (n2.y - center[1]);
        });
        nodes.forEach(function(n2, j2) {
          if ((0, util_1.isNumber)(n2.fx) && (0, util_1.isNumber)(n2.fy)) {
            n2.x = n2.fx;
            n2.y = n2.fy;
            return;
          }
          if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
            return;
          var distLength = Math.sqrt(displacements[j2].x * displacements[j2].x + displacements[j2].y * displacements[j2].y);
          if (distLength > 0) {
            var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
            n2.x += displacements[j2].x / distLength * limitedDist;
            n2.y += displacements[j2].y / distLength * limitedDist;
          }
        });
        (_a2 = self2.tick) === null || _a2 === void 0 ? void 0 : _a2.call(self2);
      };
      FruchtermanLayout3.prototype.applyCalculate = function(nodes, edges, displacements, k2, k22) {
        var self2 = this;
        self2.calRepulsive(nodes, displacements, k22);
        if (edges)
          self2.calAttractive(edges, displacements, k2);
      };
      FruchtermanLayout3.prototype.calRepulsive = function(nodes, displacements, k2) {
        nodes.forEach(function(v2, i2) {
          displacements[i2] = { x: 0, y: 0 };
          nodes.forEach(function(u2, j2) {
            if (i2 === j2) {
              return;
            }
            if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
              return;
            }
            var vecX = v2.x - u2.x;
            var vecY = v2.y - u2.y;
            var vecLengthSqr = vecX * vecX + vecY * vecY;
            if (vecLengthSqr === 0) {
              vecLengthSqr = 1;
              var sign = i2 > j2 ? 1 : -1;
              vecX = 0.01 * sign;
              vecY = 0.01 * sign;
            }
            var common = k2 / vecLengthSqr;
            displacements[i2].x += vecX * common;
            displacements[i2].y += vecY * common;
          });
        });
      };
      FruchtermanLayout3.prototype.calAttractive = function(edges, displacements, k2) {
        var _this = this;
        edges.forEach(function(e8) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          if (!source || !target)
            return;
          var uIndex = _this.nodeIdxMap[source];
          var vIndex = _this.nodeIdxMap[target];
          if (uIndex === vIndex) {
            return;
          }
          var u2 = _this.nodeMap[source];
          var v2 = _this.nodeMap[target];
          if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
            return;
          }
          var vecX = v2.x - u2.x;
          var vecY = v2.y - u2.y;
          var vecLength = Math.sqrt(vecX * vecX + vecY * vecY);
          var common = vecLength * vecLength / k2;
          displacements[vIndex].x -= vecX / vecLength * common;
          displacements[vIndex].y -= vecY / vecLength * common;
          displacements[uIndex].x += vecX / vecLength * common;
          displacements[uIndex].y += vecY / vecLength * common;
        });
      };
      FruchtermanLayout3.prototype.stop = function() {
        if (this.timeInterval && typeof window !== "undefined") {
          window.clearInterval(this.timeInterval);
        }
      };
      FruchtermanLayout3.prototype.destroy = function() {
        var self2 = this;
        self2.stop();
        self2.tick = null;
        self2.nodes = null;
        self2.edges = null;
        self2.destroyed = true;
      };
      FruchtermanLayout3.prototype.getType = function() {
        return "fruchterman";
      };
      return FruchtermanLayout3;
    }(base_1.Base);
    exports.FruchtermanLayout = FruchtermanLayout2;
  }
});

// node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js
function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor)
    return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}
var init_initializerDefineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js
function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function(key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ("value" in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function(desc2, decorator) {
    return decorator(target, property, desc2) || desc2;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = void 0;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}
var init_applyDecoratedDescriptor = __esm({
  "node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js
var init_initializerWarningHelper = __esm({
  "node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js"() {
  }
});

// node_modules/reflect-metadata/Reflect.js
var Reflect2;
var init_Reflect = __esm({
  "node_modules/reflect-metadata/Reflect.js"() {
    (function(Reflect3) {
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
          return function(key, value) {
            if (typeof target[key] !== "function") {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map4, key) {
            return hasOwn.call(map4, key);
          } : function(map4, key) {
            return key in map4;
          },
          get: downLevel ? function(map4, key) {
            return hasOwn.call(map4, key) ? map4[key] : void 0;
          } : function(map4, key) {
            return map4[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata2 = new _WeakMap();
        function decorate2(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate2);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata2.get(target);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata2.delete(target);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i2 = decorators.length - 1; i2 >= 0; --i2) {
            var decorator = decorators[i2];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O2, P2, Create) {
          var targetMetadata = Metadata2.get(O2);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata2.set(O2, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P2);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P2, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P2);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O2, P2) {
          var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O2, P2) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O2, P2);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P2);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O2, P2) {
          var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O2, P2) {
          var metadataMap = GetOrCreateMetadataMap(O2, P2, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O2, P2) {
          var ownKeys13 = OrdinaryOwnMetadataKeys(O2, P2);
          var parent = OrdinaryGetPrototypeOf(O2);
          if (parent === null)
            return ownKeys13;
          var parentKeys = OrdinaryMetadataKeys(parent, P2);
          if (parentKeys.length <= 0)
            return ownKeys13;
          if (ownKeys13.length <= 0)
            return parentKeys;
          var set8 = new _Set();
          var keys2 = [];
          for (var _i2 = 0, ownKeys_1 = ownKeys13; _i2 < ownKeys_1.length; _i2++) {
            var key = ownKeys_1[_i2];
            var hasKey = set8.has(key);
            if (!hasKey) {
              set8.add(key);
              keys2.push(key);
            }
          }
          for (var _a2 = 0, parentKeys_1 = parentKeys; _a2 < parentKeys_1.length; _a2++) {
            var key = parentKeys_1[_a2];
            var hasKey = set8.has(key);
            if (!hasKey) {
              set8.add(key);
              keys2.push(key);
            }
          }
          return keys2;
        }
        function OrdinaryOwnMetadataKeys(O2, P2) {
          var keys2 = [];
          var metadataMap = GetOrCreateMetadataMap(O2, P2, false);
          if (IsUndefined(metadataMap))
            return keys2;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k2 = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys2.length = k2;
              return keys2;
            }
            var nextValue = IteratorValue(next);
            try {
              keys2[k2] = nextValue;
            } catch (e8) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e8;
              }
            }
            k2++;
          }
        }
        function Type(x2) {
          if (x2 === null)
            return 1;
          switch (typeof x2) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x2 === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x2) {
          return x2 === void 0;
        }
        function IsNull(x2) {
          return x2 === null;
        }
        function IsSymbol(x2) {
          return typeof x2 === "symbol";
        }
        function IsObject(x2) {
          return typeof x2 === "object" ? x2 !== null : typeof x2 === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O2, hint) {
          if (hint === "string") {
            var toString_1 = O2.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O2);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O2);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O2.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O2);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O2.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O2);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(argument, 3);
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V2, P2) {
          var func = V2[P2];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f2 = iterator["return"];
          if (f2)
            f2.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O2) {
          var proto = Object.getPrototypeOf(O2);
          if (typeof O2 !== "function" || O2 === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O2.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O2)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = function() {
            function MapIterator2(keys2, values2, selector) {
              this._index = 0;
              this._keys = keys2;
              this._values = values2;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result = this._selector(this._keys[index], this._values[index]);
                if (index + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }();
          return function() {
            function Map2() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map2.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map2.prototype.has = function(key) {
              return this._find(key, false) >= 0;
            };
            Map2.prototype.get = function(key) {
              var index = this._find(key, false);
              return index >= 0 ? this._values[index] : void 0;
            };
            Map2.prototype.set = function(key, value) {
              var index = this._find(key, true);
              this._values[index] = value;
              return this;
            };
            Map2.prototype.delete = function(key) {
              var index = this._find(key, false);
              if (index >= 0) {
                var size2 = this._keys.length;
                for (var i2 = index + 1; i2 < size2; i2++) {
                  this._keys[i2 - 1] = this._keys[i2];
                  this._values[i2 - 1] = this._values[i2];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map2.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map2.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map2.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue2);
            };
            Map2.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map2.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map2.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map2.prototype._find = function(key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map2;
          }();
          function getKey(key, _2) {
            return key;
          }
          function getValue2(_2, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return function() {
            function Set2() {
              this._map = new _Map();
            }
            Object.defineProperty(Set2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set2.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set2.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set2.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set2.prototype.clear = function() {
              this._map.clear();
            };
            Set2.prototype.keys = function() {
              return this._map.keys();
            };
            Set2.prototype.values = function() {
              return this._map.values();
            };
            Set2.prototype.entries = function() {
              return this._map.entries();
            };
            Set2.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set2.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set2;
          }();
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys2 = HashMap.create();
          var rootKey = CreateUniqueKey();
          return function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(target, true);
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }();
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys2, key));
            keys2[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create8) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create8)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size2) {
            for (var i2 = 0; i2 < size2; ++i2)
              buffer[i2] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size2) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size2));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size2));
              return FillRandomBytes(new Uint8Array(size2), size2);
            }
            return FillRandomBytes(new Array(size2), size2);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve2, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve2(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve2, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve2, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/Entity.js
function createEntity() {
  return entitySequence++;
}
var EMPTY, entitySequence;
var init_Entity = __esm({
  "node_modules/@antv/g-webgpu-core/es/Entity.js"() {
    EMPTY = -1;
    entitySequence = 1;
  }
});

// node_modules/@antv/g-webgpu-core/es/ComponentManager.js
var import_regenerator, Component, ComponentManager;
var init_ComponentManager = __esm({
  "node_modules/@antv/g-webgpu-core/es/ComponentManager.js"() {
    import_regenerator = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_createClass();
    init_classCallCheck();
    init_Entity();
    Component = function Component2(data) {
      _classCallCheck(this, Component2);
    };
    ComponentManager = function() {
      function ComponentManager2(clazz) {
        _classCallCheck(this, ComponentManager2);
        this.clazz = void 0;
        this.components = [];
        this.entities = [];
        this.lookup = {};
        this.clazz = clazz;
      }
      _createClass(ComponentManager2, [{
        key: "clear",
        value: function clear() {
          this.components = [];
          this.entities = [];
          this.lookup = {};
        }
      }, {
        key: "contains",
        value: function contains2(entity) {
          return this.lookup[entity] > -1;
        }
      }, {
        key: "create",
        value: function create8(entity, data) {
          this.lookup[entity] = this.components.length;
          var component = new this.clazz(data || {});
          this.components.push(component);
          this.entities.push(entity);
          return component;
        }
      }, {
        key: "remove",
        value: function remove2(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            if (componentIndex < this.components.length - 1) {
              this.components[componentIndex] = this.components[this.components.length - 1];
              this.entities[componentIndex] = this.entities[this.entities.length - 1];
              this.lookup[this.entities[componentIndex]] = componentIndex;
            }
          }
          this.components.pop();
          this.entities.pop();
          delete this.lookup[entity];
        }
      }, {
        key: "removeKeepSorted",
        value: function removeKeepSorted(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            var entity2 = this.entities[componentIndex];
            if (componentIndex < this.components.length - 1) {
              for (var _i2 = componentIndex + 1; _i2 < this.components.length; ++_i2) {
                this.components[_i2 - 1] = this.components[_i2];
              }
              for (var _i22 = componentIndex + 1; _i22 < this.entities.length; ++_i22) {
                this.entities[_i22 - 1] = this.entities[_i22];
                this.lookup[this.entities[_i22 - 1]] = _i22 - 1;
              }
            }
            this.components.pop();
            this.entities.pop();
            delete this.lookup[entity2];
          }
        }
      }, {
        key: "moveItem",
        value: function moveItem(srcIndex, destIndex) {
          if (srcIndex === destIndex) {
            return;
          }
          var srcComponent = this.components[srcIndex];
          var srcEntity = this.entities[srcIndex];
          var direction3 = srcIndex < destIndex ? 1 : -1;
          for (var _i3 = srcIndex; _i3 !== destIndex; _i3 += direction3) {
            var next = _i3 + direction3;
            this.components[_i3] = this.components[next];
            this.entities[_i3] = this.entities[next];
            this.lookup[this.entities[_i3]] = _i3;
          }
          this.components[destIndex] = srcComponent;
          this.entities[destIndex] = srcEntity;
          this.lookup[srcEntity] = destIndex;
        }
      }, {
        key: "getEntity",
        value: function getEntity(index) {
          return this.entities[index];
        }
      }, {
        key: "getComponent",
        value: function getComponent(index) {
          return this.components[index];
        }
      }, {
        key: "getComponentByEntity",
        value: function getComponentByEntity(entity) {
          var componentIndex = this.lookup[entity];
          if (componentIndex > -1) {
            return this.components[componentIndex];
          }
          return null;
        }
      }, {
        key: "getCount",
        value: function getCount() {
          return this.components.length;
        }
      }, {
        key: "getEntityByComponentIndex",
        value: function getEntityByComponentIndex(componentIdx) {
          for (var _i4 = 0, _Object$keys = Object.keys(this.lookup); _i4 < _Object$keys.length; _i4++) {
            var _entity = _Object$keys[_i4];
            var entityInNum = Number(_entity);
            if (this.lookup[entityInNum] === componentIdx) {
              return entityInNum;
            }
          }
          return EMPTY;
        }
      }, {
        key: "find",
        value: function find2(callback) {
          for (var _i5 = 0; _i5 < this.getCount(); _i5++) {
            var _component = this.getComponent(_i5);
            if (callback(_component, _i5)) {
              return _component;
            }
          }
          return null;
        }
      }, {
        key: "findIndex",
        value: function findIndex2(callback) {
          for (var _i6 = 0; _i6 < this.getCount(); _i6++) {
            var _component2 = this.getComponent(_i6);
            if (callback(_component2, _i6)) {
              return _i6;
            }
          }
          return -1;
        }
      }, {
        key: "forEach",
        value: function forEach4(callback) {
          for (var _i7 = 0, _Object$keys2 = Object.keys(this.lookup); _i7 < _Object$keys2.length; _i7++) {
            var _entity2 = _Object$keys2[_i7];
            var entityInNum = Number(_entity2);
            var componentIndex = this.lookup[entityInNum];
            callback(entityInNum, this.getComponent(componentIndex));
          }
        }
      }, {
        key: "forEachAsync",
        value: function() {
          var _forEachAsync = _asyncToGenerator(import_regenerator.default.mark(function _callee(callback) {
            var _i8, _Object$keys3, _entity3, entityInNum, componentIndex;
            return import_regenerator.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _i8 = 0, _Object$keys3 = Object.keys(this.lookup);
                  case 1:
                    if (!(_i8 < _Object$keys3.length)) {
                      _context.next = 10;
                      break;
                    }
                    _entity3 = _Object$keys3[_i8];
                    entityInNum = Number(_entity3);
                    componentIndex = this.lookup[entityInNum];
                    _context.next = 7;
                    return callback(entityInNum, this.getComponent(componentIndex));
                  case 7:
                    _i8++;
                    _context.next = 1;
                    break;
                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function forEachAsync(_x) {
            return _forEachAsync.apply(this, arguments);
          }
          return forEachAsync;
        }()
      }, {
        key: "map",
        value: function map4(callback) {
          var result = [];
          for (var _i9 = 0, _Object$keys4 = Object.keys(this.lookup); _i9 < _Object$keys4.length; _i9++) {
            var _entity4 = _Object$keys4[_i9];
            var entityInNum = Number(_entity4);
            var componentIndex = this.lookup[entityInNum];
            result.push(callback(entityInNum, this.getComponent(componentIndex)));
          }
          return result;
        }
      }]);
      return ComponentManager2;
    }();
  }
});

// node_modules/inversify/es/constants/metadata_keys.js
function getNonCustomTagKeys() {
  return [
    INJECT_TAG,
    MULTI_INJECT_TAG,
    NAME_TAG,
    UNMANAGED_TAG,
    NAMED_TAG,
    OPTIONAL_TAG
  ];
}
var NAMED_TAG, NAME_TAG, UNMANAGED_TAG, OPTIONAL_TAG, INJECT_TAG, MULTI_INJECT_TAG, TAGGED, TAGGED_PROP, PARAM_TYPES, DESIGN_PARAM_TYPES, POST_CONSTRUCT, NON_CUSTOM_TAG_KEYS;
var init_metadata_keys = __esm({
  "node_modules/inversify/es/constants/metadata_keys.js"() {
    NAMED_TAG = "named";
    NAME_TAG = "name";
    UNMANAGED_TAG = "unmanaged";
    OPTIONAL_TAG = "optional";
    INJECT_TAG = "inject";
    MULTI_INJECT_TAG = "multi_inject";
    TAGGED = "inversify:tagged";
    TAGGED_PROP = "inversify:tagged_props";
    PARAM_TYPES = "inversify:paramtypes";
    DESIGN_PARAM_TYPES = "design:paramtypes";
    POST_CONSTRUCT = "post_construct";
    NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();
  }
});

// node_modules/inversify/es/constants/literal_types.js
var BindingScopeEnum, BindingTypeEnum, TargetTypeEnum;
var init_literal_types = __esm({
  "node_modules/inversify/es/constants/literal_types.js"() {
    BindingScopeEnum = {
      Request: "Request",
      Singleton: "Singleton",
      Transient: "Transient"
    };
    BindingTypeEnum = {
      ConstantValue: "ConstantValue",
      Constructor: "Constructor",
      DynamicValue: "DynamicValue",
      Factory: "Factory",
      Function: "Function",
      Instance: "Instance",
      Invalid: "Invalid",
      Provider: "Provider"
    };
    TargetTypeEnum = {
      ClassProperty: "ClassProperty",
      ConstructorArgument: "ConstructorArgument",
      Variable: "Variable"
    };
  }
});

// node_modules/inversify/es/utils/id.js
function id() {
  return idCounter++;
}
var idCounter;
var init_id = __esm({
  "node_modules/inversify/es/utils/id.js"() {
    idCounter = 0;
  }
});

// node_modules/inversify/es/bindings/binding.js
var Binding;
var init_binding = __esm({
  "node_modules/inversify/es/bindings/binding.js"() {
    init_literal_types();
    init_id();
    Binding = function() {
      function Binding2(serviceIdentifier, scope) {
        this.id = id();
        this.activated = false;
        this.serviceIdentifier = serviceIdentifier;
        this.scope = scope;
        this.type = BindingTypeEnum.Invalid;
        this.constraint = function(request) {
          return true;
        };
        this.implementationType = null;
        this.cache = null;
        this.factory = null;
        this.provider = null;
        this.onActivation = null;
        this.dynamicValue = null;
      }
      Binding2.prototype.clone = function() {
        var clone8 = new Binding2(this.serviceIdentifier, this.scope);
        clone8.activated = clone8.scope === BindingScopeEnum.Singleton ? this.activated : false;
        clone8.implementationType = this.implementationType;
        clone8.dynamicValue = this.dynamicValue;
        clone8.scope = this.scope;
        clone8.type = this.type;
        clone8.factory = this.factory;
        clone8.provider = this.provider;
        clone8.constraint = this.constraint;
        clone8.onActivation = this.onActivation;
        clone8.cache = this.cache;
        return clone8;
      };
      return Binding2;
    }();
  }
});

// node_modules/inversify/es/constants/error_msgs.js
var DUPLICATED_INJECTABLE_DECORATOR, DUPLICATED_METADATA, NULL_ARGUMENT, KEY_NOT_FOUND, AMBIGUOUS_MATCH, CANNOT_UNBIND, NOT_REGISTERED, MISSING_INJECTABLE_ANNOTATION, MISSING_INJECT_ANNOTATION, UNDEFINED_INJECT_ANNOTATION, CIRCULAR_DEPENDENCY, INVALID_BINDING_TYPE, NO_MORE_SNAPSHOTS_AVAILABLE, INVALID_MIDDLEWARE_RETURN, INVALID_FUNCTION_BINDING, INVALID_TO_SELF_VALUE, INVALID_DECORATOR_OPERATION, ARGUMENTS_LENGTH_MISMATCH, CONTAINER_OPTIONS_MUST_BE_AN_OBJECT, CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE, CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE, CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK, POST_CONSTRUCT_ERROR, CIRCULAR_DEPENDENCY_IN_FACTORY, STACK_OVERFLOW;
var init_error_msgs = __esm({
  "node_modules/inversify/es/constants/error_msgs.js"() {
    DUPLICATED_INJECTABLE_DECORATOR = "Cannot apply @injectable decorator multiple times.";
    DUPLICATED_METADATA = "Metadata key was used more than once in a parameter:";
    NULL_ARGUMENT = "NULL argument";
    KEY_NOT_FOUND = "Key Not Found";
    AMBIGUOUS_MATCH = "Ambiguous match found for serviceIdentifier:";
    CANNOT_UNBIND = "Could not unbind serviceIdentifier:";
    NOT_REGISTERED = "No matching bindings found for serviceIdentifier:";
    MISSING_INJECTABLE_ANNOTATION = "Missing required @injectable annotation in:";
    MISSING_INJECT_ANNOTATION = "Missing required @inject or @multiInject annotation in:";
    UNDEFINED_INJECT_ANNOTATION = function(name) {
      return "@inject called with undefined this could mean that the class " + name + " has a circular dependency problem. You can use a LazyServiceIdentifer to  overcome this limitation.";
    };
    CIRCULAR_DEPENDENCY = "Circular dependency found:";
    INVALID_BINDING_TYPE = "Invalid binding type:";
    NO_MORE_SNAPSHOTS_AVAILABLE = "No snapshot available to restore.";
    INVALID_MIDDLEWARE_RETURN = "Invalid return type in middleware. Middleware must return!";
    INVALID_FUNCTION_BINDING = "Value provided to function binding must be a function!";
    INVALID_TO_SELF_VALUE = "The toSelf function can only be applied when a constructor is used as service identifier";
    INVALID_DECORATOR_OPERATION = "The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.";
    ARGUMENTS_LENGTH_MISMATCH = function() {
      var values2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        values2[_i2] = arguments[_i2];
      }
      return "The number of constructor arguments in the derived class " + (values2[0] + " must be >= than the number of constructor arguments of its base class.");
    };
    CONTAINER_OPTIONS_MUST_BE_AN_OBJECT = "Invalid Container constructor argument. Container options must be an object.";
    CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE = "Invalid Container option. Default scope must be a string ('singleton' or 'transient').";
    CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE = "Invalid Container option. Auto bind injectable must be a boolean";
    CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK = "Invalid Container option. Skip base check must be a boolean";
    POST_CONSTRUCT_ERROR = function() {
      var values2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        values2[_i2] = arguments[_i2];
      }
      return "@postConstruct error in class " + values2[0] + ": " + values2[1];
    };
    CIRCULAR_DEPENDENCY_IN_FACTORY = function() {
      var values2 = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        values2[_i2] = arguments[_i2];
      }
      return "It looks like there is a circular dependency " + ("in one of the '" + values2[0] + "' bindings. Please investigate bindings with") + ("service identifier '" + values2[1] + "'.");
    };
    STACK_OVERFLOW = "Maximum call stack size exceeded";
  }
});

// node_modules/inversify/es/planning/metadata_reader.js
var MetadataReader;
var init_metadata_reader = __esm({
  "node_modules/inversify/es/planning/metadata_reader.js"() {
    init_metadata_keys();
    MetadataReader = function() {
      function MetadataReader2() {
      }
      MetadataReader2.prototype.getConstructorMetadata = function(constructorFunc) {
        var compilerGeneratedMetadata = Reflect.getMetadata(PARAM_TYPES, constructorFunc);
        var userGeneratedMetadata = Reflect.getMetadata(TAGGED, constructorFunc);
        return {
          compilerGeneratedMetadata,
          userGeneratedMetadata: userGeneratedMetadata || {}
        };
      };
      MetadataReader2.prototype.getPropertiesMetadata = function(constructorFunc) {
        var userGeneratedMetadata = Reflect.getMetadata(TAGGED_PROP, constructorFunc) || [];
        return userGeneratedMetadata;
      };
      return MetadataReader2;
    }();
  }
});

// node_modules/inversify/es/bindings/binding_count.js
var BindingCount;
var init_binding_count = __esm({
  "node_modules/inversify/es/bindings/binding_count.js"() {
    BindingCount = {
      MultipleBindingsAvailable: 2,
      NoBindingsAvailable: 0,
      OnlyOneBindingAvailable: 1
    };
  }
});

// node_modules/inversify/es/utils/exceptions.js
function isStackOverflowExeption(error) {
  return error instanceof RangeError || error.message === STACK_OVERFLOW;
}
var init_exceptions = __esm({
  "node_modules/inversify/es/utils/exceptions.js"() {
    init_error_msgs();
  }
});

// node_modules/inversify/es/utils/serialization.js
function getServiceIdentifierAsString(serviceIdentifier) {
  if (typeof serviceIdentifier === "function") {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier.name;
  } else if (typeof serviceIdentifier === "symbol") {
    return serviceIdentifier.toString();
  } else {
    var _serviceIdentifier = serviceIdentifier;
    return _serviceIdentifier;
  }
}
function listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifier, getBindings2) {
  var registeredBindingsList = "";
  var registeredBindings = getBindings2(container2, serviceIdentifier);
  if (registeredBindings.length !== 0) {
    registeredBindingsList = "\nRegistered bindings:";
    registeredBindings.forEach(function(binding) {
      var name = "Object";
      if (binding.implementationType !== null) {
        name = getFunctionName(binding.implementationType);
      }
      registeredBindingsList = registeredBindingsList + "\n " + name;
      if (binding.constraint.metaData) {
        registeredBindingsList = registeredBindingsList + " - " + binding.constraint.metaData;
      }
    });
  }
  return registeredBindingsList;
}
function alreadyDependencyChain(request, serviceIdentifier) {
  if (request.parentRequest === null) {
    return false;
  } else if (request.parentRequest.serviceIdentifier === serviceIdentifier) {
    return true;
  } else {
    return alreadyDependencyChain(request.parentRequest, serviceIdentifier);
  }
}
function dependencyChainToString(request) {
  function _createStringArr(req, result) {
    if (result === void 0) {
      result = [];
    }
    var serviceIdentifier = getServiceIdentifierAsString(req.serviceIdentifier);
    result.push(serviceIdentifier);
    if (req.parentRequest !== null) {
      return _createStringArr(req.parentRequest, result);
    }
    return result;
  }
  var stringArr = _createStringArr(request);
  return stringArr.reverse().join(" --> ");
}
function circularDependencyToException(request) {
  request.childRequests.forEach(function(childRequest) {
    if (alreadyDependencyChain(childRequest, childRequest.serviceIdentifier)) {
      var services = dependencyChainToString(childRequest);
      throw new Error(CIRCULAR_DEPENDENCY + " " + services);
    } else {
      circularDependencyToException(childRequest);
    }
  });
}
function listMetadataForTarget(serviceIdentifierString, target) {
  if (target.isTagged() || target.isNamed()) {
    var m_1 = "";
    var namedTag = target.getNamedTag();
    var otherTags = target.getCustomTags();
    if (namedTag !== null) {
      m_1 += namedTag.toString() + "\n";
    }
    if (otherTags !== null) {
      otherTags.forEach(function(tag) {
        m_1 += tag.toString() + "\n";
      });
    }
    return " " + serviceIdentifierString + "\n " + serviceIdentifierString + " - " + m_1;
  } else {
    return " " + serviceIdentifierString;
  }
}
function getFunctionName(v2) {
  if (v2.name) {
    return v2.name;
  } else {
    var name_1 = v2.toString();
    var match = name_1.match(/^function\s*([^\s(]+)/);
    return match ? match[1] : "Anonymous function: " + name_1;
  }
}
var init_serialization = __esm({
  "node_modules/inversify/es/utils/serialization.js"() {
    init_error_msgs();
  }
});

// node_modules/inversify/es/planning/context.js
var Context;
var init_context = __esm({
  "node_modules/inversify/es/planning/context.js"() {
    init_id();
    Context = function() {
      function Context2(container2) {
        this.id = id();
        this.container = container2;
      }
      Context2.prototype.addPlan = function(plan2) {
        this.plan = plan2;
      };
      Context2.prototype.setCurrentRequest = function(currentRequest) {
        this.currentRequest = currentRequest;
      };
      return Context2;
    }();
  }
});

// node_modules/inversify/es/planning/metadata.js
var Metadata;
var init_metadata = __esm({
  "node_modules/inversify/es/planning/metadata.js"() {
    init_metadata_keys();
    Metadata = function() {
      function Metadata2(key, value) {
        this.key = key;
        this.value = value;
      }
      Metadata2.prototype.toString = function() {
        if (this.key === NAMED_TAG) {
          return "named: " + this.value.toString() + " ";
        } else {
          return "tagged: { key:" + this.key.toString() + ", value: " + this.value + " }";
        }
      };
      return Metadata2;
    }();
  }
});

// node_modules/inversify/es/planning/plan.js
var Plan;
var init_plan = __esm({
  "node_modules/inversify/es/planning/plan.js"() {
    Plan = function() {
      function Plan2(parentContext, rootRequest) {
        this.parentContext = parentContext;
        this.rootRequest = rootRequest;
      }
      return Plan2;
    }();
  }
});

// node_modules/inversify/es/annotation/decorator_utils.js
function tagParameter(annotationTarget, propertyName, parameterIndex, metadata) {
  var metadataKey = TAGGED;
  _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex);
}
function tagProperty(annotationTarget, propertyName, metadata) {
  var metadataKey = TAGGED_PROP;
  _tagParameterOrProperty(metadataKey, annotationTarget.constructor, propertyName, metadata);
}
function _tagParameterOrProperty(metadataKey, annotationTarget, propertyName, metadata, parameterIndex) {
  var paramsOrPropertiesMetadata = {};
  var isParameterDecorator = typeof parameterIndex === "number";
  var key = parameterIndex !== void 0 && isParameterDecorator ? parameterIndex.toString() : propertyName;
  if (isParameterDecorator && propertyName !== void 0) {
    throw new Error(INVALID_DECORATOR_OPERATION);
  }
  if (Reflect.hasOwnMetadata(metadataKey, annotationTarget)) {
    paramsOrPropertiesMetadata = Reflect.getMetadata(metadataKey, annotationTarget);
  }
  var paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  if (!Array.isArray(paramOrPropertyMetadata)) {
    paramOrPropertyMetadata = [];
  } else {
    for (var _i2 = 0, paramOrPropertyMetadata_1 = paramOrPropertyMetadata; _i2 < paramOrPropertyMetadata_1.length; _i2++) {
      var m2 = paramOrPropertyMetadata_1[_i2];
      if (m2.key === metadata.key) {
        throw new Error(DUPLICATED_METADATA + " " + m2.key.toString());
      }
    }
  }
  paramOrPropertyMetadata.push(metadata);
  paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata;
  Reflect.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
var init_decorator_utils = __esm({
  "node_modules/inversify/es/annotation/decorator_utils.js"() {
    init_error_msgs();
    init_metadata_keys();
  }
});

// node_modules/inversify/es/annotation/inject.js
function inject(serviceIdentifier) {
  return function(target, targetKey, index) {
    if (serviceIdentifier === void 0) {
      throw new Error(UNDEFINED_INJECT_ANNOTATION(target.name));
    }
    var metadata = new Metadata(INJECT_TAG, serviceIdentifier);
    if (typeof index === "number") {
      tagParameter(target, targetKey, index, metadata);
    } else {
      tagProperty(target, targetKey, metadata);
    }
  };
}
var LazyServiceIdentifer;
var init_inject = __esm({
  "node_modules/inversify/es/annotation/inject.js"() {
    init_error_msgs();
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
    LazyServiceIdentifer = function() {
      function LazyServiceIdentifer2(cb) {
        this._cb = cb;
      }
      LazyServiceIdentifer2.prototype.unwrap = function() {
        return this._cb();
      };
      return LazyServiceIdentifer2;
    }();
  }
});

// node_modules/inversify/es/planning/queryable_string.js
var QueryableString;
var init_queryable_string = __esm({
  "node_modules/inversify/es/planning/queryable_string.js"() {
    QueryableString = function() {
      function QueryableString2(str7) {
        this.str = str7;
      }
      QueryableString2.prototype.startsWith = function(searchString) {
        return this.str.indexOf(searchString) === 0;
      };
      QueryableString2.prototype.endsWith = function(searchString) {
        var reverseString = "";
        var reverseSearchString = searchString.split("").reverse().join("");
        reverseString = this.str.split("").reverse().join("");
        return this.startsWith.call({ str: reverseString }, reverseSearchString);
      };
      QueryableString2.prototype.contains = function(searchString) {
        return this.str.indexOf(searchString) !== -1;
      };
      QueryableString2.prototype.equals = function(compareString) {
        return this.str === compareString;
      };
      QueryableString2.prototype.value = function() {
        return this.str;
      };
      return QueryableString2;
    }();
  }
});

// node_modules/inversify/es/planning/target.js
var Target;
var init_target = __esm({
  "node_modules/inversify/es/planning/target.js"() {
    init_metadata_keys();
    init_id();
    init_metadata();
    init_queryable_string();
    Target = function() {
      function Target3(type, name, serviceIdentifier, namedOrTagged) {
        this.id = id();
        this.type = type;
        this.serviceIdentifier = serviceIdentifier;
        this.name = new QueryableString(name || "");
        this.metadata = new Array();
        var metadataItem = null;
        if (typeof namedOrTagged === "string") {
          metadataItem = new Metadata(NAMED_TAG, namedOrTagged);
        } else if (namedOrTagged instanceof Metadata) {
          metadataItem = namedOrTagged;
        }
        if (metadataItem !== null) {
          this.metadata.push(metadataItem);
        }
      }
      Target3.prototype.hasTag = function(key) {
        for (var _i2 = 0, _a2 = this.metadata; _i2 < _a2.length; _i2++) {
          var m2 = _a2[_i2];
          if (m2.key === key) {
            return true;
          }
        }
        return false;
      };
      Target3.prototype.isArray = function() {
        return this.hasTag(MULTI_INJECT_TAG);
      };
      Target3.prototype.matchesArray = function(name) {
        return this.matchesTag(MULTI_INJECT_TAG)(name);
      };
      Target3.prototype.isNamed = function() {
        return this.hasTag(NAMED_TAG);
      };
      Target3.prototype.isTagged = function() {
        return this.metadata.some(function(metadata) {
          return NON_CUSTOM_TAG_KEYS.every(function(key) {
            return metadata.key !== key;
          });
        });
      };
      Target3.prototype.isOptional = function() {
        return this.matchesTag(OPTIONAL_TAG)(true);
      };
      Target3.prototype.getNamedTag = function() {
        if (this.isNamed()) {
          return this.metadata.filter(function(m2) {
            return m2.key === NAMED_TAG;
          })[0];
        }
        return null;
      };
      Target3.prototype.getCustomTags = function() {
        if (this.isTagged()) {
          return this.metadata.filter(function(metadata) {
            return NON_CUSTOM_TAG_KEYS.every(function(key) {
              return metadata.key !== key;
            });
          });
        } else {
          return null;
        }
      };
      Target3.prototype.matchesNamedTag = function(name) {
        return this.matchesTag(NAMED_TAG)(name);
      };
      Target3.prototype.matchesTag = function(key) {
        var _this = this;
        return function(value) {
          for (var _i2 = 0, _a2 = _this.metadata; _i2 < _a2.length; _i2++) {
            var m2 = _a2[_i2];
            if (m2.key === key && m2.value === value) {
              return true;
            }
          }
          return false;
        };
      };
      return Target3;
    }();
  }
});

// node_modules/inversify/es/planning/reflection_utils.js
function getDependencies(metadataReader, func) {
  var constructorName = getFunctionName(func);
  var targets = getTargets(metadataReader, constructorName, func, false);
  return targets;
}
function getTargets(metadataReader, constructorName, func, isBaseClass) {
  var metadata = metadataReader.getConstructorMetadata(func);
  var serviceIdentifiers = metadata.compilerGeneratedMetadata;
  if (serviceIdentifiers === void 0) {
    var msg = MISSING_INJECTABLE_ANNOTATION + " " + constructorName + ".";
    throw new Error(msg);
  }
  var constructorArgsMetadata = metadata.userGeneratedMetadata;
  var keys2 = Object.keys(constructorArgsMetadata);
  var hasUserDeclaredUnknownInjections = func.length === 0 && keys2.length > 0;
  var hasOptionalParameters = keys2.length > func.length;
  var iterations = hasUserDeclaredUnknownInjections || hasOptionalParameters ? keys2.length : func.length;
  var constructorTargets = getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations);
  var propertyTargets = getClassPropsAsTargets(metadataReader, func);
  var targets = __spreadArray4(__spreadArray4([], constructorTargets), propertyTargets);
  return targets;
}
function getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata) {
  var targetMetadata = constructorArgsMetadata[index.toString()] || [];
  var metadata = formatTargetMetadata(targetMetadata);
  var isManaged = metadata.unmanaged !== true;
  var serviceIdentifier = serviceIdentifiers[index];
  var injectIdentifier = metadata.inject || metadata.multiInject;
  serviceIdentifier = injectIdentifier ? injectIdentifier : serviceIdentifier;
  if (serviceIdentifier instanceof LazyServiceIdentifer) {
    serviceIdentifier = serviceIdentifier.unwrap();
  }
  if (isManaged) {
    var isObject2 = serviceIdentifier === Object;
    var isFunction2 = serviceIdentifier === Function;
    var isUndefined2 = serviceIdentifier === void 0;
    var isUnknownType = isObject2 || isFunction2 || isUndefined2;
    if (!isBaseClass && isUnknownType) {
      var msg = MISSING_INJECT_ANNOTATION + " argument " + index + " in class " + constructorName + ".";
      throw new Error(msg);
    }
    var target = new Target(TargetTypeEnum.ConstructorArgument, metadata.targetName, serviceIdentifier);
    target.metadata = targetMetadata;
    return target;
  }
  return null;
}
function getConstructorArgsAsTargets(isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata, iterations) {
  var targets = [];
  for (var i2 = 0; i2 < iterations; i2++) {
    var index = i2;
    var target = getConstructorArgsAsTarget(index, isBaseClass, constructorName, serviceIdentifiers, constructorArgsMetadata);
    if (target !== null) {
      targets.push(target);
    }
  }
  return targets;
}
function getClassPropsAsTargets(metadataReader, constructorFunc) {
  var classPropsMetadata = metadataReader.getPropertiesMetadata(constructorFunc);
  var targets = [];
  var keys2 = Object.keys(classPropsMetadata);
  for (var _i2 = 0, keys_1 = keys2; _i2 < keys_1.length; _i2++) {
    var key = keys_1[_i2];
    var targetMetadata = classPropsMetadata[key];
    var metadata = formatTargetMetadata(classPropsMetadata[key]);
    var targetName2 = metadata.targetName || key;
    var serviceIdentifier = metadata.inject || metadata.multiInject;
    var target = new Target(TargetTypeEnum.ClassProperty, targetName2, serviceIdentifier);
    target.metadata = targetMetadata;
    targets.push(target);
  }
  var baseConstructor = Object.getPrototypeOf(constructorFunc.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseTargets = getClassPropsAsTargets(metadataReader, baseConstructor);
    targets = __spreadArray4(__spreadArray4([], targets), baseTargets);
  }
  return targets;
}
function getBaseClassDependencyCount(metadataReader, func) {
  var baseConstructor = Object.getPrototypeOf(func.prototype).constructor;
  if (baseConstructor !== Object) {
    var baseConstructorName = getFunctionName(baseConstructor);
    var targets = getTargets(metadataReader, baseConstructorName, baseConstructor, true);
    var metadata = targets.map(function(t4) {
      return t4.metadata.filter(function(m2) {
        return m2.key === UNMANAGED_TAG;
      });
    });
    var unmanagedCount = [].concat.apply([], metadata).length;
    var dependencyCount = targets.length - unmanagedCount;
    if (dependencyCount > 0) {
      return dependencyCount;
    } else {
      return getBaseClassDependencyCount(metadataReader, baseConstructor);
    }
  } else {
    return 0;
  }
}
function formatTargetMetadata(targetMetadata) {
  var targetMetadataMap = {};
  targetMetadata.forEach(function(m2) {
    targetMetadataMap[m2.key.toString()] = m2.value;
  });
  return {
    inject: targetMetadataMap[INJECT_TAG],
    multiInject: targetMetadataMap[MULTI_INJECT_TAG],
    targetName: targetMetadataMap[NAME_TAG],
    unmanaged: targetMetadataMap[UNMANAGED_TAG]
  };
}
var __spreadArray4;
var init_reflection_utils = __esm({
  "node_modules/inversify/es/planning/reflection_utils.js"() {
    init_inject();
    init_error_msgs();
    init_literal_types();
    init_metadata_keys();
    init_serialization();
    init_target();
    __spreadArray4 = function(to2, from) {
      for (var i2 = 0, il = from.length, j2 = to2.length; i2 < il; i2++, j2++)
        to2[j2] = from[i2];
      return to2;
    };
  }
});

// node_modules/inversify/es/planning/request.js
var Request;
var init_request = __esm({
  "node_modules/inversify/es/planning/request.js"() {
    init_id();
    Request = function() {
      function Request2(serviceIdentifier, parentContext, parentRequest, bindings, target) {
        this.id = id();
        this.serviceIdentifier = serviceIdentifier;
        this.parentContext = parentContext;
        this.parentRequest = parentRequest;
        this.target = target;
        this.childRequests = [];
        this.bindings = Array.isArray(bindings) ? bindings : [bindings];
        this.requestScope = parentRequest === null ? /* @__PURE__ */ new Map() : null;
      }
      Request2.prototype.addChildRequest = function(serviceIdentifier, bindings, target) {
        var child = new Request2(serviceIdentifier, this.parentContext, this, bindings, target);
        this.childRequests.push(child);
        return child;
      };
      return Request2;
    }();
  }
});

// node_modules/inversify/es/planning/planner.js
function getBindingDictionary(cntnr) {
  return cntnr._bindingDictionary;
}
function _createTarget(isMultiInject, targetType, serviceIdentifier, name, key, value) {
  var metadataKey = isMultiInject ? MULTI_INJECT_TAG : INJECT_TAG;
  var injectMetadata = new Metadata(metadataKey, serviceIdentifier);
  var target = new Target(targetType, name, serviceIdentifier, injectMetadata);
  if (key !== void 0) {
    var tagMetadata = new Metadata(key, value);
    target.metadata.push(tagMetadata);
  }
  return target;
}
function _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target) {
  var bindings = getBindings(context.container, target.serviceIdentifier);
  var activeBindings = [];
  if (bindings.length === BindingCount.NoBindingsAvailable && context.container.options.autoBindInjectable && typeof target.serviceIdentifier === "function" && metadataReader.getConstructorMetadata(target.serviceIdentifier).compilerGeneratedMetadata) {
    context.container.bind(target.serviceIdentifier).toSelf();
    bindings = getBindings(context.container, target.serviceIdentifier);
  }
  if (!avoidConstraints) {
    activeBindings = bindings.filter(function(binding) {
      var request = new Request(binding.serviceIdentifier, context, parentRequest, binding, target);
      return binding.constraint(request);
    });
  } else {
    activeBindings = bindings;
  }
  _validateActiveBindingCount(target.serviceIdentifier, activeBindings, target, context.container);
  return activeBindings;
}
function _validateActiveBindingCount(serviceIdentifier, bindings, target, container2) {
  switch (bindings.length) {
    case BindingCount.NoBindingsAvailable:
      if (target.isOptional()) {
        return bindings;
      } else {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
        var msg = NOT_REGISTERED;
        msg += listMetadataForTarget(serviceIdentifierString, target);
        msg += listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings);
        throw new Error(msg);
      }
    case BindingCount.OnlyOneBindingAvailable:
      if (!target.isArray()) {
        return bindings;
      }
    case BindingCount.MultipleBindingsAvailable:
    default:
      if (!target.isArray()) {
        var serviceIdentifierString = getServiceIdentifierAsString(serviceIdentifier);
        var msg = AMBIGUOUS_MATCH + " " + serviceIdentifierString;
        msg += listRegisteredBindingsForServiceIdentifier(container2, serviceIdentifierString, getBindings);
        throw new Error(msg);
      } else {
        return bindings;
      }
  }
}
function _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, parentRequest, target) {
  var activeBindings;
  var childRequest;
  if (parentRequest === null) {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, null, target);
    childRequest = new Request(serviceIdentifier, context, null, activeBindings, target);
    var thePlan = new Plan(context, childRequest);
    context.addPlan(thePlan);
  } else {
    activeBindings = _getActiveBindings(metadataReader, avoidConstraints, context, parentRequest, target);
    childRequest = parentRequest.addChildRequest(target.serviceIdentifier, activeBindings, target);
  }
  activeBindings.forEach(function(binding) {
    var subChildRequest = null;
    if (target.isArray()) {
      subChildRequest = childRequest.addChildRequest(binding.serviceIdentifier, binding, target);
    } else {
      if (binding.cache) {
        return;
      }
      subChildRequest = childRequest;
    }
    if (binding.type === BindingTypeEnum.Instance && binding.implementationType !== null) {
      var dependencies = getDependencies(metadataReader, binding.implementationType);
      if (!context.container.options.skipBaseClassChecks) {
        var baseClassDependencyCount = getBaseClassDependencyCount(metadataReader, binding.implementationType);
        if (dependencies.length < baseClassDependencyCount) {
          var error = ARGUMENTS_LENGTH_MISMATCH(getFunctionName(binding.implementationType));
          throw new Error(error);
        }
      }
      dependencies.forEach(function(dependency) {
        _createSubRequests(metadataReader, false, dependency.serviceIdentifier, context, subChildRequest, dependency);
      });
    }
  });
}
function getBindings(container2, serviceIdentifier) {
  var bindings = [];
  var bindingDictionary = getBindingDictionary(container2);
  if (bindingDictionary.hasKey(serviceIdentifier)) {
    bindings = bindingDictionary.get(serviceIdentifier);
  } else if (container2.parent !== null) {
    bindings = getBindings(container2.parent, serviceIdentifier);
  }
  return bindings;
}
function plan(metadataReader, container2, isMultiInject, targetType, serviceIdentifier, key, value, avoidConstraints) {
  if (avoidConstraints === void 0) {
    avoidConstraints = false;
  }
  var context = new Context(container2);
  var target = _createTarget(isMultiInject, targetType, serviceIdentifier, "", key, value);
  try {
    _createSubRequests(metadataReader, avoidConstraints, serviceIdentifier, context, null, target);
    return context;
  } catch (error) {
    if (isStackOverflowExeption(error)) {
      if (context.plan) {
        circularDependencyToException(context.plan.rootRequest);
      }
    }
    throw error;
  }
}
function createMockRequest(container2, serviceIdentifier, key, value) {
  var target = new Target(TargetTypeEnum.Variable, "", serviceIdentifier, new Metadata(key, value));
  var context = new Context(container2);
  var request = new Request(serviceIdentifier, context, null, [], target);
  return request;
}
var init_planner = __esm({
  "node_modules/inversify/es/planning/planner.js"() {
    init_binding_count();
    init_error_msgs();
    init_literal_types();
    init_metadata_keys();
    init_exceptions();
    init_serialization();
    init_context();
    init_metadata();
    init_plan();
    init_reflection_utils();
    init_request();
    init_target();
  }
});

// node_modules/inversify/es/resolution/instantiation.js
function _injectProperties(instance, childRequests, resolveRequest) {
  var propertyInjectionsRequests = childRequests.filter(function(childRequest) {
    return childRequest.target !== null && childRequest.target.type === TargetTypeEnum.ClassProperty;
  });
  var propertyInjections = propertyInjectionsRequests.map(resolveRequest);
  propertyInjectionsRequests.forEach(function(r2, index) {
    var propertyName = "";
    propertyName = r2.target.name.value();
    var injection = propertyInjections[index];
    instance[propertyName] = injection;
  });
  return instance;
}
function _createInstance(Func, injections) {
  return new (Func.bind.apply(Func, __spreadArray5([void 0], injections)))();
}
function _postConstruct(constr, result) {
  if (Reflect.hasMetadata(POST_CONSTRUCT, constr)) {
    var data = Reflect.getMetadata(POST_CONSTRUCT, constr);
    try {
      result[data.value]();
    } catch (e8) {
      throw new Error(POST_CONSTRUCT_ERROR(constr.name, e8.message));
    }
  }
}
function resolveInstance(constr, childRequests, resolveRequest) {
  var result = null;
  if (childRequests.length > 0) {
    var constructorInjectionsRequests = childRequests.filter(function(childRequest) {
      return childRequest.target !== null && childRequest.target.type === TargetTypeEnum.ConstructorArgument;
    });
    var constructorInjections = constructorInjectionsRequests.map(resolveRequest);
    result = _createInstance(constr, constructorInjections);
    result = _injectProperties(result, childRequests, resolveRequest);
  } else {
    result = new constr();
  }
  _postConstruct(constr, result);
  return result;
}
var __spreadArray5;
var init_instantiation = __esm({
  "node_modules/inversify/es/resolution/instantiation.js"() {
    init_error_msgs();
    init_literal_types();
    init_metadata_keys();
    __spreadArray5 = function(to2, from) {
      for (var i2 = 0, il = from.length, j2 = to2.length; i2 < il; i2++, j2++)
        to2[j2] = from[i2];
      return to2;
    };
  }
});

// node_modules/inversify/es/resolution/resolver.js
function resolve(context) {
  var _f = _resolveRequest(context.plan.rootRequest.requestScope);
  return _f(context.plan.rootRequest);
}
var invokeFactory, _resolveRequest;
var init_resolver = __esm({
  "node_modules/inversify/es/resolution/resolver.js"() {
    init_error_msgs();
    init_literal_types();
    init_exceptions();
    init_serialization();
    init_instantiation();
    invokeFactory = function(factoryType, serviceIdentifier, fn2) {
      try {
        return fn2();
      } catch (error) {
        if (isStackOverflowExeption(error)) {
          throw new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(factoryType, serviceIdentifier.toString()));
        } else {
          throw error;
        }
      }
    };
    _resolveRequest = function(requestScope) {
      return function(request) {
        request.parentContext.setCurrentRequest(request);
        var bindings = request.bindings;
        var childRequests = request.childRequests;
        var targetIsAnArray = request.target && request.target.isArray();
        var targetParentIsNotAnArray = !request.parentRequest || !request.parentRequest.target || !request.target || !request.parentRequest.target.matchesArray(request.target.serviceIdentifier);
        if (targetIsAnArray && targetParentIsNotAnArray) {
          return childRequests.map(function(childRequest) {
            var _f = _resolveRequest(requestScope);
            return _f(childRequest);
          });
        } else {
          var result = null;
          if (request.target.isOptional() && bindings.length === 0) {
            return void 0;
          }
          var binding_1 = bindings[0];
          var isSingleton = binding_1.scope === BindingScopeEnum.Singleton;
          var isRequestSingleton = binding_1.scope === BindingScopeEnum.Request;
          if (isSingleton && binding_1.activated) {
            return binding_1.cache;
          }
          if (isRequestSingleton && requestScope !== null && requestScope.has(binding_1.id)) {
            return requestScope.get(binding_1.id);
          }
          if (binding_1.type === BindingTypeEnum.ConstantValue) {
            result = binding_1.cache;
            binding_1.activated = true;
          } else if (binding_1.type === BindingTypeEnum.Function) {
            result = binding_1.cache;
            binding_1.activated = true;
          } else if (binding_1.type === BindingTypeEnum.Constructor) {
            result = binding_1.implementationType;
          } else if (binding_1.type === BindingTypeEnum.DynamicValue && binding_1.dynamicValue !== null) {
            result = invokeFactory("toDynamicValue", binding_1.serviceIdentifier, function() {
              return binding_1.dynamicValue(request.parentContext);
            });
          } else if (binding_1.type === BindingTypeEnum.Factory && binding_1.factory !== null) {
            result = invokeFactory("toFactory", binding_1.serviceIdentifier, function() {
              return binding_1.factory(request.parentContext);
            });
          } else if (binding_1.type === BindingTypeEnum.Provider && binding_1.provider !== null) {
            result = invokeFactory("toProvider", binding_1.serviceIdentifier, function() {
              return binding_1.provider(request.parentContext);
            });
          } else if (binding_1.type === BindingTypeEnum.Instance && binding_1.implementationType !== null) {
            result = resolveInstance(binding_1.implementationType, childRequests, _resolveRequest(requestScope));
          } else {
            var serviceIdentifier = getServiceIdentifierAsString(request.serviceIdentifier);
            throw new Error(INVALID_BINDING_TYPE + " " + serviceIdentifier);
          }
          if (typeof binding_1.onActivation === "function") {
            result = binding_1.onActivation(request.parentContext, result);
          }
          if (isSingleton) {
            binding_1.cache = result;
            binding_1.activated = true;
          }
          if (isRequestSingleton && requestScope !== null && !requestScope.has(binding_1.id)) {
            requestScope.set(binding_1.id, result);
          }
          return result;
        }
      };
    };
  }
});

// node_modules/inversify/es/syntax/constraint_helpers.js
var traverseAncerstors, taggedConstraint, namedConstraint, typeConstraint;
var init_constraint_helpers = __esm({
  "node_modules/inversify/es/syntax/constraint_helpers.js"() {
    init_metadata_keys();
    init_metadata();
    traverseAncerstors = function(request, constraint) {
      var parent = request.parentRequest;
      if (parent !== null) {
        return constraint(parent) ? true : traverseAncerstors(parent, constraint);
      } else {
        return false;
      }
    };
    taggedConstraint = function(key) {
      return function(value) {
        var constraint = function(request) {
          return request !== null && request.target !== null && request.target.matchesTag(key)(value);
        };
        constraint.metaData = new Metadata(key, value);
        return constraint;
      };
    };
    namedConstraint = taggedConstraint(NAMED_TAG);
    typeConstraint = function(type) {
      return function(request) {
        var binding = null;
        if (request !== null) {
          binding = request.bindings[0];
          if (typeof type === "string") {
            var serviceIdentifier = binding.serviceIdentifier;
            return serviceIdentifier === type;
          } else {
            var constructor = request.bindings[0].implementationType;
            return type === constructor;
          }
        }
        return false;
      };
    };
  }
});

// node_modules/inversify/es/syntax/binding_when_syntax.js
var BindingWhenSyntax;
var init_binding_when_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_when_syntax.js"() {
    init_binding_on_syntax();
    init_constraint_helpers();
    BindingWhenSyntax = function() {
      function BindingWhenSyntax2(binding) {
        this._binding = binding;
      }
      BindingWhenSyntax2.prototype.when = function(constraint) {
        this._binding.constraint = constraint;
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetNamed = function(name) {
        this._binding.constraint = namedConstraint(name);
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetIsDefault = function() {
        this._binding.constraint = function(request) {
          var targetIsDefault = request.target !== null && !request.target.isNamed() && !request.target.isTagged();
          return targetIsDefault;
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenTargetTagged = function(tag, value) {
        this._binding.constraint = taggedConstraint(tag)(value);
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenInjectedInto = function(parent) {
        this._binding.constraint = function(request) {
          return typeConstraint(parent)(request.parentRequest);
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentNamed = function(name) {
        this._binding.constraint = function(request) {
          return namedConstraint(name)(request.parentRequest);
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenParentTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return taggedConstraint(tag)(value)(request.parentRequest);
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return traverseAncerstors(request, typeConstraint(ancestor));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        this._binding.constraint = function(request) {
          return !traverseAncerstors(request, typeConstraint(ancestor));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return traverseAncerstors(request, namedConstraint(name));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorNamed = function(name) {
        this._binding.constraint = function(request) {
          return !traverseAncerstors(request, namedConstraint(name));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return traverseAncerstors(request, taggedConstraint(tag)(value));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        this._binding.constraint = function(request) {
          return !traverseAncerstors(request, taggedConstraint(tag)(value));
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return traverseAncerstors(request, constraint);
        };
        return new BindingOnSyntax(this._binding);
      };
      BindingWhenSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        this._binding.constraint = function(request) {
          return !traverseAncerstors(request, constraint);
        };
        return new BindingOnSyntax(this._binding);
      };
      return BindingWhenSyntax2;
    }();
  }
});

// node_modules/inversify/es/syntax/binding_on_syntax.js
var BindingOnSyntax;
var init_binding_on_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_on_syntax.js"() {
    init_binding_when_syntax();
    BindingOnSyntax = function() {
      function BindingOnSyntax2(binding) {
        this._binding = binding;
      }
      BindingOnSyntax2.prototype.onActivation = function(handler) {
        this._binding.onActivation = handler;
        return new BindingWhenSyntax(this._binding);
      };
      return BindingOnSyntax2;
    }();
  }
});

// node_modules/inversify/es/syntax/binding_when_on_syntax.js
var BindingWhenOnSyntax;
var init_binding_when_on_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_when_on_syntax.js"() {
    init_binding_on_syntax();
    init_binding_when_syntax();
    BindingWhenOnSyntax = function() {
      function BindingWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new BindingOnSyntax(this._binding);
      }
      BindingWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingWhenOnSyntax2;
    }();
  }
});

// node_modules/inversify/es/syntax/binding_in_syntax.js
var BindingInSyntax;
var init_binding_in_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_in_syntax.js"() {
    init_literal_types();
    init_binding_when_on_syntax();
    BindingInSyntax = function() {
      function BindingInSyntax2(binding) {
        this._binding = binding;
      }
      BindingInSyntax2.prototype.inRequestScope = function() {
        this._binding.scope = BindingScopeEnum.Request;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inSingletonScope = function() {
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingInSyntax2.prototype.inTransientScope = function() {
        this._binding.scope = BindingScopeEnum.Transient;
        return new BindingWhenOnSyntax(this._binding);
      };
      return BindingInSyntax2;
    }();
  }
});

// node_modules/inversify/es/syntax/binding_in_when_on_syntax.js
var BindingInWhenOnSyntax;
var init_binding_in_when_on_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_in_when_on_syntax.js"() {
    init_binding_in_syntax();
    init_binding_on_syntax();
    init_binding_when_syntax();
    BindingInWhenOnSyntax = function() {
      function BindingInWhenOnSyntax2(binding) {
        this._binding = binding;
        this._bindingWhenSyntax = new BindingWhenSyntax(this._binding);
        this._bindingOnSyntax = new BindingOnSyntax(this._binding);
        this._bindingInSyntax = new BindingInSyntax(binding);
      }
      BindingInWhenOnSyntax2.prototype.inRequestScope = function() {
        return this._bindingInSyntax.inRequestScope();
      };
      BindingInWhenOnSyntax2.prototype.inSingletonScope = function() {
        return this._bindingInSyntax.inSingletonScope();
      };
      BindingInWhenOnSyntax2.prototype.inTransientScope = function() {
        return this._bindingInSyntax.inTransientScope();
      };
      BindingInWhenOnSyntax2.prototype.when = function(constraint) {
        return this._bindingWhenSyntax.when(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetNamed = function(name) {
        return this._bindingWhenSyntax.whenTargetNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenTargetIsDefault = function() {
        return this._bindingWhenSyntax.whenTargetIsDefault();
      };
      BindingInWhenOnSyntax2.prototype.whenTargetTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenTargetTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenInjectedInto = function(parent) {
        return this._bindingWhenSyntax.whenInjectedInto(parent);
      };
      BindingInWhenOnSyntax2.prototype.whenParentNamed = function(name) {
        return this._bindingWhenSyntax.whenParentNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenParentTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenParentTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenAnyAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorIs = function(ancestor) {
        return this._bindingWhenSyntax.whenNoAncestorIs(ancestor);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenAnyAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenAnyAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorNamed = function(name) {
        return this._bindingWhenSyntax.whenNoAncestorNamed(name);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorTagged = function(tag, value) {
        return this._bindingWhenSyntax.whenNoAncestorTagged(tag, value);
      };
      BindingInWhenOnSyntax2.prototype.whenAnyAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenAnyAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.whenNoAncestorMatches = function(constraint) {
        return this._bindingWhenSyntax.whenNoAncestorMatches(constraint);
      };
      BindingInWhenOnSyntax2.prototype.onActivation = function(handler) {
        return this._bindingOnSyntax.onActivation(handler);
      };
      return BindingInWhenOnSyntax2;
    }();
  }
});

// node_modules/inversify/es/syntax/binding_to_syntax.js
var BindingToSyntax;
var init_binding_to_syntax = __esm({
  "node_modules/inversify/es/syntax/binding_to_syntax.js"() {
    init_error_msgs();
    init_literal_types();
    init_binding_in_when_on_syntax();
    init_binding_when_on_syntax();
    BindingToSyntax = function() {
      function BindingToSyntax2(binding) {
        this._binding = binding;
      }
      BindingToSyntax2.prototype.to = function(constructor) {
        this._binding.type = BindingTypeEnum.Instance;
        this._binding.implementationType = constructor;
        return new BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toSelf = function() {
        if (typeof this._binding.serviceIdentifier !== "function") {
          throw new Error("" + INVALID_TO_SELF_VALUE);
        }
        var self2 = this._binding.serviceIdentifier;
        return this.to(self2);
      };
      BindingToSyntax2.prototype.toConstantValue = function(value) {
        this._binding.type = BindingTypeEnum.ConstantValue;
        this._binding.cache = value;
        this._binding.dynamicValue = null;
        this._binding.implementationType = null;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toDynamicValue = function(func) {
        this._binding.type = BindingTypeEnum.DynamicValue;
        this._binding.cache = null;
        this._binding.dynamicValue = func;
        this._binding.implementationType = null;
        return new BindingInWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toConstructor = function(constructor) {
        this._binding.type = BindingTypeEnum.Constructor;
        this._binding.implementationType = constructor;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFactory = function(factory) {
        this._binding.type = BindingTypeEnum.Factory;
        this._binding.factory = factory;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toFunction = function(func) {
        if (typeof func !== "function") {
          throw new Error(INVALID_FUNCTION_BINDING);
        }
        var bindingWhenOnSyntax = this.toConstantValue(func);
        this._binding.type = BindingTypeEnum.Function;
        this._binding.scope = BindingScopeEnum.Singleton;
        return bindingWhenOnSyntax;
      };
      BindingToSyntax2.prototype.toAutoFactory = function(serviceIdentifier) {
        this._binding.type = BindingTypeEnum.Factory;
        this._binding.factory = function(context) {
          var autofactory = function() {
            return context.container.get(serviceIdentifier);
          };
          return autofactory;
        };
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toProvider = function(provider) {
        this._binding.type = BindingTypeEnum.Provider;
        this._binding.provider = provider;
        this._binding.scope = BindingScopeEnum.Singleton;
        return new BindingWhenOnSyntax(this._binding);
      };
      BindingToSyntax2.prototype.toService = function(service) {
        this.toDynamicValue(function(context) {
          return context.container.get(service);
        });
      };
      return BindingToSyntax2;
    }();
  }
});

// node_modules/inversify/es/container/container_snapshot.js
var ContainerSnapshot;
var init_container_snapshot = __esm({
  "node_modules/inversify/es/container/container_snapshot.js"() {
    ContainerSnapshot = function() {
      function ContainerSnapshot2() {
      }
      ContainerSnapshot2.of = function(bindings, middleware) {
        var snapshot = new ContainerSnapshot2();
        snapshot.bindings = bindings;
        snapshot.middleware = middleware;
        return snapshot;
      };
      return ContainerSnapshot2;
    }();
  }
});

// node_modules/inversify/es/container/lookup.js
var Lookup;
var init_lookup = __esm({
  "node_modules/inversify/es/container/lookup.js"() {
    init_error_msgs();
    Lookup = function() {
      function Lookup2() {
        this._map = /* @__PURE__ */ new Map();
      }
      Lookup2.prototype.getMap = function() {
        return this._map;
      };
      Lookup2.prototype.add = function(serviceIdentifier, value) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(NULL_ARGUMENT);
        }
        if (value === null || value === void 0) {
          throw new Error(NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          entry.push(value);
          this._map.set(serviceIdentifier, entry);
        } else {
          this._map.set(serviceIdentifier, [value]);
        }
      };
      Lookup2.prototype.get = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(NULL_ARGUMENT);
        }
        var entry = this._map.get(serviceIdentifier);
        if (entry !== void 0) {
          return entry;
        } else {
          throw new Error(KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.remove = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(NULL_ARGUMENT);
        }
        if (!this._map.delete(serviceIdentifier)) {
          throw new Error(KEY_NOT_FOUND);
        }
      };
      Lookup2.prototype.removeByCondition = function(condition) {
        var _this = this;
        this._map.forEach(function(entries, key) {
          var updatedEntries = entries.filter(function(entry) {
            return !condition(entry);
          });
          if (updatedEntries.length > 0) {
            _this._map.set(key, updatedEntries);
          } else {
            _this._map.delete(key);
          }
        });
      };
      Lookup2.prototype.hasKey = function(serviceIdentifier) {
        if (serviceIdentifier === null || serviceIdentifier === void 0) {
          throw new Error(NULL_ARGUMENT);
        }
        return this._map.has(serviceIdentifier);
      };
      Lookup2.prototype.clone = function() {
        var copy8 = new Lookup2();
        this._map.forEach(function(value, key) {
          value.forEach(function(b10) {
            return copy8.add(key, b10.clone());
          });
        });
        return copy8;
      };
      Lookup2.prototype.traverse = function(func) {
        this._map.forEach(function(value, key) {
          func(key, value);
        });
      };
      return Lookup2;
    }();
  }
});

// node_modules/inversify/es/container/container.js
var __awaiter2, __generator2, __spreadArray6, Container2;
var init_container = __esm({
  "node_modules/inversify/es/container/container.js"() {
    init_binding();
    init_error_msgs();
    init_literal_types();
    init_metadata_keys();
    init_metadata_reader();
    init_planner();
    init_resolver();
    init_binding_to_syntax();
    init_id();
    init_serialization();
    init_container_snapshot();
    init_lookup();
    __awaiter2 = function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: [] }, f2, y2, t4, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t4 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op[1])).done)
              return t4;
            if (y2 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t4[1]) {
                  _2.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _2.label < t4[2]) {
                  _2.label = t4[2];
                  _2.ops.push(op);
                  break;
                }
                if (t4[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e8) {
            op = [6, e8];
            y2 = 0;
          } finally {
            f2 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __spreadArray6 = function(to2, from) {
      for (var i2 = 0, il = from.length, j2 = to2.length; i2 < il; i2++, j2++)
        to2[j2] = from[i2];
      return to2;
    };
    Container2 = function() {
      function Container3(containerOptions) {
        this._appliedMiddleware = [];
        var options = containerOptions || {};
        if (typeof options !== "object") {
          throw new Error("" + CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);
        }
        if (options.defaultScope === void 0) {
          options.defaultScope = BindingScopeEnum.Transient;
        } else if (options.defaultScope !== BindingScopeEnum.Singleton && options.defaultScope !== BindingScopeEnum.Transient && options.defaultScope !== BindingScopeEnum.Request) {
          throw new Error("" + CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);
        }
        if (options.autoBindInjectable === void 0) {
          options.autoBindInjectable = false;
        } else if (typeof options.autoBindInjectable !== "boolean") {
          throw new Error("" + CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);
        }
        if (options.skipBaseClassChecks === void 0) {
          options.skipBaseClassChecks = false;
        } else if (typeof options.skipBaseClassChecks !== "boolean") {
          throw new Error("" + CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);
        }
        this.options = {
          autoBindInjectable: options.autoBindInjectable,
          defaultScope: options.defaultScope,
          skipBaseClassChecks: options.skipBaseClassChecks
        };
        this.id = id();
        this._bindingDictionary = new Lookup();
        this._snapshots = [];
        this._middleware = null;
        this.parent = null;
        this._metadataReader = new MetadataReader();
      }
      Container3.merge = function(container1, container2) {
        var container3 = [];
        for (var _i2 = 2; _i2 < arguments.length; _i2++) {
          container3[_i2 - 2] = arguments[_i2];
        }
        var container4 = new Container3();
        var targetContainers = __spreadArray6([container1, container2], container3).map(function(targetContainer) {
          return getBindingDictionary(targetContainer);
        });
        var bindingDictionary = getBindingDictionary(container4);
        function copyDictionary(origin, destination) {
          origin.traverse(function(key, value) {
            value.forEach(function(binding) {
              destination.add(binding.serviceIdentifier, binding.clone());
            });
          });
        }
        targetContainers.forEach(function(targetBindingDictionary) {
          copyDictionary(targetBindingDictionary, bindingDictionary);
        });
        return container4;
      };
      Container3.prototype.load = function() {
        var modules = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          modules[_i2] = arguments[_i2];
        }
        var getHelpers = this._getContainerModuleHelpersFactory();
        for (var _a2 = 0, modules_1 = modules; _a2 < modules_1.length; _a2++) {
          var currentModule = modules_1[_a2];
          var containerModuleHelpers = getHelpers(currentModule.id);
          currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
        }
      };
      Container3.prototype.loadAsync = function() {
        var modules = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          modules[_i2] = arguments[_i2];
        }
        return __awaiter2(this, void 0, void 0, function() {
          var getHelpers, _a2, modules_2, currentModule, containerModuleHelpers;
          return __generator2(this, function(_b) {
            switch (_b.label) {
              case 0:
                getHelpers = this._getContainerModuleHelpersFactory();
                _a2 = 0, modules_2 = modules;
                _b.label = 1;
              case 1:
                if (!(_a2 < modules_2.length))
                  return [3, 4];
                currentModule = modules_2[_a2];
                containerModuleHelpers = getHelpers(currentModule.id);
                return [4, currentModule.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction)];
              case 2:
                _b.sent();
                _b.label = 3;
              case 3:
                _a2++;
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      Container3.prototype.unload = function() {
        var _this = this;
        var modules = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          modules[_i2] = arguments[_i2];
        }
        var conditionFactory = function(expected) {
          return function(item) {
            return item.moduleId === expected;
          };
        };
        modules.forEach(function(module) {
          var condition = conditionFactory(module.id);
          _this._bindingDictionary.removeByCondition(condition);
        });
      };
      Container3.prototype.bind = function(serviceIdentifier) {
        var scope = this.options.defaultScope || BindingScopeEnum.Transient;
        var binding = new Binding(serviceIdentifier, scope);
        this._bindingDictionary.add(serviceIdentifier, binding);
        return new BindingToSyntax(binding);
      };
      Container3.prototype.rebind = function(serviceIdentifier) {
        this.unbind(serviceIdentifier);
        return this.bind(serviceIdentifier);
      };
      Container3.prototype.unbind = function(serviceIdentifier) {
        try {
          this._bindingDictionary.remove(serviceIdentifier);
        } catch (e8) {
          throw new Error(CANNOT_UNBIND + " " + getServiceIdentifierAsString(serviceIdentifier));
        }
      };
      Container3.prototype.unbindAll = function() {
        this._bindingDictionary = new Lookup();
      };
      Container3.prototype.isBound = function(serviceIdentifier) {
        var bound = this._bindingDictionary.hasKey(serviceIdentifier);
        if (!bound && this.parent) {
          bound = this.parent.isBound(serviceIdentifier);
        }
        return bound;
      };
      Container3.prototype.isBoundNamed = function(serviceIdentifier, named3) {
        return this.isBoundTagged(serviceIdentifier, NAMED_TAG, named3);
      };
      Container3.prototype.isBoundTagged = function(serviceIdentifier, key, value) {
        var bound = false;
        if (this._bindingDictionary.hasKey(serviceIdentifier)) {
          var bindings = this._bindingDictionary.get(serviceIdentifier);
          var request_1 = createMockRequest(this, serviceIdentifier, key, value);
          bound = bindings.some(function(b10) {
            return b10.constraint(request_1);
          });
        }
        if (!bound && this.parent) {
          bound = this.parent.isBoundTagged(serviceIdentifier, key, value);
        }
        return bound;
      };
      Container3.prototype.snapshot = function() {
        this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(), this._middleware));
      };
      Container3.prototype.restore = function() {
        var snapshot = this._snapshots.pop();
        if (snapshot === void 0) {
          throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);
        }
        this._bindingDictionary = snapshot.bindings;
        this._middleware = snapshot.middleware;
      };
      Container3.prototype.createChild = function(containerOptions) {
        var child = new Container3(containerOptions || this.options);
        child.parent = this;
        return child;
      };
      Container3.prototype.applyMiddleware = function() {
        var middlewares = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          middlewares[_i2] = arguments[_i2];
        }
        this._appliedMiddleware = this._appliedMiddleware.concat(middlewares);
        var initial = this._middleware ? this._middleware : this._planAndResolve();
        this._middleware = middlewares.reduce(function(prev, curr) {
          return curr(prev);
        }, initial);
      };
      Container3.prototype.applyCustomMetadataReader = function(metadataReader) {
        this._metadataReader = metadataReader;
      };
      Container3.prototype.get = function(serviceIdentifier) {
        return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container3.prototype.getTagged = function(serviceIdentifier, key, value) {
        return this._get(false, false, TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container3.prototype.getNamed = function(serviceIdentifier, named3) {
        return this.getTagged(serviceIdentifier, NAMED_TAG, named3);
      };
      Container3.prototype.getAll = function(serviceIdentifier) {
        return this._get(true, true, TargetTypeEnum.Variable, serviceIdentifier);
      };
      Container3.prototype.getAllTagged = function(serviceIdentifier, key, value) {
        return this._get(false, true, TargetTypeEnum.Variable, serviceIdentifier, key, value);
      };
      Container3.prototype.getAllNamed = function(serviceIdentifier, named3) {
        return this.getAllTagged(serviceIdentifier, NAMED_TAG, named3);
      };
      Container3.prototype.resolve = function(constructorFunction) {
        var tempContainer = this.createChild();
        tempContainer.bind(constructorFunction).toSelf();
        this._appliedMiddleware.forEach(function(m2) {
          tempContainer.applyMiddleware(m2);
        });
        return tempContainer.get(constructorFunction);
      };
      Container3.prototype._getContainerModuleHelpersFactory = function() {
        var _this = this;
        var setModuleId = function(bindingToSyntax, moduleId) {
          bindingToSyntax._binding.moduleId = moduleId;
        };
        var getBindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _bind = _this.bind.bind(_this);
            var bindingToSyntax = _bind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        var getUnbindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _unbind = _this.unbind.bind(_this);
            _unbind(serviceIdentifier);
          };
        };
        var getIsboundFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _isBound = _this.isBound.bind(_this);
            return _isBound(serviceIdentifier);
          };
        };
        var getRebindFunction = function(moduleId) {
          return function(serviceIdentifier) {
            var _rebind = _this.rebind.bind(_this);
            var bindingToSyntax = _rebind(serviceIdentifier);
            setModuleId(bindingToSyntax, moduleId);
            return bindingToSyntax;
          };
        };
        return function(mId) {
          return {
            bindFunction: getBindFunction(mId),
            isboundFunction: getIsboundFunction(mId),
            rebindFunction: getRebindFunction(mId),
            unbindFunction: getUnbindFunction(mId)
          };
        };
      };
      Container3.prototype._get = function(avoidConstraints, isMultiInject, targetType, serviceIdentifier, key, value) {
        var result = null;
        var defaultArgs = {
          avoidConstraints,
          contextInterceptor: function(context) {
            return context;
          },
          isMultiInject,
          key,
          serviceIdentifier,
          targetType,
          value
        };
        if (this._middleware) {
          result = this._middleware(defaultArgs);
          if (result === void 0 || result === null) {
            throw new Error(INVALID_MIDDLEWARE_RETURN);
          }
        } else {
          result = this._planAndResolve()(defaultArgs);
        }
        return result;
      };
      Container3.prototype._planAndResolve = function() {
        var _this = this;
        return function(args) {
          var context = plan(_this._metadataReader, _this, args.isMultiInject, args.targetType, args.serviceIdentifier, args.key, args.value, args.avoidConstraints);
          context = args.contextInterceptor(context);
          var result = resolve(context);
          return result;
        };
      };
      return Container3;
    }();
  }
});

// node_modules/inversify/es/container/container_module.js
var ContainerModule, AsyncContainerModule;
var init_container_module = __esm({
  "node_modules/inversify/es/container/container_module.js"() {
    init_id();
    ContainerModule = function() {
      function ContainerModule2(registry) {
        this.id = id();
        this.registry = registry;
      }
      return ContainerModule2;
    }();
    AsyncContainerModule = function() {
      function AsyncContainerModule2(registry) {
        this.id = id();
        this.registry = registry;
      }
      return AsyncContainerModule2;
    }();
  }
});

// node_modules/inversify/es/annotation/injectable.js
function injectable() {
  return function(target) {
    if (Reflect.hasOwnMetadata(PARAM_TYPES, target)) {
      throw new Error(DUPLICATED_INJECTABLE_DECORATOR);
    }
    var types = Reflect.getMetadata(DESIGN_PARAM_TYPES, target) || [];
    Reflect.defineMetadata(PARAM_TYPES, types, target);
    return target;
  };
}
var init_injectable = __esm({
  "node_modules/inversify/es/annotation/injectable.js"() {
    init_error_msgs();
    init_metadata_keys();
  }
});

// node_modules/inversify/es/annotation/tagged.js
var init_tagged = __esm({
  "node_modules/inversify/es/annotation/tagged.js"() {
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/named.js
function named2(name) {
  return function(target, targetKey, index) {
    var metadata = new Metadata(NAMED_TAG, name);
    if (typeof index === "number") {
      tagParameter(target, targetKey, index, metadata);
    } else {
      tagProperty(target, targetKey, metadata);
    }
  };
}
var init_named = __esm({
  "node_modules/inversify/es/annotation/named.js"() {
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/optional.js
var init_optional = __esm({
  "node_modules/inversify/es/annotation/optional.js"() {
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/unmanaged.js
var init_unmanaged = __esm({
  "node_modules/inversify/es/annotation/unmanaged.js"() {
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/multi_inject.js
var init_multi_inject = __esm({
  "node_modules/inversify/es/annotation/multi_inject.js"() {
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/target_name.js
var init_target_name = __esm({
  "node_modules/inversify/es/annotation/target_name.js"() {
    init_metadata_keys();
    init_metadata();
    init_decorator_utils();
  }
});

// node_modules/inversify/es/annotation/post_construct.js
var init_post_construct = __esm({
  "node_modules/inversify/es/annotation/post_construct.js"() {
    init_error_msgs();
    init_metadata_keys();
    init_metadata();
  }
});

// node_modules/inversify/es/utils/binding_utils.js
var init_binding_utils = __esm({
  "node_modules/inversify/es/utils/binding_utils.js"() {
  }
});

// node_modules/inversify/es/inversify.js
var init_inversify = __esm({
  "node_modules/inversify/es/inversify.js"() {
    init_metadata_keys();
    init_container();
    init_literal_types();
    init_container_module();
    init_injectable();
    init_tagged();
    init_named();
    init_inject();
    init_optional();
    init_unmanaged();
    init_multi_inject();
    init_target_name();
    init_post_construct();
    init_metadata_reader();
    init_id();
    init_decorator_utils();
    init_constraint_helpers();
    init_serialization();
    init_binding_utils();
  }
});

// node_modules/@antv/g-webgpu-core/es/identifier.js
var IDENTIFIER;
var init_identifier = __esm({
  "node_modules/@antv/g-webgpu-core/es/identifier.js"() {
    IDENTIFIER = {
      HierarchyComponentManager: Symbol("HierarchyComponentManager"),
      TransformComponentManager: Symbol("TransformComponentManager"),
      NameComponentManager: Symbol("NameComponentManager"),
      SceneGraphSystem: Symbol("SceneGraphSystem"),
      FrameGraphSystem: Symbol("FrameGraphSystem"),
      ResourcePool: Symbol("ResourcePool"),
      ResourceHandleComponentManager: Symbol("ResourceHandleComponentManager"),
      PassNodeComponentManager: Symbol("PassNodeComponentManager"),
      RendererSystem: Symbol("RendererSystem"),
      RenderPass: Symbol("RenderPass"),
      RenderPassFactory: Symbol("Factory<IRenderPass>"),
      Renderable: Symbol("Factory<IRenderPass>"),
      MeshSystem: Symbol("MeshSystem"),
      MeshComponentManager: Symbol("MeshComponentManager"),
      CullableComponentManager: Symbol("CullableComponentManager"),
      Geometry: Symbol("Geometry"),
      GeometrySystem: Symbol("GeometrySystem"),
      GeometryComponentManager: Symbol("GeometryComponentManager"),
      Material: Symbol("Material"),
      MaterialSystem: Symbol("MaterialSystem"),
      MaterialComponentManager: Symbol("MaterialComponentManager"),
      ForwardRenderPath: Symbol("ForwardRenderPath"),
      ComputeSystem: Symbol("ComputeSystem"),
      ComputeComponentManager: Symbol("ComputeComponentManager"),
      ComputeStrategy: Symbol("ComputeStrategy"),
      Systems: Symbol("Systems"),
      World: Symbol("World"),
      RenderEngine: Symbol("RenderEngine"),
      WebGPUEngine: Symbol("WebGPUEngine"),
      WebGLEngine: Symbol("WebGLEngine"),
      ShaderModuleService: Symbol("ShaderModuleService"),
      ConfigService: Symbol("ConfigService"),
      InteractorService: Symbol("InteractorService"),
      IEventEmitter: Symbol("IEventEmitter"),
      Light: Symbol("Light")
    };
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/FrameGraphHandle.js
var FrameGraphHandle;
var init_FrameGraphHandle = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/FrameGraphHandle.js"() {
    init_classCallCheck();
    FrameGraphHandle = function FrameGraphHandle2() {
      _classCallCheck(this, FrameGraphHandle2);
      this.index = void 0;
    };
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/FrameGraphPass.js
var FrameGraphPass;
var init_FrameGraphPass = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/FrameGraphPass.js"() {
    init_classCallCheck();
    FrameGraphPass = function FrameGraphPass2() {
      _classCallCheck(this, FrameGraphPass2);
      this.name = void 0;
      this.data = void 0;
      this.execute = void 0;
      this.tearDown = void 0;
    };
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/PassNode.js
var PassNode;
var init_PassNode = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/PassNode.js"() {
    init_classCallCheck();
    init_createClass();
    PassNode = function() {
      function PassNode2() {
        _classCallCheck(this, PassNode2);
        this.name = void 0;
        this.refCount = 0;
        this.hasSideEffect = false;
        this.devirtualize = [];
        this.destroy = [];
        this.reads = [];
        this.writes = [];
      }
      _createClass(PassNode2, [{
        key: "read",
        value: function read3(handle) {
          if (!this.reads.find(function(h2) {
            return h2.index === handle.index;
          })) {
            this.reads.push(handle);
          }
          return handle;
        }
      }, {
        key: "sample",
        value: function sample(handle) {
          this.read(handle);
          return handle;
        }
      }, {
        key: "write",
        value: function write3(fg, handle) {
          var existed = this.writes.find(function(h2) {
            return h2.index === handle.index;
          });
          if (existed) {
            return handle;
          }
          var node = fg.getResourceNode(handle);
          node.resource.version++;
          if (node.resource.imported) {
            this.hasSideEffect = true;
          }
          var r2 = fg.createResourceNode(node.resource);
          var newNode = fg.getResourceNode(r2);
          newNode.writer = this;
          this.writes.push(r2);
          return r2;
        }
      }]);
      return PassNode2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf2(o2, p2) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf2(o2, p2);
}
var init_setPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf2(o2) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf2(o2);
}
var init_getPrototypeOf = __esm({
  "node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/VirtualResource.js
var VirtualResource;
var init_VirtualResource = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/VirtualResource.js"() {
    init_classCallCheck();
    VirtualResource = function VirtualResource2() {
      _classCallCheck(this, VirtualResource2);
      this.first = void 0;
      this.last = void 0;
    };
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourceEntry.js
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var ResourceEntry;
var init_ResourceEntry = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourceEntry.js"() {
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_VirtualResource();
    ResourceEntry = function(_VirtualResource) {
      _inherits2(ResourceEntry2, _VirtualResource);
      var _super = _createSuper2(ResourceEntry2);
      function ResourceEntry2() {
        var _this;
        _classCallCheck(this, ResourceEntry2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _this.version = 0;
        _this.refs = 0;
        _this.name = void 0;
        _this.imported = void 0;
        _this.priority = void 0;
        _this.discardStart = true;
        _this.discardEnd = false;
        _this.descriptor = void 0;
        _this.resource = void 0;
        return _this;
      }
      _createClass(ResourceEntry2, [{
        key: "preExecuteDestroy",
        value: function preExecuteDestroy() {
          this.discardEnd = true;
        }
      }, {
        key: "postExecuteDestroy",
        value: function postExecuteDestroy() {
          if (!this.imported) {
          }
        }
      }, {
        key: "postExecuteDevirtualize",
        value: function postExecuteDevirtualize() {
          this.discardStart = false;
        }
      }, {
        key: "preExecuteDevirtualize",
        value: function preExecuteDevirtualize() {
          if (!this.imported) {
          }
        }
      }]);
      return ResourceEntry2;
    }(VirtualResource);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourceNode.js
var ResourceNode;
var init_ResourceNode = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourceNode.js"() {
    init_classCallCheck();
    ResourceNode = function ResourceNode2() {
      _classCallCheck(this, ResourceNode2);
      this.resource = void 0;
      this.writer = void 0;
      this.readerCount = 0;
      this.version = void 0;
    };
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/System.js
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray2(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e8(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e8(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray2(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray2(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray2(o2, minLen);
}
function _arrayLikeToArray2(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var import_regenerator2, _dec, _dec2, _class, _class2, _descriptor, _temp, FrameGraphSystem;
var init_System = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/System.js"() {
    init_slicedToArray();
    import_regenerator2 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_identifier();
    init_FrameGraphHandle();
    init_FrameGraphPass();
    init_PassNode();
    init_ResourceEntry();
    init_ResourceNode();
    FrameGraphSystem = (_dec = injectable(), _dec2 = inject(IDENTIFIER.RenderEngine), _dec(_class = (_class2 = (_temp = function() {
      function FrameGraphSystem2() {
        _classCallCheck(this, FrameGraphSystem2);
        this.passNodes = [];
        this.resourceNodes = [];
        this.frameGraphPasses = [];
        _initializerDefineProperty(this, "engine", _descriptor, this);
      }
      _createClass(FrameGraphSystem2, [{
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator2.default.mark(function _callee(views) {
            return import_regenerator2.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.compile();
                    _context.next = 3;
                    return this.executePassNodes(views);
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute(_x) {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.frameGraphPasses.forEach(function(pass) {
            if (pass.tearDown) {
              pass.tearDown();
            }
          });
          this.reset();
        }
      }, {
        key: "addPass",
        value: function addPass(name, setup, execute, tearDown) {
          var frameGraphPass = new FrameGraphPass();
          frameGraphPass.execute = execute;
          if (tearDown) {
            frameGraphPass.tearDown = tearDown;
          }
          frameGraphPass.name = name;
          var passNode = new PassNode();
          passNode.name = name;
          this.passNodes.push(passNode);
          this.frameGraphPasses.push(frameGraphPass);
          setup(this, passNode, frameGraphPass);
          return frameGraphPass;
        }
      }, {
        key: "getPass",
        value: function getPass(name) {
          return this.frameGraphPasses.find(function(p2) {
            return p2.name === name;
          });
        }
      }, {
        key: "compile",
        value: function compile() {
          var _this = this;
          var _iterator = _createForOfIteratorHelper(this.passNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _pass = _step.value;
              _pass.refCount = _pass.writes.length + (_pass.hasSideEffect ? 1 : 0);
              _pass.reads.forEach(function(handle) {
                _this.resourceNodes[handle.index].readerCount++;
              });
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          var stack = [];
          var _iterator2 = _createForOfIteratorHelper(this.resourceNodes), _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
              var node = _step2.value;
              if (node.readerCount === 0) {
                stack.push(node);
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
          while (stack.length) {
            var pNode = stack.pop();
            var writer = pNode && pNode.writer;
            if (writer) {
              if (--writer.refCount === 0) {
                var _iterator3 = _createForOfIteratorHelper(writer.reads), _step3;
                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                    var resource = _step3.value;
                    var r2 = this.resourceNodes[resource.index];
                    if (--r2.readerCount === 0) {
                      stack.push(r2);
                    }
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }
              }
            }
          }
          this.resourceNodes.forEach(function(node2) {
            node2.resource.refs += node2.readerCount;
          });
          var _iterator4 = _createForOfIteratorHelper(this.passNodes), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var _pass2 = _step4.value;
              if (!_pass2.refCount) {
                continue;
              }
              var _iterator6 = _createForOfIteratorHelper(_pass2.reads), _step6;
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
                  var _resource2 = _step6.value;
                  var pResource = this.resourceNodes[_resource2.index].resource;
                  pResource.first = pResource.first ? pResource.first : _pass2;
                  pResource.last = _pass2;
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
              var _iterator7 = _createForOfIteratorHelper(_pass2.writes), _step7;
              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
                  var _resource3 = _step7.value;
                  var _pResource = this.resourceNodes[_resource3.index].resource;
                  _pResource.first = _pResource.first ? _pResource.first : _pass2;
                  _pResource.last = _pass2;
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          for (var priority = 0; priority < 2; priority++) {
            var _iterator5 = _createForOfIteratorHelper(this.resourceNodes), _step5;
            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                var resoureNode = _step5.value;
                var _resource = resoureNode.resource;
                if (_resource.priority === priority && _resource.refs) {
                  var pFirst = _resource.first;
                  var pLast = _resource.last;
                  if (pFirst && pLast) {
                    pFirst.devirtualize.push(_resource);
                    pLast.destroy.push(_resource);
                  }
                }
              }
            } catch (err) {
              _iterator5.e(err);
            } finally {
              _iterator5.f();
            }
          }
        }
      }, {
        key: "executePassNodes",
        value: function() {
          var _executePassNodes = _asyncToGenerator(import_regenerator2.default.mark(function _callee2(views) {
            var _iterator8, _step8, _step8$value, index, node, _iterator9, _step9, resource, _iterator10, _step10, _resource4, _iterator11, _step11, _resource5, _iterator12, _step12, _resource6;
            return import_regenerator2.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _iterator8 = _createForOfIteratorHelper(this.passNodes.entries());
                    _context2.prev = 1;
                    _iterator8.s();
                  case 3:
                    if ((_step8 = _iterator8.n()).done) {
                      _context2.next = 18;
                      break;
                    }
                    _step8$value = _slicedToArray(_step8.value, 2), index = _step8$value[0], node = _step8$value[1];
                    if (!node.refCount) {
                      _context2.next = 16;
                      break;
                    }
                    _iterator9 = _createForOfIteratorHelper(node.devirtualize);
                    try {
                      for (_iterator9.s(); !(_step9 = _iterator9.n()).done; ) {
                        resource = _step9.value;
                        resource.preExecuteDevirtualize(this.engine);
                      }
                    } catch (err) {
                      _iterator9.e(err);
                    } finally {
                      _iterator9.f();
                    }
                    _iterator10 = _createForOfIteratorHelper(node.destroy);
                    try {
                      for (_iterator10.s(); !(_step10 = _iterator10.n()).done; ) {
                        _resource4 = _step10.value;
                        _resource4.preExecuteDestroy(this.engine);
                      }
                    } catch (err) {
                      _iterator10.e(err);
                    } finally {
                      _iterator10.f();
                    }
                    _context2.next = 12;
                    return this.frameGraphPasses[index].execute(this, this.frameGraphPasses[index], views);
                  case 12:
                    _iterator11 = _createForOfIteratorHelper(node.devirtualize);
                    try {
                      for (_iterator11.s(); !(_step11 = _iterator11.n()).done; ) {
                        _resource5 = _step11.value;
                        _resource5.postExecuteDevirtualize(this.engine);
                      }
                    } catch (err) {
                      _iterator11.e(err);
                    } finally {
                      _iterator11.f();
                    }
                    _iterator12 = _createForOfIteratorHelper(node.destroy);
                    try {
                      for (_iterator12.s(); !(_step12 = _iterator12.n()).done; ) {
                        _resource6 = _step12.value;
                        _resource6.postExecuteDestroy(this.engine);
                      }
                    } catch (err) {
                      _iterator12.e(err);
                    } finally {
                      _iterator12.f();
                    }
                  case 16:
                    _context2.next = 3;
                    break;
                  case 18:
                    _context2.next = 23;
                    break;
                  case 20:
                    _context2.prev = 20;
                    _context2.t0 = _context2["catch"](1);
                    _iterator8.e(_context2.t0);
                  case 23:
                    _context2.prev = 23;
                    _iterator8.f();
                    return _context2.finish(23);
                  case 26:
                    this.reset();
                  case 27:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[1, 20, 23, 26]]);
          }));
          function executePassNodes(_x2) {
            return _executePassNodes.apply(this, arguments);
          }
          return executePassNodes;
        }()
      }, {
        key: "reset",
        value: function reset() {
          this.passNodes = [];
          this.resourceNodes = [];
          this.frameGraphPasses = [];
        }
      }, {
        key: "getResourceNode",
        value: function getResourceNode(r2) {
          return this.resourceNodes[r2.index];
        }
      }, {
        key: "createResourceNode",
        value: function createResourceNode(resourceEntry) {
          var resourceNode = new ResourceNode();
          resourceNode.resource = resourceEntry;
          resourceNode.version = resourceEntry.version;
          this.resourceNodes.push(resourceNode);
          var fgh = new FrameGraphHandle();
          fgh.index = this.resourceNodes.length - 1;
          return fgh;
        }
      }, {
        key: "createTexture",
        value: function createTexture(passNode, name, descriptor) {
          var resource = new ResourceEntry();
          resource.name = name;
          resource.descriptor = descriptor;
          return this.createResourceNode(resource);
        }
      }, {
        key: "createRenderTarget",
        value: function createRenderTarget(passNode, name, descriptor) {
          var resource = new ResourceEntry();
          resource.name = name;
          resource.descriptor = descriptor;
          return this.createResourceNode(resource);
        }
      }, {
        key: "present",
        value: function present(input) {
          this.addPass("Present", function(fg, passNode) {
            passNode.read(input);
            passNode.hasSideEffect = true;
          }, _asyncToGenerator(import_regenerator2.default.mark(function _callee3() {
            return import_regenerator2.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          })));
        }
      }]);
      return FrameGraphSystem2;
    }(), _temp), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "engine", [_dec2], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class2)) || _class);
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/is-typedarray.js
function baseIsTypedArray(value) {
  return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}
function isLength(value) {
  return typeof value === "number" && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;
}
function isObjectLike2(value) {
  return !!value && _typeof(value) === "object";
}
var MAX_SAFE_INTEGER, argsTag, arrayTag, boolTag, dateTag, errorTag, funcTag, mapTag, numberTag, objectTag, regexpTag, setTag, stringTag, weakMapTag, arrayBufferTag, dataViewTag, float32Tag, float64Tag, int8Tag, int16Tag, int32Tag, uint8Tag, uint8ClampedTag, uint16Tag, uint32Tag, typedArrayTags, objectProto2, objectToString, isTypedArray;
var init_is_typedarray = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/is-typedarray.js"() {
    init_typeof();
    MAX_SAFE_INTEGER = 9007199254740991;
    argsTag = "[object Arguments]";
    arrayTag = "[object Array]";
    boolTag = "[object Boolean]";
    dateTag = "[object Date]";
    errorTag = "[object Error]";
    funcTag = "[object Function]";
    mapTag = "[object Map]";
    numberTag = "[object Number]";
    objectTag = "[object Object]";
    regexpTag = "[object RegExp]";
    setTag = "[object Set]";
    stringTag = "[object String]";
    weakMapTag = "[object WeakMap]";
    arrayBufferTag = "[object ArrayBuffer]";
    dataViewTag = "[object DataView]";
    float32Tag = "[object Float32Array]";
    float64Tag = "[object Float64Array]";
    int8Tag = "[object Int8Array]";
    int16Tag = "[object Int16Array]";
    int32Tag = "[object Int32Array]";
    uint8Tag = "[object Uint8Array]";
    uint8ClampedTag = "[object Uint8ClampedArray]";
    uint16Tag = "[object Uint16Array]";
    uint32Tag = "[object Uint32Array]";
    typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    objectProto2 = Object.prototype;
    objectToString = objectProto2.toString;
    isTypedArray = baseIsTypedArray;
  }
});

// node_modules/@antv/g-webgpu-core/es/components/geometry/GeometryComponent.js
function ownKeys2(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var GeometryComponent;
var init_GeometryComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/geometry/GeometryComponent.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_esm2();
    init_ComponentManager();
    init_is_typedarray();
    GeometryComponent = function(_Component) {
      _inherits2(GeometryComponent2, _Component);
      var _super = _createSuper3(GeometryComponent2);
      function GeometryComponent2(data) {
        var _this;
        _classCallCheck(this, GeometryComponent2);
        _this = _super.call(this, data);
        _this.dirty = true;
        _this.attributes = [];
        _this.indices = void 0;
        _this.indicesBuffer = void 0;
        _this.vertexCount = 0;
        _this.maxInstancedCount = void 0;
        _this.aabb = void 0;
        _this.entity = void 0;
        Object.assign(_assertThisInitialized2(_this), data);
        return _this;
      }
      _createClass(GeometryComponent2, [{
        key: "setAttribute",
        value: function setAttribute(name, data, descriptor, bufferGetter) {
          var existed = this.attributes.find(function(a2) {
            return a2.name === name;
          });
          if (!existed) {
            this.attributes.push(_objectSpread2(_objectSpread2({
              dirty: true,
              name,
              data
            }, descriptor), {}, {
              bufferGetter
            }));
          } else {
            existed.data = data;
            existed.dirty = true;
          }
          this.dirty = true;
          return this;
        }
      }, {
        key: "setIndex",
        value: function setIndex(data) {
          this.indices = new Uint32Array(data.buffer ? data.buffer : data);
          this.dirty = true;
          return this;
        }
      }, {
        key: "applyMatrix",
        value: function applyMatrix4(matrix) {
          var positionAttribute = this.attributes.find(function(_ref2) {
            var name = _ref2.name;
            return name === "position";
          });
          var normalAttribute = this.attributes.find(function(_ref2) {
            var name = _ref2.name;
            return name === "normal";
          });
          if (positionAttribute) {
            positionAttribute.dirty = true;
            if (positionAttribute.data && positionAttribute.data.length) {
              for (var i2 = 0; i2 < positionAttribute.data.length; i2 += 3) {
                var position = vec4_exports.fromValues(positionAttribute.data[i2], positionAttribute.data[i2 + 1], positionAttribute.data[i2 + 2], 1);
                vec4_exports.transformMat4(position, position, matrix);
                if (isTypedArray(positionAttribute.data)) {
                  positionAttribute.data.set([position[0], position[1], position[2]], i2);
                } else {
                  positionAttribute.data[i2] = position[0];
                  positionAttribute.data[i2 + 1] = position[1];
                  positionAttribute.data[i2 + 2] = position[2];
                }
              }
            }
          }
          if (normalAttribute) {
            var normalMatrix = mat3_exports.normalFromMat4(mat3_exports.create(), matrix);
            if (normalAttribute.data && normalAttribute.data.length) {
              for (var _i2 = 0; _i2 < normalAttribute.data.length; _i2 += 3) {
                var normal2 = vec3_exports.fromValues(normalAttribute.data[_i2], normalAttribute.data[_i2 + 1], normalAttribute.data[_i2 + 2]);
                vec3_exports.transformMat3(normal2, normal2, normalMatrix);
                vec3_exports.normalize(normal2, normal2);
                if (isTypedArray(normalAttribute.data)) {
                  normalAttribute.data.set([normal2[0], normal2[1], normal2[2]], _i2);
                } else {
                  normalAttribute.data[_i2] = normal2[0];
                  normalAttribute.data[_i2 + 1] = normal2[1];
                  normalAttribute.data[_i2 + 2] = normal2[2];
                }
              }
            }
          }
        }
      }]);
      return GeometryComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js
var gl;
var init_gl = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/gl.js"() {
    (function(gl2) {
      gl2[gl2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
      gl2[gl2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
      gl2[gl2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
      gl2[gl2["POINTS"] = 0] = "POINTS";
      gl2[gl2["LINES"] = 1] = "LINES";
      gl2[gl2["LINE_LOOP"] = 2] = "LINE_LOOP";
      gl2[gl2["LINE_STRIP"] = 3] = "LINE_STRIP";
      gl2[gl2["TRIANGLES"] = 4] = "TRIANGLES";
      gl2[gl2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
      gl2[gl2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
      gl2[gl2["ZERO"] = 0] = "ZERO";
      gl2[gl2["ONE"] = 1] = "ONE";
      gl2[gl2["SRC_COLOR"] = 768] = "SRC_COLOR";
      gl2[gl2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
      gl2[gl2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
      gl2[gl2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
      gl2[gl2["DST_ALPHA"] = 772] = "DST_ALPHA";
      gl2[gl2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
      gl2[gl2["DST_COLOR"] = 774] = "DST_COLOR";
      gl2[gl2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
      gl2[gl2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
      gl2[gl2["FUNC_ADD"] = 32774] = "FUNC_ADD";
      gl2[gl2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
      gl2[gl2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
      gl2[gl2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
      gl2[gl2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
      gl2[gl2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
      gl2[gl2["MAX_EXT"] = 32776] = "MAX_EXT";
      gl2[gl2["MIN_EXT"] = 32775] = "MIN_EXT";
      gl2[gl2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
      gl2[gl2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
      gl2[gl2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
      gl2[gl2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
      gl2[gl2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
      gl2[gl2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
      gl2[gl2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
      gl2[gl2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
      gl2[gl2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
      gl2[gl2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
      gl2[gl2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
      gl2[gl2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
      gl2[gl2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
      gl2[gl2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
      gl2[gl2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
      gl2[gl2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
      gl2[gl2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
      gl2[gl2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
      gl2[gl2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
      gl2[gl2["FRONT"] = 1028] = "FRONT";
      gl2[gl2["BACK"] = 1029] = "BACK";
      gl2[gl2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
      gl2[gl2["CULL_FACE"] = 2884] = "CULL_FACE";
      gl2[gl2["BLEND"] = 3042] = "BLEND";
      gl2[gl2["DITHER"] = 3024] = "DITHER";
      gl2[gl2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
      gl2[gl2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
      gl2[gl2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
      gl2[gl2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
      gl2[gl2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
      gl2[gl2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
      gl2[gl2["NO_ERROR"] = 0] = "NO_ERROR";
      gl2[gl2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
      gl2[gl2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
      gl2[gl2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
      gl2[gl2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
      gl2[gl2["CW"] = 2304] = "CW";
      gl2[gl2["CCW"] = 2305] = "CCW";
      gl2[gl2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
      gl2[gl2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
      gl2[gl2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
      gl2[gl2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
      gl2[gl2["FRONT_FACE"] = 2886] = "FRONT_FACE";
      gl2[gl2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
      gl2[gl2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
      gl2[gl2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
      gl2[gl2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
      gl2[gl2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
      gl2[gl2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
      gl2[gl2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_REF"] = 2967] = "STENCIL_REF";
      gl2[gl2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
      gl2[gl2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
      gl2[gl2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
      gl2[gl2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
      gl2[gl2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
      gl2[gl2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
      gl2[gl2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
      gl2[gl2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
      gl2[gl2["VIEWPORT"] = 2978] = "VIEWPORT";
      gl2[gl2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
      gl2[gl2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
      gl2[gl2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
      gl2[gl2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
      gl2[gl2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
      gl2[gl2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
      gl2[gl2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
      gl2[gl2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
      gl2[gl2["RED_BITS"] = 3410] = "RED_BITS";
      gl2[gl2["GREEN_BITS"] = 3411] = "GREEN_BITS";
      gl2[gl2["BLUE_BITS"] = 3412] = "BLUE_BITS";
      gl2[gl2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
      gl2[gl2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
      gl2[gl2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
      gl2[gl2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
      gl2[gl2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
      gl2[gl2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
      gl2[gl2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
      gl2[gl2["SAMPLES"] = 32937] = "SAMPLES";
      gl2[gl2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
      gl2[gl2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
      gl2[gl2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
      gl2[gl2["DONT_CARE"] = 4352] = "DONT_CARE";
      gl2[gl2["FASTEST"] = 4353] = "FASTEST";
      gl2[gl2["NICEST"] = 4354] = "NICEST";
      gl2[gl2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
      gl2[gl2["BYTE"] = 5120] = "BYTE";
      gl2[gl2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
      gl2[gl2["SHORT"] = 5122] = "SHORT";
      gl2[gl2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
      gl2[gl2["INT"] = 5124] = "INT";
      gl2[gl2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
      gl2[gl2["FLOAT"] = 5126] = "FLOAT";
      gl2[gl2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
      gl2[gl2["ALPHA"] = 6406] = "ALPHA";
      gl2[gl2["RGB"] = 6407] = "RGB";
      gl2[gl2["RGBA"] = 6408] = "RGBA";
      gl2[gl2["LUMINANCE"] = 6409] = "LUMINANCE";
      gl2[gl2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
      gl2[gl2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
      gl2[gl2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
      gl2[gl2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
      gl2[gl2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
      gl2[gl2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
      gl2[gl2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
      gl2[gl2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
      gl2[gl2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
      gl2[gl2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
      gl2[gl2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
      gl2[gl2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
      gl2[gl2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
      gl2[gl2["LINK_STATUS"] = 35714] = "LINK_STATUS";
      gl2[gl2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
      gl2[gl2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
      gl2[gl2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
      gl2[gl2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
      gl2[gl2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
      gl2[gl2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
      gl2[gl2["NEVER"] = 512] = "NEVER";
      gl2[gl2["LESS"] = 513] = "LESS";
      gl2[gl2["EQUAL"] = 514] = "EQUAL";
      gl2[gl2["LEQUAL"] = 515] = "LEQUAL";
      gl2[gl2["GREATER"] = 516] = "GREATER";
      gl2[gl2["NOTEQUAL"] = 517] = "NOTEQUAL";
      gl2[gl2["GEQUAL"] = 518] = "GEQUAL";
      gl2[gl2["ALWAYS"] = 519] = "ALWAYS";
      gl2[gl2["KEEP"] = 7680] = "KEEP";
      gl2[gl2["REPLACE"] = 7681] = "REPLACE";
      gl2[gl2["INCR"] = 7682] = "INCR";
      gl2[gl2["DECR"] = 7683] = "DECR";
      gl2[gl2["INVERT"] = 5386] = "INVERT";
      gl2[gl2["INCR_WRAP"] = 34055] = "INCR_WRAP";
      gl2[gl2["DECR_WRAP"] = 34056] = "DECR_WRAP";
      gl2[gl2["VENDOR"] = 7936] = "VENDOR";
      gl2[gl2["RENDERER"] = 7937] = "RENDERER";
      gl2[gl2["VERSION"] = 7938] = "VERSION";
      gl2[gl2["NEAREST"] = 9728] = "NEAREST";
      gl2[gl2["LINEAR"] = 9729] = "LINEAR";
      gl2[gl2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
      gl2[gl2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
      gl2[gl2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
      gl2[gl2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
      gl2[gl2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
      gl2[gl2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
      gl2[gl2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
      gl2[gl2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
      gl2[gl2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
      gl2[gl2["TEXTURE"] = 5890] = "TEXTURE";
      gl2[gl2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
      gl2[gl2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
      gl2[gl2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
      gl2[gl2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
      gl2[gl2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
      gl2[gl2["TEXTURE0"] = 33984] = "TEXTURE0";
      gl2[gl2["TEXTURE1"] = 33985] = "TEXTURE1";
      gl2[gl2["TEXTURE2"] = 33986] = "TEXTURE2";
      gl2[gl2["TEXTURE3"] = 33987] = "TEXTURE3";
      gl2[gl2["TEXTURE4"] = 33988] = "TEXTURE4";
      gl2[gl2["TEXTURE5"] = 33989] = "TEXTURE5";
      gl2[gl2["TEXTURE6"] = 33990] = "TEXTURE6";
      gl2[gl2["TEXTURE7"] = 33991] = "TEXTURE7";
      gl2[gl2["TEXTURE8"] = 33992] = "TEXTURE8";
      gl2[gl2["TEXTURE9"] = 33993] = "TEXTURE9";
      gl2[gl2["TEXTURE10"] = 33994] = "TEXTURE10";
      gl2[gl2["TEXTURE11"] = 33995] = "TEXTURE11";
      gl2[gl2["TEXTURE12"] = 33996] = "TEXTURE12";
      gl2[gl2["TEXTURE13"] = 33997] = "TEXTURE13";
      gl2[gl2["TEXTURE14"] = 33998] = "TEXTURE14";
      gl2[gl2["TEXTURE15"] = 33999] = "TEXTURE15";
      gl2[gl2["TEXTURE16"] = 34e3] = "TEXTURE16";
      gl2[gl2["TEXTURE17"] = 34001] = "TEXTURE17";
      gl2[gl2["TEXTURE18"] = 34002] = "TEXTURE18";
      gl2[gl2["TEXTURE19"] = 34003] = "TEXTURE19";
      gl2[gl2["TEXTURE20"] = 34004] = "TEXTURE20";
      gl2[gl2["TEXTURE21"] = 34005] = "TEXTURE21";
      gl2[gl2["TEXTURE22"] = 34006] = "TEXTURE22";
      gl2[gl2["TEXTURE23"] = 34007] = "TEXTURE23";
      gl2[gl2["TEXTURE24"] = 34008] = "TEXTURE24";
      gl2[gl2["TEXTURE25"] = 34009] = "TEXTURE25";
      gl2[gl2["TEXTURE26"] = 34010] = "TEXTURE26";
      gl2[gl2["TEXTURE27"] = 34011] = "TEXTURE27";
      gl2[gl2["TEXTURE28"] = 34012] = "TEXTURE28";
      gl2[gl2["TEXTURE29"] = 34013] = "TEXTURE29";
      gl2[gl2["TEXTURE30"] = 34014] = "TEXTURE30";
      gl2[gl2["TEXTURE31"] = 34015] = "TEXTURE31";
      gl2[gl2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
      gl2[gl2["REPEAT"] = 10497] = "REPEAT";
      gl2[gl2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
      gl2[gl2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
      gl2[gl2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
      gl2[gl2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
      gl2[gl2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
      gl2[gl2["INT_VEC2"] = 35667] = "INT_VEC2";
      gl2[gl2["INT_VEC3"] = 35668] = "INT_VEC3";
      gl2[gl2["INT_VEC4"] = 35669] = "INT_VEC4";
      gl2[gl2["BOOL"] = 35670] = "BOOL";
      gl2[gl2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
      gl2[gl2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
      gl2[gl2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
      gl2[gl2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
      gl2[gl2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
      gl2[gl2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
      gl2[gl2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
      gl2[gl2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
      gl2[gl2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
      gl2[gl2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
      gl2[gl2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
      gl2[gl2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
      gl2[gl2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
      gl2[gl2["LOW_INT"] = 36339] = "LOW_INT";
      gl2[gl2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
      gl2[gl2["HIGH_INT"] = 36341] = "HIGH_INT";
      gl2[gl2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
      gl2[gl2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
      gl2[gl2["RGBA4"] = 32854] = "RGBA4";
      gl2[gl2["RGB5_A1"] = 32855] = "RGB5_A1";
      gl2[gl2["RGB565"] = 36194] = "RGB565";
      gl2[gl2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
      gl2[gl2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
      gl2[gl2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
      gl2[gl2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
      gl2[gl2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
      gl2[gl2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
      gl2[gl2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
      gl2[gl2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
      gl2[gl2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
      gl2[gl2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
      gl2[gl2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
      gl2[gl2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
      gl2[gl2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
      gl2[gl2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
      gl2[gl2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
      gl2[gl2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
      gl2[gl2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
      gl2[gl2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
      gl2[gl2["NONE"] = 0] = "NONE";
      gl2[gl2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
      gl2[gl2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
      gl2[gl2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
      gl2[gl2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
      gl2[gl2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
      gl2[gl2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
      gl2[gl2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
      gl2[gl2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
      gl2[gl2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
      gl2[gl2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
      gl2[gl2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
      gl2[gl2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
      gl2[gl2["COPY_SRC"] = 1] = "COPY_SRC";
      gl2[gl2["COPY_DST"] = 2] = "COPY_DST";
      gl2[gl2["SAMPLED"] = 4] = "SAMPLED";
      gl2[gl2["STORAGE"] = 8] = "STORAGE";
      gl2[gl2["RENDER_ATTACHMENT"] = 16] = "RENDER_ATTACHMENT";
    })(gl || (gl = {}));
  }
});

// node_modules/@antv/g-webgpu-core/es/components/geometry/System.js
var import_regenerator3, _dec3, _dec22, _dec32, _class3, _class22, _descriptor2, _descriptor22, _temp2, GeometrySystem;
var init_System2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/geometry/System.js"() {
    import_regenerator3 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_es3();
    init_identifier();
    init_gl();
    GeometrySystem = (_dec3 = injectable(), _dec22 = inject(IDENTIFIER.GeometryComponentManager), _dec32 = inject(IDENTIFIER.RenderEngine), _dec3(_class3 = (_class22 = (_temp2 = function() {
      function GeometrySystem2() {
        _classCallCheck(this, GeometrySystem2);
        _initializerDefineProperty(this, "geometry", _descriptor2, this);
        _initializerDefineProperty(this, "engine", _descriptor22, this);
      }
      _createClass(GeometrySystem2, [{
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator3.default.mark(function _callee() {
            var _this = this;
            return import_regenerator3.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.geometry.forEach(function(entity, component) {
                      if (component.dirty) {
                        component.attributes.forEach(function(attribute) {
                          if (attribute.dirty && attribute.data) {
                            if (!attribute.buffer) {
                              attribute.buffer = _this.engine.createBuffer({
                                data: attribute.data,
                                type: gl.FLOAT
                              });
                            } else {
                              var _attribute$buffer;
                              (_attribute$buffer = attribute.buffer) === null || _attribute$buffer === void 0 ? void 0 : _attribute$buffer.subData({
                                data: attribute.data,
                                offset: 0
                              });
                            }
                            attribute.dirty = false;
                          }
                        });
                        if (component.indices) {
                          if (!component.indicesBuffer) {
                            component.indicesBuffer = _this.engine.createElements({
                              data: component.indices,
                              count: component.indices.length,
                              type: gl.UNSIGNED_INT,
                              usage: gl.STATIC_DRAW
                            });
                          } else {
                            component.indicesBuffer.subData({
                              data: component.indices,
                              offset: 0
                            });
                          }
                        }
                        component.dirty = false;
                      }
                    });
                  case 1:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.geometry.forEach(function(_2, geometry) {
            if (geometry.indicesBuffer) {
              geometry.indicesBuffer.destroy();
            }
            geometry.attributes.forEach(function(attribute) {
              if (attribute.buffer) {
                attribute.buffer.destroy();
              }
            });
          });
          this.geometry.clear();
        }
      }, {
        key: "createBufferGeometry",
        value: function createBufferGeometry() {
          var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
            vertexCount: 3
          }, vertexCount = _ref2.vertexCount;
          var entity = createEntity();
          return this.geometry.create(entity, {
            vertexCount
          });
        }
      }, {
        key: "createInstancedBufferGeometry",
        value: function createInstancedBufferGeometry(_ref2) {
          var maxInstancedCount = _ref2.maxInstancedCount, vertexCount = _ref2.vertexCount;
          var entity = createEntity();
          return this.geometry.create(entity, {
            maxInstancedCount,
            vertexCount
          });
        }
      }]);
      return GeometrySystem2;
    }(), _temp2), _descriptor2 = _applyDecoratedDescriptor(_class22.prototype, "geometry", [_dec22], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor22 = _applyDecoratedDescriptor(_class22.prototype, "engine", [_dec32], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class22)) || _class3);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/material/MaterialComponent.js
function ownKeys3(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var MaterialComponent;
var init_MaterialComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/material/MaterialComponent.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_es3();
    init_ComponentManager();
    MaterialComponent = function(_Component) {
      _inherits2(MaterialComponent2, _Component);
      var _super = _createSuper4(MaterialComponent2);
      function MaterialComponent2(data) {
        var _this;
        _classCallCheck(this, MaterialComponent2);
        _this = _super.call(this, data);
        _this.vertexShaderGLSL = void 0;
        _this.fragmentShaderGLSL = void 0;
        _this.defines = {};
        _this.dirty = true;
        _this.uniforms = [];
        _this.cull = {
          enable: true,
          face: gl.BACK
        };
        _this.depth = {
          enable: true
        };
        _this.blend = void 0;
        _this.entity = void 0;
        _this.type = void 0;
        Object.assign(_assertThisInitialized2(_this), data);
        return _this;
      }
      _createClass(MaterialComponent2, [{
        key: "setDefines",
        value: function setDefines(defines) {
          this.defines = _objectSpread3(_objectSpread3({}, this.defines), defines);
          return this;
        }
      }, {
        key: "setCull",
        value: function setCull(cull) {
          this.cull = cull;
          return this;
        }
      }, {
        key: "setDepth",
        value: function setDepth(depth) {
          this.depth = depth;
          return this;
        }
      }, {
        key: "setBlend",
        value: function setBlend(blend) {
          this.blend = blend;
          return this;
        }
      }, {
        key: "setUniform",
        value: function setUniform(name, data) {
          var _this2 = this;
          if (typeof name !== "string") {
            Object.keys(name).forEach(function(key) {
              return _this2.setUniform(key, name[key]);
            });
            return this;
          }
          var existedUniform = this.uniforms.find(function(u2) {
            return u2.name === name;
          });
          if (!existedUniform) {
            this.uniforms.push({
              name,
              dirty: true,
              data
            });
          } else {
            existedUniform.dirty = true;
            existedUniform.data = data;
          }
          this.dirty = true;
          return this;
        }
      }]);
      return MaterialComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/material/System.js
function ownKeys4(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator4, _dec4, _dec23, _dec33, _dec42, _class4, _class23, _descriptor3, _descriptor23, _descriptor32, _temp3, MaterialSystem;
var init_System3 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/material/System.js"() {
    init_defineProperty();
    import_regenerator4 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_es3();
    init_identifier();
    MaterialSystem = (_dec4 = injectable(), _dec23 = inject(IDENTIFIER.MaterialComponentManager), _dec33 = inject(IDENTIFIER.RenderEngine), _dec42 = inject(IDENTIFIER.ShaderModuleService), _dec4(_class4 = (_class23 = (_temp3 = function() {
      function MaterialSystem2() {
        _classCallCheck(this, MaterialSystem2);
        _initializerDefineProperty(this, "material", _descriptor3, this);
        _initializerDefineProperty(this, "engine", _descriptor23, this);
        _initializerDefineProperty(this, "shaderModule", _descriptor32, this);
      }
      _createClass(MaterialSystem2, [{
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator4.default.mark(function _callee() {
            return import_regenerator4.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.material.clear();
        }
      }, {
        key: "createShaderMaterial",
        value: function createShaderMaterial(params) {
          var entity = createEntity();
          var vertexShaderGLSL = params.vertexShader;
          var fragmentShaderGLSL = params.fragmentShader;
          var uniforms = [];
          if (!this.engine.supportWebGPU) {
            var moduleName = "material-".concat(entity);
            this.shaderModule.registerModule(moduleName, {
              vs: params.vertexShader,
              fs: params.fragmentShader
            });
            var materialModule = this.shaderModule.getModule(moduleName);
            vertexShaderGLSL = materialModule.vs;
            fragmentShaderGLSL = materialModule.fs;
            if (materialModule.uniforms) {
              uniforms = Object.keys(materialModule.uniforms).map(function(uniformName) {
                return {
                  dirty: true,
                  name: uniformName,
                  data: materialModule.uniforms[uniformName]
                };
              });
            }
          }
          return this.material.create(entity, _objectSpread4(_objectSpread4({
            vertexShaderGLSL,
            fragmentShaderGLSL
          }, params), {}, {
            uniforms
          }));
        }
      }]);
      return MaterialSystem2;
    }(), _temp3), _descriptor3 = _applyDecoratedDescriptor(_class23.prototype, "material", [_dec23], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor23 = _applyDecoratedDescriptor(_class23.prototype, "engine", [_dec33], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor32 = _applyDecoratedDescriptor(_class23.prototype, "shaderModule", [_dec42], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class23)) || _class4);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/mesh/CullableComponent.js
function _createSuper5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var Strategy, CullableComponent;
var init_CullableComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/mesh/CullableComponent.js"() {
    init_classCallCheck();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_ComponentManager();
    (function(Strategy2) {
      Strategy2[Strategy2["Standard"] = 0] = "Standard";
    })(Strategy || (Strategy = {}));
    CullableComponent = function(_Component) {
      _inherits2(CullableComponent2, _Component);
      var _super = _createSuper5(CullableComponent2);
      function CullableComponent2(data) {
        var _this;
        _classCallCheck(this, CullableComponent2);
        _this = _super.call(this, data);
        _this.strategy = Strategy.Standard;
        _this.visibilityPlaneMask = 0;
        _this.visible = false;
        Object.assign(_assertThisInitialized2(_this), data);
        return _this;
      }
      return CullableComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/AABB.js
var AABB;
var init_AABB = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/AABB.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm2();
    AABB = function() {
      function AABB2(center, halfExtents) {
        _classCallCheck(this, AABB2);
        this.center = void 0;
        this.halfExtents = void 0;
        this.min = vec3_exports.create();
        this.max = vec3_exports.create();
        this.update(center, halfExtents);
      }
      _createClass(AABB2, [{
        key: "update",
        value: function update15(center, halfExtents) {
          this.center = center || vec3_exports.create();
          this.halfExtents = halfExtents || vec3_exports.fromValues(0.5, 0.5, 0.5);
          this.min = vec3_exports.sub(this.min, this.center, this.halfExtents);
          this.max = vec3_exports.add(this.max, this.center, this.halfExtents);
        }
      }, {
        key: "setMinMax",
        value: function setMinMax(min6, max7) {
          vec3_exports.add(this.center, max7, min6);
          vec3_exports.scale(this.center, this.center, 0.5);
          vec3_exports.sub(this.halfExtents, max7, min6);
          vec3_exports.scale(this.halfExtents, this.halfExtents, 0.5);
          vec3_exports.copy(this.min, min6);
          vec3_exports.copy(this.max, max7);
        }
      }, {
        key: "getMin",
        value: function getMin() {
          return this.min;
        }
      }, {
        key: "getMax",
        value: function getMax() {
          return this.max;
        }
      }, {
        key: "add",
        value: function add7(aabb) {
          var tc2 = this.center;
          var tcx = tc2[0];
          var tcy = tc2[1];
          var tcz = tc2[2];
          var th = this.halfExtents;
          var thx = th[0];
          var thy = th[1];
          var thz = th[2];
          var tminx = tcx - thx;
          var tmaxx = tcx + thx;
          var tminy = tcy - thy;
          var tmaxy = tcy + thy;
          var tminz = tcz - thz;
          var tmaxz = tcz + thz;
          var oc2 = aabb.center;
          var ocx = oc2[0];
          var ocy = oc2[1];
          var ocz = oc2[2];
          var oh = aabb.halfExtents;
          var ohx = oh[0];
          var ohy = oh[1];
          var ohz = oh[2];
          var ominx = ocx - ohx;
          var omaxx = ocx + ohx;
          var ominy = ocy - ohy;
          var omaxy = ocy + ohy;
          var ominz = ocz - ohz;
          var omaxz = ocz + ohz;
          if (ominx < tminx) {
            tminx = ominx;
          }
          if (omaxx > tmaxx) {
            tmaxx = omaxx;
          }
          if (ominy < tminy) {
            tminy = ominy;
          }
          if (omaxy > tmaxy) {
            tmaxy = omaxy;
          }
          if (ominz < tminz) {
            tminz = ominz;
          }
          if (omaxz > tmaxz) {
            tmaxz = omaxz;
          }
          tc2[0] = (tminx + tmaxx) * 0.5;
          tc2[1] = (tminy + tmaxy) * 0.5;
          tc2[2] = (tminz + tmaxz) * 0.5;
          th[0] = (tmaxx - tminx) * 0.5;
          th[1] = (tmaxy - tminy) * 0.5;
          th[2] = (tmaxz - tminz) * 0.5;
          this.min[0] = tminx;
          this.min[1] = tminy;
          this.min[2] = tminz;
          this.max[0] = tmaxx;
          this.max[1] = tmaxy;
          this.max[2] = tmaxz;
        }
      }, {
        key: "intersects",
        value: function intersects(aabb) {
          var aMax = this.getMax();
          var aMin = this.getMin();
          var bMax = aabb.getMax();
          var bMin = aabb.getMin();
          return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
        }
      }, {
        key: "containsPoint",
        value: function containsPoint(point) {
          var min6 = this.getMin();
          var max7 = this.getMax();
          return !(point[0] < min6[0] || point[0] > max7[0] || point[1] < min6[1] || point[1] > max7[1] || point[2] < min6[2] || point[2] > max7[2]);
        }
      }, {
        key: "getNegativeFarPoint",
        value: function getNegativeFarPoint(plane) {
          if (plane.pnVertexFlag === 273) {
            return vec3_exports.copy(vec3_exports.create(), this.min);
          } else if (plane.pnVertexFlag === 272) {
            return vec3_exports.fromValues(this.min[0], this.min[1], this.max[2]);
          } else if (plane.pnVertexFlag === 257) {
            return vec3_exports.fromValues(this.min[0], this.max[1], this.min[2]);
          } else if (plane.pnVertexFlag === 256) {
            return vec3_exports.fromValues(this.min[0], this.max[1], this.max[2]);
          } else if (plane.pnVertexFlag === 17) {
            return vec3_exports.fromValues(this.max[0], this.min[1], this.min[2]);
          } else if (plane.pnVertexFlag === 16) {
            return vec3_exports.fromValues(this.max[0], this.min[1], this.max[2]);
          } else if (plane.pnVertexFlag === 1) {
            return vec3_exports.fromValues(this.max[0], this.max[1], this.min[2]);
          } else {
            return vec3_exports.fromValues(this.max[0], this.max[1], this.max[2]);
          }
        }
      }, {
        key: "getPositiveFarPoint",
        value: function getPositiveFarPoint(plane) {
          if (plane.pnVertexFlag === 273) {
            return vec3_exports.copy(vec3_exports.create(), this.max);
          } else if (plane.pnVertexFlag === 272) {
            return vec3_exports.fromValues(this.max[0], this.max[1], this.min[2]);
          } else if (plane.pnVertexFlag === 257) {
            return vec3_exports.fromValues(this.max[0], this.min[1], this.max[2]);
          } else if (plane.pnVertexFlag === 256) {
            return vec3_exports.fromValues(this.max[0], this.min[1], this.min[2]);
          } else if (plane.pnVertexFlag === 17) {
            return vec3_exports.fromValues(this.min[0], this.max[1], this.max[2]);
          } else if (plane.pnVertexFlag === 16) {
            return vec3_exports.fromValues(this.min[0], this.max[1], this.min[2]);
          } else if (plane.pnVertexFlag === 1) {
            return vec3_exports.fromValues(this.min[0], this.min[1], this.max[2]);
          } else {
            return vec3_exports.fromValues(this.min[0], this.min[1], this.min[2]);
          }
        }
      }]);
      return AABB2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/mesh/MeshComponent.js
function _createSuper6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var MeshComponent;
var init_MeshComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/mesh/MeshComponent.js"() {
    init_classCallCheck();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_ComponentManager();
    init_AABB();
    MeshComponent = function(_Component) {
      _inherits2(MeshComponent2, _Component);
      var _super = _createSuper6(MeshComponent2);
      function MeshComponent2(data) {
        var _this;
        _classCallCheck(this, MeshComponent2);
        _this = _super.call(this, data);
        _this.material = void 0;
        _this.geometry = void 0;
        _this.aabb = new AABB();
        _this.aabbDirty = true;
        _this.model = void 0;
        _this.visible = true;
        _this.children = [];
        Object.assign(_assertThisInitialized2(_this), data);
        return _this;
      }
      return MeshComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/Plane.js
var Plane;
var init_Plane = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/Plane.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm2();
    Plane = function() {
      function Plane3(distance11, normal2) {
        _classCallCheck(this, Plane3);
        this.distance = void 0;
        this.normal = void 0;
        this.pnVertexFlag = void 0;
        this.distance = distance11 || 0;
        this.normal = normal2 || vec3_exports.fromValues(0, 1, 0);
        this.updatePNVertexFlag();
      }
      _createClass(Plane3, [{
        key: "updatePNVertexFlag",
        value: function updatePNVertexFlag() {
          this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
        }
      }, {
        key: "distanceToPoint",
        value: function distanceToPoint(point) {
          return vec3_exports.dot(point, this.normal) - this.distance;
        }
      }, {
        key: "normalize",
        value: function normalize5() {
          var invLen = 1 / vec3_exports.len(this.normal);
          vec3_exports.scale(this.normal, this.normal, invLen);
          this.distance *= invLen;
        }
      }, {
        key: "intersectsLine",
        value: function intersectsLine(start, end2, point) {
          var d0 = this.distanceToPoint(start);
          var d1 = this.distanceToPoint(end2);
          var t4 = d0 / (d0 - d1);
          var intersects = t4 >= 0 && t4 <= 1;
          if (intersects && point) {
            vec3_exports.lerp(point, start, end2, t4);
          }
          return intersects;
        }
      }]);
      return Plane3;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/Frustum.js
var Mask, Frustum;
var init_Frustum = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/Frustum.js"() {
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_esm2();
    init_Plane();
    (function(Mask2) {
      Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
      Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
      Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
    })(Mask || (Mask = {}));
    Frustum = function() {
      function Frustum2(planes) {
        _classCallCheck(this, Frustum2);
        this.planes = [];
        if (planes) {
          this.planes = planes;
        } else {
          for (var i2 = 0; i2 < 6; i2++) {
            this.planes.push(new Plane());
          }
        }
      }
      _createClass(Frustum2, [{
        key: "extractFromVPMatrix",
        value: function extractFromVPMatrix(vpMatrix) {
          var _vpMatrix = _slicedToArray(vpMatrix, 16), m0 = _vpMatrix[0], m1 = _vpMatrix[1], m2 = _vpMatrix[2], m3 = _vpMatrix[3], m4 = _vpMatrix[4], m5 = _vpMatrix[5], m6 = _vpMatrix[6], m7 = _vpMatrix[7], m8 = _vpMatrix[8], m9 = _vpMatrix[9], m10 = _vpMatrix[10], m11 = _vpMatrix[11], m12 = _vpMatrix[12], m13 = _vpMatrix[13], m14 = _vpMatrix[14], m15 = _vpMatrix[15];
          vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
          this.planes[0].distance = -(m15 - m12);
          vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
          this.planes[1].distance = -(m15 + m12);
          vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
          this.planes[2].distance = -(m15 + m13);
          vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
          this.planes[3].distance = -(m15 - m13);
          vec3_exports.set(this.planes[4].normal, m3 - m2, m7 - m6, m11 - m10);
          this.planes[4].distance = -(m15 - m14);
          vec3_exports.set(this.planes[5].normal, m3 + m2, m7 + m6, m11 + m10);
          this.planes[5].distance = -(m15 + m14);
          this.planes.forEach(function(plane) {
            plane.normalize();
            plane.updatePNVertexFlag();
          });
        }
      }]);
      return Frustum2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/is-number.js
var init_is_number2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/is-number.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/math.js
function getRotationScale(matrix, result) {
  result[0] = matrix[0];
  result[1] = matrix[1];
  result[2] = matrix[2];
  result[3] = matrix[4];
  result[4] = matrix[5];
  result[5] = matrix[6];
  result[6] = matrix[8];
  result[7] = matrix[9];
  result[8] = matrix[10];
  return result;
}
function decodePickingColor(color3) {
  var _color = _slicedToArray(color3, 3), i1 = _color[0], i2 = _color[1], i3 = _color[2];
  var index = i1 + i2 * 256 + i3 * 65536 - 1;
  return index;
}
var init_math = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/math.js"() {
    init_slicedToArray();
    init_esm2();
    init_is_number2();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/mesh/System.js
function _createForOfIteratorHelper2(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray3(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e8(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e8(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray3(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray3(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray3(o2, minLen);
}
function _arrayLikeToArray3(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var import_regenerator5, _dec5, _dec24, _dec34, _dec43, _dec52, _dec6, _class5, _class24, _descriptor4, _descriptor24, _descriptor33, _descriptor42, _descriptor5, _temp4, MeshSystem;
var init_System4 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/mesh/System.js"() {
    import_regenerator5 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_esm2();
    init_inversify();
    init_identifier();
    init_Frustum();
    init_math();
    MeshSystem = (_dec5 = injectable(), _dec24 = inject(IDENTIFIER.MeshComponentManager), _dec34 = inject(IDENTIFIER.CullableComponentManager), _dec43 = inject(IDENTIFIER.GeometryComponentManager), _dec52 = inject(IDENTIFIER.HierarchyComponentManager), _dec6 = inject(IDENTIFIER.TransformComponentManager), _dec5(_class5 = (_class24 = (_temp4 = function() {
      function MeshSystem2() {
        _classCallCheck(this, MeshSystem2);
        _initializerDefineProperty(this, "mesh", _descriptor4, this);
        _initializerDefineProperty(this, "cullable", _descriptor24, this);
        _initializerDefineProperty(this, "geometry", _descriptor33, this);
        _initializerDefineProperty(this, "hierarchy", _descriptor42, this);
        _initializerDefineProperty(this, "transform", _descriptor5, this);
        this.planes = void 0;
      }
      _createClass(MeshSystem2, [{
        key: "setFrustumPlanes",
        value: function setFrustumPlanes(planes) {
          this.planes = planes;
        }
      }, {
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator5.default.mark(function _callee(views) {
            var _iterator, _step, view, scene, camera, _iterator2, _step2, entity, component, hierarchyComponent, cullableComponent, geometryComponent, meshTransform, worldTransform, _geometryComponent$aa, center, halfExtents, transformedCenter, rotationScale, transformedHalfExtents, parentCullableComponent;
            return import_regenerator5.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _iterator = _createForOfIteratorHelper2(views);
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        view = _step.value;
                        scene = view.getScene();
                        camera = view.getCamera();
                        _iterator2 = _createForOfIteratorHelper2(scene.getEntities());
                        try {
                          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                            entity = _step2.value;
                            component = this.mesh.getComponentByEntity(entity);
                            if (component) {
                              hierarchyComponent = this.hierarchy.getComponentByEntity(entity);
                              cullableComponent = this.cullable.getComponentByEntity(entity);
                              geometryComponent = component.geometry;
                              meshTransform = this.transform.getComponentByEntity(entity);
                              if (geometryComponent && geometryComponent.aabb && meshTransform && component.aabbDirty) {
                                worldTransform = meshTransform.worldTransform;
                                _geometryComponent$aa = geometryComponent.aabb, center = _geometryComponent$aa.center, halfExtents = _geometryComponent$aa.halfExtents;
                                transformedCenter = vec3_exports.transformMat4(vec3_exports.create(), center, worldTransform);
                                rotationScale = getRotationScale(worldTransform, mat3_exports.create());
                                transformedHalfExtents = vec3_exports.transformMat3(vec3_exports.create(), halfExtents, rotationScale);
                                component.aabb.update(transformedCenter, transformedHalfExtents);
                                component.aabbDirty = false;
                              }
                              if (cullableComponent && geometryComponent) {
                                parentCullableComponent = this.cullable.getComponentByEntity((hierarchyComponent === null || hierarchyComponent === void 0 ? void 0 : hierarchyComponent.parentID) || -1);
                                cullableComponent.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(component.aabb, (parentCullableComponent === null || parentCullableComponent === void 0 ? void 0 : parentCullableComponent.visibilityPlaneMask) || Mask.INDETERMINATE, this.planes || camera.getFrustum().planes);
                                cullableComponent.visible = cullableComponent.visibilityPlaneMask !== Mask.OUTSIDE;
                              }
                            }
                          }
                        } catch (err) {
                          _iterator2.e(err);
                        } finally {
                          _iterator2.f();
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute(_x) {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.cullable.clear();
          this.mesh.clear();
        }
      }, {
        key: "computeVisibilityWithPlaneMask",
        value: function computeVisibilityWithPlaneMask(aabb, parentPlaneMask, planes) {
          if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
            return parentPlaneMask;
          }
          var mask = Mask.INSIDE;
          for (var k2 = 0, len5 = planes.length; k2 < len5; ++k2) {
            var flag = k2 < 31 ? 1 << k2 : 0;
            if (k2 < 31 && (parentPlaneMask & flag) === 0) {
              continue;
            }
            var _planes$k = planes[k2], normal2 = _planes$k.normal, distance11 = _planes$k.distance;
            if (vec3_exports.dot(normal2, aabb.getNegativeFarPoint(planes[k2])) + distance11 > 0) {
              return Mask.OUTSIDE;
            }
            if (vec3_exports.dot(normal2, aabb.getPositiveFarPoint(planes[k2])) + distance11 > 0) {
              mask |= flag;
            }
          }
          return mask;
        }
      }]);
      return MeshSystem2;
    }(), _temp4), _descriptor4 = _applyDecoratedDescriptor(_class24.prototype, "mesh", [_dec24], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor24 = _applyDecoratedDescriptor(_class24.prototype, "cullable", [_dec34], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor33 = _applyDecoratedDescriptor(_class24.prototype, "geometry", [_dec43], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor42 = _applyDecoratedDescriptor(_class24.prototype, "hierarchy", [_dec52], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor5 = _applyDecoratedDescriptor(_class24.prototype, "transform", [_dec6], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class24)) || _class5);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/passes/RenderPass.js
function _createForOfIteratorHelper3(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray4(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e8(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e8(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray4(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray4(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray4(o2, minLen);
}
function _arrayLikeToArray4(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var import_regenerator6, _dec7, _dec25, _dec35, _dec44, _dec53, _dec62, _dec72, _dec8, _dec9, _dec10, _dec11, _class6, _class25, _descriptor6, _descriptor25, _descriptor34, _descriptor43, _descriptor52, _descriptor62, _descriptor7, _descriptor8, _descriptor9, _class32, _temp5, RenderPass;
var init_RenderPass = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/passes/RenderPass.js"() {
    import_regenerator6 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_esm2();
    init_inversify();
    init_identifier();
    init_gl();
    RenderPass = (_dec7 = injectable(), _dec25 = inject(IDENTIFIER.MeshComponentManager), _dec35 = inject(IDENTIFIER.GeometryComponentManager), _dec44 = inject(IDENTIFIER.MaterialComponentManager), _dec53 = inject(IDENTIFIER.CullableComponentManager), _dec62 = inject(IDENTIFIER.TransformComponentManager), _dec72 = inject(IDENTIFIER.HierarchyComponentManager), _dec8 = inject(IDENTIFIER.Systems), _dec9 = named2(IDENTIFIER.FrameGraphSystem), _dec10 = inject(IDENTIFIER.RenderEngine), _dec11 = inject(IDENTIFIER.ResourcePool), _dec7(_class6 = (_class25 = (_temp5 = _class32 = function() {
      function RenderPass2() {
        var _this = this;
        _classCallCheck(this, RenderPass2);
        _initializerDefineProperty(this, "mesh", _descriptor6, this);
        _initializerDefineProperty(this, "geometry", _descriptor25, this);
        _initializerDefineProperty(this, "material", _descriptor34, this);
        _initializerDefineProperty(this, "cullable", _descriptor43, this);
        _initializerDefineProperty(this, "transform", _descriptor52, this);
        _initializerDefineProperty(this, "hierarchy", _descriptor62, this);
        _initializerDefineProperty(this, "frameGraphSystem", _descriptor7, this);
        _initializerDefineProperty(this, "engine", _descriptor8, this);
        _initializerDefineProperty(this, "resourcePool", _descriptor9, this);
        this.modelCache = {};
        this.setup = function(fg, passNode, pass) {
          var output = fg.createRenderTarget(passNode, "color buffer", {
            width: 1,
            height: 1,
            usage: gl.RENDER_ATTACHMENT | gl.SAMPLED | gl.COPY_SRC
          });
          pass.data = {
            output: passNode.write(fg, output)
          };
        };
        this.execute = function() {
          var _ref2 = _asyncToGenerator(import_regenerator6.default.mark(function _callee(fg, pass, views) {
            var resourceNode, framebuffer, _iterator, _step, view, canvas;
            return import_regenerator6.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    resourceNode = fg.getResourceNode(pass.data.output);
                    framebuffer = _this.resourcePool.getOrCreateResource(resourceNode.resource);
                    _iterator = _createForOfIteratorHelper3(views);
                    _context.prev = 3;
                    _iterator.s();
                  case 5:
                    if ((_step = _iterator.n()).done) {
                      _context.next = 11;
                      break;
                    }
                    view = _step.value;
                    _context.next = 9;
                    return _this.initView(view);
                  case 9:
                    _context.next = 5;
                    break;
                  case 11:
                    _context.next = 16;
                    break;
                  case 13:
                    _context.prev = 13;
                    _context.t0 = _context["catch"](3);
                    _iterator.e(_context.t0);
                  case 16:
                    _context.prev = 16;
                    _iterator.f();
                    return _context.finish(16);
                  case 19:
                    canvas = _this.engine.getCanvas();
                    framebuffer.resize({
                      width: canvas.width,
                      height: canvas.height
                    });
                    _this.engine.setScissor({
                      enable: false
                    });
                    _this.engine.clear({
                      framebuffer,
                      color: views[0].getClearColor(),
                      depth: 1
                    });
                    _this.engine.useFramebuffer(framebuffer, function() {
                      var _iterator2 = _createForOfIteratorHelper3(views), _step2;
                      try {
                        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                          var view2 = _step2.value;
                          _this.renderView(view2);
                        }
                      } catch (err) {
                        _iterator2.e(err);
                      } finally {
                        _iterator2.f();
                      }
                    });
                  case 24:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[3, 13, 16, 19]]);
          }));
          return function(_x, _x2, _x3) {
            return _ref2.apply(this, arguments);
          };
        }();
      }
      _createClass(RenderPass2, [{
        key: "renderView",
        value: function renderView(view) {
          var scene = view.getScene();
          var camera = view.getCamera();
          var viewMatrix = camera.getViewTransform();
          var viewProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), camera.getPerspective(), viewMatrix);
          camera.getFrustum().extractFromVPMatrix(viewProjectionMatrix);
          var _view$getViewport = view.getViewport(), x2 = _view$getViewport.x, y2 = _view$getViewport.y, width = _view$getViewport.width, height = _view$getViewport.height;
          this.engine.viewport({
            x: x2,
            y: y2,
            width,
            height
          });
          var _iterator3 = _createForOfIteratorHelper3(scene.getEntities()), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var meshEntity = _step3.value;
              this.renderMesh(meshEntity, {
                camera,
                view,
                viewMatrix
              });
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      }, {
        key: "renderMesh",
        value: function renderMesh(meshEntity, _ref2) {
          var camera = _ref2.camera, view = _ref2.view, viewMatrix = _ref2.viewMatrix;
          var mesh = this.mesh.getComponentByEntity(meshEntity);
          if (!mesh || !mesh.visible) {
            return;
          }
          var material = mesh.material;
          var geometry = mesh.geometry;
          if (!geometry || geometry.dirty || !material) {
            return;
          }
          var transform14 = this.transform.getComponentByEntity(meshEntity);
          var modelViewMatrix = mat4_exports.multiply(mat4_exports.create(), viewMatrix, transform14.worldTransform);
          var _view$getViewport2 = view.getViewport(), width = _view$getViewport2.width, height = _view$getViewport2.height;
          material.setUniform({
            projectionMatrix: camera.getPerspective(),
            modelViewMatrix,
            modelMatrix: transform14.worldTransform,
            viewMatrix,
            cameraPosition: camera.getPosition(),
            u_viewport: [width, height]
          });
          if (mesh.model) {
            mesh.model.draw({
              uniforms: material.uniforms.reduce(function(cur, prev) {
                cur[prev.name] = prev.data;
                return cur;
              }, {})
            });
            material.uniforms.forEach(function(u2) {
              u2.dirty = false;
            });
            material.dirty = false;
          }
        }
      }, {
        key: "initMesh",
        value: function() {
          var _initMesh = _asyncToGenerator(import_regenerator6.default.mark(function _callee2(meshEntity, view) {
            var mesh, material, geometry, modelCacheKey, _this$engine, createModel, createAttribute, modelInitializationOptions;
            return import_regenerator6.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    mesh = this.mesh.getComponentByEntity(meshEntity);
                    if (mesh) {
                      _context2.next = 3;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 3:
                    material = mesh.material;
                    geometry = mesh.geometry;
                    if (!(!geometry || geometry.dirty || !material)) {
                      _context2.next = 7;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 7:
                    if (mesh.model) {
                      _context2.next = 24;
                      break;
                    }
                    modelCacheKey = "m-".concat(material.entity, "-g-").concat(geometry.entity);
                    if (!this.modelCache[modelCacheKey]) {
                      _context2.next = 12;
                      break;
                    }
                    mesh.model = this.modelCache[modelCacheKey];
                    return _context2.abrupt("return");
                  case 12:
                    material.setUniform({
                      projectionMatrix: 1,
                      modelViewMatrix: 1,
                      modelMatrix: 1,
                      viewMatrix: 1,
                      cameraPosition: 1,
                      u_viewport: 1
                    });
                    _this$engine = this.engine, createModel = _this$engine.createModel, createAttribute = _this$engine.createAttribute;
                    modelInitializationOptions = {
                      vs: material.vertexShaderGLSL,
                      fs: material.fragmentShaderGLSL,
                      defines: material.defines,
                      attributes: geometry.attributes.reduce(function(cur, prev) {
                        if (prev.data && prev.buffer) {
                          cur[prev.name] = createAttribute({
                            buffer: prev.buffer,
                            attributes: prev.attributes,
                            arrayStride: prev.arrayStride,
                            stepMode: prev.stepMode,
                            divisor: prev.stepMode === "vertex" ? 0 : 1
                          });
                        }
                        return cur;
                      }, {}),
                      uniforms: material.uniforms.reduce(function(cur, prev) {
                        cur[prev.name] = prev.data;
                        return cur;
                      }, {}),
                      scissor: {
                        enable: true,
                        box: function box2() {
                          return view.getViewport();
                        }
                      }
                    };
                    if (material.cull) {
                      modelInitializationOptions.cull = material.cull;
                    }
                    if (material.depth) {
                      modelInitializationOptions.depth = material.depth;
                    }
                    if (material.blend) {
                      modelInitializationOptions.blend = material.blend;
                    }
                    if (geometry.indicesBuffer) {
                      modelInitializationOptions.elements = geometry.indicesBuffer;
                    }
                    if (geometry.maxInstancedCount) {
                      modelInitializationOptions.instances = geometry.maxInstancedCount;
                      modelInitializationOptions.count = geometry.vertexCount || 3;
                    }
                    _context2.next = 22;
                    return createModel(modelInitializationOptions);
                  case 22:
                    mesh.model = _context2.sent;
                    this.modelCache[modelCacheKey] = mesh.model;
                  case 24:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function initMesh(_x4, _x5) {
            return _initMesh.apply(this, arguments);
          }
          return initMesh;
        }()
      }, {
        key: "initView",
        value: function() {
          var _initView = _asyncToGenerator(import_regenerator6.default.mark(function _callee3(view) {
            var scene, _iterator4, _step4, meshEntity;
            return import_regenerator6.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    scene = view.getScene();
                    _iterator4 = _createForOfIteratorHelper3(scene.getEntities());
                    _context3.prev = 2;
                    _iterator4.s();
                  case 4:
                    if ((_step4 = _iterator4.n()).done) {
                      _context3.next = 10;
                      break;
                    }
                    meshEntity = _step4.value;
                    _context3.next = 8;
                    return this.initMesh(meshEntity, view);
                  case 8:
                    _context3.next = 4;
                    break;
                  case 10:
                    _context3.next = 15;
                    break;
                  case 12:
                    _context3.prev = 12;
                    _context3.t0 = _context3["catch"](2);
                    _iterator4.e(_context3.t0);
                  case 15:
                    _context3.prev = 15;
                    _iterator4.f();
                    return _context3.finish(15);
                  case 18:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this, [[2, 12, 15, 18]]);
          }));
          function initView(_x6) {
            return _initView.apply(this, arguments);
          }
          return initView;
        }()
      }]);
      return RenderPass2;
    }(), _class32.IDENTIFIER = "Render Pass", _temp5), _descriptor6 = _applyDecoratedDescriptor(_class25.prototype, "mesh", [_dec25], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor25 = _applyDecoratedDescriptor(_class25.prototype, "geometry", [_dec35], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor34 = _applyDecoratedDescriptor(_class25.prototype, "material", [_dec44], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor43 = _applyDecoratedDescriptor(_class25.prototype, "cullable", [_dec53], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor52 = _applyDecoratedDescriptor(_class25.prototype, "transform", [_dec62], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor62 = _applyDecoratedDescriptor(_class25.prototype, "hierarchy", [_dec72], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor7 = _applyDecoratedDescriptor(_class25.prototype, "frameGraphSystem", [_dec8, _dec9], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor8 = _applyDecoratedDescriptor(_class25.prototype, "engine", [_dec10], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor9 = _applyDecoratedDescriptor(_class25.prototype, "resourcePool", [_dec11], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class25)) || _class6);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/passes/PixelPickingPass.js
function _createForOfIteratorHelper4(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray5(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e8(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e8(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray5(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray5(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray5(o2, minLen);
}
function _arrayLikeToArray5(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var import_regenerator7, _dec12, _dec26, _dec36, _dec45, _dec54, _class7, _class26, _descriptor10, _descriptor26, _descriptor35, _descriptor44, _class33, _temp6, PickingStage, PixelPickingPass;
var init_PixelPickingPass = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/passes/PixelPickingPass.js"() {
    import_regenerator7 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_identifier();
    init_math();
    init_RenderPass();
    PickingStage = {
      NONE: 0,
      ENCODE: 1,
      HIGHLIGHT: 2
    };
    PixelPickingPass = (_dec12 = injectable(), _dec26 = inject(IDENTIFIER.RenderEngine), _dec36 = inject(IDENTIFIER.ResourcePool), _dec45 = inject(IDENTIFIER.RenderPassFactory), _dec54 = inject(IDENTIFIER.MeshComponentManager), _dec12(_class7 = (_class26 = (_temp6 = _class33 = function() {
      function PixelPickingPass2() {
        var _this = this;
        _classCallCheck(this, PixelPickingPass2);
        _initializerDefineProperty(this, "engine", _descriptor10, this);
        _initializerDefineProperty(this, "resourcePool", _descriptor26, this);
        _initializerDefineProperty(this, "renderPassFactory", _descriptor35, this);
        _initializerDefineProperty(this, "mesh", _descriptor44, this);
        this.pickingFBO = void 0;
        this.views = void 0;
        this.highlightEnabled = true;
        this.highlightColor = [255, 0, 0, 255];
        this.alreadyInRendering = false;
        this.setup = function(fg, passNode, pass) {
          var output = fg.createRenderTarget(passNode, "picking fbo", {
            width: 1,
            height: 1
          });
          pass.data = {
            output: passNode.write(fg, output)
          };
          passNode.hasSideEffect = true;
        };
        this.execute = function() {
          var _ref2 = _asyncToGenerator(import_regenerator7.default.mark(function _callee(fg, pass, views) {
            var _iterator, _step, _loop;
            return import_regenerator7.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this.views = views;
                    if (!_this.alreadyInRendering) {
                      _context.next = 3;
                      break;
                    }
                    return _context.abrupt("return");
                  case 3:
                    _iterator = _createForOfIteratorHelper4(views);
                    try {
                      _loop = function _loop2() {
                        var view = _step.value;
                        var _view$getViewport = view.getViewport(), width = _view$getViewport.width, height = _view$getViewport.height;
                        _this.alreadyInRendering = true;
                        var resourceNode = fg.getResourceNode(pass.data.output);
                        _this.pickingFBO = _this.resourcePool.getOrCreateResource(resourceNode.resource);
                        _this.pickingFBO.resize({
                          width,
                          height
                        });
                        _this.engine.useFramebuffer(_this.pickingFBO, function() {
                          _this.engine.clear({
                            framebuffer: _this.pickingFBO,
                            color: [0, 0, 0, 0],
                            stencil: 0,
                            depth: 1
                          });
                          var renderPass = _this.renderPassFactory(RenderPass.IDENTIFIER);
                          var meshes = [];
                          var scene = view.getScene();
                          var _iterator2 = _createForOfIteratorHelper4(scene.getEntities()), _step2;
                          try {
                            for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                              var meshEntity = _step2.value;
                              var mesh = _this.mesh.getComponentByEntity(meshEntity);
                              var material = mesh.material;
                              material.setUniform("u_PickingStage", PickingStage.ENCODE);
                              meshes.push(mesh);
                            }
                          } catch (err) {
                            _iterator2.e(err);
                          } finally {
                            _iterator2.f();
                          }
                          renderPass.renderView(view);
                          meshes.forEach(function(mesh2) {
                            var material2 = mesh2.material;
                            material2.setUniform("u_PickingStage", PickingStage.HIGHLIGHT);
                          });
                          _this.alreadyInRendering = false;
                        });
                      };
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        _loop();
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function(_x, _x2, _x3) {
            return _ref2.apply(this, arguments);
          };
        }();
        this.pick = function(_ref2, view) {
          var x2 = _ref2.x, y2 = _ref2.y;
          var _this$engine = _this.engine, readPixels = _this$engine.readPixels, useFramebuffer = _this$engine.useFramebuffer;
          var _view$getViewport2 = view.getViewport(), width = _view$getViewport2.width, height = _view$getViewport2.height;
          var xInDevicePixel = x2 * window.devicePixelRatio;
          var yInDevicePixel = y2 * window.devicePixelRatio;
          if (xInDevicePixel > width || xInDevicePixel < 0 || yInDevicePixel > height || yInDevicePixel < 0) {
            return;
          }
          var pickedColors;
          var pickedFeatureIdx;
          useFramebuffer(_this.pickingFBO, function() {
            pickedColors = readPixels({
              x: Math.round(xInDevicePixel),
              y: Math.round(height - (y2 + 1) * window.devicePixelRatio),
              width: 1,
              height: 1,
              data: new Uint8Array(1 * 1 * 4),
              framebuffer: _this.pickingFBO
            });
            if (pickedColors[0] !== 0 || pickedColors[1] !== 0 || pickedColors[2] !== 0) {
              pickedFeatureIdx = decodePickingColor(pickedColors);
              if (_this.highlightEnabled) {
                _this.highlightPickedFeature(pickedColors, view);
              }
            }
          });
          return pickedFeatureIdx;
        };
      }
      _createClass(PixelPickingPass2, [{
        key: "enableHighlight",
        value: function enableHighlight(enabled) {
          this.highlightEnabled = enabled;
        }
      }, {
        key: "setHighlightColor",
        value: function setHighlightColor(color3) {
          this.highlightColor = color3;
        }
      }, {
        key: "highlightPickedFeature",
        value: function highlightPickedFeature(pickedColors, view) {
          if (pickedColors) {
            var _iterator3 = _createForOfIteratorHelper4(view.getScene().getEntities()), _step3;
            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                var meshEntity = _step3.value;
                var mesh = this.mesh.getComponentByEntity(meshEntity);
                var material = mesh.material;
                material.setUniform("u_PickingStage", PickingStage.HIGHLIGHT);
                material.setUniform("u_PickingColor", [pickedColors[0], pickedColors[1], pickedColors[2]]);
                material.setUniform("u_HighlightColor", this.highlightColor);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        }
      }]);
      return PixelPickingPass2;
    }(), _class33.IDENTIFIER = "PixelPicking Pass", _temp6), _descriptor10 = _applyDecoratedDescriptor(_class26.prototype, "engine", [_dec26], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor26 = _applyDecoratedDescriptor(_class26.prototype, "resourcePool", [_dec36], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor35 = _applyDecoratedDescriptor(_class26.prototype, "renderPassFactory", [_dec45], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor44 = _applyDecoratedDescriptor(_class26.prototype, "mesh", [_dec54], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class26)) || _class7);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/passes/CopyPass.js
var import_regenerator8, _dec13, _dec27, _dec37, _class8, _class27, _descriptor11, _descriptor27, _class34, _temp7, copyFrag, copyVert, copyFragWebGPU, copyVertWebGPU, CopyPass;
var init_CopyPass = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/passes/CopyPass.js"() {
    import_regenerator8 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_identifier();
    init_gl();
    init_RenderPass();
    copyFrag = "varying vec2 v_UV;\n\nuniform sampler2D u_Texture;\n\nvoid main() {\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\n}";
    copyVert = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
    copyFragWebGPU = "layout(set = 0, binding = 0) uniform sampler u_TextureSampler;\nlayout(set = 0, binding = 1) uniform texture2D u_Texture;\n\nlayout(location = 0) in vec2 v_UV;\nlayout(location = 0) out vec4 outColor;\n\nvoid main() {\n  outColor = texture(sampler2D(u_Texture, u_TextureSampler), v_UV);\n}";
    copyVertWebGPU = "layout(location = 0) in vec2 a_Position;\nlayout(location = 0) out vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
    CopyPass = (_dec13 = injectable(), _dec27 = inject(IDENTIFIER.RenderEngine), _dec37 = inject(IDENTIFIER.ResourcePool), _dec13(_class8 = (_class27 = (_temp7 = _class34 = function CopyPass2() {
      var _this = this;
      _classCallCheck(this, CopyPass2);
      _initializerDefineProperty(this, "engine", _descriptor11, this);
      _initializerDefineProperty(this, "resourcePool", _descriptor27, this);
      this.model = void 0;
      this.setup = function(fg, passNode, pass) {
        var renderPass = fg.getPass(RenderPass.IDENTIFIER);
        if (renderPass) {
          var output = fg.createRenderTarget(passNode, "render to screen", {
            width: 1,
            height: 1
          });
          pass.data = {
            input: passNode.read(renderPass.data.output),
            output: passNode.write(fg, output)
          };
        }
      };
      this.execute = function() {
        var _ref2 = _asyncToGenerator(import_regenerator8.default.mark(function _callee(fg, pass) {
          var _this$engine, createModel, createAttribute, createBuffer, model, resourceNode, framebuffer;
          return import_regenerator8.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _this$engine = _this.engine, createModel = _this$engine.createModel, createAttribute = _this$engine.createAttribute, createBuffer = _this$engine.createBuffer;
                  if (_this.model) {
                    _context.next = 6;
                    break;
                  }
                  _context.next = 4;
                  return createModel({
                    vs: _this.engine.supportWebGPU ? copyVertWebGPU : copyVert,
                    fs: _this.engine.supportWebGPU ? copyFragWebGPU : copyFrag,
                    attributes: {
                      a_Position: createAttribute({
                        buffer: createBuffer({
                          data: [-4, -4, 4, -4, 0, 4],
                          type: gl.FLOAT
                        }),
                        size: 2,
                        arrayStride: 2 * 4,
                        stepMode: "vertex",
                        attributes: [{
                          shaderLocation: 0,
                          offset: 0,
                          format: "float2"
                        }]
                      })
                    },
                    uniforms: {
                      u_Texture: null
                    },
                    depth: {
                      enable: false
                    },
                    count: 3,
                    blend: {
                      enable: true
                    }
                  });
                case 4:
                  model = _context.sent;
                  _this.model = model;
                case 6:
                  resourceNode = fg.getResourceNode(pass.data.input);
                  framebuffer = _this.resourcePool.getOrCreateResource(resourceNode.resource);
                  _this.engine.useFramebuffer(null, function() {
                    _this.engine.clear({
                      framebuffer: null,
                      color: [0, 0, 0, 0],
                      depth: 1,
                      stencil: 0
                    });
                    _this.model.draw({
                      uniforms: {
                        u_Texture: framebuffer
                      }
                    });
                  });
                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function(_x, _x2) {
          return _ref2.apply(this, arguments);
        };
      }();
      this.tearDown = function() {
        _this.model = void 0;
      };
    }, _class34.IDENTIFIER = "Copy Pass", _temp7), _descriptor11 = _applyDecoratedDescriptor(_class27.prototype, "engine", [_dec27], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor27 = _applyDecoratedDescriptor(_class27.prototype, "resourcePool", [_dec37], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class27)) || _class8);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/System.js
var import_regenerator9, _dec14, _dec28, _dec38, _dec46, _dec55, _dec63, _class9, _class28, _descriptor12, _descriptor28, _descriptor36, _descriptor45, _temp8, RendererSystem;
var init_System5 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/System.js"() {
    import_regenerator9 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_identifier();
    init_CopyPass();
    init_PixelPickingPass();
    init_RenderPass();
    RendererSystem = (_dec14 = injectable(), _dec28 = inject(IDENTIFIER.Systems), _dec38 = named2(IDENTIFIER.FrameGraphSystem), _dec46 = inject(IDENTIFIER.RenderPassFactory), _dec55 = inject(IDENTIFIER.ConfigService), _dec63 = inject(IDENTIFIER.ResourcePool), _dec14(_class9 = (_class28 = (_temp8 = function() {
      function RendererSystem2() {
        _classCallCheck(this, RendererSystem2);
        _initializerDefineProperty(this, "frameGraphSystem", _descriptor12, this);
        _initializerDefineProperty(this, "renderPassFactory", _descriptor28, this);
        _initializerDefineProperty(this, "configService", _descriptor36, this);
        _initializerDefineProperty(this, "resourcePool", _descriptor45, this);
      }
      _createClass(RendererSystem2, [{
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator9.default.mark(function _callee(views) {
            var _this$renderPassFacto, setupRenderPass, executeRenderPass, renderPass, _this$renderPassFacto2, setupCopyPass, executeCopyPass, tearDownCopyPass, copyPass;
            return import_regenerator9.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this$renderPassFacto = this.renderPassFactory(RenderPass.IDENTIFIER), setupRenderPass = _this$renderPassFacto.setup, executeRenderPass = _this$renderPassFacto.execute;
                    renderPass = this.frameGraphSystem.addPass(RenderPass.IDENTIFIER, setupRenderPass, executeRenderPass);
                    _this$renderPassFacto2 = this.renderPassFactory(CopyPass.IDENTIFIER), setupCopyPass = _this$renderPassFacto2.setup, executeCopyPass = _this$renderPassFacto2.execute, tearDownCopyPass = _this$renderPassFacto2.tearDown;
                    copyPass = this.frameGraphSystem.addPass(CopyPass.IDENTIFIER, setupCopyPass, executeCopyPass, tearDownCopyPass);
                    this.frameGraphSystem.present(copyPass.data.output);
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute(_x) {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.resourcePool.clean();
        }
      }, {
        key: "pick",
        value: function pick(position, view) {
          var pickingPass = this.renderPassFactory(PixelPickingPass.IDENTIFIER);
          return pickingPass.pick(position, view);
        }
      }]);
      return RendererSystem2;
    }(), _temp8), _descriptor12 = _applyDecoratedDescriptor(_class28.prototype, "frameGraphSystem", [_dec28, _dec38], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor28 = _applyDecoratedDescriptor(_class28.prototype, "renderPassFactory", [_dec46], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor36 = _applyDecoratedDescriptor(_class28.prototype, "configService", [_dec55], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor45 = _applyDecoratedDescriptor(_class28.prototype, "resourcePool", [_dec63], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class28)) || _class9);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/scenegraph/HierarchyComponent.js
function _createSuper7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var HierarchyComponent;
var init_HierarchyComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/scenegraph/HierarchyComponent.js"() {
    init_classCallCheck();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_ComponentManager();
    HierarchyComponent = function(_Component) {
      _inherits2(HierarchyComponent2, _Component);
      var _super = _createSuper7(HierarchyComponent2);
      function HierarchyComponent2(data) {
        var _this;
        _classCallCheck(this, HierarchyComponent2);
        _this = _super.call(this, data);
        _this.parentID = void 0;
        Object.assign(_assertThisInitialized2(_this), data);
        return _this;
      }
      return HierarchyComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/scenegraph/System.js
var import_regenerator10, _dec15, _dec29, _dec39, _dec47, _class10, _class29, _descriptor13, _descriptor29, _descriptor37, _temp9, SceneGraphSystem;
var init_System6 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/scenegraph/System.js"() {
    import_regenerator10 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_esm2();
    init_inversify();
    init_identifier();
    SceneGraphSystem = (_dec15 = injectable(), _dec29 = inject(IDENTIFIER.HierarchyComponentManager), _dec39 = inject(IDENTIFIER.TransformComponentManager), _dec47 = inject(IDENTIFIER.MeshComponentManager), _dec15(_class10 = (_class29 = (_temp9 = function() {
      function SceneGraphSystem2() {
        _classCallCheck(this, SceneGraphSystem2);
        _initializerDefineProperty(this, "hierarchy", _descriptor13, this);
        _initializerDefineProperty(this, "transform", _descriptor29, this);
        _initializerDefineProperty(this, "mesh", _descriptor37, this);
      }
      _createClass(SceneGraphSystem2, [{
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator10.default.mark(function _callee() {
            return import_regenerator10.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.runTransformUpdateSystem();
                    this.runHierarchyUpdateSystem();
                  case 2:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "tearDown",
        value: function tearDown() {
          this.hierarchy.clear();
          this.transform.clear();
        }
      }, {
        key: "getHierarchyComponentManager",
        value: function getHierarchyComponentManager() {
          return this.hierarchy;
        }
      }, {
        key: "getTransformComponentManager",
        value: function getTransformComponentManager() {
          return this.transform;
        }
      }, {
        key: "runTransformUpdateSystem",
        value: function runTransformUpdateSystem() {
          var _this = this;
          this.transform.forEach(function(entity, transform14) {
            if (transform14.isDirty() || transform14.isLocalDirty()) {
              _this.setMeshAABBDirty(_this.mesh.getComponentByEntity(entity));
              transform14.updateTransform();
            }
          });
        }
      }, {
        key: "runHierarchyUpdateSystem",
        value: function runHierarchyUpdateSystem() {
          var _this2 = this;
          this.hierarchy.forEach(function(entity, parentComponent) {
            var transformChild = _this2.transform.getComponentByEntity(entity);
            var transformParent = _this2.transform.getComponentByEntity(parentComponent.parentID);
            if (transformChild !== null && transformParent !== null) {
              transformChild.updateTransformWithParent(transformParent);
            }
          });
        }
      }, {
        key: "attach",
        value: function attach(entity, parent, isChildAlreadyInLocalSpace) {
          if (this.hierarchy.contains(entity)) {
            this.detach(entity);
          }
          this.hierarchy.create(entity, {
            parentID: parent
          });
          var mesh = this.mesh.getComponentByEntity(parent);
          this.setMeshAABBDirty(mesh);
          if (mesh && mesh.children.indexOf(entity) === -1) {
            mesh.children.push(entity);
          }
          if (this.hierarchy.getCount() > 1) {
            for (var i2 = this.hierarchy.getCount() - 1; i2 > 0; --i2) {
              var parentCandidateEntity = this.hierarchy.getEntity(i2);
              for (var j2 = 0; j2 < i2; ++j2) {
                var childCandidateEntity = this.hierarchy.getComponent(j2);
                if (childCandidateEntity.parentID === parentCandidateEntity) {
                  this.hierarchy.moveItem(i2, j2);
                  ++i2;
                  break;
                }
              }
            }
          }
          var parentcomponent = this.hierarchy.getComponentByEntity(entity);
          var transformParent = this.transform.getComponentByEntity(parent);
          if (transformParent === null) {
            transformParent = this.transform.create(parent);
          }
          var transformChild = this.transform.getComponentByEntity(entity);
          if (transformChild === null) {
            transformChild = this.transform.create(entity);
            transformParent = this.transform.getComponentByEntity(parent);
          }
          transformChild.parent = transformParent;
          if (!isChildAlreadyInLocalSpace && transformParent) {
            transformChild.matrixTransform(mat4_exports.invert(mat4_exports.create(), transformParent.worldTransform));
            transformChild.updateTransform();
          }
          if (transformParent) {
            transformChild.updateTransformWithParent(transformParent);
          }
        }
      }, {
        key: "detach",
        value: function detach(entity) {
          var self2 = this.hierarchy.getComponentByEntity(entity);
          if (self2 !== null) {
            var transform14 = this.transform.getComponentByEntity(entity);
            if (transform14 !== null) {
              transform14.parent = null;
              transform14.applyTransform();
            }
            this.hierarchy.removeKeepSorted(entity);
            var mesh = this.mesh.getComponentByEntity(self2.parentID);
            if (mesh) {
              var index = mesh.children.indexOf(entity);
              mesh.children.splice(index, 1);
            }
            this.setMeshAABBDirty(mesh);
          }
        }
      }, {
        key: "detachChildren",
        value: function detachChildren(parent) {
          var mesh = this.mesh.getComponentByEntity(parent);
          if (mesh) {
            mesh.children = [];
          }
          for (var i2 = 0; i2 < this.hierarchy.getCount(); ) {
            var _this$hierarchy$getCo;
            if (((_this$hierarchy$getCo = this.hierarchy.getComponent(i2)) === null || _this$hierarchy$getCo === void 0 ? void 0 : _this$hierarchy$getCo.parentID) === parent) {
              var entity = this.hierarchy.getEntity(i2);
              this.detach(entity);
            } else {
              ++i2;
            }
          }
        }
      }, {
        key: "setMeshAABBDirty",
        value: function setMeshAABBDirty(mesh) {
          if (mesh) {
            mesh.aabbDirty = true;
          }
        }
      }]);
      return SceneGraphSystem2;
    }(), _temp9), _descriptor13 = _applyDecoratedDescriptor(_class29.prototype, "hierarchy", [_dec29], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor29 = _applyDecoratedDescriptor(_class29.prototype, "transform", [_dec39], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor37 = _applyDecoratedDescriptor(_class29.prototype, "mesh", [_dec47], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class29)) || _class10);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/scenegraph/TransformComponent.js
function _createSuper8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var TransformComponent;
var init_TransformComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/scenegraph/TransformComponent.js"() {
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_esm2();
    init_ComponentManager();
    TransformComponent = function(_Component) {
      _inherits2(TransformComponent2, _Component);
      var _super = _createSuper8(TransformComponent2);
      function TransformComponent2(data) {
        var _this;
        _classCallCheck(this, TransformComponent2);
        _this = _super.call(this, data);
        _this.dirtyFlag = void 0;
        _this.localDirtyFlag = void 0;
        _this.parent = null;
        _this.localPosition = vec3_exports.fromValues(0, 0, 0);
        _this.localRotation = quat_exports.fromValues(0, 0, 0, 1);
        _this.localScale = vec3_exports.fromValues(1, 1, 1);
        _this.localTransform = mat4_exports.create();
        _this.position = vec3_exports.fromValues(0, 0, 0);
        _this.rotation = quat_exports.fromValues(0, 0, 0, 1);
        _this.scaling = vec3_exports.fromValues(1, 1, 1);
        _this.worldTransform = mat4_exports.create();
        _this.matrixTransform = function() {
          var transformed = mat4_exports.create();
          return function(mat) {
            mat4_exports.multiply(transformed, _this.getLocalTransform(), mat);
            mat4_exports.getScaling(_this.localScale, transformed);
            mat4_exports.getTranslation(_this.localPosition, transformed);
            mat4_exports.getRotation(_this.localRotation, transformed);
          };
        }();
        _this.rotateRollPitchYaw = function() {
          var quatX = quat_exports.create();
          var quatY = quat_exports.create();
          var quatZ = quat_exports.create();
          return function(x2, y2, z2) {
            _this.setDirty();
            quat_exports.fromEuler(quatX, x2, 0, 0);
            quat_exports.fromEuler(quatY, 0, y2, 0);
            quat_exports.fromEuler(quatZ, 0, 0, z2);
            quat_exports.multiply(_this.localRotation, quatX, _this.localRotation);
            quat_exports.multiply(_this.localRotation, _this.localRotation, quatY);
            quat_exports.multiply(_this.localRotation, quatZ, _this.localRotation);
            quat_exports.normalize(_this.localRotation, _this.localRotation);
          };
        }();
        _this.lerp = function() {
          var aS = vec3_exports.create();
          var aR = quat_exports.create();
          var aT = vec3_exports.create();
          var bS = vec3_exports.create();
          var bR = quat_exports.create();
          var bT = vec3_exports.create();
          return function(a2, b10, t4) {
            _this.setDirty();
            mat4_exports.getScaling(aS, a2.worldTransform);
            mat4_exports.getTranslation(aT, a2.worldTransform);
            mat4_exports.getRotation(aR, a2.worldTransform);
            mat4_exports.getScaling(bS, b10.worldTransform);
            mat4_exports.getTranslation(bT, b10.worldTransform);
            mat4_exports.getRotation(bR, b10.worldTransform);
            vec3_exports.lerp(_this.localScale, aS, bS, t4);
            quat_exports.slerp(_this.localRotation, aR, bR, t4);
            vec3_exports.lerp(_this.localPosition, aT, bT, t4);
          };
        }();
        _this.translate = function() {
          var tr2 = vec3_exports.create();
          return function(translation) {
            vec3_exports.add(tr2, _this.getPosition(), translation);
            _this.setPosition(tr2);
            _this.setDirty(true);
            return _assertThisInitialized2(_this);
          };
        }();
        _this.translateLocal = function() {
          return function(translation) {
            vec3_exports.transformQuat(translation, translation, _this.localRotation);
            vec3_exports.add(_this.localPosition, _this.localPosition, translation);
            _this.setLocalDirty(true);
            return _assertThisInitialized2(_this);
          };
        }();
        _this.setPosition = function() {
          var parentInvertMatrix = mat4_exports.create();
          return function(position) {
            _this.position = position;
            _this.setLocalDirty(true);
            if (_this.parent === null) {
              vec3_exports.copy(_this.localPosition, position);
            } else {
              mat4_exports.copy(parentInvertMatrix, _this.parent.worldTransform);
              mat4_exports.invert(parentInvertMatrix, parentInvertMatrix);
              vec3_exports.transformMat4(_this.localPosition, position, parentInvertMatrix);
            }
            return _assertThisInitialized2(_this);
          };
        }();
        _this.rotate = function() {
          var parentInvertRotation = quat_exports.create();
          return function(quaternion) {
            if (_this.parent === null) {
              quat_exports.multiply(_this.localRotation, _this.localRotation, quaternion);
              quat_exports.normalize(_this.localRotation, _this.localRotation);
            } else {
              var rot = _this.getRotation();
              var parentRot = _this.parent.getRotation();
              quat_exports.copy(parentInvertRotation, parentRot);
              quat_exports.invert(parentInvertRotation, parentInvertRotation);
              quat_exports.multiply(parentInvertRotation, parentInvertRotation, quaternion);
              quat_exports.multiply(_this.localRotation, quaternion, rot);
              quat_exports.normalize(_this.localRotation, _this.localRotation);
            }
            _this.setLocalDirty();
            return _assertThisInitialized2(_this);
          };
        }();
        _this.rotateLocal = function() {
          return function(quaternion) {
            quat_exports.multiply(_this.localRotation, _this.localRotation, quaternion);
            quat_exports.normalize(_this.localRotation, _this.localRotation);
            _this.setLocalDirty(true);
            return _assertThisInitialized2(_this);
          };
        }();
        _this.setRotation = function() {
          var invParentRot = quat_exports.create();
          return function(rotation) {
            if (_this.parent === null) {
              quat_exports.copy(_this.localRotation, rotation);
            } else {
              quat_exports.copy(invParentRot, _this.parent.getRotation());
              quat_exports.invert(invParentRot, invParentRot);
              quat_exports.copy(_this.localRotation, invParentRot);
              quat_exports.mul(_this.localRotation, _this.localRotation, rotation);
            }
            _this.setLocalDirty(true);
            return _assertThisInitialized2(_this);
          };
        }();
        return _this;
      }
      _createClass(TransformComponent2, [{
        key: "setLocalPosition",
        value: function setLocalPosition(position) {
          vec3_exports.copy(this.localPosition, position);
          this.setLocalDirty(true);
        }
      }, {
        key: "setLocalScale",
        value: function setLocalScale(scale9) {
          vec3_exports.copy(this.localScale, scale9);
          this.setLocalDirty(true);
        }
      }, {
        key: "setLocalRotation",
        value: function setLocalRotation(rotation) {
          quat_exports.copy(this.localRotation, rotation);
          this.setLocalDirty(true);
          return this;
        }
      }, {
        key: "isDirty",
        value: function isDirty() {
          return this.dirtyFlag;
        }
      }, {
        key: "setDirty",
        value: function setDirty() {
          var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (value) {
            this.dirtyFlag |= TransformComponent2.DIRTY;
          } else {
            this.dirtyFlag &= ~TransformComponent2.DIRTY;
          }
        }
      }, {
        key: "isLocalDirty",
        value: function isLocalDirty() {
          return this.localDirtyFlag;
        }
      }, {
        key: "setLocalDirty",
        value: function setLocalDirty() {
          var value = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
          if (value) {
            this.localDirtyFlag |= TransformComponent2.DIRTY;
            this.setDirty(true);
          } else {
            this.localDirtyFlag &= ~TransformComponent2.DIRTY;
          }
        }
      }, {
        key: "updateTransform",
        value: function updateTransform() {
          if (this.isLocalDirty()) {
            this.getLocalTransform();
          }
          if (this.isDirty()) {
            if (this.parent === null) {
              mat4_exports.copy(this.worldTransform, this.getLocalTransform());
              this.setDirty(false);
            }
          }
        }
      }, {
        key: "updateTransformWithParent",
        value: function updateTransformWithParent(parent) {
          mat4_exports.multiply(this.worldTransform, parent.worldTransform, this.getLocalTransform());
        }
      }, {
        key: "applyTransform",
        value: function applyTransform() {
          this.setDirty();
          mat4_exports.getScaling(this.localScale, this.worldTransform);
          mat4_exports.getTranslation(this.localPosition, this.worldTransform);
          mat4_exports.getRotation(this.localRotation, this.worldTransform);
        }
      }, {
        key: "clearTransform",
        value: function clearTransform() {
          this.setDirty();
          this.localPosition = vec3_exports.fromValues(0, 0, 0);
          this.localRotation = quat_exports.fromValues(0, 0, 0, 1);
          this.localScale = vec3_exports.fromValues(1, 1, 1);
        }
      }, {
        key: "scaleLocal",
        value: function scaleLocal(scaling) {
          this.setLocalDirty();
          vec3_exports.multiply(this.localScale, this.localScale, scaling);
          return this;
        }
      }, {
        key: "getLocalPosition",
        value: function getLocalPosition() {
          return this.localPosition;
        }
      }, {
        key: "getLocalRotation",
        value: function getLocalRotation() {
          return this.localRotation;
        }
      }, {
        key: "getLocalScale",
        value: function getLocalScale() {
          return this.localScale;
        }
      }, {
        key: "getLocalTransform",
        value: function getLocalTransform() {
          if (this.localDirtyFlag) {
            mat4_exports.fromRotationTranslationScale(this.localTransform, this.localRotation, this.localPosition, this.localScale);
            this.setLocalDirty(false);
          }
          return this.localTransform;
        }
      }, {
        key: "getWorldTransform",
        value: function getWorldTransform() {
          if (!this.isLocalDirty() && !this.isDirty()) {
            return this.worldTransform;
          }
          if (this.parent) {
            this.parent.getWorldTransform();
          }
          this.updateTransform();
          return this.worldTransform;
        }
      }, {
        key: "getPosition",
        value: function getPosition() {
          mat4_exports.getTranslation(this.position, this.worldTransform);
          return this.position;
        }
      }, {
        key: "getRotation",
        value: function getRotation2() {
          mat4_exports.getRotation(this.rotation, this.worldTransform);
          return this.rotation;
        }
      }, {
        key: "getScale",
        value: function getScale() {
          mat4_exports.getScaling(this.scaling, this.worldTransform);
          return this.scaling;
        }
      }]);
      return TransformComponent2;
    }(Component);
    TransformComponent.DIRTY = 1 << 0;
  }
});

// node_modules/inversify-inject-decorators/es/decorators.js
function _proxyGetter(proto, key, resolve2, doCache) {
  function getter() {
    if (doCache && !Reflect.hasMetadata(INJECTION, this, key)) {
      Reflect.defineMetadata(INJECTION, resolve2(), this, key);
    }
    if (Reflect.hasMetadata(INJECTION, this, key)) {
      return Reflect.getMetadata(INJECTION, this, key);
    } else {
      return resolve2();
    }
  }
  function setter(newVal) {
    Reflect.defineMetadata(INJECTION, newVal, this, key);
  }
  Object.defineProperty(proto, key, {
    configurable: true,
    enumerable: true,
    get: getter,
    set: setter
  });
}
function makePropertyInjectDecorator(container2, doCache) {
  return function(serviceIdentifier) {
    return function(proto, key) {
      var resolve2 = function() {
        return container2.get(serviceIdentifier);
      };
      _proxyGetter(proto, key, resolve2, doCache);
    };
  };
}
function makePropertyInjectNamedDecorator(container2, doCache) {
  return function(serviceIdentifier, named3) {
    return function(proto, key) {
      var resolve2 = function() {
        return container2.getNamed(serviceIdentifier, named3);
      };
      _proxyGetter(proto, key, resolve2, doCache);
    };
  };
}
function makePropertyInjectTaggedDecorator(container2, doCache) {
  return function(serviceIdentifier, key, value) {
    return function(proto, propertyName) {
      var resolve2 = function() {
        return container2.getTagged(serviceIdentifier, key, value);
      };
      _proxyGetter(proto, propertyName, resolve2, doCache);
    };
  };
}
function makePropertyMultiInjectDecorator(container2, doCache) {
  return function(serviceIdentifier) {
    return function(proto, key) {
      var resolve2 = function() {
        return container2.getAll(serviceIdentifier);
      };
      _proxyGetter(proto, key, resolve2, doCache);
    };
  };
}
var INJECTION;
var init_decorators = __esm({
  "node_modules/inversify-inject-decorators/es/decorators.js"() {
    INJECTION = Symbol.for("INJECTION");
  }
});

// node_modules/inversify-inject-decorators/es/index.js
function getDecorators(container2, doCache) {
  if (doCache === void 0) {
    doCache = true;
  }
  var lazyInject2 = makePropertyInjectDecorator(container2, doCache);
  var lazyInjectNamed = makePropertyInjectNamedDecorator(container2, doCache);
  var lazyInjectTagged = makePropertyInjectTaggedDecorator(container2, doCache);
  var lazyMultiInject2 = makePropertyMultiInjectDecorator(container2, doCache);
  return {
    lazyInject: lazyInject2,
    lazyInjectNamed,
    lazyInjectTagged,
    lazyMultiInject: lazyMultiInject2
  };
}
var es_default3;
var init_es2 = __esm({
  "node_modules/inversify-inject-decorators/es/index.js"() {
    init_decorators();
    es_default3 = getDecorators;
  }
});

// node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourcePool.js
var _dec16, _dec210, _class11, _class210, _descriptor14, _temp10, ResourcePool;
var init_ResourcePool = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/framegraph/ResourcePool.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_inversify();
    init_identifier();
    init_gl();
    ResourcePool = (_dec16 = injectable(), _dec210 = inject(IDENTIFIER.RenderEngine), _dec16(_class11 = (_class210 = (_temp10 = function() {
      function ResourcePool2() {
        _classCallCheck(this, ResourcePool2);
        _initializerDefineProperty(this, "engine", _descriptor14, this);
        this.resourcePool = {};
      }
      _createClass(ResourcePool2, [{
        key: "getOrCreateResource",
        value: function getOrCreateResource(resource) {
          if (!this.resourcePool[resource.name]) {
            var _resource$descriptor = resource.descriptor, width = _resource$descriptor.width, height = _resource$descriptor.height, usage = _resource$descriptor.usage;
            this.resourcePool[resource.name] = this.engine.createFramebuffer({
              color: this.engine.createTexture2D({
                width,
                height,
                wrapS: gl.CLAMP_TO_EDGE,
                wrapT: gl.CLAMP_TO_EDGE,
                usage
              })
            });
          }
          return this.resourcePool[resource.name];
        }
      }, {
        key: "clean",
        value: function clean() {
          this.resourcePool = {};
        }
      }]);
      return ResourcePool2;
    }(), _temp10), _descriptor14 = _applyDecoratedDescriptor(_class210.prototype, "engine", [_dec210], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class210)) || _class11);
  }
});

// node_modules/@antv/g-webgpu-core/es/components/scenegraph/NameComponent.js
function _createSuper9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var NameComponent;
var init_NameComponent = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/scenegraph/NameComponent.js"() {
    init_classCallCheck();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_ComponentManager();
    NameComponent = function(_Component) {
      _inherits2(NameComponent2, _Component);
      var _super = _createSuper9(NameComponent2);
      function NameComponent2(data) {
        var _this;
        _classCallCheck(this, NameComponent2);
        _this = _super.call(this, data);
        _this.name = void 0;
        _this.name = data.name || "";
        return _this;
      }
      return NameComponent2;
    }(Component);
  }
});

// node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js
var _dec17, _class12, _temp11, ConfigService;
var init_ConfigService = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/config/ConfigService.js"() {
    init_classCallCheck();
    init_createClass();
    init_inversify();
    ConfigService = (_dec17 = injectable(), _dec17(_class12 = (_temp11 = function() {
      function ConfigService2() {
        _classCallCheck(this, ConfigService2);
        this.config = void 0;
      }
      _createClass(ConfigService2, [{
        key: "get",
        value: function get2() {
          return this.config;
        }
      }, {
        key: "set",
        value: function set8(config) {
          this.config = config;
        }
      }]);
      return ConfigService2;
    }(), _temp11)) || _class12);
  }
});

// node_modules/@antv/g-webgpu-core/es/services/interactor/IteractorService.js
var _dec18, _class13, IInteractorEvent, InteractorService;
var init_IteractorService = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/interactor/IteractorService.js"() {
    init_classCallCheck();
    init_createClass();
    init_inversify();
    (function(IInteractorEvent2) {
      IInteractorEvent2["PANSTART"] = "PANSTART";
      IInteractorEvent2["PANEND"] = "PANEND";
      IInteractorEvent2["PANMOVE"] = "PANMOVE";
      IInteractorEvent2["PINCH"] = "PINCH";
      IInteractorEvent2["KEYDOWN"] = "KEYDOWN";
      IInteractorEvent2["KEYUP"] = "KEYUP";
      IInteractorEvent2["HOVER"] = "HOVER";
    })(IInteractorEvent || (IInteractorEvent = {}));
    InteractorService = (_dec18 = injectable(), _dec18(_class13 = function() {
      function InteractorService2() {
        _classCallCheck(this, InteractorService2);
      }
      _createClass(InteractorService2, [{
        key: "listen",
        value: function listen(canvas) {
        }
      }, {
        key: "on",
        value: function on2(event, args) {
        }
      }, {
        key: "connect",
        value: function connect() {
        }
      }, {
        key: "disconnect",
        value: function disconnect() {
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }]);
      return InteractorService2;
    }()) || _class13);
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/shader-module.js
function getUniformLengthByType(type) {
  var arrayLength = 0;
  switch (type) {
    case "vec2":
    case "ivec2":
      arrayLength = 2;
      break;
    case "vec3":
    case "ivec3":
      arrayLength = 3;
      break;
    case "vec4":
    case "ivec4":
    case "mat2":
      arrayLength = 4;
      break;
    case "mat3":
      arrayLength = 9;
      break;
    case "mat4":
      arrayLength = 16;
      break;
    default:
  }
  return arrayLength;
}
function extractUniforms(content) {
  var uniforms = {};
  content = content.replace(uniformRegExp, function(_2, type, c2) {
    var defaultValues = c2.split(":");
    var uniformName = defaultValues[0].trim();
    var defaultValue = "";
    if (defaultValues.length > 1) {
      defaultValue = defaultValues[1].trim();
    }
    switch (type) {
      case "bool":
        defaultValue = defaultValue === "true";
        break;
      case "float":
      case "int":
        defaultValue = Number(defaultValue);
        break;
      case "vec2":
      case "vec3":
      case "vec4":
      case "ivec2":
      case "ivec3":
      case "ivec4":
      case "mat2":
      case "mat3":
      case "mat4":
        if (defaultValue) {
          defaultValue = defaultValue.replace("[", "").replace("]", "").split(",").reduce(function(prev, cur) {
            prev.push(Number(cur.trim()));
            return prev;
          }, []);
        } else {
          defaultValue = new Array(getUniformLengthByType(type)).fill(0);
        }
        break;
      default:
    }
    uniforms[uniformName] = defaultValue;
    return "uniform ".concat(type, " ").concat(uniformName, ";\n");
  });
  return {
    content,
    uniforms
  };
}
var uniformRegExp;
var init_shader_module = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/shader-module.js"() {
    uniformRegExp = /uniform\s+(bool|float|int|vec2|vec3|vec4|ivec2|ivec3|ivec4|mat2|mat3|mat4|sampler2D|samplerCube)\s+([\s\S]*?);/g;
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/uniq.js
function uniq2(array) {
  return array.filter(function(v2, i2, a2) {
    return a2.indexOf(v2) === i2;
  });
}
var init_uniq2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/uniq.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/services/shader-module/ShaderModuleService.js
function ownKeys5(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread5(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var _dec19, _class14, _temp12, pickingFrag, pickingVert, sdf2dFrag, precisionRegExp, globalDefaultprecision, includeRegExp, ShaderModuleService;
var init_ShaderModuleService = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/shader-module/ShaderModuleService.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_inversify();
    init_shader_module();
    init_uniq2();
    pickingFrag = "varying vec4 v_PickingResult;\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\nuniform float u_PickingStage : 0.0;\n\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 filterHighlightColor(vec4 color) {\n  bool selected = bool(v_PickingResult.a);\n\n  if (selected) {\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\n\n    float highLightAlpha = highLightColor.a;\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\n\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\n    return vec4(resultRGB, color.a);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 filterPickingColor(vec4 color) {\n  vec3 pickingColor = v_PickingResult.rgb;\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 filterColor(vec4 color) {\n  return filterPickingColor(filterHighlightColor(color));\n}\n";
    pickingVert = "attribute vec3 a_PickingColor;\nvarying vec4 v_PickingResult;\n\nuniform vec3 u_PickingColor : [0, 0, 0];\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\nuniform float u_PickingStage : 0.0;\nuniform float u_PickingThreshold : 1.0;\nuniform float u_PickingBuffer: 0.0;\n\n#define PICKING_ENCODE 1.0\n#define PICKING_HIGHLIGHT 2.0\n#define COLOR_SCALE 1. / 255.\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    abs(vertexColor.r - u_PickingColor.r) < u_PickingThreshold &&\n    abs(vertexColor.g - u_PickingColor.g) < u_PickingThreshold &&\n    abs(vertexColor.b - u_PickingColor.b) < u_PickingThreshold;\n}\n\nvoid setPickingColor(vec3 pickingColor) {\n  // compares only in highlight stage\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nfloat setPickingSize(float x) {\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\n}";
    sdf2dFrag = "/**\n * 2D signed distance field functions\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n */\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCircle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdEquilateralTriangle(vec2 p) {\n  float k = sqrt(3.0);\n  p.x = abs(p.x) - 1.0;\n  p.y = p.y + 1.0/k;\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n  p.x -= clamp( p.x, -2.0, 0.0 );\n  return -length(p)*sign(p.y);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPentagon(vec2 p, float r) {\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n  p.x = abs(p.x);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagon(vec2 p, float r) {\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdOctogon(vec2 p, float r) {\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n  p = abs(p);\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdHexagram(vec2 p, float r) {\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n  return length(p)*sign(p.y);\n}\n\nfloat sdRhombus(vec2 p, vec2 b) {\n  vec2 q = abs(p);\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdVesica(vec2 p, float r, float d) {\n  p = abs(p);\n  float b = sqrt(r*r-d*d); // can delay this sqrt\n  return ((p.y-b)*d>p.x*b)\n          ? length(p-vec2(0.0,b))\n          : length(p-vec2(-d,0.0))-r;\n}";
    precisionRegExp = /precision\s+(high|low|medium)p\s+float/;
    globalDefaultprecision = "#ifdef GL_FRAGMENT_PRECISION_HIGH\n precision highp float;\n #else\n precision mediump float;\n#endif\n";
    includeRegExp = /#pragma include (["^+"]?["\ "[a-zA-Z_0-9](.*)"]*?)/g;
    ShaderModuleService = (_dec19 = injectable(), _dec19(_class14 = (_temp12 = function() {
      function ShaderModuleService2() {
        _classCallCheck(this, ShaderModuleService2);
        this.moduleCache = {};
        this.rawContentCache = {};
      }
      _createClass(ShaderModuleService2, [{
        key: "registerBuiltinModules",
        value: function registerBuiltinModules() {
          this.destroy();
          this.registerModule("picking", {
            vs: pickingVert,
            fs: pickingFrag
          });
          this.registerModule("sdf2d", {
            vs: "",
            fs: sdf2dFrag
          });
        }
      }, {
        key: "registerModule",
        value: function registerModule(moduleName, moduleParams) {
          if (this.rawContentCache[moduleName]) {
            return;
          }
          var _moduleParams$vs = moduleParams.vs, vs = _moduleParams$vs === void 0 ? "" : _moduleParams$vs, _moduleParams$fs = moduleParams.fs, fs = _moduleParams$fs === void 0 ? "" : _moduleParams$fs, declaredUniforms = moduleParams.uniforms;
          var _extractUniforms = extractUniforms(vs), extractedVS = _extractUniforms.content, vsUniforms = _extractUniforms.uniforms;
          var _extractUniforms2 = extractUniforms(fs), extractedFS = _extractUniforms2.content, fsUniforms = _extractUniforms2.uniforms;
          this.rawContentCache[moduleName] = {
            fs: extractedFS,
            uniforms: _objectSpread5(_objectSpread5(_objectSpread5({}, vsUniforms), fsUniforms), declaredUniforms),
            vs: extractedVS
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.moduleCache = {};
          this.rawContentCache = {};
        }
      }, {
        key: "getModule",
        value: function getModule(moduleName) {
          var _this = this;
          if (this.moduleCache[moduleName]) {
            return this.moduleCache[moduleName];
          }
          var rawVS = this.rawContentCache[moduleName].vs || "";
          var rawFS = this.rawContentCache[moduleName].fs || "";
          var _this$processModule = this.processModule(rawVS, [], "vs"), vs = _this$processModule.content, vsIncludeList = _this$processModule.includeList;
          var _this$processModule2 = this.processModule(rawFS, [], "fs"), fs = _this$processModule2.content, fsIncludeList = _this$processModule2.includeList;
          var compiledFs = fs;
          var uniforms = uniq2(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function(prev, cur) {
            return _objectSpread5(_objectSpread5({}, prev), _this.rawContentCache[cur].uniforms);
          }, {});
          if (!precisionRegExp.test(fs)) {
            compiledFs = globalDefaultprecision + fs;
          }
          this.moduleCache[moduleName] = {
            fs: compiledFs.trim(),
            uniforms,
            vs: vs.trim()
          };
          return this.moduleCache[moduleName];
        }
      }, {
        key: "processModule",
        value: function processModule(rawContent, includeList, type) {
          var _this2 = this;
          var compiled = rawContent.replace(includeRegExp, function(_2, strMatch) {
            var includeOpt = strMatch.split(" ");
            var includeName = includeOpt[0].replace(/"/g, "");
            if (includeList.indexOf(includeName) > -1) {
              return "";
            }
            var txt = _this2.rawContentCache[includeName][type];
            includeList.push(includeName);
            var _this2$processModule = _this2.processModule(txt || "", includeList, type), content = _this2$processModule.content;
            return content;
          });
          return {
            content: compiled,
            includeList
          };
        }
      }]);
      return ShaderModuleService2;
    }(), _temp12)) || _class14);
  }
});

// node_modules/@antv/g-webgpu-core/es/inversify.config.js
function createWorldContainer() {
  var worldContainer = new Container2();
  worldContainer.parent = container;
  worldContainer.bind(IDENTIFIER.Systems).to(SceneGraphSystem).inSingletonScope().whenTargetNamed(IDENTIFIER.SceneGraphSystem);
  worldContainer.bind(IDENTIFIER.Systems).to(FrameGraphSystem).inSingletonScope().whenTargetNamed(IDENTIFIER.FrameGraphSystem);
  worldContainer.bind(IDENTIFIER.Systems).to(MeshSystem).inSingletonScope().whenTargetNamed(IDENTIFIER.MeshSystem);
  worldContainer.bind(IDENTIFIER.Systems).to(GeometrySystem).inSingletonScope().whenTargetNamed(IDENTIFIER.GeometrySystem);
  worldContainer.bind(IDENTIFIER.Systems).to(MaterialSystem).inSingletonScope().whenTargetNamed(IDENTIFIER.MaterialSystem);
  worldContainer.bind(IDENTIFIER.Systems).to(RendererSystem).inSingletonScope().whenTargetNamed(IDENTIFIER.RendererSystem);
  worldContainer.bind(IDENTIFIER.ResourcePool).to(ResourcePool).inSingletonScope();
  worldContainer.bind(IDENTIFIER.ConfigService).to(ConfigService).inSingletonScope();
  worldContainer.bind(IDENTIFIER.InteractorService).to(InteractorService).inSingletonScope();
  worldContainer.bind(IDENTIFIER.RenderPass).to(RenderPass).inSingletonScope().whenTargetNamed(RenderPass.IDENTIFIER);
  worldContainer.bind(IDENTIFIER.RenderPass).to(CopyPass).inSingletonScope().whenTargetNamed(CopyPass.IDENTIFIER);
  worldContainer.bind(IDENTIFIER.RenderPass).to(PixelPickingPass).inSingletonScope().whenTargetNamed(PixelPickingPass.IDENTIFIER);
  worldContainer.bind(IDENTIFIER.RenderPassFactory).toFactory(function(context) {
    return function(name) {
      return context.container.getNamed(IDENTIFIER.RenderPass, name);
    };
  });
  return worldContainer;
}
var container, DECORATORS;
var init_inversify_config = __esm({
  "node_modules/@antv/g-webgpu-core/es/inversify.config.js"() {
    init_Reflect();
    init_inversify();
    init_es2();
    init_ComponentManager();
    init_ResourcePool();
    init_System();
    init_GeometryComponent();
    init_System2();
    init_MaterialComponent();
    init_System3();
    init_CullableComponent();
    init_MeshComponent();
    init_System4();
    init_CopyPass();
    init_PixelPickingPass();
    init_RenderPass();
    init_System5();
    init_HierarchyComponent();
    init_NameComponent();
    init_System6();
    init_TransformComponent();
    init_identifier();
    init_ConfigService();
    init_IteractorService();
    init_ShaderModuleService();
    container = new Container2();
    DECORATORS = es_default3(container, false);
    container.bind(IDENTIFIER.ShaderModuleService).to(ShaderModuleService).inSingletonScope();
    container.bind(IDENTIFIER.NameComponentManager).toConstantValue(new ComponentManager(NameComponent));
    container.bind(IDENTIFIER.HierarchyComponentManager).toConstantValue(new ComponentManager(HierarchyComponent));
    container.bind(IDENTIFIER.TransformComponentManager).toConstantValue(new ComponentManager(TransformComponent));
    container.bind(IDENTIFIER.MeshComponentManager).toConstantValue(new ComponentManager(MeshComponent));
    container.bind(IDENTIFIER.CullableComponentManager).toConstantValue(new ComponentManager(CullableComponent));
    container.bind(IDENTIFIER.GeometryComponentManager).toConstantValue(new ComponentManager(GeometryComponent));
    container.bind(IDENTIFIER.MaterialComponentManager).toConstantValue(new ComponentManager(MaterialComponent));
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/aabb.js
function generateAABBFromVertices(positions) {
  var aabb = new AABB();
  var min6 = vec3_exports.fromValues(positions[0], positions[1], positions[2]);
  var max7 = vec3_exports.fromValues(positions[0], positions[1], positions[2]);
  for (var i2 = 3; i2 < positions.length; ) {
    var x2 = positions[i2++];
    var y2 = positions[i2++];
    var z2 = positions[i2++];
    if (x2 < min6[0]) {
      min6[0] = x2;
    }
    if (y2 < min6[1]) {
      min6[1] = y2;
    }
    if (z2 < min6[2]) {
      min6[2] = z2;
    }
    if (x2 > max7[0]) {
      max7[0] = x2;
    }
    if (y2 > max7[1]) {
      max7[1] = y2;
    }
    if (z2 > max7[2]) {
      max7[2] = z2;
    }
  }
  aabb.setMinMax(min6, max7);
  return aabb;
}
var init_aabb = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/aabb.js"() {
    init_esm2();
    init_AABB();
  }
});

// node_modules/@antv/g-webgpu-core/es/utils/isSafari.js
var isSafari;
var init_isSafari = __esm({
  "node_modules/@antv/g-webgpu-core/es/utils/isSafari.js"() {
    isSafari = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
  }
});

// node_modules/@antv/g-webgpu-core/es/services/config/index.js
var init_config = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/config/index.js"() {
    init_ConfigService();
  }
});

// node_modules/@antv/g-webgpu-core/es/services/interactor/index.js
var init_interactor = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/interactor/index.js"() {
    init_IteractorService();
  }
});

// node_modules/@antv/g-webgpu-core/es/services/shader-module/index.js
var init_shader_module2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/shader-module/index.js"() {
    init_ShaderModuleService();
  }
});

// node_modules/@antv/g-webgpu-core/es/services/index.js
var init_services = __esm({
  "node_modules/@antv/g-webgpu-core/es/services/index.js"() {
    init_config();
    init_interactor();
    init_shader_module2();
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/BoundingSphere.js
var tmpVecA, BoundingSphere;
var init_BoundingSphere = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/BoundingSphere.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm2();
    tmpVecA = vec3_exports.create();
    BoundingSphere = function() {
      function BoundingSphere2(center, radius) {
        _classCallCheck(this, BoundingSphere2);
        this.center = void 0;
        this.radius = void 0;
        this.center = center || vec3_exports.create();
        this.radius = radius || 0.5;
      }
      _createClass(BoundingSphere2, [{
        key: "containsPoint",
        value: function containsPoint(point) {
          vec3_exports.sub(tmpVecA, point, this.center);
          return vec3_exports.length(tmpVecA) < this.radius * this.radius;
        }
      }, {
        key: "intersects",
        value: function intersects(sphere) {
          vec3_exports.sub(tmpVecA, sphere.center, this.center);
          var totalRadius = sphere.radius + this.radius;
          if (vec3_exports.length(tmpVecA) <= totalRadius * totalRadius) {
            return true;
          }
          return false;
        }
      }]);
      return BoundingSphere2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/Ray.js
var tmpVecA2, tmpVecB, tmpVecC, tmpVecD, tmpVecE, Ray;
var init_Ray = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/Ray.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm2();
    tmpVecA2 = vec3_exports.create();
    tmpVecB = vec3_exports.create();
    tmpVecC = vec3_exports.create();
    tmpVecD = vec3_exports.create();
    tmpVecE = vec3_exports.create();
    Ray = function() {
      function Ray2(origin, direction3) {
        _classCallCheck(this, Ray2);
        this.origin = void 0;
        this.direction = void 0;
        this.origin = origin || vec3_exports.create();
        this.direction = direction3 || vec3_exports.fromValues(0, 0, -1);
      }
      _createClass(Ray2, [{
        key: "intersectsAABB",
        value: function intersectsAABB(aabb, intersection2) {
          return intersection2 ? this.intersectAABBWithIntersection(aabb, intersection2) : this.intersectsAABBWithoutIntersection(aabb);
        }
      }, {
        key: "intersectsSphere",
        value: function intersectsSphere(sphere, intersection2) {
          var m2 = vec3_exports.sub(tmpVecA2, this.origin, sphere.center);
          vec3_exports.normalize(tmpVecB, vec3_exports.copy(tmpVecB, this.direction));
          var b10 = vec3_exports.dot(m2, tmpVecB);
          var c2 = vec3_exports.dot(m2, m2) - sphere.radius * sphere.radius;
          if (c2 > 0 && b10 > 0) {
            return null;
          }
          var discr = b10 * b10 - c2;
          if (discr < 0) {
            return false;
          }
          var t4 = Math.abs(-b10 - Math.sqrt(discr));
          if (intersection2) {
            vec3_exports.copy(intersection2, this.direction);
            vec3_exports.scaleAndAdd(intersection2, this.origin, intersection2, t4);
          }
          return true;
        }
      }, {
        key: "intersectsPlane",
        value: function intersectsPlane(plane, intersection2) {
          var t4 = (plane.distance - vec3_exports.dot(plane.normal, this.origin)) / vec3_exports.dot(plane.normal, this.direction);
          var intersects = t4 >= 0;
          if (intersects && intersection2) {
            vec3_exports.scaleAndAdd(intersection2, this.origin, this.direction, t4);
          }
          return intersects;
        }
      }, {
        key: "intersectsAABBWithoutIntersection",
        value: function intersectsAABBWithoutIntersection(aabb) {
          var diff = tmpVecA2;
          var cross6 = tmpVecB;
          var prod = tmpVecC;
          var absDiff = tmpVecD;
          var absDir = tmpVecE;
          var rayDir = this.direction;
          vec3_exports.sub(diff, this.origin, aabb.center);
          vec3_exports.set(absDiff, Math.abs(diff[0]), Math.abs(diff[1]), Math.abs(diff[2]));
          vec3_exports.mul(prod, diff, rayDir);
          if (absDiff[0] > aabb.halfExtents[0] && prod[0] >= 0 || absDiff[1] > aabb.halfExtents[1] && prod[1] >= 0 || absDiff[2] > aabb.halfExtents[2] && prod[2] >= 0) {
            return false;
          }
          vec3_exports.set(absDir, Math.abs(rayDir[0]), Math.abs(rayDir[1]), Math.abs(rayDir[2]));
          vec3_exports.cross(cross6, rayDir, diff);
          vec3_exports.set(cross6, Math.abs(cross6[0]), Math.abs(cross6[1]), Math.abs(cross6[2]));
          return !(cross6[0] > aabb.halfExtents[1] * absDir[2] + aabb.halfExtents[2] * absDir[1] || cross6[1] > aabb.halfExtents[0] * absDir[2] + aabb.halfExtents[2] * absDir[0] || cross6[2] > aabb.halfExtents[0] * absDir[1] + aabb.halfExtents[1] * absDir[0]);
        }
      }, {
        key: "intersectAABBWithIntersection",
        value: function intersectAABBWithIntersection(aabb, intersection2) {
          var tMin = vec3_exports.copy(vec3_exports.create(), aabb.getMin());
          vec3_exports.sub(tMin, tMin, this.origin);
          var tMax = vec3_exports.copy(vec3_exports.create(), aabb.getMax());
          vec3_exports.sub(tMax, tMax, this.origin);
          var dir = this.direction;
          if (dir[0] === 0) {
            tMin[0] = tMin[0] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            tMax[0] = tMax[0] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
          } else {
            tMin[0] /= dir[0];
            tMax[0] /= dir[0];
          }
          if (dir[1] === 0) {
            tMin[1] = tMin[1] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            tMax[1] = tMax[1] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
          } else {
            tMin[1] /= dir[1];
            tMax[1] /= dir[1];
          }
          if (dir[2] === 0) {
            tMin[2] = tMin[2] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            tMax[2] = tMax[2] < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
          } else {
            tMin[2] /= dir[2];
            tMax[2] /= dir[2];
          }
          var realMin = vec3_exports.set(tmpVecC, Math.min(tMin[0], tMax[0]), Math.min(tMin[1], tMax[1]), Math.min(tMin[2], tMax[2]));
          var realMax = vec3_exports.set(tmpVecD, Math.max(tMin[0], tMax[0]), Math.max(tMin[1], tMax[1]), Math.max(tMin[2], tMax[2]));
          var minMax = Math.min(Math.min(realMax[0], realMax[1]), realMax[2]);
          var maxMin = Math.max(Math.max(realMin[0], realMin[1]), realMin[2]);
          var intersects = minMax >= maxMin && maxMin >= 0;
          if (intersects) {
            vec3_exports.copy(intersection2, this.direction);
            vec3_exports.scaleAndAdd(intersection2, this.origin, intersection2, maxMin);
          }
          return intersects;
        }
      }]);
      return Ray2;
    }();
  }
});

// node_modules/@antv/g-webgpu-core/es/shape/index.js
var init_shape = __esm({
  "node_modules/@antv/g-webgpu-core/es/shape/index.js"() {
    init_AABB();
    init_BoundingSphere();
    init_Frustum();
    init_Plane();
    init_Ray();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IAttribute.js
var init_IAttribute = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IAttribute.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IBuffer.js
var init_IBuffer = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IBuffer.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IComputeModel.js
var init_IComputeModel = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IComputeModel.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IElements.js
var init_IElements = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IElements.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IFramebuffer.js
var init_IFramebuffer = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IFramebuffer.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IModel.js
var init_IModel = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IModel.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IMultiPassRenderer.js
var PassType;
var init_IMultiPassRenderer = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IMultiPassRenderer.js"() {
    (function(PassType2) {
      PassType2["Normal"] = "normal";
      PassType2["PostProcessing"] = "post-processing";
    })(PassType || (PassType = {}));
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IRenderbuffer.js
var init_IRenderbuffer = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IRenderbuffer.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IRendererService.js
var init_IRendererService = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IRendererService.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/ITexture2D.js
var init_ITexture2D = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/ITexture2D.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/IUniform.js
var init_IUniform = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/IUniform.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/renderer/index.js
var init_renderer = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/renderer/index.js"() {
    init_gl();
    init_IAttribute();
    init_IBuffer();
    init_IComputeModel();
    init_IElements();
    init_IFramebuffer();
    init_IModel();
    init_IMultiPassRenderer();
    init_IRenderbuffer();
    init_IRendererService();
    init_ITexture2D();
    init_IUniform();
  }
});

// node_modules/@antv/g-webgpu-core/es/components/material/interface.js
var init_interface = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/material/interface.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/components/mesh/interface.js
var init_interface2 = __esm({
  "node_modules/@antv/g-webgpu-core/es/components/mesh/interface.js"() {
  }
});

// node_modules/@antv/g-webgpu-core/es/index.js
var AST_TOKEN_TYPES, AST_NODE_TYPES, STORAGE_CLASS, Target2, DefineValuePlaceholder;
var init_es3 = __esm({
  "node_modules/@antv/g-webgpu-core/es/index.js"() {
    init_Reflect();
    init_ComponentManager();
    init_System();
    init_GeometryComponent();
    init_System2();
    init_MaterialComponent();
    init_System3();
    init_CullableComponent();
    init_MeshComponent();
    init_System4();
    init_PixelPickingPass();
    init_System5();
    init_HierarchyComponent();
    init_System6();
    init_TransformComponent();
    init_Entity();
    init_identifier();
    init_inversify_config();
    init_aabb();
    init_isSafari();
    init_ComponentManager();
    init_services();
    init_shape();
    init_renderer();
    init_interface();
    init_interface2();
    init_renderer();
    (function(AST_TOKEN_TYPES2) {
      AST_TOKEN_TYPES2["Void"] = "Void";
      AST_TOKEN_TYPES2["Boolean"] = "Boolean";
      AST_TOKEN_TYPES2["Float"] = "Float";
      AST_TOKEN_TYPES2["Uint32"] = "Uint32";
      AST_TOKEN_TYPES2["Int32"] = "Int32";
      AST_TOKEN_TYPES2["Vector"] = "Vector";
      AST_TOKEN_TYPES2["Vector2Float"] = "vec2<f32>";
      AST_TOKEN_TYPES2["Vector3Float"] = "vec3<f32>";
      AST_TOKEN_TYPES2["Vector4Float"] = "vec4<f32>";
      AST_TOKEN_TYPES2["Vector2Boolean"] = "vec2<bool>";
      AST_TOKEN_TYPES2["Vector3Boolean"] = "vec3<bool>";
      AST_TOKEN_TYPES2["Vector4Boolean"] = "vec4<bool>";
      AST_TOKEN_TYPES2["Vector2Uint"] = "vec2<u32>";
      AST_TOKEN_TYPES2["Vector3Uint"] = "vec3<u32>";
      AST_TOKEN_TYPES2["Vector4Uint"] = "vec4<u32>";
      AST_TOKEN_TYPES2["Vector2Int"] = "vec2<i32>";
      AST_TOKEN_TYPES2["Vector3Int"] = "vec3<i32>";
      AST_TOKEN_TYPES2["Vector4Int"] = "vec4<i32>";
      AST_TOKEN_TYPES2["Matrix"] = "Matrix";
      AST_TOKEN_TYPES2["Matrix3x3Float"] = "mat3x3<f32>";
      AST_TOKEN_TYPES2["Matrix4x4Float"] = "mat4x4<i32>";
      AST_TOKEN_TYPES2["Struct"] = "Struct";
      AST_TOKEN_TYPES2["FloatArray"] = "Float[]";
      AST_TOKEN_TYPES2["Vector4FloatArray"] = "vec4<f32>[]";
    })(AST_TOKEN_TYPES || (AST_TOKEN_TYPES = {}));
    (function(AST_NODE_TYPES2) {
      AST_NODE_TYPES2["Program"] = "Program";
      AST_NODE_TYPES2["Identifier"] = "Identifier";
      AST_NODE_TYPES2["VariableDeclaration"] = "VariableDeclaration";
      AST_NODE_TYPES2["BlockStatement"] = "BlockStatement";
      AST_NODE_TYPES2["ReturnStatement"] = "ReturnStatement";
      AST_NODE_TYPES2["FunctionDeclaration"] = "FunctionDeclaration";
      AST_NODE_TYPES2["VariableDeclarator"] = "VariableDeclarator";
      AST_NODE_TYPES2["AssignmentExpression"] = "AssignmentExpression";
      AST_NODE_TYPES2["LogicalExpression"] = "LogicalExpression";
      AST_NODE_TYPES2["BinaryExpression"] = "BinaryExpression";
      AST_NODE_TYPES2["ArrayExpression"] = "ArrayExpression";
      AST_NODE_TYPES2["UnaryExpression"] = "UnaryExpression";
      AST_NODE_TYPES2["UpdateExpression"] = "UpdateExpression";
      AST_NODE_TYPES2["FunctionExpression"] = "FunctionExpression";
      AST_NODE_TYPES2["MemberExpression"] = "MemberExpression";
      AST_NODE_TYPES2["ConditionalExpression"] = "ConditionalExpression";
      AST_NODE_TYPES2["ExpressionStatement"] = "ExpressionStatement";
      AST_NODE_TYPES2["CallExpression"] = "CallExpression";
      AST_NODE_TYPES2["NumThreadStatement"] = "NumThreadStatement";
      AST_NODE_TYPES2["StorageStatement"] = "StorageStatement";
      AST_NODE_TYPES2["DoWhileStatement"] = "DoWhileStatement";
      AST_NODE_TYPES2["WhileStatement"] = "WhileStatement";
      AST_NODE_TYPES2["ForStatement"] = "ForStatement";
      AST_NODE_TYPES2["BreakStatement"] = "BreakStatement";
      AST_NODE_TYPES2["ContinueStatement"] = "ContinueStatement";
      AST_NODE_TYPES2["IfStatement"] = "IfStatement";
      AST_NODE_TYPES2["ImportedFunctionStatement"] = "ImportedFunctionStatement";
    })(AST_NODE_TYPES || (AST_NODE_TYPES = {}));
    (function(STORAGE_CLASS2) {
      STORAGE_CLASS2["Input"] = "Input";
      STORAGE_CLASS2["Output"] = "Output";
      STORAGE_CLASS2["Uniform"] = "Uniform";
      STORAGE_CLASS2["Workgroup"] = "Workgroup";
      STORAGE_CLASS2["UniformConstant"] = "UniformConstant";
      STORAGE_CLASS2["Image"] = "Image";
      STORAGE_CLASS2["StorageBuffer"] = "StorageBuffer";
      STORAGE_CLASS2["Private"] = "Private";
      STORAGE_CLASS2["Function"] = "Function";
    })(STORAGE_CLASS || (STORAGE_CLASS = {}));
    (function(Target3) {
      Target3["GLSL100"] = "GLSL100";
      Target3["GLSL450"] = "GLSL450";
      Target3["WGSL"] = "WGSL";
    })(Target2 || (Target2 = {}));
    DefineValuePlaceholder = "__DefineValuePlaceholder__";
  }
});

// node_modules/@antv/g-webgpu/es/utils/is-number.js
function isNumber3(value) {
  return typeof value === "number";
}
var init_is_number3 = __esm({
  "node_modules/@antv/g-webgpu/es/utils/is-number.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/utils/math.js
function getAngle3(angle3) {
  if (angle3 === void 0) {
    return 0;
  } else if (angle3 > 360 || angle3 < -360) {
    return angle3 % 360;
  }
  return angle3;
}
function createVec3(x2, y2, z2) {
  if (isNumber3(x2)) {
    return vec3_exports.fromValues(x2, y2, z2);
  }
  if (x2.length === 3) {
    return vec3_exports.clone(x2);
  }
  return vec3_exports.fromValues(x2[0], x2[1], x2[2]);
}
var init_math2 = __esm({
  "node_modules/@antv/g-webgpu/es/utils/math.js"() {
    init_esm2();
    init_is_number3();
  }
});

// node_modules/@antv/g-webgpu/es/camera/Landmark.js
var Landmark;
var init_Landmark = __esm({
  "node_modules/@antv/g-webgpu/es/camera/Landmark.js"() {
    init_classCallCheck();
    init_createClass();
    init_esm2();
    Landmark = function() {
      function Landmark2(name, c2) {
        _classCallCheck(this, Landmark2);
        this.name = void 0;
        this.matrix = void 0;
        this.right = void 0;
        this.up = void 0;
        this.forward = void 0;
        this.position = void 0;
        this.focalPoint = void 0;
        this.distanceVector = void 0;
        this.distance = void 0;
        this.dollyingStep = void 0;
        this.azimuth = 0;
        this.elevation = 0;
        this.roll = 0;
        this.relAzimuth = 0;
        this.relElevation = 0;
        this.relRoll = 0;
        this.name = name;
        this.matrix = mat4_exports.clone(c2.matrix);
        this.right = vec3_exports.clone(c2.right);
        this.up = vec3_exports.clone(c2.up);
        this.forward = vec3_exports.clone(c2.forward);
        this.position = vec3_exports.clone(c2.position);
        this.focalPoint = vec3_exports.clone(c2.focalPoint);
        this.distanceVector = vec3_exports.clone(c2.distanceVector);
        this.azimuth = c2.azimuth;
        this.elevation = c2.elevation;
        this.roll = c2.roll;
        this.relAzimuth = c2.relAzimuth;
        this.relElevation = c2.relElevation;
        this.relRoll = c2.relRoll;
        this.dollyingStep = c2.dollyingStep;
        this.distance = c2.distance;
      }
      _createClass(Landmark2, [{
        key: "getPosition",
        value: function getPosition() {
          return this.position;
        }
      }, {
        key: "getFocalPoint",
        value: function getFocalPoint() {
          return this.focalPoint;
        }
      }, {
        key: "getRoll",
        value: function getRoll() {
          return this.roll;
        }
      }, {
        key: "retrieve",
        value: function retrieve(c2) {
          c2.matrix = mat4_exports.copy(c2.matrix, this.matrix);
          c2.right = vec3_exports.copy(c2.right, this.right);
          c2.up = vec3_exports.copy(c2.up, this.up);
          c2.forward = vec3_exports.copy(c2.forward, this.forward);
          c2.position = vec3_exports.copy(c2.position, this.position);
          c2.focalPoint = vec3_exports.copy(c2.focalPoint, this.focalPoint);
          c2.distanceVector = vec3_exports.copy(c2.distanceVector, this.distanceVector);
          c2.azimuth = this.azimuth;
          c2.elevation = this.elevation;
          c2.roll = this.roll;
          c2.relAzimuth = this.relAzimuth;
          c2.relElevation = this.relElevation;
          c2.relRoll = this.relRoll;
          c2.dollyingStep = this.dollyingStep;
          c2.distance = this.distance;
        }
      }]);
      return Landmark2;
    }();
  }
});

// node_modules/@antv/g-webgpu/es/camera/Camera.js
var _dec20, _dec211, _class15, _class211, _descriptor15, _class35, _temp13, CAMERA_TYPE, CAMERA_TRACKING_MODE, CAMERA_PROJECTION_MODE, DEG_2_RAD, RAD_2_DEG, Camera;
var init_Camera = __esm({
  "node_modules/@antv/g-webgpu/es/camera/Camera.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_esm2();
    init_inversify();
    init_math2();
    init_Landmark();
    (function(CAMERA_TYPE2) {
      CAMERA_TYPE2["ORBITING"] = "ORBITING";
      CAMERA_TYPE2["EXPLORING"] = "EXPLORING";
      CAMERA_TYPE2["TRACKING"] = "TRACKING";
    })(CAMERA_TYPE || (CAMERA_TYPE = {}));
    (function(CAMERA_TRACKING_MODE2) {
      CAMERA_TRACKING_MODE2["DEFAULT"] = "DEFAULT";
      CAMERA_TRACKING_MODE2["ROTATIONAL"] = "ROTATIONAL";
      CAMERA_TRACKING_MODE2["TRANSLATIONAL"] = "TRANSLATIONAL";
      CAMERA_TRACKING_MODE2["CINEMATIC"] = "CINEMATIC";
    })(CAMERA_TRACKING_MODE || (CAMERA_TRACKING_MODE = {}));
    (function(CAMERA_PROJECTION_MODE2) {
      CAMERA_PROJECTION_MODE2["ORTHOGRAPHIC"] = "ORTHOGRAPHIC";
      CAMERA_PROJECTION_MODE2["PERSPECTIVE"] = "PERSPECTIVE";
    })(CAMERA_PROJECTION_MODE || (CAMERA_PROJECTION_MODE = {}));
    DEG_2_RAD = Math.PI / 180;
    RAD_2_DEG = 180 / Math.PI;
    Camera = (_dec20 = injectable(), _dec211 = inject(IDENTIFIER.InteractorService), _dec20(_class15 = (_class211 = (_temp13 = _class35 = function() {
      function Camera2() {
        _classCallCheck(this, Camera2);
        this.matrix = mat4_exports.create();
        this.right = vec3_exports.fromValues(1, 0, 0);
        this.up = vec3_exports.fromValues(0, 1, 0);
        this.forward = vec3_exports.fromValues(0, 0, 1);
        this.position = vec3_exports.fromValues(0, 0, 1);
        this.focalPoint = vec3_exports.fromValues(0, 0, 0);
        this.distanceVector = vec3_exports.fromValues(0, 0, 0);
        this.distance = 1;
        this.azimuth = 0;
        this.elevation = 0;
        this.roll = 0;
        this.relAzimuth = 0;
        this.relElevation = 0;
        this.relRoll = 0;
        this.dollyingStep = 0;
        this.maxDistance = Infinity;
        this.minDistance = -Infinity;
        this.rotateWorld = false;
        _initializerDefineProperty(this, "interactor", _descriptor15, this);
        this.fov = 30;
        this.near = 0.1;
        this.far = 1e4;
        this.aspect = 1;
        this.left = void 0;
        this.rright = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.zoom = 1;
        this.perspective = mat4_exports.create();
        this.view = void 0;
        this.following = void 0;
        this.type = CAMERA_TYPE.EXPLORING;
        this.trackingMode = CAMERA_TRACKING_MODE.DEFAULT;
        this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;
        this.frustum = new Frustum();
        this.landmarks = [];
        this.landmarkAnimationID = void 0;
      }
      _createClass(Camera2, [{
        key: "clone",
        value: function clone8() {
          var camera = new Camera2();
          camera.setType(this.type, void 0);
          camera.interactor = this.interactor;
          return camera;
        }
      }, {
        key: "getProjectionMode",
        value: function getProjectionMode() {
          return this.projectionMode;
        }
      }, {
        key: "getPerspective",
        value: function getPerspective() {
          return this.perspective;
        }
      }, {
        key: "getFrustum",
        value: function getFrustum() {
          return this.frustum;
        }
      }, {
        key: "getPosition",
        value: function getPosition() {
          return this.position;
        }
      }, {
        key: "setType",
        value: function setType(type, trackingMode) {
          this.type = type;
          if (this.type === CAMERA_TYPE.EXPLORING) {
            this.setWorldRotation(true);
          } else {
            this.setWorldRotation(false);
          }
          this._getAngles();
          if (this.type === CAMERA_TYPE.TRACKING && trackingMode !== void 0) {
            this.setTrackingMode(trackingMode);
          }
          return this;
        }
      }, {
        key: "setProjectionMode",
        value: function setProjectionMode(projectionMode) {
          this.projectionMode = projectionMode;
          return this;
        }
      }, {
        key: "setTrackingMode",
        value: function setTrackingMode(trackingMode) {
          if (this.type !== CAMERA_TYPE.TRACKING) {
            throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
          }
          this.trackingMode = trackingMode;
          return this;
        }
      }, {
        key: "setWorldRotation",
        value: function setWorldRotation(flag) {
          this.rotateWorld = flag;
          this._getAngles();
        }
      }, {
        key: "getViewTransform",
        value: function getViewTransform() {
          return mat4_exports.invert(mat4_exports.create(), this.matrix);
        }
      }, {
        key: "getWorldTransform",
        value: function getWorldTransform() {
          return this.matrix;
        }
      }, {
        key: "setMatrix",
        value: function setMatrix(matrix) {
          this.matrix = matrix;
          this._update();
          return this;
        }
      }, {
        key: "setAspect",
        value: function setAspect(aspect) {
          this.setPerspective(this.near, this.far, this.fov, aspect);
          return this;
        }
      }, {
        key: "setViewOffset",
        value: function setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
          this.aspect = fullWidth / fullHeight;
          if (this.view === void 0) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = fullWidth;
          this.view.fullHeight = fullHeight;
          this.view.offsetX = x2;
          this.view.offsetY = y2;
          this.view.width = width;
          this.view.height = height;
          if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {
            this.setPerspective(this.near, this.far, this.fov, this.aspect);
          } else {
            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
          }
          return this;
        }
      }, {
        key: "clearViewOffset",
        value: function clearViewOffset() {
          if (this.view !== void 0) {
            this.view.enabled = false;
          }
          if (this.projectionMode === CAMERA_PROJECTION_MODE.PERSPECTIVE) {
            this.setPerspective(this.near, this.far, this.fov, this.aspect);
          } else {
            this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
          }
          return this;
        }
      }, {
        key: "setPerspective",
        value: function setPerspective(near, far, fov, aspect) {
          this.projectionMode = CAMERA_PROJECTION_MODE.PERSPECTIVE;
          this.fov = fov;
          this.near = near;
          this.far = far;
          this.aspect = aspect;
          mat4_exports.perspective(this.perspective, this.fov * DEG_2_RAD, this.aspect, this.near, this.far);
          return this;
        }
      }, {
        key: "setOrthographic",
        value: function setOrthographic(l2, r2, t4, b10, near, far) {
          this.projectionMode = CAMERA_PROJECTION_MODE.ORTHOGRAPHIC;
          this.rright = r2;
          this.left = l2;
          this.top = t4;
          this.bottom = b10;
          this.near = near;
          this.far = far;
          var dx = (this.rright - this.left) / (2 * this.zoom);
          var dy = (this.top - this.bottom) / (2 * this.zoom);
          var cx = (this.rright + this.left) / 2;
          var cy = (this.top + this.bottom) / 2;
          var left = cx - dx;
          var right = cx + dx;
          var top = cy + dy;
          var bottom = cy - dy;
          if (this.view !== void 0 && this.view.enabled) {
            var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
            var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            left += scaleW * this.view.offsetX;
            right = left + scaleW * this.view.width;
            top -= scaleH * this.view.offsetY;
            bottom = top - scaleH * this.view.height;
          }
          mat4_exports.ortho(this.perspective, left, right, top, bottom, near, far);
          return this;
        }
      }, {
        key: "setPosition",
        value: function setPosition(x2, y2, z2) {
          this._setPosition(x2, y2, z2);
          this.setFocalPoint(this.focalPoint);
          return this;
        }
      }, {
        key: "setFocalPoint",
        value: function setFocalPoint(x2, y2, z2) {
          var up = vec3_exports.fromValues(0, 1, 0);
          this.focalPoint = createVec3(x2, y2, z2);
          if (this.trackingMode === CAMERA_TRACKING_MODE.CINEMATIC) {
            var d2 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
            x2 = d2[0];
            y2 = d2[1];
            z2 = d2[2];
            var r2 = vec3_exports.length(d2);
            var el = Math.asin(y2 / r2) * RAD_2_DEG;
            var az = 90 + Math.atan2(z2, x2) * RAD_2_DEG;
            var m2 = mat4_exports.create();
            mat4_exports.rotateY(m2, m2, az * DEG_2_RAD);
            mat4_exports.rotateX(m2, m2, el * DEG_2_RAD);
            up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m2);
          }
          mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
          this._getAxes();
          this._getDistance();
          this._getAngles();
          return this;
        }
      }, {
        key: "setDistance",
        value: function setDistance(d2) {
          if (this.distance === d2 || d2 < 0) {
            return;
          }
          this.distance = d2;
          if (this.distance < 2e-4) {
            this.distance = 2e-4;
          }
          this.dollyingStep = this.distance / 100;
          var pos = vec3_exports.create();
          d2 = this.distance;
          var n2 = this.forward;
          var f2 = this.focalPoint;
          pos[0] = d2 * n2[0] + f2[0];
          pos[1] = d2 * n2[1] + f2[1];
          pos[2] = d2 * n2[2] + f2[2];
          this._setPosition(pos);
          return this;
        }
      }, {
        key: "setMaxDistance",
        value: function setMaxDistance(d2) {
          this.maxDistance = d2;
          return this;
        }
      }, {
        key: "setMinDistance",
        value: function setMinDistance(d2) {
          this.minDistance = d2;
          return this;
        }
      }, {
        key: "changeAzimuth",
        value: function changeAzimuth(az) {
          this.setAzimuth(this.azimuth + az);
          return this;
        }
      }, {
        key: "changeElevation",
        value: function changeElevation(el) {
          this.setElevation(this.elevation + el);
          return this;
        }
      }, {
        key: "changeRoll",
        value: function changeRoll(rl) {
          this.setRoll(this.roll + rl);
          return this;
        }
      }, {
        key: "setAzimuth",
        value: function setAzimuth(az) {
          this.azimuth = getAngle3(az);
          this.computeMatrix();
          this._getAxes();
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            this._getPosition();
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            this._getFocalPoint();
          }
          return this;
        }
      }, {
        key: "getAzimuth",
        value: function getAzimuth() {
          return this.azimuth;
        }
      }, {
        key: "setElevation",
        value: function setElevation(el) {
          this.elevation = getAngle3(el);
          this.computeMatrix();
          this._getAxes();
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            this._getPosition();
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            this._getFocalPoint();
          }
          return this;
        }
      }, {
        key: "setRoll",
        value: function setRoll(angle3) {
          this.roll = getAngle3(angle3);
          this.computeMatrix();
          this._getAxes();
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            this._getPosition();
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            this._getFocalPoint();
          }
          return this;
        }
      }, {
        key: "rotate",
        value: function rotate7(azimuth, elevation, roll) {
          if (this.type === CAMERA_TYPE.EXPLORING) {
            azimuth = getAngle3(azimuth);
            elevation = getAngle3(elevation);
            roll = getAngle3(roll);
            var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], (this.rotateWorld ? 1 : -1) * elevation * DEG_2_RAD);
            var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], (this.rotateWorld ? 1 : -1) * azimuth * DEG_2_RAD);
            var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], roll * DEG_2_RAD);
            var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
            rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
            var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
            mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
            mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
            mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
          } else {
            if (Math.abs(this.elevation + elevation) > 90) {
              return;
            }
            this.relElevation = getAngle3(elevation);
            this.relAzimuth = getAngle3(azimuth);
            this.relRoll = getAngle3(roll);
            this.elevation += this.relElevation;
            this.azimuth += this.relAzimuth;
            this.roll += this.relRoll;
            this.computeMatrix();
          }
          this._getAxes();
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            this._getPosition();
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            this._getFocalPoint();
          }
          this._update();
          return this;
        }
      }, {
        key: "pan",
        value: function pan(tx, ty) {
          var coords = createVec3(tx, ty, 0);
          var pos = vec3_exports.clone(this.position);
          vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
          vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
          this._setPosition(pos);
          return this;
        }
      }, {
        key: "dolly",
        value: function dolly(value) {
          var n2 = this.forward;
          var pos = vec3_exports.clone(this.position);
          var step = value * this.dollyingStep;
          var updatedDistance = this.distance + value * this.dollyingStep;
          step = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
          pos[0] += step * n2[0];
          pos[1] += step * n2[1];
          pos[2] += step * n2[2];
          this._setPosition(pos);
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            this._getDistance();
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            vec3_exports.add(this.focalPoint, pos, this.distanceVector);
          }
          return this;
        }
      }, {
        key: "createLandmark",
        value: function createLandmark(name, params) {
          var camera = this.clone();
          camera.setPosition(params.position);
          camera.setFocalPoint(params.focalPoint);
          if (params.roll !== void 0) {
            camera.setRoll(params.roll);
          }
          var landmark = new Landmark(name, camera);
          this.landmarks.push(landmark);
          return landmark;
        }
      }, {
        key: "setLandmark",
        value: function setLandmark(name) {
          var landmark = new Landmark(name, this);
          this.landmarks.push(landmark);
          return this;
        }
      }, {
        key: "gotoLandmark",
        value: function gotoLandmark(name) {
          var _this = this;
          var duration = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
          var landmark = this.landmarks.find(function(l2) {
            return l2.name === name;
          });
          if (landmark) {
            if (duration === 0) {
              landmark.retrieve(this);
              return;
            }
            if (this.landmarkAnimationID !== void 0) {
              window.cancelAnimationFrame(this.landmarkAnimationID);
            }
            this.interactor.disconnect();
            var destPosition = landmark.getPosition();
            var destFocalPoint = landmark.getFocalPoint();
            var destRoll = landmark.getRoll();
            var timeStart;
            var animate = function animate2(timestamp) {
              if (timeStart === void 0) {
                timeStart = timestamp;
              }
              var elapsed = timestamp - timeStart;
              var t4 = (1 - Math.cos(elapsed / duration * Math.PI)) / 2;
              var interFocalPoint = vec3_exports.create();
              var interPosition = vec3_exports.create();
              var interRoll = 0;
              vec3_exports.lerp(interFocalPoint, _this.focalPoint, destFocalPoint, t4);
              vec3_exports.lerp(interPosition, _this.position, destPosition, t4);
              interRoll = _this.roll * (1 - t4) + destRoll * t4;
              _this.setFocalPoint(interFocalPoint);
              _this.setPosition(interPosition);
              _this.setRoll(interRoll);
              _this.computeMatrix();
              var dist4 = vec3_exports.dist(interFocalPoint, destFocalPoint) + vec3_exports.dist(interPosition, destPosition);
              if (dist4 > 0.01) {
              } else {
                _this.setFocalPoint(interFocalPoint);
                _this.setPosition(interPosition);
                _this.setRoll(interRoll);
                _this.computeMatrix();
                _this.interactor.connect();
                return;
              }
              if (elapsed < duration) {
                _this.landmarkAnimationID = window.requestAnimationFrame(animate2);
              }
            };
            window.requestAnimationFrame(animate);
          }
        }
      }, {
        key: "_update",
        value: function _update2() {
          this._getAxes();
          this._getPosition();
          this._getDistance();
          this._getAngles();
        }
      }, {
        key: "computeMatrix",
        value: function computeMatrix() {
          var rotX;
          var rotY;
          var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], this.roll * DEG_2_RAD);
          mat4_exports.identity(this.matrix);
          rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.elevation * DEG_2_RAD);
          rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], (this.rotateWorld && this.type !== CAMERA_TYPE.TRACKING || this.type === CAMERA_TYPE.TRACKING ? 1 : -1) * this.azimuth * DEG_2_RAD);
          var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
          rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
          var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
          if (this.type === CAMERA_TYPE.ORBITING || this.type === CAMERA_TYPE.EXPLORING) {
            mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
            mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
            mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
          } else if (this.type === CAMERA_TYPE.TRACKING) {
            mat4_exports.translate(this.matrix, this.matrix, this.position);
            mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          }
        }
      }, {
        key: "_setPosition",
        value: function _setPosition(x2, y2, z2) {
          this.position = createVec3(x2, y2, z2);
          var m2 = this.matrix;
          m2[12] = this.position[0];
          m2[13] = this.position[1];
          m2[14] = this.position[2];
          m2[15] = 1;
        }
      }, {
        key: "_getAxes",
        value: function _getAxes() {
          vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
          vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
          vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
          vec3_exports.normalize(this.right, this.right);
          vec3_exports.normalize(this.up, this.up);
          vec3_exports.normalize(this.forward, this.forward);
        }
      }, {
        key: "_getAngles",
        value: function _getAngles() {
          var x2 = this.distanceVector[0];
          var y2 = this.distanceVector[1];
          var z2 = this.distanceVector[2];
          var r2 = vec3_exports.length(this.distanceVector);
          if (r2 === 0) {
            this.elevation = 0;
            this.azimuth = 0;
            return;
          }
          if (this.type === CAMERA_TYPE.TRACKING) {
            this.elevation = Math.asin(y2 / r2) * RAD_2_DEG;
            this.azimuth = Math.atan2(-x2, -z2) * RAD_2_DEG;
          } else {
            if (this.rotateWorld) {
              this.elevation = Math.asin(y2 / r2) * RAD_2_DEG;
              this.azimuth = Math.atan2(-x2, -z2) * RAD_2_DEG;
            } else {
              this.elevation = -Math.asin(y2 / r2) * RAD_2_DEG;
              this.azimuth = -Math.atan2(-x2, -z2) * RAD_2_DEG;
            }
          }
        }
      }, {
        key: "_getPosition",
        value: function _getPosition() {
          vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
          this._getDistance();
        }
      }, {
        key: "_getFocalPoint",
        value: function _getFocalPoint() {
          vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
          vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
          this._getDistance();
        }
      }, {
        key: "_getDistance",
        value: function _getDistance() {
          this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
          this.distance = vec3_exports.length(this.distanceVector);
          this.dollyingStep = this.distance / 100;
        }
      }]);
      return Camera2;
    }(), _class35.ProjectionMode = {
      ORTHOGRAPHIC: "ORTHOGRAPHIC",
      PERSPECTIVE: "PERSPECTIVE"
    }, _temp13), _descriptor15 = _applyDecoratedDescriptor(_class211.prototype, "interactor", [_dec211], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class211)) || _class15);
  }
});

// node_modules/@antv/g-webgpu/es/geometry/index.js
var _dec21, _dec212, _class16, _class212, _descriptor16, _class36, _temp14, Geometry;
var init_geometry = __esm({
  "node_modules/@antv/g-webgpu/es/geometry/index.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    Geometry = (_dec21 = injectable(), _dec212 = inject(IDENTIFIER.GeometryComponentManager), _dec21(_class16 = (_class212 = (_temp14 = _class36 = function() {
      function Geometry2() {
        _classCallCheck(this, Geometry2);
        this.config = void 0;
        _initializerDefineProperty(this, "geometry", _descriptor16, this);
        this.entity = void 0;
        this.component = void 0;
      }
      _createClass(Geometry2, [{
        key: "getEntity",
        value: function getEntity() {
          return this.entity;
        }
      }, {
        key: "getComponent",
        value: function getComponent() {
          return this.component;
        }
      }, {
        key: "setConfig",
        value: function setConfig(config) {
          this.config = config;
        }
      }, {
        key: "setEntity",
        value: function setEntity(entity) {
          this.entity = entity;
          this.component = this.geometry.create(entity);
          this.component.entity = entity;
          this.onEntityCreated();
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
        }
      }]);
      return Geometry2;
    }(), _class36.BOX = "box", _class36.SPHERE = "sphere", _class36.PLANE = "plane", _class36.MERGED = "merged", _temp14), _descriptor16 = _applyDecoratedDescriptor(_class212.prototype, "geometry", [_dec212], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class212)) || _class16);
  }
});

// node_modules/@webgpu/types/dist/constants.js
var require_constants2 = __commonJS({
  "node_modules/@webgpu/types/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ExtensionName;
    (function(ExtensionName2) {
      ExtensionName2["TextureCompressionBC"] = "texture-compression-bc";
    })(ExtensionName = exports.ExtensionName || (exports.ExtensionName = {}));
    var AddressMode;
    (function(AddressMode2) {
      AddressMode2["ClampToEdge"] = "clamp-to-edge";
      AddressMode2["Repeat"] = "repeat";
      AddressMode2["MirrorRepeat"] = "mirror-repeat";
    })(AddressMode = exports.AddressMode || (exports.AddressMode = {}));
    var BindingType2;
    (function(BindingType3) {
      BindingType3["UniformBuffer"] = "uniform-buffer";
      BindingType3["StorageBuffer"] = "storage-buffer";
      BindingType3["ReadonlyStorageBuffer"] = "readonly-storage-buffer";
      BindingType3["Sampler"] = "sampler";
      BindingType3["ComparisonSampler"] = "comparison-sampler";
      BindingType3["SampledTexture"] = "sampled-texture";
      BindingType3["ReadonlyStorageTexture"] = "readonly-storage-texture";
      BindingType3["WriteonlyStorageTexture"] = "writeonly-storage-texture";
    })(BindingType2 = exports.BindingType || (exports.BindingType = {}));
    var BlendFactor2;
    (function(BlendFactor3) {
      BlendFactor3["Zero"] = "zero";
      BlendFactor3["One"] = "one";
      BlendFactor3["SrcColor"] = "src-color";
      BlendFactor3["OneMinusSrcColor"] = "one-minus-src-color";
      BlendFactor3["SrcAlpha"] = "src-alpha";
      BlendFactor3["OneMinusSrcAlpha"] = "one-minus-src-alpha";
      BlendFactor3["DstColor"] = "dst-color";
      BlendFactor3["OneMinusDstColor"] = "one-minus-dst-color";
      BlendFactor3["DstAlpha"] = "dst-alpha";
      BlendFactor3["OneMinusDstAlpha"] = "one-minus-dst-alpha";
      BlendFactor3["SrcAlphaSaturated"] = "src-alpha-saturated";
      BlendFactor3["BlendColor"] = "blend-color";
      BlendFactor3["OneMinusBlendColor"] = "one-minus-blend-color";
    })(BlendFactor2 = exports.BlendFactor || (exports.BlendFactor = {}));
    var BlendOperation2;
    (function(BlendOperation3) {
      BlendOperation3["Add"] = "add";
      BlendOperation3["Subtract"] = "subtract";
      BlendOperation3["ReverseSubtract"] = "reverse-subtract";
      BlendOperation3["Min"] = "min";
      BlendOperation3["Max"] = "max";
    })(BlendOperation2 = exports.BlendOperation || (exports.BlendOperation = {}));
    var CompareFunction2;
    (function(CompareFunction3) {
      CompareFunction3["Never"] = "never";
      CompareFunction3["Less"] = "less";
      CompareFunction3["Equal"] = "equal";
      CompareFunction3["LessEqual"] = "less-equal";
      CompareFunction3["Greater"] = "greater";
      CompareFunction3["NotEqual"] = "not-equal";
      CompareFunction3["GreaterEqual"] = "greater-equal";
      CompareFunction3["Always"] = "always";
    })(CompareFunction2 = exports.CompareFunction || (exports.CompareFunction = {}));
    var CullMode3;
    (function(CullMode4) {
      CullMode4["None"] = "none";
      CullMode4["Front"] = "front";
      CullMode4["Back"] = "back";
    })(CullMode3 = exports.CullMode || (exports.CullMode = {}));
    var FilterMode;
    (function(FilterMode2) {
      FilterMode2["Nearest"] = "nearest";
      FilterMode2["Linear"] = "linear";
    })(FilterMode = exports.FilterMode || (exports.FilterMode = {}));
    var FrontFace2;
    (function(FrontFace3) {
      FrontFace3["CCW"] = "ccw";
      FrontFace3["CW"] = "cw";
    })(FrontFace2 = exports.FrontFace || (exports.FrontFace = {}));
    var IndexFormat2;
    (function(IndexFormat3) {
      IndexFormat3["Uint16"] = "uint16";
      IndexFormat3["Uint32"] = "uint32";
    })(IndexFormat2 = exports.IndexFormat || (exports.IndexFormat = {}));
    var InputStepMode;
    (function(InputStepMode2) {
      InputStepMode2["Vertex"] = "vertex";
      InputStepMode2["Instance"] = "instance";
    })(InputStepMode = exports.InputStepMode || (exports.InputStepMode = {}));
    var LoadOp2;
    (function(LoadOp3) {
      LoadOp3["Load"] = "load";
    })(LoadOp2 = exports.LoadOp || (exports.LoadOp = {}));
    var PrimitiveTopology2;
    (function(PrimitiveTopology3) {
      PrimitiveTopology3["PointList"] = "point-list";
      PrimitiveTopology3["LineList"] = "line-list";
      PrimitiveTopology3["LineStrip"] = "line-strip";
      PrimitiveTopology3["TriangleList"] = "triangle-list";
      PrimitiveTopology3["TriangleStrip"] = "triangle-strip";
    })(PrimitiveTopology2 = exports.PrimitiveTopology || (exports.PrimitiveTopology = {}));
    var StencilOperation2;
    (function(StencilOperation3) {
      StencilOperation3["Keep"] = "keep";
      StencilOperation3["Zero"] = "zero";
      StencilOperation3["Replace"] = "replace";
      StencilOperation3["Invert"] = "invert";
      StencilOperation3["IncrementClamp"] = "increment-clamp";
      StencilOperation3["DecrementClamp"] = "decrement-clamp";
      StencilOperation3["IncrementWrap"] = "increment-wrap";
      StencilOperation3["DecrementWrap"] = "decrement-wrap";
    })(StencilOperation2 = exports.StencilOperation || (exports.StencilOperation = {}));
    var StoreOp2;
    (function(StoreOp3) {
      StoreOp3["Store"] = "store";
      StoreOp3["Clear"] = "clear";
    })(StoreOp2 = exports.StoreOp || (exports.StoreOp = {}));
    var TextureDimension3;
    (function(TextureDimension4) {
      TextureDimension4["E1d"] = "1d";
      TextureDimension4["E2d"] = "2d";
      TextureDimension4["E3d"] = "3d";
    })(TextureDimension3 = exports.TextureDimension || (exports.TextureDimension = {}));
    var TextureFormat6;
    (function(TextureFormat7) {
      TextureFormat7["R8Unorm"] = "r8unorm";
      TextureFormat7["R8Snorm"] = "r8snorm";
      TextureFormat7["R8Uint"] = "r8uint";
      TextureFormat7["R8Sint"] = "r8sint";
      TextureFormat7["R16Uint"] = "r16uint";
      TextureFormat7["R16Sint"] = "r16sint";
      TextureFormat7["R16Float"] = "r16float";
      TextureFormat7["RG8Unorm"] = "rg8unorm";
      TextureFormat7["RG8Snorm"] = "rg8snorm";
      TextureFormat7["RG8Uint"] = "rg8uint";
      TextureFormat7["RG8Sint"] = "rg8sint";
      TextureFormat7["R32Uint"] = "r32uint";
      TextureFormat7["R32Sint"] = "r32sint";
      TextureFormat7["R32Float"] = "r32float";
      TextureFormat7["RG16Uint"] = "rg16uint";
      TextureFormat7["RG16Sint"] = "rg16sint";
      TextureFormat7["RG16Float"] = "rg16float";
      TextureFormat7["RGBA8Unorm"] = "rgba8unorm";
      TextureFormat7["RGBA8UnormSRGB"] = "rgba8unorm-srgb";
      TextureFormat7["RGBA8Snorm"] = "rgba8snorm";
      TextureFormat7["RGBA8Uint"] = "rgba8uint";
      TextureFormat7["RGBA8Sint"] = "rgba8sint";
      TextureFormat7["BGRA8Unorm"] = "bgra8unorm";
      TextureFormat7["BGRA8UnormSRGB"] = "bgra8unorm-srgb";
      TextureFormat7["RGB10A2Unorm"] = "rgb10a2unorm";
      TextureFormat7["RG11B10Float"] = "rg11b10float";
      TextureFormat7["RG32Uint"] = "rg32uint";
      TextureFormat7["RG32Sint"] = "rg32sint";
      TextureFormat7["RG32Float"] = "rg32float";
      TextureFormat7["RGBA16Uint"] = "rgba16uint";
      TextureFormat7["RGBA16Sint"] = "rgba16sint";
      TextureFormat7["RGBA16Float"] = "rgba16float";
      TextureFormat7["RGBA32Uint"] = "rgba32uint";
      TextureFormat7["RGBA32Sint"] = "rgba32sint";
      TextureFormat7["RGBA32Float"] = "rgba32float";
      TextureFormat7["Depth32Float"] = "depth32float";
      TextureFormat7["Depth24Plus"] = "depth24plus";
      TextureFormat7["Depth24PlusStencil8"] = "depth24plus-stencil8";
    })(TextureFormat6 = exports.TextureFormat || (exports.TextureFormat = {}));
    var TextureComponentType;
    (function(TextureComponentType2) {
      TextureComponentType2["Float"] = "float";
      TextureComponentType2["Sint"] = "sint";
      TextureComponentType2["Uint"] = "uint";
    })(TextureComponentType = exports.TextureComponentType || (exports.TextureComponentType = {}));
    var TextureViewDimension2;
    (function(TextureViewDimension3) {
      TextureViewDimension3["E1d"] = "1d";
      TextureViewDimension3["E2d"] = "2d";
      TextureViewDimension3["E2dArray"] = "2d-array";
      TextureViewDimension3["Cube"] = "cube";
      TextureViewDimension3["CubeArray"] = "cube-array";
      TextureViewDimension3["E3d"] = "3d";
    })(TextureViewDimension2 = exports.TextureViewDimension || (exports.TextureViewDimension = {}));
    var VertexFormat;
    (function(VertexFormat2) {
      VertexFormat2["Uchar2"] = "uchar2";
      VertexFormat2["Uchar4"] = "uchar4";
      VertexFormat2["Char2"] = "char2";
      VertexFormat2["Char4"] = "char4";
      VertexFormat2["Uchar2Norm"] = "uchar2norm";
      VertexFormat2["Uchar4Norm"] = "uchar4norm";
      VertexFormat2["Char2Norm"] = "char2norm";
      VertexFormat2["Char4Norm"] = "char4norm";
      VertexFormat2["Ushort2"] = "ushort2";
      VertexFormat2["Ushort4"] = "ushort4";
      VertexFormat2["Short2"] = "short2";
      VertexFormat2["Short4"] = "short4";
      VertexFormat2["Ushort2Norm"] = "ushort2norm";
      VertexFormat2["Ushort4Norm"] = "ushort4norm";
      VertexFormat2["Short2Norm"] = "short2norm";
      VertexFormat2["Short4Norm"] = "short4norm";
      VertexFormat2["Half2"] = "half2";
      VertexFormat2["Half4"] = "half4";
      VertexFormat2["Float"] = "float";
      VertexFormat2["Float2"] = "float2";
      VertexFormat2["Float3"] = "float3";
      VertexFormat2["Float4"] = "float4";
      VertexFormat2["Uint"] = "uint";
      VertexFormat2["Uint2"] = "uint2";
      VertexFormat2["Uint3"] = "uint3";
      VertexFormat2["Uint4"] = "uint4";
      VertexFormat2["Int"] = "int";
      VertexFormat2["Int2"] = "int2";
      VertexFormat2["Int3"] = "int3";
      VertexFormat2["Int4"] = "int4";
    })(VertexFormat = exports.VertexFormat || (exports.VertexFormat = {}));
    var TextureAspect2;
    (function(TextureAspect3) {
      TextureAspect3["All"] = "all";
      TextureAspect3["StencilOnly"] = "stencil-only";
      TextureAspect3["DepthOnly"] = "depth-only";
    })(TextureAspect2 = exports.TextureAspect || (exports.TextureAspect = {}));
    var CompilationMessageType;
    (function(CompilationMessageType2) {
      CompilationMessageType2["Error"] = "error";
      CompilationMessageType2["Warning"] = "warning";
      CompilationMessageType2["Info"] = "info";
    })(CompilationMessageType = exports.CompilationMessageType || (exports.CompilationMessageType = {}));
    var QueryType;
    (function(QueryType2) {
      QueryType2["Occlusion"] = "occlusion";
    })(QueryType = exports.QueryType || (exports.QueryType = {}));
    var BufferUsage5;
    (function(BufferUsage6) {
      BufferUsage6[BufferUsage6["MapRead"] = 1] = "MapRead";
      BufferUsage6[BufferUsage6["MapWrite"] = 2] = "MapWrite";
      BufferUsage6[BufferUsage6["CopySrc"] = 4] = "CopySrc";
      BufferUsage6[BufferUsage6["CopyDst"] = 8] = "CopyDst";
      BufferUsage6[BufferUsage6["Index"] = 16] = "Index";
      BufferUsage6[BufferUsage6["Vertex"] = 32] = "Vertex";
      BufferUsage6[BufferUsage6["Uniform"] = 64] = "Uniform";
      BufferUsage6[BufferUsage6["Storage"] = 128] = "Storage";
      BufferUsage6[BufferUsage6["Indirect"] = 256] = "Indirect";
      BufferUsage6[BufferUsage6["QueryResolve"] = 512] = "QueryResolve";
    })(BufferUsage5 = exports.BufferUsage || (exports.BufferUsage = {}));
    var ColorWrite2;
    (function(ColorWrite3) {
      ColorWrite3[ColorWrite3["Red"] = 1] = "Red";
      ColorWrite3[ColorWrite3["Green"] = 2] = "Green";
      ColorWrite3[ColorWrite3["Blue"] = 4] = "Blue";
      ColorWrite3[ColorWrite3["Alpha"] = 8] = "Alpha";
      ColorWrite3[ColorWrite3["All"] = 15] = "All";
    })(ColorWrite2 = exports.ColorWrite || (exports.ColorWrite = {}));
    var ShaderStage2;
    (function(ShaderStage3) {
      ShaderStage3[ShaderStage3["Vertex"] = 1] = "Vertex";
      ShaderStage3[ShaderStage3["Fragment"] = 2] = "Fragment";
      ShaderStage3[ShaderStage3["Compute"] = 4] = "Compute";
    })(ShaderStage2 = exports.ShaderStage || (exports.ShaderStage = {}));
    var TextureUsage3;
    (function(TextureUsage4) {
      TextureUsage4[TextureUsage4["CopySrc"] = 1] = "CopySrc";
      TextureUsage4[TextureUsage4["CopyDst"] = 2] = "CopyDst";
      TextureUsage4[TextureUsage4["Sampled"] = 4] = "Sampled";
      TextureUsage4[TextureUsage4["Storage"] = 8] = "Storage";
      TextureUsage4[TextureUsage4["OutputAttachment"] = 16] = "OutputAttachment";
    })(TextureUsage3 = exports.TextureUsage || (exports.TextureUsage = {}));
    var MapMode2;
    (function(MapMode3) {
      MapMode3[MapMode3["Read"] = 1] = "Read";
      MapMode3[MapMode3["Write"] = 2] = "Write";
    })(MapMode2 = exports.MapMode || (exports.MapMode = {}));
  }
});

// node_modules/@antv/g-webgpu/es/utils/canvas.js
function createCanvas() {
  if (typeof document !== "undefined") {
    return document.createElement("canvas");
  } else {
    throw new Error("Cannot create a canvas in this context");
  }
}
var init_canvas = __esm({
  "node_modules/@antv/g-webgpu/es/utils/canvas.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/utils/is-type.js
var toString4, isType2, is_type_default2;
var init_is_type2 = __esm({
  "node_modules/@antv/g-webgpu/es/utils/is-type.js"() {
    toString4 = {}.toString;
    isType2 = function isType3(value, type) {
      return toString4.call(value) === "[object " + type + "]";
    };
    is_type_default2 = isType2;
  }
});

// node_modules/@antv/g-webgpu/es/utils/is-array.js
var is_array_default2;
var init_is_array2 = __esm({
  "node_modules/@antv/g-webgpu/es/utils/is-array.js"() {
    init_is_type2();
    is_array_default2 = function(value) {
      return Array.isArray ? Array.isArray(value) : is_type_default2(value, "Array");
    };
  }
});

// node_modules/@antv/g-webgpu/es/utils/is-typedarray.js
function baseIsTypedArray2(value) {
  return isObjectLike3(value) && isLength2(value.length) && !!typedArrayTags2[objectToString2.call(value)];
}
function isLength2(value) {
  return typeof value === "number" && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER2;
}
function isObjectLike3(value) {
  return !!value && _typeof(value) === "object";
}
var MAX_SAFE_INTEGER2, argsTag2, arrayTag2, boolTag2, dateTag2, errorTag2, funcTag2, mapTag2, numberTag2, objectTag2, regexpTag2, setTag2, stringTag2, weakMapTag2, arrayBufferTag2, dataViewTag2, float32Tag2, float64Tag2, int8Tag2, int16Tag2, int32Tag2, uint8Tag2, uint8ClampedTag2, uint16Tag2, uint32Tag2, typedArrayTags2, objectProto3, objectToString2, isTypedArray2;
var init_is_typedarray2 = __esm({
  "node_modules/@antv/g-webgpu/es/utils/is-typedarray.js"() {
    init_typeof();
    MAX_SAFE_INTEGER2 = 9007199254740991;
    argsTag2 = "[object Arguments]";
    arrayTag2 = "[object Array]";
    boolTag2 = "[object Boolean]";
    dateTag2 = "[object Date]";
    errorTag2 = "[object Error]";
    funcTag2 = "[object Function]";
    mapTag2 = "[object Map]";
    numberTag2 = "[object Number]";
    objectTag2 = "[object Object]";
    regexpTag2 = "[object RegExp]";
    setTag2 = "[object Set]";
    stringTag2 = "[object String]";
    weakMapTag2 = "[object WeakMap]";
    arrayBufferTag2 = "[object ArrayBuffer]";
    dataViewTag2 = "[object DataView]";
    float32Tag2 = "[object Float32Array]";
    float64Tag2 = "[object Float64Array]";
    int8Tag2 = "[object Int8Array]";
    int16Tag2 = "[object Int16Array]";
    int32Tag2 = "[object Int32Array]";
    uint8Tag2 = "[object Uint8Array]";
    uint8ClampedTag2 = "[object Uint8ClampedArray]";
    uint16Tag2 = "[object Uint16Array]";
    uint32Tag2 = "[object Uint32Array]";
    typedArrayTags2 = {};
    typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
    typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
    objectProto3 = Object.prototype;
    objectToString2 = objectProto3.toString;
    isTypedArray2 = baseIsTypedArray2;
  }
});

// node_modules/@antv/g-webgpu/es/Kernel.js
function ownKeys6(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread6(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator11, WebGPUConstants, _dec30, _dec213, _dec310, _class17, _class213, _descriptor17, _descriptor210, _temp15, Kernel;
var init_Kernel = __esm({
  "node_modules/@antv/g-webgpu/es/Kernel.js"() {
    import_regenerator11 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_defineProperty();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    WebGPUConstants = __toESM(require_constants2());
    init_inversify();
    init_canvas();
    init_is_array2();
    init_is_number3();
    init_is_typedarray2();
    Kernel = (_dec30 = injectable(), _dec213 = inject(IDENTIFIER.RenderEngine), _dec310 = inject(IDENTIFIER.ConfigService), _dec30(_class17 = (_class213 = (_temp15 = function() {
      function Kernel2() {
        _classCallCheck(this, Kernel2);
        _initializerDefineProperty(this, "engine", _descriptor17, this);
        _initializerDefineProperty(this, "configService", _descriptor210, this);
        this.entity = createEntity();
        this.model = void 0;
        this.dirty = true;
        this.compiledBundle = void 0;
        this.initPromise = void 0;
      }
      _createClass(Kernel2, [{
        key: "init",
        value: function init() {
          var _this$configService$g = this.configService.get(), canvas = _this$configService$g.canvas, engineOptions = _this$configService$g.engineOptions;
          this.initPromise = this.engine.init(_objectSpread6({
            canvas: canvas || createCanvas(),
            swapChainFormat: WebGPUConstants.TextureFormat.BGRA8Unorm,
            antialiasing: false
          }, engineOptions));
        }
      }, {
        key: "setBundle",
        value: function setBundle(bundle) {
          this.compiledBundle = JSON.parse(JSON.stringify(bundle));
        }
      }, {
        key: "setDispatch",
        value: function setDispatch(dispatch) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.dispatch = dispatch;
          }
          return this;
        }
      }, {
        key: "setMaxIteration",
        value: function setMaxIteration(maxIteration) {
          if (this.compiledBundle.context) {
            this.compiledBundle.context.maxIteration = maxIteration;
          }
          return this;
        }
      }, {
        key: "setBinding",
        value: function setBinding(name, data) {
          var _this = this;
          if (typeof name === "string") {
            var isNumberLikeData = isNumber3(data) || isTypedArray2(data) || is_array_default2(data);
            if (this.compiledBundle && this.compiledBundle.context) {
              var existedDefine = this.compiledBundle.context.defines.find(function(b10) {
                return b10.name === name;
              });
              if (existedDefine) {
                existedDefine.value = data;
                return this;
              }
              var existedBinding = this.compiledBundle.context.uniforms.find(function(b10) {
                return b10.name === name;
              });
              if (existedBinding) {
                if (isNumberLikeData) {
                  existedBinding.data = data;
                  existedBinding.isReferer = false;
                  if (existedBinding.storageClass === STORAGE_CLASS.Uniform) {
                    if (this.model) {
                      this.model.updateUniform(name, data);
                    }
                  } else {
                    if (this.model) {
                      this.model.updateBuffer(name, data);
                    }
                  }
                } else {
                  existedBinding.isReferer = true;
                  existedBinding.data = data;
                }
              }
            }
          } else {
            Object.keys(name).forEach(function(key) {
              _this.setBinding(key, name[key]);
            });
          }
          return this;
        }
      }, {
        key: "execute",
        value: function() {
          var _execute = _asyncToGenerator(import_regenerator11.default.mark(function _callee() {
            var _this2 = this;
            var iteration, i2, _args = arguments;
            return import_regenerator11.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    iteration = _args.length > 0 && _args[0] !== void 0 ? _args[0] : 1;
                    if (!this.dirty) {
                      _context.next = 6;
                      break;
                    }
                    if (this.compiledBundle.context) {
                      if (iteration > 1) {
                        this.compiledBundle.context.maxIteration = iteration;
                      } else {
                        this.compiledBundle.context.maxIteration++;
                      }
                    }
                    _context.next = 5;
                    return this.compile();
                  case 5:
                    this.dirty = false;
                  case 6:
                    this.engine.beginFrame();
                    this.engine.clear({});
                    if (this.compiledBundle.context) {
                      this.compiledBundle.context.uniforms.filter(function(_ref2) {
                        var isReferer = _ref2.isReferer;
                        return isReferer;
                      }).forEach(function(_ref2) {
                        var data = _ref2.data, name = _ref2.name;
                        _this2.model.confirmInput(data.model, name);
                      });
                    }
                    for (i2 = 0; i2 < iteration; i2++) {
                      this.model.run();
                    }
                    this.engine.endFrame();
                    return _context.abrupt("return", this);
                  case 12:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function execute() {
            return _execute.apply(this, arguments);
          }
          return execute;
        }()
      }, {
        key: "getOutput",
        value: function() {
          var _getOutput = _asyncToGenerator(import_regenerator11.default.mark(function _callee2() {
            return import_regenerator11.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    return _context2.abrupt("return", this.model.readData());
                  case 1:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function getOutput() {
            return _getOutput.apply(this, arguments);
          }
          return getOutput;
        }()
      }, {
        key: "compile",
        value: function() {
          var _compile = _asyncToGenerator(import_regenerator11.default.mark(function _callee3() {
            var context, target, shader;
            return import_regenerator11.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return this.initPromise;
                  case 2:
                    context = _objectSpread6({}, this.compiledBundle.context);
                    target = this.engine.supportWebGPU ? this.engine.useWGSL ? Target2.WGSL : Target2.GLSL450 : Target2.GLSL100;
                    shader = this.compiledBundle.shaders[target];
                    context.defines.filter(function(define2) {
                      return define2.runtime;
                    }).forEach(function(define2) {
                      var valuePlaceHolder = "".concat(DefineValuePlaceholder).concat(define2.name);
                      shader = shader.replace(valuePlaceHolder, "".concat(define2.value));
                    });
                    context.shader = shader;
                    context.uniforms.forEach(function(uniform) {
                      if (!uniform.data) {
                        if (uniform.storageClass === STORAGE_CLASS.StorageBuffer) {
                          var sizePerElement = 1;
                          if (uniform.type === AST_TOKEN_TYPES.FloatArray) {
                            sizePerElement = 1;
                          } else if (uniform.type === AST_TOKEN_TYPES.Vector4FloatArray) {
                            sizePerElement = 4;
                          }
                          uniform.data = new Float32Array(context.output.length * sizePerElement).fill(0);
                        }
                      }
                    });
                    this.compiledBundle.context = context;
                    _context3.next = 11;
                    return this.engine.createComputeModel(this.compiledBundle.context);
                  case 11:
                    this.model = _context3.sent;
                  case 12:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function compile() {
            return _compile.apply(this, arguments);
          }
          return compile;
        }()
      }]);
      return Kernel2;
    }(), _temp15), _descriptor17 = _applyDecoratedDescriptor(_class213.prototype, "engine", [_dec213], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor210 = _applyDecoratedDescriptor(_class213.prototype, "configService", [_dec310], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class213)) || _class17);
  }
});

// node_modules/@antv/g-webgpu/es/material/index.js
var _dec31, _dec214, _class18, _class214, _descriptor18, _class37, _temp16, Material;
var init_material = __esm({
  "node_modules/@antv/g-webgpu/es/material/index.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    Material = (_dec31 = injectable(), _dec214 = inject(IDENTIFIER.MaterialComponentManager), _dec31(_class18 = (_class214 = (_temp16 = _class37 = function() {
      function Material2() {
        _classCallCheck(this, Material2);
        this.config = void 0;
        _initializerDefineProperty(this, "material", _descriptor18, this);
        this.entity = void 0;
        this.component = void 0;
      }
      _createClass(Material2, [{
        key: "getEntity",
        value: function getEntity() {
          return this.entity;
        }
      }, {
        key: "getComponent",
        value: function getComponent() {
          return this.component;
        }
      }, {
        key: "setConfig",
        value: function setConfig(config) {
          this.config = config;
        }
      }, {
        key: "setEntity",
        value: function setEntity(entity, type) {
          this.entity = entity;
          this.component = this.material.create(entity);
          this.component.entity = entity;
          this.component.type = type;
          this.onEntityCreated();
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
        }
      }]);
      return Material2;
    }(), _class37.BASIC = "basic", _temp16), _descriptor18 = _applyDecoratedDescriptor(_class214.prototype, "material", [_dec214], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class214)) || _class18);
  }
});

// node_modules/@antv/g-webgpu/es/renderable/Renderable.js
var _dec40, _dec215, _dec311, _dec48, _dec56, _dec64, _class19, _class215, _descriptor19, _descriptor211, _descriptor38, _descriptor46, _class38, _temp17, Renderable;
var init_Renderable = __esm({
  "node_modules/@antv/g-webgpu/es/renderable/Renderable.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    Renderable = (_dec40 = injectable(), _dec215 = inject(IDENTIFIER.MeshComponentManager), _dec311 = inject(IDENTIFIER.CullableComponentManager), _dec48 = inject(IDENTIFIER.TransformComponentManager), _dec56 = inject(IDENTIFIER.Systems), _dec64 = named2(IDENTIFIER.SceneGraphSystem), _dec40(_class19 = (_class215 = (_temp17 = _class38 = function() {
      function Renderable2() {
        _classCallCheck(this, Renderable2);
        this.attributes = {};
        this.config = void 0;
        _initializerDefineProperty(this, "mesh", _descriptor19, this);
        _initializerDefineProperty(this, "cullable", _descriptor211, this);
        _initializerDefineProperty(this, "transform", _descriptor38, this);
        _initializerDefineProperty(this, "sceneGraphSystem", _descriptor46, this);
        this.meshComponent = void 0;
        this.transformComponent = void 0;
        this.entity = void 0;
      }
      _createClass(Renderable2, [{
        key: "getEntity",
        value: function getEntity() {
          return this.entity;
        }
      }, {
        key: "getTransformComponent",
        value: function getTransformComponent() {
          return this.transformComponent;
        }
      }, {
        key: "getMeshComponent",
        value: function getMeshComponent() {
          return this.meshComponent;
        }
      }, {
        key: "setConfig",
        value: function setConfig(config) {
          this.config = config;
        }
      }, {
        key: "setEntity",
        value: function setEntity(entity) {
          this.entity = entity;
          this.cullable.create(entity);
          this.meshComponent = this.mesh.create(entity);
          this.transformComponent = this.transform.create(entity);
          this.onEntityCreated();
        }
      }, {
        key: "setMaterial",
        value: function setMaterial(material) {
          this.meshComponent.material = material;
          return this;
        }
      }, {
        key: "setGeometry",
        value: function setGeometry(geometry) {
          this.meshComponent.geometry = geometry;
          return this;
        }
      }, {
        key: "setAttributes",
        value: function setAttributes(attributes) {
          var _this = this;
          Object.keys(attributes).forEach(function(name) {
            if (attributes[name] !== void 0 && attributes[name] !== _this.attributes[name]) {
              _this.onAttributeChanged({
                name,
                data: attributes[name]
              });
              _this.attributes[name] = attributes[name];
            }
          });
        }
      }, {
        key: "setVisible",
        value: function setVisible(visible) {
          var _this2 = this;
          this.meshComponent.visible = visible;
          this.meshComponent.children.forEach(function(childEntity) {
            var child = _this2.mesh.getComponentByEntity(childEntity);
            if (child) {
              child.visible = visible;
            }
          });
          return this;
        }
      }, {
        key: "isVisible",
        value: function isVisible() {
          return this.meshComponent.visible;
        }
      }, {
        key: "attach",
        value: function attach(parentRenderable) {
          this.sceneGraphSystem.attach(this.entity, parentRenderable.entity);
          return this;
        }
      }, {
        key: "detach",
        value: function detach() {
          this.sceneGraphSystem.detach(this.entity);
          return this;
        }
      }, {
        key: "detachChildren",
        value: function detachChildren() {
          this.sceneGraphSystem.detachChildren(this.entity);
          return this;
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
        }
      }, {
        key: "onAttributeChanged",
        value: function onAttributeChanged(_ref2) {
          var name = _ref2.name, data = _ref2.data;
          if (this.meshComponent && this.meshComponent.material) {
            this.meshComponent.material.setUniform(this.convertAttributeName2UniformName(name), data);
          }
        }
      }, {
        key: "convertAttributeName2UniformName",
        value: function convertAttributeName2UniformName(attributeName) {
          return attributeName;
        }
      }]);
      return Renderable2;
    }(), _class38.POINT = "point", _class38.LINE = "line", _class38.GRID = "grid", _temp17), _descriptor19 = _applyDecoratedDescriptor(_class215.prototype, "mesh", [_dec215], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor211 = _applyDecoratedDescriptor(_class215.prototype, "cullable", [_dec311], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor38 = _applyDecoratedDescriptor(_class215.prototype, "transform", [_dec48], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor46 = _applyDecoratedDescriptor(_class215.prototype, "sceneGraphSystem", [_dec56, _dec64], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class215)) || _class19);
  }
});

// node_modules/regl/dist/regl.js
var require_regl = __commonJS({
  "node_modules/regl/dist/regl.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.createREGL = factory();
    })(exports, function() {
      "use strict";
      var isTypedArray4 = function(x2) {
        return x2 instanceof Uint8Array || x2 instanceof Uint16Array || x2 instanceof Uint32Array || x2 instanceof Int8Array || x2 instanceof Int16Array || x2 instanceof Int32Array || x2 instanceof Float32Array || x2 instanceof Float64Array || x2 instanceof Uint8ClampedArray;
      };
      var extend3 = function(base, opts) {
        var keys2 = Object.keys(opts);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          base[keys2[i2]] = opts[keys2[i2]];
        }
        return base;
      };
      var endl = "\n";
      function decodeB64(str7) {
        if (typeof atob !== "undefined") {
          return atob(str7);
        }
        return "base64:" + str7;
      }
      function raise(message) {
        var error = new Error("(regl) " + message);
        console.error(error);
        throw error;
      }
      function check(pred, message) {
        if (!pred) {
          raise(message);
        }
      }
      function encolon(message) {
        if (message) {
          return ": " + message;
        }
        return "";
      }
      function checkParameter(param, possibilities, message) {
        if (!(param in possibilities)) {
          raise("unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join());
        }
      }
      function checkIsTypedArray(data, message) {
        if (!isTypedArray4(data)) {
          raise("invalid parameter type" + encolon(message) + ". must be a typed array");
        }
      }
      function standardTypeEh(value, type) {
        switch (type) {
          case "number":
            return typeof value === "number";
          case "object":
            return typeof value === "object";
          case "string":
            return typeof value === "string";
          case "boolean":
            return typeof value === "boolean";
          case "function":
            return typeof value === "function";
          case "undefined":
            return typeof value === "undefined";
          case "symbol":
            return typeof value === "symbol";
        }
      }
      function checkTypeOf(value, type, message) {
        if (!standardTypeEh(value, type)) {
          raise("invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value);
        }
      }
      function checkNonNegativeInt(value, message) {
        if (!(value >= 0 && (value | 0) === value)) {
          raise("invalid parameter type, (" + value + ")" + encolon(message) + ". must be a nonnegative integer");
        }
      }
      function checkOneOf(value, list, message) {
        if (list.indexOf(value) < 0) {
          raise("invalid value" + encolon(message) + ". must be one of: " + list);
        }
      }
      var constructorKeys = [
        "gl",
        "canvas",
        "container",
        "attributes",
        "pixelRatio",
        "extensions",
        "optionalExtensions",
        "profile",
        "onDone"
      ];
      function checkConstructor(obj) {
        Object.keys(obj).forEach(function(key) {
          if (constructorKeys.indexOf(key) < 0) {
            raise('invalid regl constructor argument "' + key + '". must be one of ' + constructorKeys);
          }
        });
      }
      function leftPad(str7, n2) {
        str7 = str7 + "";
        while (str7.length < n2) {
          str7 = " " + str7;
        }
        return str7;
      }
      function ShaderFile() {
        this.name = "unknown";
        this.lines = [];
        this.index = {};
        this.hasErrors = false;
      }
      function ShaderLine(number, line2) {
        this.number = number;
        this.line = line2;
        this.errors = [];
      }
      function ShaderError(fileNumber, lineNumber, message) {
        this.file = fileNumber;
        this.line = lineNumber;
        this.message = message;
      }
      function guessCommand() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /compileProcedure.*\n\s*at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function guessCallSite() {
        var error = new Error();
        var stack = (error.stack || error).toString();
        var pat = /at REGLCommand.*\n\s+at.*\((.*)\)/.exec(stack);
        if (pat) {
          return pat[1];
        }
        var pat2 = /at REGLCommand.*\n\s+at\s+(.*)\n/.exec(stack);
        if (pat2) {
          return pat2[1];
        }
        return "unknown";
      }
      function parseSource(source, command) {
        var lines2 = source.split("\n");
        var lineNumber = 1;
        var fileNumber = 0;
        var files = {
          unknown: new ShaderFile(),
          0: new ShaderFile()
        };
        files.unknown.name = files[0].name = command || guessCommand();
        files.unknown.lines.push(new ShaderLine(0, ""));
        for (var i2 = 0; i2 < lines2.length; ++i2) {
          var line2 = lines2[i2];
          var parts = /^\s*#\s*(\w+)\s+(.+)\s*$/.exec(line2);
          if (parts) {
            switch (parts[1]) {
              case "line":
                var lineNumberInfo = /(\d+)(\s+\d+)?/.exec(parts[2]);
                if (lineNumberInfo) {
                  lineNumber = lineNumberInfo[1] | 0;
                  if (lineNumberInfo[2]) {
                    fileNumber = lineNumberInfo[2] | 0;
                    if (!(fileNumber in files)) {
                      files[fileNumber] = new ShaderFile();
                    }
                  }
                }
                break;
              case "define":
                var nameInfo = /SHADER_NAME(_B64)?\s+(.*)$/.exec(parts[2]);
                if (nameInfo) {
                  files[fileNumber].name = nameInfo[1] ? decodeB64(nameInfo[2]) : nameInfo[2];
                }
                break;
            }
          }
          files[fileNumber].lines.push(new ShaderLine(lineNumber++, line2));
        }
        Object.keys(files).forEach(function(fileNumber2) {
          var file = files[fileNumber2];
          file.lines.forEach(function(line3) {
            file.index[line3.number] = line3;
          });
        });
        return files;
      }
      function parseErrorLog(errLog) {
        var result = [];
        errLog.split("\n").forEach(function(errMsg) {
          if (errMsg.length < 5) {
            return;
          }
          var parts = /^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(errMsg);
          if (parts) {
            result.push(new ShaderError(parts[1] | 0, parts[2] | 0, parts[3].trim()));
          } else if (errMsg.length > 0) {
            result.push(new ShaderError("unknown", 0, errMsg));
          }
        });
        return result;
      }
      function annotateFiles(files, errors) {
        errors.forEach(function(error) {
          var file = files[error.file];
          if (file) {
            var line2 = file.index[error.line];
            if (line2) {
              line2.errors.push(error);
              file.hasErrors = true;
              return;
            }
          }
          files.unknown.hasErrors = true;
          files.unknown.lines[0].errors.push(error);
        });
      }
      function checkShaderError(gl2, shader, source, type, command) {
        if (!gl2.getShaderParameter(shader, gl2.COMPILE_STATUS)) {
          var errLog = gl2.getShaderInfoLog(shader);
          var typeName = type === gl2.FRAGMENT_SHADER ? "fragment" : "vertex";
          checkCommandType(source, "string", typeName + " shader source must be a string", command);
          var files = parseSource(source, command);
          var errors = parseErrorLog(errLog);
          annotateFiles(files, errors);
          Object.keys(files).forEach(function(fileNumber) {
            var file = files[fileNumber];
            if (!file.hasErrors) {
              return;
            }
            var strings = [""];
            var styles = [""];
            function push(str7, style) {
              strings.push(str7);
              styles.push(style || "");
            }
            push("file number " + fileNumber + ": " + file.name + "\n", "color:red;text-decoration:underline;font-weight:bold");
            file.lines.forEach(function(line2) {
              if (line2.errors.length > 0) {
                push(leftPad(line2.number, 4) + "|  ", "background-color:yellow; font-weight:bold");
                push(line2.line + endl, "color:red; background-color:yellow; font-weight:bold");
                var offset = 0;
                line2.errors.forEach(function(error) {
                  var message = error.message;
                  var token2 = /^\s*'(.*)'\s*:\s*(.*)$/.exec(message);
                  if (token2) {
                    var tokenPat = token2[1];
                    message = token2[2];
                    switch (tokenPat) {
                      case "assign":
                        tokenPat = "=";
                        break;
                    }
                    offset = Math.max(line2.line.indexOf(tokenPat, offset), 0);
                  } else {
                    offset = 0;
                  }
                  push(leftPad("| ", 6));
                  push(leftPad("^^^", offset + 3) + endl, "font-weight:bold");
                  push(leftPad("| ", 6));
                  push(message + endl, "font-weight:bold");
                });
                push(leftPad("| ", 6) + endl);
              } else {
                push(leftPad(line2.number, 4) + "|  ");
                push(line2.line + endl, "color:red");
              }
            });
            if (typeof document !== "undefined" && !window.chrome) {
              styles[0] = strings.join("%c");
              console.log.apply(console, styles);
            } else {
              console.log(strings.join(""));
            }
          });
          check.raise("Error compiling " + typeName + " shader, " + files[0].name);
        }
      }
      function checkLinkError(gl2, program, fragShader, vertShader, command) {
        if (!gl2.getProgramParameter(program, gl2.LINK_STATUS)) {
          var errLog = gl2.getProgramInfoLog(program);
          var fragParse = parseSource(fragShader, command);
          var vertParse = parseSource(vertShader, command);
          var header = 'Error linking program with vertex shader, "' + vertParse[0].name + '", and fragment shader "' + fragParse[0].name + '"';
          if (typeof document !== "undefined") {
            console.log("%c" + header + endl + "%c" + errLog, "color:red;text-decoration:underline;font-weight:bold", "color:red");
          } else {
            console.log(header + endl + errLog);
          }
          check.raise(header);
        }
      }
      function saveCommandRef(object) {
        object._commandRef = guessCommand();
      }
      function saveDrawCommandInfo(opts, uniforms, attributes, stringStore) {
        saveCommandRef(opts);
        function id2(str7) {
          if (str7) {
            return stringStore.id(str7);
          }
          return 0;
        }
        opts._fragId = id2(opts.static.frag);
        opts._vertId = id2(opts.static.vert);
        function addProps(dict, set8) {
          Object.keys(set8).forEach(function(u2) {
            dict[stringStore.id(u2)] = true;
          });
        }
        var uniformSet = opts._uniformSet = {};
        addProps(uniformSet, uniforms.static);
        addProps(uniformSet, uniforms.dynamic);
        var attributeSet = opts._attributeSet = {};
        addProps(attributeSet, attributes.static);
        addProps(attributeSet, attributes.dynamic);
        opts._hasCount = "count" in opts.static || "count" in opts.dynamic || "elements" in opts.static || "elements" in opts.dynamic;
      }
      function commandRaise(message, command) {
        var callSite = guessCallSite();
        raise(message + " in command " + (command || guessCommand()) + (callSite === "unknown" ? "" : " called from " + callSite));
      }
      function checkCommand(pred, message, command) {
        if (!pred) {
          commandRaise(message, command || guessCommand());
        }
      }
      function checkParameterCommand(param, possibilities, message, command) {
        if (!(param in possibilities)) {
          commandRaise("unknown parameter (" + param + ")" + encolon(message) + ". possible values: " + Object.keys(possibilities).join(), command || guessCommand());
        }
      }
      function checkCommandType(value, type, message, command) {
        if (!standardTypeEh(value, type)) {
          commandRaise("invalid parameter type" + encolon(message) + ". expected " + type + ", got " + typeof value, command || guessCommand());
        }
      }
      function checkOptional(block) {
        block();
      }
      function checkFramebufferFormat(attachment, texFormats, rbFormats) {
        if (attachment.texture) {
          checkOneOf(attachment.texture._texture.internalformat, texFormats, "unsupported texture format for attachment");
        } else {
          checkOneOf(attachment.renderbuffer._renderbuffer.format, rbFormats, "unsupported renderbuffer format for attachment");
        }
      }
      var GL_CLAMP_TO_EDGE = 33071;
      var GL_NEAREST = 9728;
      var GL_NEAREST_MIPMAP_NEAREST = 9984;
      var GL_LINEAR_MIPMAP_NEAREST = 9985;
      var GL_NEAREST_MIPMAP_LINEAR = 9986;
      var GL_LINEAR_MIPMAP_LINEAR = 9987;
      var GL_BYTE = 5120;
      var GL_UNSIGNED_BYTE = 5121;
      var GL_SHORT = 5122;
      var GL_UNSIGNED_SHORT = 5123;
      var GL_INT = 5124;
      var GL_UNSIGNED_INT = 5125;
      var GL_FLOAT = 5126;
      var GL_UNSIGNED_SHORT_4_4_4_4 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL = 34042;
      var GL_HALF_FLOAT_OES = 36193;
      var TYPE_SIZE = {};
      TYPE_SIZE[GL_BYTE] = TYPE_SIZE[GL_UNSIGNED_BYTE] = 1;
      TYPE_SIZE[GL_SHORT] = TYPE_SIZE[GL_UNSIGNED_SHORT] = TYPE_SIZE[GL_HALF_FLOAT_OES] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_6_5] = TYPE_SIZE[GL_UNSIGNED_SHORT_4_4_4_4] = TYPE_SIZE[GL_UNSIGNED_SHORT_5_5_5_1] = 2;
      TYPE_SIZE[GL_INT] = TYPE_SIZE[GL_UNSIGNED_INT] = TYPE_SIZE[GL_FLOAT] = TYPE_SIZE[GL_UNSIGNED_INT_24_8_WEBGL] = 4;
      function pixelSize(type, channels) {
        if (type === GL_UNSIGNED_SHORT_5_5_5_1 || type === GL_UNSIGNED_SHORT_4_4_4_4 || type === GL_UNSIGNED_SHORT_5_6_5) {
          return 2;
        } else if (type === GL_UNSIGNED_INT_24_8_WEBGL) {
          return 4;
        } else {
          return TYPE_SIZE[type] * channels;
        }
      }
      function isPow2(v2) {
        return !(v2 & v2 - 1) && !!v2;
      }
      function checkTexture2D(info, mipData, limits) {
        var i2;
        var w2 = mipData.width;
        var h2 = mipData.height;
        var c2 = mipData.channels;
        check(w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize, "invalid texture shape");
        if (info.wrapS !== GL_CLAMP_TO_EDGE || info.wrapT !== GL_CLAMP_TO_EDGE) {
          check(isPow2(w2) && isPow2(h2), "incompatible wrap mode for texture, both width and height must be power of 2");
        }
        if (mipData.mipmask === 1) {
          if (w2 !== 1 && h2 !== 1) {
            check(info.minFilter !== GL_NEAREST_MIPMAP_NEAREST && info.minFilter !== GL_NEAREST_MIPMAP_LINEAR && info.minFilter !== GL_LINEAR_MIPMAP_NEAREST && info.minFilter !== GL_LINEAR_MIPMAP_LINEAR, "min filter requires mipmap");
          }
        } else {
          check(isPow2(w2) && isPow2(h2), "texture must be a square power of 2 to support mipmapping");
          check(mipData.mipmask === (w2 << 1) - 1, "missing or incomplete mipmap data");
        }
        if (mipData.type === GL_FLOAT) {
          if (limits.extensions.indexOf("oes_texture_float_linear") < 0) {
            check(info.minFilter === GL_NEAREST && info.magFilter === GL_NEAREST, "filter not supported, must enable oes_texture_float_linear");
          }
          check(!info.genMipmaps, "mipmap generation not supported with float textures");
        }
        var mipimages = mipData.images;
        for (i2 = 0; i2 < 16; ++i2) {
          if (mipimages[i2]) {
            var mw = w2 >> i2;
            var mh = h2 >> i2;
            check(mipData.mipmask & 1 << i2, "missing mipmap data");
            var img = mipimages[i2];
            check(img.width === mw && img.height === mh, "invalid shape for mip images");
            check(img.format === mipData.format && img.internalformat === mipData.internalformat && img.type === mipData.type, "incompatible type for mip image");
            if (img.compressed) {
            } else if (img.data) {
              var rowSize = Math.ceil(pixelSize(img.type, c2) * mw / img.unpackAlignment) * img.unpackAlignment;
              check(img.data.byteLength === rowSize * mh, "invalid data for image, buffer size is inconsistent with image format");
            } else if (img.element) {
            } else if (img.copy) {
            }
          } else if (!info.genMipmaps) {
            check((mipData.mipmask & 1 << i2) === 0, "extra mipmap data");
          }
        }
        if (mipData.compressed) {
          check(!info.genMipmaps, "mipmap generation for compressed images not supported");
        }
      }
      function checkTextureCube(texture, info, faces, limits) {
        var w2 = texture.width;
        var h2 = texture.height;
        var c2 = texture.channels;
        check(w2 > 0 && w2 <= limits.maxTextureSize && h2 > 0 && h2 <= limits.maxTextureSize, "invalid texture shape");
        check(w2 === h2, "cube map must be square");
        check(info.wrapS === GL_CLAMP_TO_EDGE && info.wrapT === GL_CLAMP_TO_EDGE, "wrap mode not supported by cube map");
        for (var i2 = 0; i2 < faces.length; ++i2) {
          var face = faces[i2];
          check(face.width === w2 && face.height === h2, "inconsistent cube map face shape");
          if (info.genMipmaps) {
            check(!face.compressed, "can not generate mipmap for compressed textures");
            check(face.mipmask === 1, "can not specify mipmaps and generate mipmaps");
          } else {
          }
          var mipmaps = face.images;
          for (var j2 = 0; j2 < 16; ++j2) {
            var img = mipmaps[j2];
            if (img) {
              var mw = w2 >> j2;
              var mh = h2 >> j2;
              check(face.mipmask & 1 << j2, "missing mipmap data");
              check(img.width === mw && img.height === mh, "invalid shape for mip images");
              check(img.format === texture.format && img.internalformat === texture.internalformat && img.type === texture.type, "incompatible type for mip image");
              if (img.compressed) {
              } else if (img.data) {
                check(img.data.byteLength === mw * mh * Math.max(pixelSize(img.type, c2), img.unpackAlignment), "invalid data for image, buffer size is inconsistent with image format");
              } else if (img.element) {
              } else if (img.copy) {
              }
            }
          }
        }
      }
      var check$1 = extend3(check, {
        optional: checkOptional,
        raise,
        commandRaise,
        command: checkCommand,
        parameter: checkParameter,
        commandParameter: checkParameterCommand,
        constructor: checkConstructor,
        type: checkTypeOf,
        commandType: checkCommandType,
        isTypedArray: checkIsTypedArray,
        nni: checkNonNegativeInt,
        oneOf: checkOneOf,
        shaderError: checkShaderError,
        linkError: checkLinkError,
        callSite: guessCallSite,
        saveCommandRef,
        saveDrawInfo: saveDrawCommandInfo,
        framebufferFormat: checkFramebufferFormat,
        guessCommand,
        texture2D: checkTexture2D,
        textureCube: checkTextureCube
      });
      var VARIABLE_COUNTER = 0;
      var DYN_FUNC = 0;
      var DYN_CONSTANT = 5;
      var DYN_ARRAY = 6;
      function DynamicVariable(type, data) {
        this.id = VARIABLE_COUNTER++;
        this.type = type;
        this.data = data;
      }
      function escapeStr(str7) {
        return str7.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
      }
      function splitParts(str7) {
        if (str7.length === 0) {
          return [];
        }
        var firstChar = str7.charAt(0);
        var lastChar = str7.charAt(str7.length - 1);
        if (str7.length > 1 && firstChar === lastChar && (firstChar === '"' || firstChar === "'")) {
          return ['"' + escapeStr(str7.substr(1, str7.length - 2)) + '"'];
        }
        var parts = /\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(str7);
        if (parts) {
          return splitParts(str7.substr(0, parts.index)).concat(splitParts(parts[1])).concat(splitParts(str7.substr(parts.index + parts[0].length)));
        }
        var subparts = str7.split(".");
        if (subparts.length === 1) {
          return ['"' + escapeStr(str7) + '"'];
        }
        var result = [];
        for (var i2 = 0; i2 < subparts.length; ++i2) {
          result = result.concat(splitParts(subparts[i2]));
        }
        return result;
      }
      function toAccessorString(str7) {
        return "[" + splitParts(str7).join("][") + "]";
      }
      function defineDynamic(type, data) {
        return new DynamicVariable(type, toAccessorString(data + ""));
      }
      function isDynamic(x2) {
        return typeof x2 === "function" && !x2._reglType || x2 instanceof DynamicVariable;
      }
      function unbox(x2, path) {
        if (typeof x2 === "function") {
          return new DynamicVariable(DYN_FUNC, x2);
        } else if (typeof x2 === "number" || typeof x2 === "boolean") {
          return new DynamicVariable(DYN_CONSTANT, x2);
        } else if (Array.isArray(x2)) {
          return new DynamicVariable(DYN_ARRAY, x2.map((y2, i2) => unbox(y2, path + "[" + i2 + "]")));
        } else if (x2 instanceof DynamicVariable) {
          return x2;
        }
        check$1(false, "invalid option type in uniform " + path);
      }
      var dynamic = {
        DynamicVariable,
        define: defineDynamic,
        isDynamic,
        unbox,
        accessor: toAccessorString
      };
      var raf = {
        next: typeof requestAnimationFrame === "function" ? function(cb) {
          return requestAnimationFrame(cb);
        } : function(cb) {
          return setTimeout(cb, 16);
        },
        cancel: typeof cancelAnimationFrame === "function" ? function(raf2) {
          return cancelAnimationFrame(raf2);
        } : clearTimeout
      };
      var clock2 = typeof performance !== "undefined" && performance.now ? function() {
        return performance.now();
      } : function() {
        return +new Date();
      };
      function createStringStore() {
        var stringIds = { "": 0 };
        var stringValues = [""];
        return {
          id: function(str7) {
            var result = stringIds[str7];
            if (result) {
              return result;
            }
            result = stringIds[str7] = stringValues.length;
            stringValues.push(str7);
            return result;
          },
          str: function(id2) {
            return stringValues[id2];
          }
        };
      }
      function createCanvas2(element, onDone, pixelRatio) {
        var canvas = document.createElement("canvas");
        extend3(canvas.style, {
          border: 0,
          margin: 0,
          padding: 0,
          top: 0,
          left: 0
        });
        element.appendChild(canvas);
        if (element === document.body) {
          canvas.style.position = "absolute";
          extend3(element.style, {
            margin: 0,
            padding: 0
          });
        }
        function resize() {
          var w2 = window.innerWidth;
          var h2 = window.innerHeight;
          if (element !== document.body) {
            var bounds = element.getBoundingClientRect();
            w2 = bounds.right - bounds.left;
            h2 = bounds.bottom - bounds.top;
          }
          canvas.width = pixelRatio * w2;
          canvas.height = pixelRatio * h2;
          extend3(canvas.style, {
            width: w2 + "px",
            height: h2 + "px"
          });
        }
        var resizeObserver;
        if (element !== document.body && typeof ResizeObserver === "function") {
          resizeObserver = new ResizeObserver(function() {
            setTimeout(resize);
          });
          resizeObserver.observe(element);
        } else {
          window.addEventListener("resize", resize, false);
        }
        function onDestroy() {
          if (resizeObserver) {
            resizeObserver.disconnect();
          } else {
            window.removeEventListener("resize", resize);
          }
          element.removeChild(canvas);
        }
        resize();
        return {
          canvas,
          onDestroy
        };
      }
      function createContext(canvas, contextAttributes) {
        function get2(name) {
          try {
            return canvas.getContext(name, contextAttributes);
          } catch (e8) {
            return null;
          }
        }
        return get2("webgl") || get2("experimental-webgl") || get2("webgl-experimental");
      }
      function isHTMLElement(obj) {
        return typeof obj.nodeName === "string" && typeof obj.appendChild === "function" && typeof obj.getBoundingClientRect === "function";
      }
      function isWebGLContext(obj) {
        return typeof obj.drawArrays === "function" || typeof obj.drawElements === "function";
      }
      function parseExtensions(input) {
        if (typeof input === "string") {
          return input.split();
        }
        check$1(Array.isArray(input), "invalid extension array");
        return input;
      }
      function getElement(desc) {
        if (typeof desc === "string") {
          check$1(typeof document !== "undefined", "not supported outside of DOM");
          return document.querySelector(desc);
        }
        return desc;
      }
      function parseArgs(args_) {
        var args = args_ || {};
        var element, container2, canvas, gl2;
        var contextAttributes = {};
        var extensions = [];
        var optionalExtensions = [];
        var pixelRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio;
        var profile = false;
        var onDone = function(err) {
          if (err) {
            check$1.raise(err);
          }
        };
        var onDestroy = function() {
        };
        if (typeof args === "string") {
          check$1(typeof document !== "undefined", "selector queries only supported in DOM enviroments");
          element = document.querySelector(args);
          check$1(element, "invalid query string for element");
        } else if (typeof args === "object") {
          if (isHTMLElement(args)) {
            element = args;
          } else if (isWebGLContext(args)) {
            gl2 = args;
            canvas = gl2.canvas;
          } else {
            check$1.constructor(args);
            if ("gl" in args) {
              gl2 = args.gl;
            } else if ("canvas" in args) {
              canvas = getElement(args.canvas);
            } else if ("container" in args) {
              container2 = getElement(args.container);
            }
            if ("attributes" in args) {
              contextAttributes = args.attributes;
              check$1.type(contextAttributes, "object", "invalid context attributes");
            }
            if ("extensions" in args) {
              extensions = parseExtensions(args.extensions);
            }
            if ("optionalExtensions" in args) {
              optionalExtensions = parseExtensions(args.optionalExtensions);
            }
            if ("onDone" in args) {
              check$1.type(args.onDone, "function", "invalid or missing onDone callback");
              onDone = args.onDone;
            }
            if ("profile" in args) {
              profile = !!args.profile;
            }
            if ("pixelRatio" in args) {
              pixelRatio = +args.pixelRatio;
              check$1(pixelRatio > 0, "invalid pixel ratio");
            }
          }
        } else {
          check$1.raise("invalid arguments to regl");
        }
        if (element) {
          if (element.nodeName.toLowerCase() === "canvas") {
            canvas = element;
          } else {
            container2 = element;
          }
        }
        if (!gl2) {
          if (!canvas) {
            check$1(typeof document !== "undefined", "must manually specify webgl context outside of DOM environments");
            var result = createCanvas2(container2 || document.body, onDone, pixelRatio);
            if (!result) {
              return null;
            }
            canvas = result.canvas;
            onDestroy = result.onDestroy;
          }
          if (contextAttributes.premultipliedAlpha === void 0)
            contextAttributes.premultipliedAlpha = true;
          gl2 = createContext(canvas, contextAttributes);
        }
        if (!gl2) {
          onDestroy();
          onDone("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org");
          return null;
        }
        return {
          gl: gl2,
          canvas,
          container: container2,
          extensions,
          optionalExtensions,
          pixelRatio,
          profile,
          onDone,
          onDestroy
        };
      }
      function createExtensionCache(gl2, config) {
        var extensions = {};
        function tryLoadExtension(name_) {
          check$1.type(name_, "string", "extension name must be string");
          var name2 = name_.toLowerCase();
          var ext;
          try {
            ext = extensions[name2] = gl2.getExtension(name2);
          } catch (e8) {
          }
          return !!ext;
        }
        for (var i2 = 0; i2 < config.extensions.length; ++i2) {
          var name = config.extensions[i2];
          if (!tryLoadExtension(name)) {
            config.onDestroy();
            config.onDone('"' + name + '" extension is not supported by the current WebGL context, try upgrading your system or a different browser');
            return null;
          }
        }
        config.optionalExtensions.forEach(tryLoadExtension);
        return {
          extensions,
          restore: function() {
            Object.keys(extensions).forEach(function(name2) {
              if (extensions[name2] && !tryLoadExtension(name2)) {
                throw new Error("(regl): error restoring extension " + name2);
              }
            });
          }
        };
      }
      function loop(n2, f2) {
        var result = Array(n2);
        for (var i2 = 0; i2 < n2; ++i2) {
          result[i2] = f2(i2);
        }
        return result;
      }
      var GL_BYTE$1 = 5120;
      var GL_UNSIGNED_BYTE$2 = 5121;
      var GL_SHORT$1 = 5122;
      var GL_UNSIGNED_SHORT$1 = 5123;
      var GL_INT$1 = 5124;
      var GL_UNSIGNED_INT$1 = 5125;
      var GL_FLOAT$2 = 5126;
      function nextPow16(v2) {
        for (var i2 = 16; i2 <= 1 << 28; i2 *= 16) {
          if (v2 <= i2) {
            return i2;
          }
        }
        return 0;
      }
      function log2(v2) {
        var r2, shift;
        r2 = (v2 > 65535) << 4;
        v2 >>>= r2;
        shift = (v2 > 255) << 3;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 15) << 2;
        v2 >>>= shift;
        r2 |= shift;
        shift = (v2 > 3) << 1;
        v2 >>>= shift;
        r2 |= shift;
        return r2 | v2 >> 1;
      }
      function createPool() {
        var bufferPool = loop(8, function() {
          return [];
        });
        function alloc(n2) {
          var sz = nextPow16(n2);
          var bin = bufferPool[log2(sz) >> 2];
          if (bin.length > 0) {
            return bin.pop();
          }
          return new ArrayBuffer(sz);
        }
        function free(buf) {
          bufferPool[log2(buf.byteLength) >> 2].push(buf);
        }
        function allocType(type, n2) {
          var result = null;
          switch (type) {
            case GL_BYTE$1:
              result = new Int8Array(alloc(n2), 0, n2);
              break;
            case GL_UNSIGNED_BYTE$2:
              result = new Uint8Array(alloc(n2), 0, n2);
              break;
            case GL_SHORT$1:
              result = new Int16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_UNSIGNED_SHORT$1:
              result = new Uint16Array(alloc(2 * n2), 0, n2);
              break;
            case GL_INT$1:
              result = new Int32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_UNSIGNED_INT$1:
              result = new Uint32Array(alloc(4 * n2), 0, n2);
              break;
            case GL_FLOAT$2:
              result = new Float32Array(alloc(4 * n2), 0, n2);
              break;
            default:
              return null;
          }
          if (result.length !== n2) {
            return result.subarray(0, n2);
          }
          return result;
        }
        function freeType(array) {
          free(array.buffer);
        }
        return {
          alloc,
          free,
          allocType,
          freeType
        };
      }
      var pool = createPool();
      pool.zero = createPool();
      var GL_SUBPIXEL_BITS = 3408;
      var GL_RED_BITS = 3410;
      var GL_GREEN_BITS = 3411;
      var GL_BLUE_BITS = 3412;
      var GL_ALPHA_BITS = 3413;
      var GL_DEPTH_BITS = 3414;
      var GL_STENCIL_BITS = 3415;
      var GL_ALIASED_POINT_SIZE_RANGE = 33901;
      var GL_ALIASED_LINE_WIDTH_RANGE = 33902;
      var GL_MAX_TEXTURE_SIZE = 3379;
      var GL_MAX_VIEWPORT_DIMS = 3386;
      var GL_MAX_VERTEX_ATTRIBS = 34921;
      var GL_MAX_VERTEX_UNIFORM_VECTORS = 36347;
      var GL_MAX_VARYING_VECTORS = 36348;
      var GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661;
      var GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660;
      var GL_MAX_TEXTURE_IMAGE_UNITS = 34930;
      var GL_MAX_FRAGMENT_UNIFORM_VECTORS = 36349;
      var GL_MAX_CUBE_MAP_TEXTURE_SIZE = 34076;
      var GL_MAX_RENDERBUFFER_SIZE = 34024;
      var GL_VENDOR = 7936;
      var GL_RENDERER = 7937;
      var GL_VERSION = 7938;
      var GL_SHADING_LANGUAGE_VERSION = 35724;
      var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
      var GL_MAX_COLOR_ATTACHMENTS_WEBGL = 36063;
      var GL_MAX_DRAW_BUFFERS_WEBGL = 34852;
      var GL_TEXTURE_2D = 3553;
      var GL_TEXTURE_CUBE_MAP = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 34069;
      var GL_TEXTURE0 = 33984;
      var GL_RGBA = 6408;
      var GL_FLOAT$1 = 5126;
      var GL_UNSIGNED_BYTE$1 = 5121;
      var GL_FRAMEBUFFER = 36160;
      var GL_FRAMEBUFFER_COMPLETE = 36053;
      var GL_COLOR_ATTACHMENT0 = 36064;
      var GL_COLOR_BUFFER_BIT$1 = 16384;
      var wrapLimits = function(gl2, extensions) {
        var maxAnisotropic = 1;
        if (extensions.ext_texture_filter_anisotropic) {
          maxAnisotropic = gl2.getParameter(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        }
        var maxDrawbuffers = 1;
        var maxColorAttachments = 1;
        if (extensions.webgl_draw_buffers) {
          maxDrawbuffers = gl2.getParameter(GL_MAX_DRAW_BUFFERS_WEBGL);
          maxColorAttachments = gl2.getParameter(GL_MAX_COLOR_ATTACHMENTS_WEBGL);
        }
        var readFloat = !!extensions.oes_texture_float;
        if (readFloat) {
          var readFloatTexture = gl2.createTexture();
          gl2.bindTexture(GL_TEXTURE_2D, readFloatTexture);
          gl2.texImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 1, 1, 0, GL_RGBA, GL_FLOAT$1, null);
          var fbo = gl2.createFramebuffer();
          gl2.bindFramebuffer(GL_FRAMEBUFFER, fbo);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, readFloatTexture, 0);
          gl2.bindTexture(GL_TEXTURE_2D, null);
          if (gl2.checkFramebufferStatus(GL_FRAMEBUFFER) !== GL_FRAMEBUFFER_COMPLETE)
            readFloat = false;
          else {
            gl2.viewport(0, 0, 1, 1);
            gl2.clearColor(1, 0, 0, 1);
            gl2.clear(GL_COLOR_BUFFER_BIT$1);
            var pixels = pool.allocType(GL_FLOAT$1, 4);
            gl2.readPixels(0, 0, 1, 1, GL_RGBA, GL_FLOAT$1, pixels);
            if (gl2.getError())
              readFloat = false;
            else {
              gl2.deleteFramebuffer(fbo);
              gl2.deleteTexture(readFloatTexture);
              readFloat = pixels[0] === 1;
            }
            pool.freeType(pixels);
          }
        }
        var isIE = typeof navigator !== "undefined" && (/MSIE/.test(navigator.userAgent) || /Trident\//.test(navigator.appVersion) || /Edge/.test(navigator.userAgent));
        var npotTextureCube = true;
        if (!isIE) {
          var cubeTexture = gl2.createTexture();
          var data = pool.allocType(GL_UNSIGNED_BYTE$1, 36);
          gl2.activeTexture(GL_TEXTURE0);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, cubeTexture);
          gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0, GL_RGBA, 3, 3, 0, GL_RGBA, GL_UNSIGNED_BYTE$1, data);
          pool.freeType(data);
          gl2.bindTexture(GL_TEXTURE_CUBE_MAP, null);
          gl2.deleteTexture(cubeTexture);
          npotTextureCube = !gl2.getError();
        }
        return {
          colorBits: [
            gl2.getParameter(GL_RED_BITS),
            gl2.getParameter(GL_GREEN_BITS),
            gl2.getParameter(GL_BLUE_BITS),
            gl2.getParameter(GL_ALPHA_BITS)
          ],
          depthBits: gl2.getParameter(GL_DEPTH_BITS),
          stencilBits: gl2.getParameter(GL_STENCIL_BITS),
          subpixelBits: gl2.getParameter(GL_SUBPIXEL_BITS),
          extensions: Object.keys(extensions).filter(function(ext) {
            return !!extensions[ext];
          }),
          maxAnisotropic,
          maxDrawbuffers,
          maxColorAttachments,
          pointSizeDims: gl2.getParameter(GL_ALIASED_POINT_SIZE_RANGE),
          lineWidthDims: gl2.getParameter(GL_ALIASED_LINE_WIDTH_RANGE),
          maxViewportDims: gl2.getParameter(GL_MAX_VIEWPORT_DIMS),
          maxCombinedTextureUnits: gl2.getParameter(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxCubeMapSize: gl2.getParameter(GL_MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderbufferSize: gl2.getParameter(GL_MAX_RENDERBUFFER_SIZE),
          maxTextureUnits: gl2.getParameter(GL_MAX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: gl2.getParameter(GL_MAX_TEXTURE_SIZE),
          maxAttributes: gl2.getParameter(GL_MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: gl2.getParameter(GL_MAX_VERTEX_UNIFORM_VECTORS),
          maxVertexTextureUnits: gl2.getParameter(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxVaryingVectors: gl2.getParameter(GL_MAX_VARYING_VECTORS),
          maxFragmentUniforms: gl2.getParameter(GL_MAX_FRAGMENT_UNIFORM_VECTORS),
          glsl: gl2.getParameter(GL_SHADING_LANGUAGE_VERSION),
          renderer: gl2.getParameter(GL_RENDERER),
          vendor: gl2.getParameter(GL_VENDOR),
          version: gl2.getParameter(GL_VERSION),
          readFloat,
          npotTextureCube
        };
      };
      function isNDArrayLike(obj) {
        return !!obj && typeof obj === "object" && Array.isArray(obj.shape) && Array.isArray(obj.stride) && typeof obj.offset === "number" && obj.shape.length === obj.stride.length && (Array.isArray(obj.data) || isTypedArray4(obj.data));
      }
      var values2 = function(obj) {
        return Object.keys(obj).map(function(key) {
          return obj[key];
        });
      };
      var flattenUtils = {
        shape: arrayShape$1,
        flatten: flattenArray
      };
      function flatten1D(array, nx, out) {
        for (var i2 = 0; i2 < nx; ++i2) {
          out[i2] = array[i2];
        }
      }
      function flatten2D(array, nx, ny, out) {
        var ptr = 0;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            out[ptr++] = row[j2];
          }
        }
      }
      function flatten3D(array, nx, ny, nz, out, ptr_) {
        var ptr = ptr_;
        for (var i2 = 0; i2 < nx; ++i2) {
          var row = array[i2];
          for (var j2 = 0; j2 < ny; ++j2) {
            var col = row[j2];
            for (var k2 = 0; k2 < nz; ++k2) {
              out[ptr++] = col[k2];
            }
          }
        }
      }
      function flattenRec(array, shape, level, out, ptr) {
        var stride = 1;
        for (var i2 = level + 1; i2 < shape.length; ++i2) {
          stride *= shape[i2];
        }
        var n2 = shape[level];
        if (shape.length - level === 4) {
          var nx = shape[level + 1];
          var ny = shape[level + 2];
          var nz = shape[level + 3];
          for (i2 = 0; i2 < n2; ++i2) {
            flatten3D(array[i2], nx, ny, nz, out, ptr);
            ptr += stride;
          }
        } else {
          for (i2 = 0; i2 < n2; ++i2) {
            flattenRec(array[i2], shape, level + 1, out, ptr);
            ptr += stride;
          }
        }
      }
      function flattenArray(array, shape, type, out_) {
        var sz = 1;
        if (shape.length) {
          for (var i2 = 0; i2 < shape.length; ++i2) {
            sz *= shape[i2];
          }
        } else {
          sz = 0;
        }
        var out = out_ || pool.allocType(type, sz);
        switch (shape.length) {
          case 0:
            break;
          case 1:
            flatten1D(array, shape[0], out);
            break;
          case 2:
            flatten2D(array, shape[0], shape[1], out);
            break;
          case 3:
            flatten3D(array, shape[0], shape[1], shape[2], out, 0);
            break;
          default:
            flattenRec(array, shape, 0, out, 0);
        }
        return out;
      }
      function arrayShape$1(array_) {
        var shape = [];
        for (var array = array_; array.length; array = array[0]) {
          shape.push(array.length);
        }
        return shape;
      }
      var arrayTypes = {
        "[object Int8Array]": 5120,
        "[object Int16Array]": 5122,
        "[object Int32Array]": 5124,
        "[object Uint8Array]": 5121,
        "[object Uint8ClampedArray]": 5121,
        "[object Uint16Array]": 5123,
        "[object Uint32Array]": 5125,
        "[object Float32Array]": 5126,
        "[object Float64Array]": 5121,
        "[object ArrayBuffer]": 5121
      };
      var int8 = 5120;
      var int16 = 5122;
      var int32 = 5124;
      var uint8 = 5121;
      var uint16 = 5123;
      var uint32 = 5125;
      var float = 5126;
      var float32 = 5126;
      var glTypes = {
        int8,
        int16,
        int32,
        uint8,
        uint16,
        uint32,
        float,
        float32
      };
      var dynamic$1 = 35048;
      var stream = 35040;
      var usageTypes = {
        dynamic: dynamic$1,
        stream,
        "static": 35044
      };
      var arrayFlatten = flattenUtils.flatten;
      var arrayShape = flattenUtils.shape;
      var GL_STATIC_DRAW = 35044;
      var GL_STREAM_DRAW = 35040;
      var GL_UNSIGNED_BYTE$3 = 5121;
      var GL_FLOAT$3 = 5126;
      var DTYPES_SIZES = [];
      DTYPES_SIZES[5120] = 1;
      DTYPES_SIZES[5122] = 2;
      DTYPES_SIZES[5124] = 4;
      DTYPES_SIZES[5121] = 1;
      DTYPES_SIZES[5123] = 2;
      DTYPES_SIZES[5125] = 4;
      DTYPES_SIZES[5126] = 4;
      function typedArrayCode(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function copyArray(out, inp) {
        for (var i2 = 0; i2 < inp.length; ++i2) {
          out[i2] = inp[i2];
        }
      }
      function transpose3(result, data, shapeX, shapeY, strideX, strideY, offset) {
        var ptr = 0;
        for (var i2 = 0; i2 < shapeX; ++i2) {
          for (var j2 = 0; j2 < shapeY; ++j2) {
            result[ptr++] = data[strideX * i2 + strideY * j2 + offset];
          }
        }
      }
      function wrapBufferState(gl2, stats2, config, destroyBuffer) {
        var bufferCount = 0;
        var bufferSet = {};
        function REGLBuffer(type) {
          this.id = bufferCount++;
          this.buffer = gl2.createBuffer();
          this.type = type;
          this.usage = GL_STATIC_DRAW;
          this.byteLength = 0;
          this.dimension = 1;
          this.dtype = GL_UNSIGNED_BYTE$3;
          this.persistentData = null;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLBuffer.prototype.bind = function() {
          gl2.bindBuffer(this.type, this.buffer);
        };
        REGLBuffer.prototype.destroy = function() {
          destroy(this);
        };
        var streamPool = [];
        function createStream(type, data) {
          var buffer = streamPool.pop();
          if (!buffer) {
            buffer = new REGLBuffer(type);
          }
          buffer.bind();
          initBufferFromData(buffer, data, GL_STREAM_DRAW, 0, 1, false);
          return buffer;
        }
        function destroyStream(stream$$1) {
          streamPool.push(stream$$1);
        }
        function initBufferFromTypedArray(buffer, data, usage) {
          buffer.byteLength = data.byteLength;
          gl2.bufferData(buffer.type, data, usage);
        }
        function initBufferFromData(buffer, data, usage, dtype, dimension, persist) {
          var shape;
          buffer.usage = usage;
          if (Array.isArray(data)) {
            buffer.dtype = dtype || GL_FLOAT$3;
            if (data.length > 0) {
              var flatData;
              if (Array.isArray(data[0])) {
                shape = arrayShape(data);
                var dim = 1;
                for (var i2 = 1; i2 < shape.length; ++i2) {
                  dim *= shape[i2];
                }
                buffer.dimension = dim;
                flatData = arrayFlatten(data, shape, buffer.dtype);
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else if (typeof data[0] === "number") {
                buffer.dimension = dimension;
                var typedData = pool.allocType(buffer.dtype, data.length);
                copyArray(typedData, data);
                initBufferFromTypedArray(buffer, typedData, usage);
                if (persist) {
                  buffer.persistentData = typedData;
                } else {
                  pool.freeType(typedData);
                }
              } else if (isTypedArray4(data[0])) {
                buffer.dimension = data[0].length;
                buffer.dtype = dtype || typedArrayCode(data[0]) || GL_FLOAT$3;
                flatData = arrayFlatten(data, [data.length, data[0].length], buffer.dtype);
                initBufferFromTypedArray(buffer, flatData, usage);
                if (persist) {
                  buffer.persistentData = flatData;
                } else {
                  pool.freeType(flatData);
                }
              } else {
                check$1.raise("invalid buffer data");
              }
            }
          } else if (isTypedArray4(data)) {
            buffer.dtype = dtype || typedArrayCode(data);
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data.buffer));
            }
          } else if (isNDArrayLike(data)) {
            shape = data.shape;
            var stride = data.stride;
            var offset = data.offset;
            var shapeX = 0;
            var shapeY = 0;
            var strideX = 0;
            var strideY = 0;
            if (shape.length === 1) {
              shapeX = shape[0];
              shapeY = 1;
              strideX = stride[0];
              strideY = 0;
            } else if (shape.length === 2) {
              shapeX = shape[0];
              shapeY = shape[1];
              strideX = stride[0];
              strideY = stride[1];
            } else {
              check$1.raise("invalid shape");
            }
            buffer.dtype = dtype || typedArrayCode(data.data) || GL_FLOAT$3;
            buffer.dimension = shapeY;
            var transposeData2 = pool.allocType(buffer.dtype, shapeX * shapeY);
            transpose3(transposeData2, data.data, shapeX, shapeY, strideX, strideY, offset);
            initBufferFromTypedArray(buffer, transposeData2, usage);
            if (persist) {
              buffer.persistentData = transposeData2;
            } else {
              pool.freeType(transposeData2);
            }
          } else if (data instanceof ArrayBuffer) {
            buffer.dtype = GL_UNSIGNED_BYTE$3;
            buffer.dimension = dimension;
            initBufferFromTypedArray(buffer, data, usage);
            if (persist) {
              buffer.persistentData = new Uint8Array(new Uint8Array(data));
            }
          } else {
            check$1.raise("invalid buffer data");
          }
        }
        function destroy(buffer) {
          stats2.bufferCount--;
          destroyBuffer(buffer);
          var handle = buffer.buffer;
          check$1(handle, "buffer must not be deleted already");
          gl2.deleteBuffer(handle);
          buffer.buffer = null;
          delete bufferSet[buffer.id];
        }
        function createBuffer(options, type, deferInit, persistent) {
          stats2.bufferCount++;
          var buffer = new REGLBuffer(type);
          bufferSet[buffer.id] = buffer;
          function reglBuffer(options2) {
            var usage = GL_STATIC_DRAW;
            var data = null;
            var byteLength = 0;
            var dtype = 0;
            var dimension = 1;
            if (Array.isArray(options2) || isTypedArray4(options2) || isNDArrayLike(options2) || options2 instanceof ArrayBuffer) {
              data = options2;
            } else if (typeof options2 === "number") {
              byteLength = options2 | 0;
            } else if (options2) {
              check$1.type(options2, "object", "buffer arguments must be an object, a number or an array");
              if ("data" in options2) {
                check$1(data === null || Array.isArray(data) || isTypedArray4(data) || isNDArrayLike(data), "invalid data for buffer");
                data = options2.data;
              }
              if ("usage" in options2) {
                check$1.parameter(options2.usage, usageTypes, "invalid buffer usage");
                usage = usageTypes[options2.usage];
              }
              if ("type" in options2) {
                check$1.parameter(options2.type, glTypes, "invalid buffer type");
                dtype = glTypes[options2.type];
              }
              if ("dimension" in options2) {
                check$1.type(options2.dimension, "number", "invalid dimension");
                dimension = options2.dimension | 0;
              }
              if ("length" in options2) {
                check$1.nni(byteLength, "buffer length must be a nonnegative integer");
                byteLength = options2.length | 0;
              }
            }
            buffer.bind();
            if (!data) {
              if (byteLength)
                gl2.bufferData(buffer.type, byteLength, usage);
              buffer.dtype = dtype || GL_UNSIGNED_BYTE$3;
              buffer.usage = usage;
              buffer.dimension = dimension;
              buffer.byteLength = byteLength;
            } else {
              initBufferFromData(buffer, data, usage, dtype, dimension, persistent);
            }
            if (config.profile) {
              buffer.stats.size = buffer.byteLength * DTYPES_SIZES[buffer.dtype];
            }
            return reglBuffer;
          }
          function setSubData(data, offset) {
            check$1(offset + data.byteLength <= buffer.byteLength, "invalid buffer subdata call, buffer is too small.  Can't write data of size " + data.byteLength + " starting from offset " + offset + " to a buffer of size " + buffer.byteLength);
            gl2.bufferSubData(buffer.type, offset, data);
          }
          function subdata(data, offset_) {
            var offset = (offset_ || 0) | 0;
            var shape;
            buffer.bind();
            if (isTypedArray4(data) || data instanceof ArrayBuffer) {
              setSubData(data, offset);
            } else if (Array.isArray(data)) {
              if (data.length > 0) {
                if (typeof data[0] === "number") {
                  var converted = pool.allocType(buffer.dtype, data.length);
                  copyArray(converted, data);
                  setSubData(converted, offset);
                  pool.freeType(converted);
                } else if (Array.isArray(data[0]) || isTypedArray4(data[0])) {
                  shape = arrayShape(data);
                  var flatData = arrayFlatten(data, shape, buffer.dtype);
                  setSubData(flatData, offset);
                  pool.freeType(flatData);
                } else {
                  check$1.raise("invalid buffer data");
                }
              }
            } else if (isNDArrayLike(data)) {
              shape = data.shape;
              var stride = data.stride;
              var shapeX = 0;
              var shapeY = 0;
              var strideX = 0;
              var strideY = 0;
              if (shape.length === 1) {
                shapeX = shape[0];
                shapeY = 1;
                strideX = stride[0];
                strideY = 0;
              } else if (shape.length === 2) {
                shapeX = shape[0];
                shapeY = shape[1];
                strideX = stride[0];
                strideY = stride[1];
              } else {
                check$1.raise("invalid shape");
              }
              var dtype = Array.isArray(data.data) ? buffer.dtype : typedArrayCode(data.data);
              var transposeData2 = pool.allocType(dtype, shapeX * shapeY);
              transpose3(transposeData2, data.data, shapeX, shapeY, strideX, strideY, data.offset);
              setSubData(transposeData2, offset);
              pool.freeType(transposeData2);
            } else {
              check$1.raise("invalid data for buffer subdata");
            }
            return reglBuffer;
          }
          if (!deferInit) {
            reglBuffer(options);
          }
          reglBuffer._reglType = "buffer";
          reglBuffer._buffer = buffer;
          reglBuffer.subdata = subdata;
          if (config.profile) {
            reglBuffer.stats = buffer.stats;
          }
          reglBuffer.destroy = function() {
            destroy(buffer);
          };
          return reglBuffer;
        }
        function restoreBuffers() {
          values2(bufferSet).forEach(function(buffer) {
            buffer.buffer = gl2.createBuffer();
            gl2.bindBuffer(buffer.type, buffer.buffer);
            gl2.bufferData(buffer.type, buffer.persistentData || buffer.byteLength, buffer.usage);
          });
        }
        if (config.profile) {
          stats2.getTotalBufferSize = function() {
            var total = 0;
            Object.keys(bufferSet).forEach(function(key) {
              total += bufferSet[key].stats.size;
            });
            return total;
          };
        }
        return {
          create: createBuffer,
          createStream,
          destroyStream,
          clear: function() {
            values2(bufferSet).forEach(destroy);
            streamPool.forEach(destroy);
          },
          getBuffer: function(wrapper) {
            if (wrapper && wrapper._buffer instanceof REGLBuffer) {
              return wrapper._buffer;
            }
            return null;
          },
          restore: restoreBuffers,
          _initBuffer: initBufferFromData
        };
      }
      var points = 0;
      var point = 0;
      var lines = 1;
      var line = 1;
      var triangles = 4;
      var triangle2 = 4;
      var primTypes = {
        points,
        point,
        lines,
        line,
        triangles,
        triangle: triangle2,
        "line loop": 2,
        "line strip": 3,
        "triangle strip": 5,
        "triangle fan": 6
      };
      var GL_POINTS = 0;
      var GL_LINES = 1;
      var GL_TRIANGLES = 4;
      var GL_BYTE$2 = 5120;
      var GL_UNSIGNED_BYTE$4 = 5121;
      var GL_SHORT$2 = 5122;
      var GL_UNSIGNED_SHORT$2 = 5123;
      var GL_INT$2 = 5124;
      var GL_UNSIGNED_INT$2 = 5125;
      var GL_ELEMENT_ARRAY_BUFFER = 34963;
      var GL_STREAM_DRAW$1 = 35040;
      var GL_STATIC_DRAW$1 = 35044;
      function wrapElementsState(gl2, extensions, bufferState, stats2) {
        var elementSet = {};
        var elementCount = 0;
        var elementTypes = {
          "uint8": GL_UNSIGNED_BYTE$4,
          "uint16": GL_UNSIGNED_SHORT$2
        };
        if (extensions.oes_element_index_uint) {
          elementTypes.uint32 = GL_UNSIGNED_INT$2;
        }
        function REGLElementBuffer(buffer) {
          this.id = elementCount++;
          elementSet[this.id] = this;
          this.buffer = buffer;
          this.primType = GL_TRIANGLES;
          this.vertCount = 0;
          this.type = 0;
        }
        REGLElementBuffer.prototype.bind = function() {
          this.buffer.bind();
        };
        var bufferPool = [];
        function createElementStream(data) {
          var result = bufferPool.pop();
          if (!result) {
            result = new REGLElementBuffer(bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true, false)._buffer);
          }
          initElements(result, data, GL_STREAM_DRAW$1, -1, -1, 0, 0);
          return result;
        }
        function destroyElementStream(elements) {
          bufferPool.push(elements);
        }
        function initElements(elements, data, usage, prim3, count, byteLength, type) {
          elements.buffer.bind();
          var dtype;
          if (data) {
            var predictedType = type;
            if (!type && (!isTypedArray4(data) || isNDArrayLike(data) && !isTypedArray4(data.data))) {
              predictedType = extensions.oes_element_index_uint ? GL_UNSIGNED_INT$2 : GL_UNSIGNED_SHORT$2;
            }
            bufferState._initBuffer(elements.buffer, data, usage, predictedType, 3);
          } else {
            gl2.bufferData(GL_ELEMENT_ARRAY_BUFFER, byteLength, usage);
            elements.buffer.dtype = dtype || GL_UNSIGNED_BYTE$4;
            elements.buffer.usage = usage;
            elements.buffer.dimension = 3;
            elements.buffer.byteLength = byteLength;
          }
          dtype = type;
          if (!type) {
            switch (elements.buffer.dtype) {
              case GL_UNSIGNED_BYTE$4:
              case GL_BYTE$2:
                dtype = GL_UNSIGNED_BYTE$4;
                break;
              case GL_UNSIGNED_SHORT$2:
              case GL_SHORT$2:
                dtype = GL_UNSIGNED_SHORT$2;
                break;
              case GL_UNSIGNED_INT$2:
              case GL_INT$2:
                dtype = GL_UNSIGNED_INT$2;
                break;
              default:
                check$1.raise("unsupported type for element array");
            }
            elements.buffer.dtype = dtype;
          }
          elements.type = dtype;
          check$1(dtype !== GL_UNSIGNED_INT$2 || !!extensions.oes_element_index_uint, "32 bit element buffers not supported, enable oes_element_index_uint first");
          var vertCount = count;
          if (vertCount < 0) {
            vertCount = elements.buffer.byteLength;
            if (dtype === GL_UNSIGNED_SHORT$2) {
              vertCount >>= 1;
            } else if (dtype === GL_UNSIGNED_INT$2) {
              vertCount >>= 2;
            }
          }
          elements.vertCount = vertCount;
          var primType = prim3;
          if (prim3 < 0) {
            primType = GL_TRIANGLES;
            var dimension = elements.buffer.dimension;
            if (dimension === 1)
              primType = GL_POINTS;
            if (dimension === 2)
              primType = GL_LINES;
            if (dimension === 3)
              primType = GL_TRIANGLES;
          }
          elements.primType = primType;
        }
        function destroyElements(elements) {
          stats2.elementsCount--;
          check$1(elements.buffer !== null, "must not double destroy elements");
          delete elementSet[elements.id];
          elements.buffer.destroy();
          elements.buffer = null;
        }
        function createElements(options, persistent) {
          var buffer = bufferState.create(null, GL_ELEMENT_ARRAY_BUFFER, true);
          var elements = new REGLElementBuffer(buffer._buffer);
          stats2.elementsCount++;
          function reglElements(options2) {
            if (!options2) {
              buffer();
              elements.primType = GL_TRIANGLES;
              elements.vertCount = 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else if (typeof options2 === "number") {
              buffer(options2);
              elements.primType = GL_TRIANGLES;
              elements.vertCount = options2 | 0;
              elements.type = GL_UNSIGNED_BYTE$4;
            } else {
              var data = null;
              var usage = GL_STATIC_DRAW$1;
              var primType = -1;
              var vertCount = -1;
              var byteLength = 0;
              var dtype = 0;
              if (Array.isArray(options2) || isTypedArray4(options2) || isNDArrayLike(options2)) {
                data = options2;
              } else {
                check$1.type(options2, "object", "invalid arguments for elements");
                if ("data" in options2) {
                  data = options2.data;
                  check$1(Array.isArray(data) || isTypedArray4(data) || isNDArrayLike(data), "invalid data for element buffer");
                }
                if ("usage" in options2) {
                  check$1.parameter(options2.usage, usageTypes, "invalid element buffer usage");
                  usage = usageTypes[options2.usage];
                }
                if ("primitive" in options2) {
                  check$1.parameter(options2.primitive, primTypes, "invalid element buffer primitive");
                  primType = primTypes[options2.primitive];
                }
                if ("count" in options2) {
                  check$1(typeof options2.count === "number" && options2.count >= 0, "invalid vertex count for elements");
                  vertCount = options2.count | 0;
                }
                if ("type" in options2) {
                  check$1.parameter(options2.type, elementTypes, "invalid buffer type");
                  dtype = elementTypes[options2.type];
                }
                if ("length" in options2) {
                  byteLength = options2.length | 0;
                } else {
                  byteLength = vertCount;
                  if (dtype === GL_UNSIGNED_SHORT$2 || dtype === GL_SHORT$2) {
                    byteLength *= 2;
                  } else if (dtype === GL_UNSIGNED_INT$2 || dtype === GL_INT$2) {
                    byteLength *= 4;
                  }
                }
              }
              initElements(elements, data, usage, primType, vertCount, byteLength, dtype);
            }
            return reglElements;
          }
          reglElements(options);
          reglElements._reglType = "elements";
          reglElements._elements = elements;
          reglElements.subdata = function(data, offset) {
            buffer.subdata(data, offset);
            return reglElements;
          };
          reglElements.destroy = function() {
            destroyElements(elements);
          };
          return reglElements;
        }
        return {
          create: createElements,
          createStream: createElementStream,
          destroyStream: destroyElementStream,
          getElements: function(elements) {
            if (typeof elements === "function" && elements._elements instanceof REGLElementBuffer) {
              return elements._elements;
            }
            return null;
          },
          clear: function() {
            values2(elementSet).forEach(destroyElements);
          }
        };
      }
      var FLOAT = new Float32Array(1);
      var INT = new Uint32Array(FLOAT.buffer);
      var GL_UNSIGNED_SHORT$4 = 5123;
      function convertToHalfFloat(array) {
        var ushorts = pool.allocType(GL_UNSIGNED_SHORT$4, array.length);
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (isNaN(array[i2])) {
            ushorts[i2] = 65535;
          } else if (array[i2] === Infinity) {
            ushorts[i2] = 31744;
          } else if (array[i2] === -Infinity) {
            ushorts[i2] = 64512;
          } else {
            FLOAT[0] = array[i2];
            var x2 = INT[0];
            var sgn = x2 >>> 31 << 15;
            var exp2 = (x2 << 1 >>> 24) - 127;
            var frac = x2 >> 13 & (1 << 10) - 1;
            if (exp2 < -24) {
              ushorts[i2] = sgn;
            } else if (exp2 < -14) {
              var s2 = -14 - exp2;
              ushorts[i2] = sgn + (frac + (1 << 10) >> s2);
            } else if (exp2 > 15) {
              ushorts[i2] = sgn + 31744;
            } else {
              ushorts[i2] = sgn + (exp2 + 15 << 10) + frac;
            }
          }
        }
        return ushorts;
      }
      function isArrayLike2(s2) {
        return Array.isArray(s2) || isTypedArray4(s2);
      }
      var isPow2$1 = function(v2) {
        return !(v2 & v2 - 1) && !!v2;
      };
      var GL_COMPRESSED_TEXTURE_FORMATS = 34467;
      var GL_TEXTURE_2D$1 = 3553;
      var GL_TEXTURE_CUBE_MAP$1 = 34067;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 = 34069;
      var GL_RGBA$1 = 6408;
      var GL_ALPHA = 6406;
      var GL_RGB = 6407;
      var GL_LUMINANCE = 6409;
      var GL_LUMINANCE_ALPHA = 6410;
      var GL_RGBA4 = 32854;
      var GL_RGB5_A1 = 32855;
      var GL_RGB565 = 36194;
      var GL_UNSIGNED_SHORT_4_4_4_4$1 = 32819;
      var GL_UNSIGNED_SHORT_5_5_5_1$1 = 32820;
      var GL_UNSIGNED_SHORT_5_6_5$1 = 33635;
      var GL_UNSIGNED_INT_24_8_WEBGL$1 = 34042;
      var GL_DEPTH_COMPONENT = 6402;
      var GL_DEPTH_STENCIL = 34041;
      var GL_SRGB_EXT = 35904;
      var GL_SRGB_ALPHA_EXT = 35906;
      var GL_HALF_FLOAT_OES$1 = 36193;
      var GL_COMPRESSED_RGB_S3TC_DXT1_EXT = 33776;
      var GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777;
      var GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778;
      var GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779;
      var GL_COMPRESSED_RGB_ATC_WEBGL = 35986;
      var GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987;
      var GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798;
      var GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840;
      var GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841;
      var GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842;
      var GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843;
      var GL_COMPRESSED_RGB_ETC1_WEBGL = 36196;
      var GL_UNSIGNED_BYTE$5 = 5121;
      var GL_UNSIGNED_SHORT$3 = 5123;
      var GL_UNSIGNED_INT$3 = 5125;
      var GL_FLOAT$4 = 5126;
      var GL_TEXTURE_WRAP_S = 10242;
      var GL_TEXTURE_WRAP_T = 10243;
      var GL_REPEAT = 10497;
      var GL_CLAMP_TO_EDGE$1 = 33071;
      var GL_MIRRORED_REPEAT = 33648;
      var GL_TEXTURE_MAG_FILTER = 10240;
      var GL_TEXTURE_MIN_FILTER = 10241;
      var GL_NEAREST$1 = 9728;
      var GL_LINEAR = 9729;
      var GL_NEAREST_MIPMAP_NEAREST$1 = 9984;
      var GL_LINEAR_MIPMAP_NEAREST$1 = 9985;
      var GL_NEAREST_MIPMAP_LINEAR$1 = 9986;
      var GL_LINEAR_MIPMAP_LINEAR$1 = 9987;
      var GL_GENERATE_MIPMAP_HINT = 33170;
      var GL_DONT_CARE = 4352;
      var GL_FASTEST = 4353;
      var GL_NICEST = 4354;
      var GL_TEXTURE_MAX_ANISOTROPY_EXT = 34046;
      var GL_UNPACK_ALIGNMENT = 3317;
      var GL_UNPACK_FLIP_Y_WEBGL = 37440;
      var GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441;
      var GL_UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443;
      var GL_BROWSER_DEFAULT_WEBGL = 37444;
      var GL_TEXTURE0$1 = 33984;
      var MIPMAP_FILTERS = [
        GL_NEAREST_MIPMAP_NEAREST$1,
        GL_NEAREST_MIPMAP_LINEAR$1,
        GL_LINEAR_MIPMAP_NEAREST$1,
        GL_LINEAR_MIPMAP_LINEAR$1
      ];
      var CHANNELS_FORMAT = [
        0,
        GL_LUMINANCE,
        GL_LUMINANCE_ALPHA,
        GL_RGB,
        GL_RGBA$1
      ];
      var FORMAT_CHANNELS = {};
      FORMAT_CHANNELS[GL_LUMINANCE] = FORMAT_CHANNELS[GL_ALPHA] = FORMAT_CHANNELS[GL_DEPTH_COMPONENT] = 1;
      FORMAT_CHANNELS[GL_DEPTH_STENCIL] = FORMAT_CHANNELS[GL_LUMINANCE_ALPHA] = 2;
      FORMAT_CHANNELS[GL_RGB] = FORMAT_CHANNELS[GL_SRGB_EXT] = 3;
      FORMAT_CHANNELS[GL_RGBA$1] = FORMAT_CHANNELS[GL_SRGB_ALPHA_EXT] = 4;
      function objectName(str7) {
        return "[object " + str7 + "]";
      }
      var CANVAS_CLASS = objectName("HTMLCanvasElement");
      var OFFSCREENCANVAS_CLASS = objectName("OffscreenCanvas");
      var CONTEXT2D_CLASS = objectName("CanvasRenderingContext2D");
      var BITMAP_CLASS = objectName("ImageBitmap");
      var IMAGE_CLASS = objectName("HTMLImageElement");
      var VIDEO_CLASS = objectName("HTMLVideoElement");
      var PIXEL_CLASSES = Object.keys(arrayTypes).concat([
        CANVAS_CLASS,
        OFFSCREENCANVAS_CLASS,
        CONTEXT2D_CLASS,
        BITMAP_CLASS,
        IMAGE_CLASS,
        VIDEO_CLASS
      ]);
      var TYPE_SIZES = [];
      TYPE_SIZES[GL_UNSIGNED_BYTE$5] = 1;
      TYPE_SIZES[GL_FLOAT$4] = 4;
      TYPE_SIZES[GL_HALF_FLOAT_OES$1] = 2;
      TYPE_SIZES[GL_UNSIGNED_SHORT$3] = 2;
      TYPE_SIZES[GL_UNSIGNED_INT$3] = 4;
      var FORMAT_SIZES_SPECIAL = [];
      FORMAT_SIZES_SPECIAL[GL_RGBA4] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB5_A1] = 2;
      FORMAT_SIZES_SPECIAL[GL_RGB565] = 2;
      FORMAT_SIZES_SPECIAL[GL_DEPTH_STENCIL] = 4;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT1_EXT] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT3_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_S3TC_DXT5_EXT] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ATC_WEBGL] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL] = 1;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = 0.5;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = 0.25;
      FORMAT_SIZES_SPECIAL[GL_COMPRESSED_RGB_ETC1_WEBGL] = 0.5;
      function isNumericArray(arr) {
        return Array.isArray(arr) && (arr.length === 0 || typeof arr[0] === "number");
      }
      function isRectArray(arr) {
        if (!Array.isArray(arr)) {
          return false;
        }
        var width = arr.length;
        if (width === 0 || !isArrayLike2(arr[0])) {
          return false;
        }
        return true;
      }
      function classString(x2) {
        return Object.prototype.toString.call(x2);
      }
      function isCanvasElement(object) {
        return classString(object) === CANVAS_CLASS;
      }
      function isOffscreenCanvas(object) {
        return classString(object) === OFFSCREENCANVAS_CLASS;
      }
      function isContext2D(object) {
        return classString(object) === CONTEXT2D_CLASS;
      }
      function isBitmap(object) {
        return classString(object) === BITMAP_CLASS;
      }
      function isImageElement(object) {
        return classString(object) === IMAGE_CLASS;
      }
      function isVideoElement(object) {
        return classString(object) === VIDEO_CLASS;
      }
      function isPixelData(object) {
        if (!object) {
          return false;
        }
        var className = classString(object);
        if (PIXEL_CLASSES.indexOf(className) >= 0) {
          return true;
        }
        return isNumericArray(object) || isRectArray(object) || isNDArrayLike(object);
      }
      function typedArrayCode$1(data) {
        return arrayTypes[Object.prototype.toString.call(data)] | 0;
      }
      function convertData(result, data) {
        var n2 = data.length;
        switch (result.type) {
          case GL_UNSIGNED_BYTE$5:
          case GL_UNSIGNED_SHORT$3:
          case GL_UNSIGNED_INT$3:
          case GL_FLOAT$4:
            var converted = pool.allocType(result.type, n2);
            converted.set(data);
            result.data = converted;
            break;
          case GL_HALF_FLOAT_OES$1:
            result.data = convertToHalfFloat(data);
            break;
          default:
            check$1.raise("unsupported texture type, must specify a typed array");
        }
      }
      function preConvert(image, n2) {
        return pool.allocType(image.type === GL_HALF_FLOAT_OES$1 ? GL_FLOAT$4 : image.type, n2);
      }
      function postConvert(image, data) {
        if (image.type === GL_HALF_FLOAT_OES$1) {
          image.data = convertToHalfFloat(data);
          pool.freeType(data);
        } else {
          image.data = data;
        }
      }
      function transposeData(image, array, strideX, strideY, strideC, offset) {
        var w2 = image.width;
        var h2 = image.height;
        var c2 = image.channels;
        var n2 = w2 * h2 * c2;
        var data = preConvert(image, n2);
        var p2 = 0;
        for (var i2 = 0; i2 < h2; ++i2) {
          for (var j2 = 0; j2 < w2; ++j2) {
            for (var k2 = 0; k2 < c2; ++k2) {
              data[p2++] = array[strideX * j2 + strideY * i2 + strideC * k2 + offset];
            }
          }
        }
        postConvert(image, data);
      }
      function getTextureSize(format2, type, width, height, isMipmap, isCube) {
        var s2;
        if (typeof FORMAT_SIZES_SPECIAL[format2] !== "undefined") {
          s2 = FORMAT_SIZES_SPECIAL[format2];
        } else {
          s2 = FORMAT_CHANNELS[format2] * TYPE_SIZES[type];
        }
        if (isCube) {
          s2 *= 6;
        }
        if (isMipmap) {
          var total = 0;
          var w2 = width;
          while (w2 >= 1) {
            total += s2 * w2 * w2;
            w2 /= 2;
          }
          return total;
        } else {
          return s2 * width * height;
        }
      }
      function createTextureSet(gl2, extensions, limits, reglPoll, contextState, stats2, config) {
        var mipmapHint = {
          "don't care": GL_DONT_CARE,
          "dont care": GL_DONT_CARE,
          "nice": GL_NICEST,
          "fast": GL_FASTEST
        };
        var wrapModes = {
          "repeat": GL_REPEAT,
          "clamp": GL_CLAMP_TO_EDGE$1,
          "mirror": GL_MIRRORED_REPEAT
        };
        var magFilters = {
          "nearest": GL_NEAREST$1,
          "linear": GL_LINEAR
        };
        var minFilters = extend3({
          "mipmap": GL_LINEAR_MIPMAP_LINEAR$1,
          "nearest mipmap nearest": GL_NEAREST_MIPMAP_NEAREST$1,
          "linear mipmap nearest": GL_LINEAR_MIPMAP_NEAREST$1,
          "nearest mipmap linear": GL_NEAREST_MIPMAP_LINEAR$1,
          "linear mipmap linear": GL_LINEAR_MIPMAP_LINEAR$1
        }, magFilters);
        var colorSpace = {
          "none": 0,
          "browser": GL_BROWSER_DEFAULT_WEBGL
        };
        var textureTypes = {
          "uint8": GL_UNSIGNED_BYTE$5,
          "rgba4": GL_UNSIGNED_SHORT_4_4_4_4$1,
          "rgb565": GL_UNSIGNED_SHORT_5_6_5$1,
          "rgb5 a1": GL_UNSIGNED_SHORT_5_5_5_1$1
        };
        var textureFormats = {
          "alpha": GL_ALPHA,
          "luminance": GL_LUMINANCE,
          "luminance alpha": GL_LUMINANCE_ALPHA,
          "rgb": GL_RGB,
          "rgba": GL_RGBA$1,
          "rgba4": GL_RGBA4,
          "rgb5 a1": GL_RGB5_A1,
          "rgb565": GL_RGB565
        };
        var compressedTextureFormats = {};
        if (extensions.ext_srgb) {
          textureFormats.srgb = GL_SRGB_EXT;
          textureFormats.srgba = GL_SRGB_ALPHA_EXT;
        }
        if (extensions.oes_texture_float) {
          textureTypes.float32 = textureTypes.float = GL_FLOAT$4;
        }
        if (extensions.oes_texture_half_float) {
          textureTypes["float16"] = textureTypes["half float"] = GL_HALF_FLOAT_OES$1;
        }
        if (extensions.webgl_depth_texture) {
          extend3(textureFormats, {
            "depth": GL_DEPTH_COMPONENT,
            "depth stencil": GL_DEPTH_STENCIL
          });
          extend3(textureTypes, {
            "uint16": GL_UNSIGNED_SHORT$3,
            "uint32": GL_UNSIGNED_INT$3,
            "depth stencil": GL_UNSIGNED_INT_24_8_WEBGL$1
          });
        }
        if (extensions.webgl_compressed_texture_s3tc) {
          extend3(compressedTextureFormats, {
            "rgb s3tc dxt1": GL_COMPRESSED_RGB_S3TC_DXT1_EXT,
            "rgba s3tc dxt1": GL_COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "rgba s3tc dxt3": GL_COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "rgba s3tc dxt5": GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
          });
        }
        if (extensions.webgl_compressed_texture_atc) {
          extend3(compressedTextureFormats, {
            "rgb atc": GL_COMPRESSED_RGB_ATC_WEBGL,
            "rgba atc explicit alpha": GL_COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,
            "rgba atc interpolated alpha": GL_COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL
          });
        }
        if (extensions.webgl_compressed_texture_pvrtc) {
          extend3(compressedTextureFormats, {
            "rgb pvrtc 4bppv1": GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
            "rgb pvrtc 2bppv1": GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
            "rgba pvrtc 4bppv1": GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
            "rgba pvrtc 2bppv1": GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
          });
        }
        if (extensions.webgl_compressed_texture_etc1) {
          compressedTextureFormats["rgb etc1"] = GL_COMPRESSED_RGB_ETC1_WEBGL;
        }
        var supportedCompressedFormats = Array.prototype.slice.call(gl2.getParameter(GL_COMPRESSED_TEXTURE_FORMATS));
        Object.keys(compressedTextureFormats).forEach(function(name) {
          var format2 = compressedTextureFormats[name];
          if (supportedCompressedFormats.indexOf(format2) >= 0) {
            textureFormats[name] = format2;
          }
        });
        var supportedFormats = Object.keys(textureFormats);
        limits.textureFormats = supportedFormats;
        var textureFormatsInvert = [];
        Object.keys(textureFormats).forEach(function(key) {
          var val = textureFormats[key];
          textureFormatsInvert[val] = key;
        });
        var textureTypesInvert = [];
        Object.keys(textureTypes).forEach(function(key) {
          var val = textureTypes[key];
          textureTypesInvert[val] = key;
        });
        var magFiltersInvert = [];
        Object.keys(magFilters).forEach(function(key) {
          var val = magFilters[key];
          magFiltersInvert[val] = key;
        });
        var minFiltersInvert = [];
        Object.keys(minFilters).forEach(function(key) {
          var val = minFilters[key];
          minFiltersInvert[val] = key;
        });
        var wrapModesInvert = [];
        Object.keys(wrapModes).forEach(function(key) {
          var val = wrapModes[key];
          wrapModesInvert[val] = key;
        });
        var colorFormats = supportedFormats.reduce(function(color3, key) {
          var glenum = textureFormats[key];
          if (glenum === GL_LUMINANCE || glenum === GL_ALPHA || glenum === GL_LUMINANCE || glenum === GL_LUMINANCE_ALPHA || glenum === GL_DEPTH_COMPONENT || glenum === GL_DEPTH_STENCIL || extensions.ext_srgb && (glenum === GL_SRGB_EXT || glenum === GL_SRGB_ALPHA_EXT)) {
            color3[glenum] = glenum;
          } else if (glenum === GL_RGB5_A1 || key.indexOf("rgba") >= 0) {
            color3[glenum] = GL_RGBA$1;
          } else {
            color3[glenum] = GL_RGB;
          }
          return color3;
        }, {});
        function TexFlags() {
          this.internalformat = GL_RGBA$1;
          this.format = GL_RGBA$1;
          this.type = GL_UNSIGNED_BYTE$5;
          this.compressed = false;
          this.premultiplyAlpha = false;
          this.flipY = false;
          this.unpackAlignment = 1;
          this.colorSpace = GL_BROWSER_DEFAULT_WEBGL;
          this.width = 0;
          this.height = 0;
          this.channels = 0;
        }
        function copyFlags(result, other) {
          result.internalformat = other.internalformat;
          result.format = other.format;
          result.type = other.type;
          result.compressed = other.compressed;
          result.premultiplyAlpha = other.premultiplyAlpha;
          result.flipY = other.flipY;
          result.unpackAlignment = other.unpackAlignment;
          result.colorSpace = other.colorSpace;
          result.width = other.width;
          result.height = other.height;
          result.channels = other.channels;
        }
        function parseFlags2(flags, options) {
          if (typeof options !== "object" || !options) {
            return;
          }
          if ("premultiplyAlpha" in options) {
            check$1.type(options.premultiplyAlpha, "boolean", "invalid premultiplyAlpha");
            flags.premultiplyAlpha = options.premultiplyAlpha;
          }
          if ("flipY" in options) {
            check$1.type(options.flipY, "boolean", "invalid texture flip");
            flags.flipY = options.flipY;
          }
          if ("alignment" in options) {
            check$1.oneOf(options.alignment, [1, 2, 4, 8], "invalid texture unpack alignment");
            flags.unpackAlignment = options.alignment;
          }
          if ("colorSpace" in options) {
            check$1.parameter(options.colorSpace, colorSpace, "invalid colorSpace");
            flags.colorSpace = colorSpace[options.colorSpace];
          }
          if ("type" in options) {
            var type = options.type;
            check$1(extensions.oes_texture_float || !(type === "float" || type === "float32"), "you must enable the OES_texture_float extension in order to use floating point textures.");
            check$1(extensions.oes_texture_half_float || !(type === "half float" || type === "float16"), "you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures.");
            check$1(extensions.webgl_depth_texture || !(type === "uint16" || type === "uint32" || type === "depth stencil"), "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.");
            check$1.parameter(type, textureTypes, "invalid texture type");
            flags.type = textureTypes[type];
          }
          var w2 = flags.width;
          var h2 = flags.height;
          var c2 = flags.channels;
          var hasChannels = false;
          if ("shape" in options) {
            check$1(Array.isArray(options.shape) && options.shape.length >= 2, "shape must be an array");
            w2 = options.shape[0];
            h2 = options.shape[1];
            if (options.shape.length === 3) {
              c2 = options.shape[2];
              check$1(c2 > 0 && c2 <= 4, "invalid number of channels");
              hasChannels = true;
            }
            check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
          } else {
            if ("radius" in options) {
              w2 = h2 = options.radius;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid radius");
            }
            if ("width" in options) {
              w2 = options.width;
              check$1(w2 >= 0 && w2 <= limits.maxTextureSize, "invalid width");
            }
            if ("height" in options) {
              h2 = options.height;
              check$1(h2 >= 0 && h2 <= limits.maxTextureSize, "invalid height");
            }
            if ("channels" in options) {
              c2 = options.channels;
              check$1(c2 > 0 && c2 <= 4, "invalid number of channels");
              hasChannels = true;
            }
          }
          flags.width = w2 | 0;
          flags.height = h2 | 0;
          flags.channels = c2 | 0;
          var hasFormat = false;
          if ("format" in options) {
            var formatStr = options.format;
            check$1(extensions.webgl_depth_texture || !(formatStr === "depth" || formatStr === "depth stencil"), "you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures.");
            check$1.parameter(formatStr, textureFormats, "invalid texture format");
            var internalformat = flags.internalformat = textureFormats[formatStr];
            flags.format = colorFormats[internalformat];
            if (formatStr in textureTypes) {
              if (!("type" in options)) {
                flags.type = textureTypes[formatStr];
              }
            }
            if (formatStr in compressedTextureFormats) {
              flags.compressed = true;
            }
            hasFormat = true;
          }
          if (!hasChannels && hasFormat) {
            flags.channels = FORMAT_CHANNELS[flags.format];
          } else if (hasChannels && !hasFormat) {
            if (flags.channels !== CHANNELS_FORMAT[flags.format]) {
              flags.format = flags.internalformat = CHANNELS_FORMAT[flags.channels];
            }
          } else if (hasFormat && hasChannels) {
            check$1(flags.channels === FORMAT_CHANNELS[flags.format], "number of channels inconsistent with specified format");
          }
        }
        function setFlags(flags) {
          gl2.pixelStorei(GL_UNPACK_FLIP_Y_WEBGL, flags.flipY);
          gl2.pixelStorei(GL_UNPACK_PREMULTIPLY_ALPHA_WEBGL, flags.premultiplyAlpha);
          gl2.pixelStorei(GL_UNPACK_COLORSPACE_CONVERSION_WEBGL, flags.colorSpace);
          gl2.pixelStorei(GL_UNPACK_ALIGNMENT, flags.unpackAlignment);
        }
        function TexImage() {
          TexFlags.call(this);
          this.xOffset = 0;
          this.yOffset = 0;
          this.data = null;
          this.needsFree = false;
          this.element = null;
          this.needsCopy = false;
        }
        function parseImage(image, options) {
          var data = null;
          if (isPixelData(options)) {
            data = options;
          } else if (options) {
            check$1.type(options, "object", "invalid pixel data type");
            parseFlags2(image, options);
            if ("x" in options) {
              image.xOffset = options.x | 0;
            }
            if ("y" in options) {
              image.yOffset = options.y | 0;
            }
            if (isPixelData(options.data)) {
              data = options.data;
            }
          }
          check$1(!image.compressed || data instanceof Uint8Array, "compressed texture data must be stored in a uint8array");
          if (options.copy) {
            check$1(!data, "can not specify copy and data field for the same texture");
            var viewW = contextState.viewportWidth;
            var viewH = contextState.viewportHeight;
            image.width = image.width || viewW - image.xOffset;
            image.height = image.height || viewH - image.yOffset;
            image.needsCopy = true;
            check$1(image.xOffset >= 0 && image.xOffset < viewW && image.yOffset >= 0 && image.yOffset < viewH && image.width > 0 && image.width <= viewW && image.height > 0 && image.height <= viewH, "copy texture read out of bounds");
          } else if (!data) {
            image.width = image.width || 1;
            image.height = image.height || 1;
            image.channels = image.channels || 4;
          } else if (isTypedArray4(data)) {
            image.channels = image.channels || 4;
            image.data = data;
            if (!("type" in options) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(data);
            }
          } else if (isNumericArray(data)) {
            image.channels = image.channels || 4;
            convertData(image, data);
            image.alignment = 1;
            image.needsFree = true;
          } else if (isNDArrayLike(data)) {
            var array = data.data;
            if (!Array.isArray(array) && image.type === GL_UNSIGNED_BYTE$5) {
              image.type = typedArrayCode$1(array);
            }
            var shape = data.shape;
            var stride = data.stride;
            var shapeX, shapeY, shapeC, strideX, strideY, strideC;
            if (shape.length === 3) {
              shapeC = shape[2];
              strideC = stride[2];
            } else {
              check$1(shape.length === 2, "invalid ndarray pixel data, must be 2 or 3D");
              shapeC = 1;
              strideC = 1;
            }
            shapeX = shape[0];
            shapeY = shape[1];
            strideX = stride[0];
            strideY = stride[1];
            image.alignment = 1;
            image.width = shapeX;
            image.height = shapeY;
            image.channels = shapeC;
            image.format = image.internalformat = CHANNELS_FORMAT[shapeC];
            image.needsFree = true;
            transposeData(image, array, strideX, strideY, strideC, data.offset);
          } else if (isCanvasElement(data) || isOffscreenCanvas(data) || isContext2D(data)) {
            if (isCanvasElement(data) || isOffscreenCanvas(data)) {
              image.element = data;
            } else {
              image.element = data.canvas;
            }
            image.width = image.element.width;
            image.height = image.element.height;
            image.channels = 4;
          } else if (isBitmap(data)) {
            image.element = data;
            image.width = data.width;
            image.height = data.height;
            image.channels = 4;
          } else if (isImageElement(data)) {
            image.element = data;
            image.width = data.naturalWidth;
            image.height = data.naturalHeight;
            image.channels = 4;
          } else if (isVideoElement(data)) {
            image.element = data;
            image.width = data.videoWidth;
            image.height = data.videoHeight;
            image.channels = 4;
          } else if (isRectArray(data)) {
            var w2 = image.width || data[0].length;
            var h2 = image.height || data.length;
            var c2 = image.channels;
            if (isArrayLike2(data[0][0])) {
              c2 = c2 || data[0][0].length;
            } else {
              c2 = c2 || 1;
            }
            var arrayShape2 = flattenUtils.shape(data);
            var n2 = 1;
            for (var dd = 0; dd < arrayShape2.length; ++dd) {
              n2 *= arrayShape2[dd];
            }
            var allocData = preConvert(image, n2);
            flattenUtils.flatten(data, arrayShape2, "", allocData);
            postConvert(image, allocData);
            image.alignment = 1;
            image.width = w2;
            image.height = h2;
            image.channels = c2;
            image.format = image.internalformat = CHANNELS_FORMAT[c2];
            image.needsFree = true;
          }
          if (image.type === GL_FLOAT$4) {
            check$1(limits.extensions.indexOf("oes_texture_float") >= 0, "oes_texture_float extension not enabled");
          } else if (image.type === GL_HALF_FLOAT_OES$1) {
            check$1(limits.extensions.indexOf("oes_texture_half_float") >= 0, "oes_texture_half_float extension not enabled");
          }
        }
        function setImage(info, target, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texImage2D(target, miplevel, format2, format2, type, element);
          } else if (info.compressed) {
            gl2.compressedTexImage2D(target, miplevel, internalformat, width, height, 0, data);
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexImage2D(target, miplevel, format2, info.xOffset, info.yOffset, width, height, 0);
          } else {
            gl2.texImage2D(target, miplevel, format2, width, height, 0, format2, type, data || null);
          }
        }
        function setSubImage(info, target, x2, y2, miplevel) {
          var element = info.element;
          var data = info.data;
          var internalformat = info.internalformat;
          var format2 = info.format;
          var type = info.type;
          var width = info.width;
          var height = info.height;
          setFlags(info);
          if (element) {
            gl2.texSubImage2D(target, miplevel, x2, y2, format2, type, element);
          } else if (info.compressed) {
            gl2.compressedTexSubImage2D(target, miplevel, x2, y2, internalformat, width, height, data);
          } else if (info.needsCopy) {
            reglPoll();
            gl2.copyTexSubImage2D(target, miplevel, x2, y2, info.xOffset, info.yOffset, width, height);
          } else {
            gl2.texSubImage2D(target, miplevel, x2, y2, width, height, format2, type, data);
          }
        }
        var imagePool = [];
        function allocImage() {
          return imagePool.pop() || new TexImage();
        }
        function freeImage(image) {
          if (image.needsFree) {
            pool.freeType(image.data);
          }
          TexImage.call(image);
          imagePool.push(image);
        }
        function MipMap() {
          TexFlags.call(this);
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
          this.mipmask = 0;
          this.images = Array(16);
        }
        function parseMipMapFromShape(mipmap, width, height) {
          var img = mipmap.images[0] = allocImage();
          mipmap.mipmask = 1;
          img.width = mipmap.width = width;
          img.height = mipmap.height = height;
          img.channels = mipmap.channels = 4;
        }
        function parseMipMapFromObject(mipmap, options) {
          var imgData = null;
          if (isPixelData(options)) {
            imgData = mipmap.images[0] = allocImage();
            copyFlags(imgData, mipmap);
            parseImage(imgData, options);
            mipmap.mipmask = 1;
          } else {
            parseFlags2(mipmap, options);
            if (Array.isArray(options.mipmap)) {
              var mipData = options.mipmap;
              for (var i2 = 0; i2 < mipData.length; ++i2) {
                imgData = mipmap.images[i2] = allocImage();
                copyFlags(imgData, mipmap);
                imgData.width >>= i2;
                imgData.height >>= i2;
                parseImage(imgData, mipData[i2]);
                mipmap.mipmask |= 1 << i2;
              }
            } else {
              imgData = mipmap.images[0] = allocImage();
              copyFlags(imgData, mipmap);
              parseImage(imgData, options);
              mipmap.mipmask = 1;
            }
          }
          copyFlags(mipmap, mipmap.images[0]);
          if (mipmap.compressed && (mipmap.internalformat === GL_COMPRESSED_RGB_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT1_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT3_EXT || mipmap.internalformat === GL_COMPRESSED_RGBA_S3TC_DXT5_EXT)) {
            check$1(mipmap.width % 4 === 0 && mipmap.height % 4 === 0, "for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4");
          }
        }
        function setMipMap(mipmap, target) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (!images[i2]) {
              return;
            }
            setImage(images[i2], target, i2);
          }
        }
        var mipPool = [];
        function allocMipMap() {
          var result = mipPool.pop() || new MipMap();
          TexFlags.call(result);
          result.mipmask = 0;
          for (var i2 = 0; i2 < 16; ++i2) {
            result.images[i2] = null;
          }
          return result;
        }
        function freeMipMap(mipmap) {
          var images = mipmap.images;
          for (var i2 = 0; i2 < images.length; ++i2) {
            if (images[i2]) {
              freeImage(images[i2]);
            }
            images[i2] = null;
          }
          mipPool.push(mipmap);
        }
        function TexInfo() {
          this.minFilter = GL_NEAREST$1;
          this.magFilter = GL_NEAREST$1;
          this.wrapS = GL_CLAMP_TO_EDGE$1;
          this.wrapT = GL_CLAMP_TO_EDGE$1;
          this.anisotropic = 1;
          this.genMipmaps = false;
          this.mipmapHint = GL_DONT_CARE;
        }
        function parseTexInfo(info, options) {
          if ("min" in options) {
            var minFilter = options.min;
            check$1.parameter(minFilter, minFilters);
            info.minFilter = minFilters[minFilter];
            if (MIPMAP_FILTERS.indexOf(info.minFilter) >= 0 && !("faces" in options)) {
              info.genMipmaps = true;
            }
          }
          if ("mag" in options) {
            var magFilter = options.mag;
            check$1.parameter(magFilter, magFilters);
            info.magFilter = magFilters[magFilter];
          }
          var wrapS = info.wrapS;
          var wrapT = info.wrapT;
          if ("wrap" in options) {
            var wrap2 = options.wrap;
            if (typeof wrap2 === "string") {
              check$1.parameter(wrap2, wrapModes);
              wrapS = wrapT = wrapModes[wrap2];
            } else if (Array.isArray(wrap2)) {
              check$1.parameter(wrap2[0], wrapModes);
              check$1.parameter(wrap2[1], wrapModes);
              wrapS = wrapModes[wrap2[0]];
              wrapT = wrapModes[wrap2[1]];
            }
          } else {
            if ("wrapS" in options) {
              var optWrapS = options.wrapS;
              check$1.parameter(optWrapS, wrapModes);
              wrapS = wrapModes[optWrapS];
            }
            if ("wrapT" in options) {
              var optWrapT = options.wrapT;
              check$1.parameter(optWrapT, wrapModes);
              wrapT = wrapModes[optWrapT];
            }
          }
          info.wrapS = wrapS;
          info.wrapT = wrapT;
          if ("anisotropic" in options) {
            var anisotropic = options.anisotropic;
            check$1(typeof anisotropic === "number" && anisotropic >= 1 && anisotropic <= limits.maxAnisotropic, "aniso samples must be between 1 and ");
            info.anisotropic = options.anisotropic;
          }
          if ("mipmap" in options) {
            var hasMipMap = false;
            switch (typeof options.mipmap) {
              case "string":
                check$1.parameter(options.mipmap, mipmapHint, "invalid mipmap hint");
                info.mipmapHint = mipmapHint[options.mipmap];
                info.genMipmaps = true;
                hasMipMap = true;
                break;
              case "boolean":
                hasMipMap = info.genMipmaps = options.mipmap;
                break;
              case "object":
                check$1(Array.isArray(options.mipmap), "invalid mipmap type");
                info.genMipmaps = false;
                hasMipMap = true;
                break;
              default:
                check$1.raise("invalid mipmap type");
            }
            if (hasMipMap && !("min" in options)) {
              info.minFilter = GL_NEAREST_MIPMAP_NEAREST$1;
            }
          }
        }
        function setTexInfo(info, target) {
          gl2.texParameteri(target, GL_TEXTURE_MIN_FILTER, info.minFilter);
          gl2.texParameteri(target, GL_TEXTURE_MAG_FILTER, info.magFilter);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_S, info.wrapS);
          gl2.texParameteri(target, GL_TEXTURE_WRAP_T, info.wrapT);
          if (extensions.ext_texture_filter_anisotropic) {
            gl2.texParameteri(target, GL_TEXTURE_MAX_ANISOTROPY_EXT, info.anisotropic);
          }
          if (info.genMipmaps) {
            gl2.hint(GL_GENERATE_MIPMAP_HINT, info.mipmapHint);
            gl2.generateMipmap(target);
          }
        }
        var textureCount = 0;
        var textureSet = {};
        var numTexUnits = limits.maxTextureUnits;
        var textureUnits = Array(numTexUnits).map(function() {
          return null;
        });
        function REGLTexture(target) {
          TexFlags.call(this);
          this.mipmask = 0;
          this.internalformat = GL_RGBA$1;
          this.id = textureCount++;
          this.refCount = 1;
          this.target = target;
          this.texture = gl2.createTexture();
          this.unit = -1;
          this.bindCount = 0;
          this.texInfo = new TexInfo();
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        function tempBind(texture) {
          gl2.activeTexture(GL_TEXTURE0$1);
          gl2.bindTexture(texture.target, texture.texture);
        }
        function tempRestore() {
          var prev = textureUnits[0];
          if (prev) {
            gl2.bindTexture(prev.target, prev.texture);
          } else {
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
          }
        }
        function destroy(texture) {
          var handle = texture.texture;
          check$1(handle, "must not double destroy texture");
          var unit = texture.unit;
          var target = texture.target;
          if (unit >= 0) {
            gl2.activeTexture(GL_TEXTURE0$1 + unit);
            gl2.bindTexture(target, null);
            textureUnits[unit] = null;
          }
          gl2.deleteTexture(handle);
          texture.texture = null;
          texture.params = null;
          texture.pixels = null;
          texture.refCount = 0;
          delete textureSet[texture.id];
          stats2.textureCount--;
        }
        extend3(REGLTexture.prototype, {
          bind: function() {
            var texture = this;
            texture.bindCount += 1;
            var unit = texture.unit;
            if (unit < 0) {
              for (var i2 = 0; i2 < numTexUnits; ++i2) {
                var other = textureUnits[i2];
                if (other) {
                  if (other.bindCount > 0) {
                    continue;
                  }
                  other.unit = -1;
                }
                textureUnits[i2] = texture;
                unit = i2;
                break;
              }
              if (unit >= numTexUnits) {
                check$1.raise("insufficient number of texture units");
              }
              if (config.profile && stats2.maxTextureUnits < unit + 1) {
                stats2.maxTextureUnits = unit + 1;
              }
              texture.unit = unit;
              gl2.activeTexture(GL_TEXTURE0$1 + unit);
              gl2.bindTexture(texture.target, texture.texture);
            }
            return unit;
          },
          unbind: function() {
            this.bindCount -= 1;
          },
          decRef: function() {
            if (--this.refCount <= 0) {
              destroy(this);
            }
          }
        });
        function createTexture2D(a2, b10) {
          var texture = new REGLTexture(GL_TEXTURE_2D$1);
          textureSet[texture.id] = texture;
          stats2.textureCount++;
          function reglTexture2D(a3, b11) {
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            var mipData = allocMipMap();
            if (typeof a3 === "number") {
              if (typeof b11 === "number") {
                parseMipMapFromShape(mipData, a3 | 0, b11 | 0);
              } else {
                parseMipMapFromShape(mipData, a3 | 0, a3 | 0);
              }
            } else if (a3) {
              check$1.type(a3, "object", "invalid arguments to regl.texture");
              parseTexInfo(texInfo, a3);
              parseMipMapFromObject(mipData, a3);
            } else {
              parseMipMapFromShape(mipData, 1, 1);
            }
            if (texInfo.genMipmaps) {
              mipData.mipmask = (mipData.width << 1) - 1;
            }
            texture.mipmask = mipData.mipmask;
            copyFlags(texture, mipData);
            check$1.texture2D(texInfo, mipData, limits);
            texture.internalformat = mipData.internalformat;
            reglTexture2D.width = mipData.width;
            reglTexture2D.height = mipData.height;
            tempBind(texture);
            setMipMap(mipData, GL_TEXTURE_2D$1);
            setTexInfo(texInfo, GL_TEXTURE_2D$1);
            tempRestore();
            freeMipMap(mipData);
            if (config.profile) {
              texture.stats.size = getTextureSize(texture.internalformat, texture.type, mipData.width, mipData.height, texInfo.genMipmaps, false);
            }
            reglTexture2D.format = textureFormatsInvert[texture.internalformat];
            reglTexture2D.type = textureTypesInvert[texture.type];
            reglTexture2D.mag = magFiltersInvert[texInfo.magFilter];
            reglTexture2D.min = minFiltersInvert[texInfo.minFilter];
            reglTexture2D.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTexture2D.wrapT = wrapModesInvert[texInfo.wrapT];
            return reglTexture2D;
          }
          function subimage(image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            var x2 = x_ | 0;
            var y2 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x2;
            imageData.height = imageData.height || (texture.height >> level) - y2;
            check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, "incompatible format for texture.subimage");
            check$1(x2 >= 0 && y2 >= 0 && x2 + imageData.width <= texture.width && y2 + imageData.height <= texture.height, "texture.subimage write out of bounds");
            check$1(texture.mipmask & 1 << level, "missing mipmap data");
            check$1(imageData.data || imageData.element || imageData.needsCopy, "missing image data");
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_2D$1, x2, y2, level);
            tempRestore();
            freeImage(imageData);
            return reglTexture2D;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === texture.width && h2 === texture.height) {
              return reglTexture2D;
            }
            reglTexture2D.width = texture.width = w2;
            reglTexture2D.height = texture.height = h2;
            tempBind(texture);
            for (var i2 = 0; texture.mipmask >> i2; ++i2) {
              var _w = w2 >> i2;
              var _h = h2 >> i2;
              if (!_w || !_h)
                break;
              gl2.texImage2D(GL_TEXTURE_2D$1, i2, texture.format, _w, _h, 0, texture.format, texture.type, null);
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(texture.internalformat, texture.type, w2, h2, false, false);
            }
            return reglTexture2D;
          }
          reglTexture2D(a2, b10);
          reglTexture2D.subimage = subimage;
          reglTexture2D.resize = resize;
          reglTexture2D._reglType = "texture2d";
          reglTexture2D._texture = texture;
          if (config.profile) {
            reglTexture2D.stats = texture.stats;
          }
          reglTexture2D.destroy = function() {
            texture.decRef();
          };
          return reglTexture2D;
        }
        function createTextureCube(a0, a1, a2, a3, a4, a5) {
          var texture = new REGLTexture(GL_TEXTURE_CUBE_MAP$1);
          textureSet[texture.id] = texture;
          stats2.cubeCount++;
          var faces = new Array(6);
          function reglTextureCube(a02, a12, a22, a32, a42, a52) {
            var i2;
            var texInfo = texture.texInfo;
            TexInfo.call(texInfo);
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2] = allocMipMap();
            }
            if (typeof a02 === "number" || !a02) {
              var s2 = a02 | 0 || 1;
              for (i2 = 0; i2 < 6; ++i2) {
                parseMipMapFromShape(faces[i2], s2, s2);
              }
            } else if (typeof a02 === "object") {
              if (a12) {
                parseMipMapFromObject(faces[0], a02);
                parseMipMapFromObject(faces[1], a12);
                parseMipMapFromObject(faces[2], a22);
                parseMipMapFromObject(faces[3], a32);
                parseMipMapFromObject(faces[4], a42);
                parseMipMapFromObject(faces[5], a52);
              } else {
                parseTexInfo(texInfo, a02);
                parseFlags2(texture, a02);
                if ("faces" in a02) {
                  var faceInput = a02.faces;
                  check$1(Array.isArray(faceInput) && faceInput.length === 6, "cube faces must be a length 6 array");
                  for (i2 = 0; i2 < 6; ++i2) {
                    check$1(typeof faceInput[i2] === "object" && !!faceInput[i2], "invalid input for cube map face");
                    copyFlags(faces[i2], texture);
                    parseMipMapFromObject(faces[i2], faceInput[i2]);
                  }
                } else {
                  for (i2 = 0; i2 < 6; ++i2) {
                    parseMipMapFromObject(faces[i2], a02);
                  }
                }
              }
            } else {
              check$1.raise("invalid arguments to cube map");
            }
            copyFlags(texture, faces[0]);
            if (!limits.npotTextureCube) {
              check$1(isPow2$1(texture.width) && isPow2$1(texture.height), "your browser does not support non power or two texture dimensions");
            }
            if (texInfo.genMipmaps) {
              texture.mipmask = (faces[0].width << 1) - 1;
            } else {
              texture.mipmask = faces[0].mipmask;
            }
            check$1.textureCube(texture, texInfo, faces, limits);
            texture.internalformat = faces[0].internalformat;
            reglTextureCube.width = faces[0].width;
            reglTextureCube.height = faces[0].height;
            tempBind(texture);
            for (i2 = 0; i2 < 6; ++i2) {
              setMipMap(faces[i2], GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2);
            }
            setTexInfo(texInfo, GL_TEXTURE_CUBE_MAP$1);
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, texInfo.genMipmaps, true);
            }
            reglTextureCube.format = textureFormatsInvert[texture.internalformat];
            reglTextureCube.type = textureTypesInvert[texture.type];
            reglTextureCube.mag = magFiltersInvert[texInfo.magFilter];
            reglTextureCube.min = minFiltersInvert[texInfo.minFilter];
            reglTextureCube.wrapS = wrapModesInvert[texInfo.wrapS];
            reglTextureCube.wrapT = wrapModesInvert[texInfo.wrapT];
            for (i2 = 0; i2 < 6; ++i2) {
              freeMipMap(faces[i2]);
            }
            return reglTextureCube;
          }
          function subimage(face, image, x_, y_, level_) {
            check$1(!!image, "must specify image data");
            check$1(typeof face === "number" && face === (face | 0) && face >= 0 && face < 6, "invalid face");
            var x2 = x_ | 0;
            var y2 = y_ | 0;
            var level = level_ | 0;
            var imageData = allocImage();
            copyFlags(imageData, texture);
            imageData.width = 0;
            imageData.height = 0;
            parseImage(imageData, image);
            imageData.width = imageData.width || (texture.width >> level) - x2;
            imageData.height = imageData.height || (texture.height >> level) - y2;
            check$1(texture.type === imageData.type && texture.format === imageData.format && texture.internalformat === imageData.internalformat, "incompatible format for texture.subimage");
            check$1(x2 >= 0 && y2 >= 0 && x2 + imageData.width <= texture.width && y2 + imageData.height <= texture.height, "texture.subimage write out of bounds");
            check$1(texture.mipmask & 1 << level, "missing mipmap data");
            check$1(imageData.data || imageData.element || imageData.needsCopy, "missing image data");
            tempBind(texture);
            setSubImage(imageData, GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + face, x2, y2, level);
            tempRestore();
            freeImage(imageData);
            return reglTextureCube;
          }
          function resize(radius_) {
            var radius = radius_ | 0;
            if (radius === texture.width) {
              return;
            }
            reglTextureCube.width = texture.width = radius;
            reglTextureCube.height = texture.height = radius;
            tempBind(texture);
            for (var i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; texture.mipmask >> j2; ++j2) {
                gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + i2, j2, texture.format, radius >> j2, radius >> j2, 0, texture.format, texture.type, null);
              }
            }
            tempRestore();
            if (config.profile) {
              texture.stats.size = getTextureSize(texture.internalformat, texture.type, reglTextureCube.width, reglTextureCube.height, false, true);
            }
            return reglTextureCube;
          }
          reglTextureCube(a0, a1, a2, a3, a4, a5);
          reglTextureCube.subimage = subimage;
          reglTextureCube.resize = resize;
          reglTextureCube._reglType = "textureCube";
          reglTextureCube._texture = texture;
          if (config.profile) {
            reglTextureCube.stats = texture.stats;
          }
          reglTextureCube.destroy = function() {
            texture.decRef();
          };
          return reglTextureCube;
        }
        function destroyTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            textureUnits[i2] = null;
          }
          values2(textureSet).forEach(destroy);
          stats2.cubeCount = 0;
          stats2.textureCount = 0;
        }
        if (config.profile) {
          stats2.getTotalTextureSize = function() {
            var total = 0;
            Object.keys(textureSet).forEach(function(key) {
              total += textureSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
          }
          values2(textureSet).forEach(function(texture) {
            texture.texture = gl2.createTexture();
            gl2.bindTexture(texture.target, texture.texture);
            for (var i3 = 0; i3 < 32; ++i3) {
              if ((texture.mipmask & 1 << i3) === 0) {
                continue;
              }
              if (texture.target === GL_TEXTURE_2D$1) {
                gl2.texImage2D(GL_TEXTURE_2D$1, i3, texture.internalformat, texture.width >> i3, texture.height >> i3, 0, texture.internalformat, texture.type, null);
              } else {
                for (var j2 = 0; j2 < 6; ++j2) {
                  gl2.texImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X$1 + j2, i3, texture.internalformat, texture.width >> i3, texture.height >> i3, 0, texture.internalformat, texture.type, null);
                }
              }
            }
            setTexInfo(texture.texInfo, texture.target);
          });
        }
        function refreshTextures() {
          for (var i2 = 0; i2 < numTexUnits; ++i2) {
            var tex = textureUnits[i2];
            if (tex) {
              tex.bindCount = 0;
              tex.unit = -1;
              textureUnits[i2] = null;
            }
            gl2.activeTexture(GL_TEXTURE0$1 + i2);
            gl2.bindTexture(GL_TEXTURE_2D$1, null);
            gl2.bindTexture(GL_TEXTURE_CUBE_MAP$1, null);
          }
        }
        return {
          create2D: createTexture2D,
          createCube: createTextureCube,
          clear: destroyTextures,
          getTexture: function(wrapper) {
            return null;
          },
          restore: restoreTextures,
          refresh: refreshTextures
        };
      }
      var GL_RENDERBUFFER = 36161;
      var GL_RGBA4$1 = 32854;
      var GL_RGB5_A1$1 = 32855;
      var GL_RGB565$1 = 36194;
      var GL_DEPTH_COMPONENT16 = 33189;
      var GL_STENCIL_INDEX8 = 36168;
      var GL_DEPTH_STENCIL$1 = 34041;
      var GL_SRGB8_ALPHA8_EXT = 35907;
      var GL_RGBA32F_EXT = 34836;
      var GL_RGBA16F_EXT = 34842;
      var GL_RGB16F_EXT = 34843;
      var FORMAT_SIZES = [];
      FORMAT_SIZES[GL_RGBA4$1] = 2;
      FORMAT_SIZES[GL_RGB5_A1$1] = 2;
      FORMAT_SIZES[GL_RGB565$1] = 2;
      FORMAT_SIZES[GL_DEPTH_COMPONENT16] = 2;
      FORMAT_SIZES[GL_STENCIL_INDEX8] = 1;
      FORMAT_SIZES[GL_DEPTH_STENCIL$1] = 4;
      FORMAT_SIZES[GL_SRGB8_ALPHA8_EXT] = 4;
      FORMAT_SIZES[GL_RGBA32F_EXT] = 16;
      FORMAT_SIZES[GL_RGBA16F_EXT] = 8;
      FORMAT_SIZES[GL_RGB16F_EXT] = 6;
      function getRenderbufferSize(format2, width, height) {
        return FORMAT_SIZES[format2] * width * height;
      }
      var wrapRenderbuffers = function(gl2, extensions, limits, stats2, config) {
        var formatTypes = {
          "rgba4": GL_RGBA4$1,
          "rgb565": GL_RGB565$1,
          "rgb5 a1": GL_RGB5_A1$1,
          "depth": GL_DEPTH_COMPONENT16,
          "stencil": GL_STENCIL_INDEX8,
          "depth stencil": GL_DEPTH_STENCIL$1
        };
        if (extensions.ext_srgb) {
          formatTypes["srgba"] = GL_SRGB8_ALPHA8_EXT;
        }
        if (extensions.ext_color_buffer_half_float) {
          formatTypes["rgba16f"] = GL_RGBA16F_EXT;
          formatTypes["rgb16f"] = GL_RGB16F_EXT;
        }
        if (extensions.webgl_color_buffer_float) {
          formatTypes["rgba32f"] = GL_RGBA32F_EXT;
        }
        var formatTypesInvert = [];
        Object.keys(formatTypes).forEach(function(key) {
          var val = formatTypes[key];
          formatTypesInvert[val] = key;
        });
        var renderbufferCount = 0;
        var renderbufferSet = {};
        function REGLRenderbuffer(renderbuffer) {
          this.id = renderbufferCount++;
          this.refCount = 1;
          this.renderbuffer = renderbuffer;
          this.format = GL_RGBA4$1;
          this.width = 0;
          this.height = 0;
          if (config.profile) {
            this.stats = { size: 0 };
          }
        }
        REGLRenderbuffer.prototype.decRef = function() {
          if (--this.refCount <= 0) {
            destroy(this);
          }
        };
        function destroy(rb) {
          var handle = rb.renderbuffer;
          check$1(handle, "must not double destroy renderbuffer");
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
          gl2.deleteRenderbuffer(handle);
          rb.renderbuffer = null;
          rb.refCount = 0;
          delete renderbufferSet[rb.id];
          stats2.renderbufferCount--;
        }
        function createRenderbuffer(a2, b10) {
          var renderbuffer = new REGLRenderbuffer(gl2.createRenderbuffer());
          renderbufferSet[renderbuffer.id] = renderbuffer;
          stats2.renderbufferCount++;
          function reglRenderbuffer(a3, b11) {
            var w2 = 0;
            var h2 = 0;
            var format2 = GL_RGBA4$1;
            if (typeof a3 === "object" && a3) {
              var options = a3;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(Array.isArray(shape) && shape.length >= 2, "invalid renderbuffer shape");
                w2 = shape[0] | 0;
                h2 = shape[1] | 0;
              } else {
                if ("radius" in options) {
                  w2 = h2 = options.radius | 0;
                }
                if ("width" in options) {
                  w2 = options.width | 0;
                }
                if ("height" in options) {
                  h2 = options.height | 0;
                }
              }
              if ("format" in options) {
                check$1.parameter(options.format, formatTypes, "invalid renderbuffer format");
                format2 = formatTypes[options.format];
              }
            } else if (typeof a3 === "number") {
              w2 = a3 | 0;
              if (typeof b11 === "number") {
                h2 = b11 | 0;
              } else {
                h2 = w2;
              }
            } else if (!a3) {
              w2 = h2 = 1;
            } else {
              check$1.raise("invalid arguments to renderbuffer constructor");
            }
            check$1(w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize, "invalid renderbuffer size");
            if (w2 === renderbuffer.width && h2 === renderbuffer.height && format2 === renderbuffer.format) {
              return;
            }
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            renderbuffer.format = format2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, format2, w2, h2);
            check$1(gl2.getError() === 0, "invalid render buffer format");
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
            }
            reglRenderbuffer.format = formatTypesInvert[renderbuffer.format];
            return reglRenderbuffer;
          }
          function resize(w_, h_) {
            var w2 = w_ | 0;
            var h2 = h_ | 0 || w2;
            if (w2 === renderbuffer.width && h2 === renderbuffer.height) {
              return reglRenderbuffer;
            }
            check$1(w2 > 0 && h2 > 0 && w2 <= limits.maxRenderbufferSize && h2 <= limits.maxRenderbufferSize, "invalid renderbuffer size");
            reglRenderbuffer.width = renderbuffer.width = w2;
            reglRenderbuffer.height = renderbuffer.height = h2;
            gl2.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, renderbuffer.format, w2, h2);
            check$1(gl2.getError() === 0, "invalid render buffer format");
            if (config.profile) {
              renderbuffer.stats.size = getRenderbufferSize(renderbuffer.format, renderbuffer.width, renderbuffer.height);
            }
            return reglRenderbuffer;
          }
          reglRenderbuffer(a2, b10);
          reglRenderbuffer.resize = resize;
          reglRenderbuffer._reglType = "renderbuffer";
          reglRenderbuffer._renderbuffer = renderbuffer;
          if (config.profile) {
            reglRenderbuffer.stats = renderbuffer.stats;
          }
          reglRenderbuffer.destroy = function() {
            renderbuffer.decRef();
          };
          return reglRenderbuffer;
        }
        if (config.profile) {
          stats2.getTotalRenderbufferSize = function() {
            var total = 0;
            Object.keys(renderbufferSet).forEach(function(key) {
              total += renderbufferSet[key].stats.size;
            });
            return total;
          };
        }
        function restoreRenderbuffers() {
          values2(renderbufferSet).forEach(function(rb) {
            rb.renderbuffer = gl2.createRenderbuffer();
            gl2.bindRenderbuffer(GL_RENDERBUFFER, rb.renderbuffer);
            gl2.renderbufferStorage(GL_RENDERBUFFER, rb.format, rb.width, rb.height);
          });
          gl2.bindRenderbuffer(GL_RENDERBUFFER, null);
        }
        return {
          create: createRenderbuffer,
          clear: function() {
            values2(renderbufferSet).forEach(destroy);
          },
          restore: restoreRenderbuffers
        };
      };
      var GL_FRAMEBUFFER$1 = 36160;
      var GL_RENDERBUFFER$1 = 36161;
      var GL_TEXTURE_2D$2 = 3553;
      var GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 = 34069;
      var GL_COLOR_ATTACHMENT0$1 = 36064;
      var GL_DEPTH_ATTACHMENT = 36096;
      var GL_STENCIL_ATTACHMENT = 36128;
      var GL_DEPTH_STENCIL_ATTACHMENT = 33306;
      var GL_FRAMEBUFFER_COMPLETE$1 = 36053;
      var GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054;
      var GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055;
      var GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057;
      var GL_FRAMEBUFFER_UNSUPPORTED = 36061;
      var GL_HALF_FLOAT_OES$2 = 36193;
      var GL_UNSIGNED_BYTE$6 = 5121;
      var GL_FLOAT$5 = 5126;
      var GL_RGB$1 = 6407;
      var GL_RGBA$2 = 6408;
      var GL_DEPTH_COMPONENT$1 = 6402;
      var colorTextureFormatEnums = [
        GL_RGB$1,
        GL_RGBA$2
      ];
      var textureFormatChannels = [];
      textureFormatChannels[GL_RGBA$2] = 4;
      textureFormatChannels[GL_RGB$1] = 3;
      var textureTypeSizes = [];
      textureTypeSizes[GL_UNSIGNED_BYTE$6] = 1;
      textureTypeSizes[GL_FLOAT$5] = 4;
      textureTypeSizes[GL_HALF_FLOAT_OES$2] = 2;
      var GL_RGBA4$2 = 32854;
      var GL_RGB5_A1$2 = 32855;
      var GL_RGB565$2 = 36194;
      var GL_DEPTH_COMPONENT16$1 = 33189;
      var GL_STENCIL_INDEX8$1 = 36168;
      var GL_DEPTH_STENCIL$2 = 34041;
      var GL_SRGB8_ALPHA8_EXT$1 = 35907;
      var GL_RGBA32F_EXT$1 = 34836;
      var GL_RGBA16F_EXT$1 = 34842;
      var GL_RGB16F_EXT$1 = 34843;
      var colorRenderbufferFormatEnums = [
        GL_RGBA4$2,
        GL_RGB5_A1$2,
        GL_RGB565$2,
        GL_SRGB8_ALPHA8_EXT$1,
        GL_RGBA16F_EXT$1,
        GL_RGB16F_EXT$1,
        GL_RGBA32F_EXT$1
      ];
      var statusCode = {};
      statusCode[GL_FRAMEBUFFER_COMPLETE$1] = "complete";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = "incomplete attachment";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = "incomplete dimensions";
      statusCode[GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = "incomplete, missing attachment";
      statusCode[GL_FRAMEBUFFER_UNSUPPORTED] = "unsupported";
      function wrapFBOState(gl2, extensions, limits, textureState, renderbufferState, stats2) {
        var framebufferState = {
          cur: null,
          next: null,
          dirty: false,
          setFBO: null
        };
        var colorTextureFormats = ["rgba"];
        var colorRenderbufferFormats = ["rgba4", "rgb565", "rgb5 a1"];
        if (extensions.ext_srgb) {
          colorRenderbufferFormats.push("srgba");
        }
        if (extensions.ext_color_buffer_half_float) {
          colorRenderbufferFormats.push("rgba16f", "rgb16f");
        }
        if (extensions.webgl_color_buffer_float) {
          colorRenderbufferFormats.push("rgba32f");
        }
        var colorTypes = ["uint8"];
        if (extensions.oes_texture_half_float) {
          colorTypes.push("half float", "float16");
        }
        if (extensions.oes_texture_float) {
          colorTypes.push("float", "float32");
        }
        function FramebufferAttachment(target, texture, renderbuffer) {
          this.target = target;
          this.texture = texture;
          this.renderbuffer = renderbuffer;
          var w2 = 0;
          var h2 = 0;
          if (texture) {
            w2 = texture.width;
            h2 = texture.height;
          } else if (renderbuffer) {
            w2 = renderbuffer.width;
            h2 = renderbuffer.height;
          }
          this.width = w2;
          this.height = h2;
        }
        function decRef(attachment) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture._texture.decRef();
            }
            if (attachment.renderbuffer) {
              attachment.renderbuffer._renderbuffer.decRef();
            }
          }
        }
        function incRefAndCheckShape(attachment, width, height) {
          if (!attachment) {
            return;
          }
          if (attachment.texture) {
            var texture = attachment.texture._texture;
            var tw = Math.max(1, texture.width);
            var th = Math.max(1, texture.height);
            check$1(tw === width && th === height, "inconsistent width/height for supplied texture");
            texture.refCount += 1;
          } else {
            var renderbuffer = attachment.renderbuffer._renderbuffer;
            check$1(renderbuffer.width === width && renderbuffer.height === height, "inconsistent width/height for renderbuffer");
            renderbuffer.refCount += 1;
          }
        }
        function attach(location, attachment) {
          if (attachment) {
            if (attachment.texture) {
              gl2.framebufferTexture2D(GL_FRAMEBUFFER$1, location, attachment.target, attachment.texture._texture.texture, 0);
            } else {
              gl2.framebufferRenderbuffer(GL_FRAMEBUFFER$1, location, GL_RENDERBUFFER$1, attachment.renderbuffer._renderbuffer.renderbuffer);
            }
          }
        }
        function parseAttachment(attachment) {
          var target = GL_TEXTURE_2D$2;
          var texture = null;
          var renderbuffer = null;
          var data = attachment;
          if (typeof attachment === "object") {
            data = attachment.data;
            if ("target" in attachment) {
              target = attachment.target | 0;
            }
          }
          check$1.type(data, "function", "invalid attachment data");
          var type = data._reglType;
          if (type === "texture2d") {
            texture = data;
            check$1(target === GL_TEXTURE_2D$2);
          } else if (type === "textureCube") {
            texture = data;
            check$1(target >= GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 && target < GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + 6, "invalid cube map target");
          } else if (type === "renderbuffer") {
            renderbuffer = data;
            target = GL_RENDERBUFFER$1;
          } else {
            check$1.raise("invalid regl object for attachment");
          }
          return new FramebufferAttachment(target, texture, renderbuffer);
        }
        function allocAttachment(width, height, isTexture, format2, type) {
          if (isTexture) {
            var texture = textureState.create2D({
              width,
              height,
              format: format2,
              type
            });
            texture._texture.refCount = 0;
            return new FramebufferAttachment(GL_TEXTURE_2D$2, texture, null);
          } else {
            var rb = renderbufferState.create({
              width,
              height,
              format: format2
            });
            rb._renderbuffer.refCount = 0;
            return new FramebufferAttachment(GL_RENDERBUFFER$1, null, rb);
          }
        }
        function unwrapAttachment(attachment) {
          return attachment && (attachment.texture || attachment.renderbuffer);
        }
        function resizeAttachment(attachment, w2, h2) {
          if (attachment) {
            if (attachment.texture) {
              attachment.texture.resize(w2, h2);
            } else if (attachment.renderbuffer) {
              attachment.renderbuffer.resize(w2, h2);
            }
            attachment.width = w2;
            attachment.height = h2;
          }
        }
        var framebufferCount = 0;
        var framebufferSet = {};
        function REGLFramebuffer() {
          this.id = framebufferCount++;
          framebufferSet[this.id] = this;
          this.framebuffer = gl2.createFramebuffer();
          this.width = 0;
          this.height = 0;
          this.colorAttachments = [];
          this.depthAttachment = null;
          this.stencilAttachment = null;
          this.depthStencilAttachment = null;
        }
        function decFBORefs(framebuffer) {
          framebuffer.colorAttachments.forEach(decRef);
          decRef(framebuffer.depthAttachment);
          decRef(framebuffer.stencilAttachment);
          decRef(framebuffer.depthStencilAttachment);
        }
        function destroy(framebuffer) {
          var handle = framebuffer.framebuffer;
          check$1(handle, "must not double destroy framebuffer");
          gl2.deleteFramebuffer(handle);
          framebuffer.framebuffer = null;
          stats2.framebufferCount--;
          delete framebufferSet[framebuffer.id];
        }
        function updateFramebuffer(framebuffer) {
          var i2;
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebuffer.framebuffer);
          var colorAttachments = framebuffer.colorAttachments;
          for (i2 = 0; i2 < colorAttachments.length; ++i2) {
            attach(GL_COLOR_ATTACHMENT0$1 + i2, colorAttachments[i2]);
          }
          for (i2 = colorAttachments.length; i2 < limits.maxColorAttachments; ++i2) {
            gl2.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_COLOR_ATTACHMENT0$1 + i2, GL_TEXTURE_2D$2, null, 0);
          }
          gl2.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);
          gl2.framebufferTexture2D(GL_FRAMEBUFFER$1, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D$2, null, 0);
          attach(GL_DEPTH_ATTACHMENT, framebuffer.depthAttachment);
          attach(GL_STENCIL_ATTACHMENT, framebuffer.stencilAttachment);
          attach(GL_DEPTH_STENCIL_ATTACHMENT, framebuffer.depthStencilAttachment);
          var status = gl2.checkFramebufferStatus(GL_FRAMEBUFFER$1);
          if (!gl2.isContextLost() && status !== GL_FRAMEBUFFER_COMPLETE$1) {
            check$1.raise("framebuffer configuration not supported, status = " + statusCode[status]);
          }
          gl2.bindFramebuffer(GL_FRAMEBUFFER$1, framebufferState.next ? framebufferState.next.framebuffer : null);
          framebufferState.cur = framebufferState.next;
          gl2.getError();
        }
        function createFBO(a0, a1) {
          var framebuffer = new REGLFramebuffer();
          stats2.framebufferCount++;
          function reglFramebuffer(a2, b10) {
            var i2;
            check$1(framebufferState.next !== framebuffer, "can not update framebuffer which is currently in use");
            var width = 0;
            var height = 0;
            var needsDepth = true;
            var needsStencil = true;
            var colorBuffer = null;
            var colorTexture = true;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            var depthBuffer = null;
            var stencilBuffer = null;
            var depthStencilBuffer = null;
            var depthStencilTexture = false;
            if (typeof a2 === "number") {
              width = a2 | 0;
              height = b10 | 0 || width;
            } else if (!a2) {
              width = height = 1;
            } else {
              check$1.type(a2, "object", "invalid arguments for framebuffer");
              var options = a2;
              if ("shape" in options) {
                var shape = options.shape;
                check$1(Array.isArray(shape) && shape.length >= 2, "invalid shape for framebuffer");
                width = shape[0];
                height = shape[1];
              } else {
                if ("radius" in options) {
                  width = height = options.radius;
                }
                if ("width" in options) {
                  width = options.width;
                }
                if ("height" in options) {
                  height = options.height;
                }
              }
              if ("color" in options || "colors" in options) {
                colorBuffer = options.color || options.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(colorBuffer.length === 1 || extensions.webgl_draw_buffers, "multiple render targets not supported");
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options) {
                  colorCount = options.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorTexture" in options) {
                  colorTexture = !!options.colorTexture;
                  colorFormat = "rgba4";
                }
                if ("colorType" in options) {
                  colorType = options.colorType;
                  if (!colorTexture) {
                    if (colorType === "half float" || colorType === "float16") {
                      check$1(extensions.ext_color_buffer_half_float, "you must enable EXT_color_buffer_half_float to use 16-bit render buffers");
                      colorFormat = "rgba16f";
                    } else if (colorType === "float" || colorType === "float32") {
                      check$1(extensions.webgl_color_buffer_float, "you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers");
                      colorFormat = "rgba32f";
                    }
                  } else {
                    check$1(extensions.oes_texture_float || !(colorType === "float" || colorType === "float32"), "you must enable OES_texture_float in order to use floating point framebuffer objects");
                    check$1(extensions.oes_texture_half_float || !(colorType === "half float" || colorType === "float16"), "you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects");
                  }
                  check$1.oneOf(colorType, colorTypes, "invalid color type");
                }
                if ("colorFormat" in options) {
                  colorFormat = options.colorFormat;
                  if (colorTextureFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = true;
                  } else if (colorRenderbufferFormats.indexOf(colorFormat) >= 0) {
                    colorTexture = false;
                  } else {
                    if (colorTexture) {
                      check$1.oneOf(options.colorFormat, colorTextureFormats, "invalid color format for texture");
                    } else {
                      check$1.oneOf(options.colorFormat, colorRenderbufferFormats, "invalid color format for renderbuffer");
                    }
                  }
                }
              }
              if ("depthTexture" in options || "depthStencilTexture" in options) {
                depthStencilTexture = !!(options.depthTexture || options.depthStencilTexture);
                check$1(!depthStencilTexture || extensions.webgl_depth_texture, "webgl_depth_texture extension not supported");
              }
              if ("depth" in options) {
                if (typeof options.depth === "boolean") {
                  needsDepth = options.depth;
                } else {
                  depthBuffer = options.depth;
                  needsStencil = false;
                }
              }
              if ("stencil" in options) {
                if (typeof options.stencil === "boolean") {
                  needsStencil = options.stencil;
                } else {
                  stencilBuffer = options.stencil;
                  needsDepth = false;
                }
              }
              if ("depthStencil" in options) {
                if (typeof options.depthStencil === "boolean") {
                  needsDepth = needsStencil = options.depthStencil;
                } else {
                  depthStencilBuffer = options.depthStencil;
                  needsDepth = false;
                  needsStencil = false;
                }
              }
            }
            var colorAttachments = null;
            var depthAttachment = null;
            var stencilAttachment = null;
            var depthStencilAttachment = null;
            if (Array.isArray(colorBuffer)) {
              colorAttachments = colorBuffer.map(parseAttachment);
            } else if (colorBuffer) {
              colorAttachments = [parseAttachment(colorBuffer)];
            } else {
              colorAttachments = new Array(colorCount);
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorAttachments[i2] = allocAttachment(width, height, colorTexture, colorFormat, colorType);
              }
            }
            check$1(extensions.webgl_draw_buffers || colorAttachments.length <= 1, "you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers.");
            check$1(colorAttachments.length <= limits.maxColorAttachments, "too many color attachments, not supported");
            width = width || colorAttachments[0].width;
            height = height || colorAttachments[0].height;
            if (depthBuffer) {
              depthAttachment = parseAttachment(depthBuffer);
            } else if (needsDepth && !needsStencil) {
              depthAttachment = allocAttachment(width, height, depthStencilTexture, "depth", "uint32");
            }
            if (stencilBuffer) {
              stencilAttachment = parseAttachment(stencilBuffer);
            } else if (needsStencil && !needsDepth) {
              stencilAttachment = allocAttachment(width, height, false, "stencil", "uint8");
            }
            if (depthStencilBuffer) {
              depthStencilAttachment = parseAttachment(depthStencilBuffer);
            } else if (!depthBuffer && !stencilBuffer && needsStencil && needsDepth) {
              depthStencilAttachment = allocAttachment(width, height, depthStencilTexture, "depth stencil", "depth stencil");
            }
            check$1(!!depthBuffer + !!stencilBuffer + !!depthStencilBuffer <= 1, "invalid framebuffer configuration, can specify exactly one depth/stencil attachment");
            var commonColorAttachmentSize = null;
            for (i2 = 0; i2 < colorAttachments.length; ++i2) {
              incRefAndCheckShape(colorAttachments[i2], width, height);
              check$1(!colorAttachments[i2] || colorAttachments[i2].texture && colorTextureFormatEnums.indexOf(colorAttachments[i2].texture._texture.format) >= 0 || colorAttachments[i2].renderbuffer && colorRenderbufferFormatEnums.indexOf(colorAttachments[i2].renderbuffer._renderbuffer.format) >= 0, "framebuffer color attachment " + i2 + " is invalid");
              if (colorAttachments[i2] && colorAttachments[i2].texture) {
                var colorAttachmentSize = textureFormatChannels[colorAttachments[i2].texture._texture.format] * textureTypeSizes[colorAttachments[i2].texture._texture.type];
                if (commonColorAttachmentSize === null) {
                  commonColorAttachmentSize = colorAttachmentSize;
                } else {
                  check$1(commonColorAttachmentSize === colorAttachmentSize, "all color attachments much have the same number of bits per pixel.");
                }
              }
            }
            incRefAndCheckShape(depthAttachment, width, height);
            check$1(!depthAttachment || depthAttachment.texture && depthAttachment.texture._texture.format === GL_DEPTH_COMPONENT$1 || depthAttachment.renderbuffer && depthAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_COMPONENT16$1, "invalid depth attachment for framebuffer object");
            incRefAndCheckShape(stencilAttachment, width, height);
            check$1(!stencilAttachment || stencilAttachment.renderbuffer && stencilAttachment.renderbuffer._renderbuffer.format === GL_STENCIL_INDEX8$1, "invalid stencil attachment for framebuffer object");
            incRefAndCheckShape(depthStencilAttachment, width, height);
            check$1(!depthStencilAttachment || depthStencilAttachment.texture && depthStencilAttachment.texture._texture.format === GL_DEPTH_STENCIL$2 || depthStencilAttachment.renderbuffer && depthStencilAttachment.renderbuffer._renderbuffer.format === GL_DEPTH_STENCIL$2, "invalid depth-stencil attachment for framebuffer object");
            decFBORefs(framebuffer);
            framebuffer.width = width;
            framebuffer.height = height;
            framebuffer.colorAttachments = colorAttachments;
            framebuffer.depthAttachment = depthAttachment;
            framebuffer.stencilAttachment = stencilAttachment;
            framebuffer.depthStencilAttachment = depthStencilAttachment;
            reglFramebuffer.color = colorAttachments.map(unwrapAttachment);
            reglFramebuffer.depth = unwrapAttachment(depthAttachment);
            reglFramebuffer.stencil = unwrapAttachment(stencilAttachment);
            reglFramebuffer.depthStencil = unwrapAttachment(depthStencilAttachment);
            reglFramebuffer.width = framebuffer.width;
            reglFramebuffer.height = framebuffer.height;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          function resize(w_, h_) {
            check$1(framebufferState.next !== framebuffer, "can not resize a framebuffer which is currently in use");
            var w2 = Math.max(w_ | 0, 1);
            var h2 = Math.max(h_ | 0 || w2, 1);
            if (w2 === framebuffer.width && h2 === framebuffer.height) {
              return reglFramebuffer;
            }
            var colorAttachments = framebuffer.colorAttachments;
            for (var i2 = 0; i2 < colorAttachments.length; ++i2) {
              resizeAttachment(colorAttachments[i2], w2, h2);
            }
            resizeAttachment(framebuffer.depthAttachment, w2, h2);
            resizeAttachment(framebuffer.stencilAttachment, w2, h2);
            resizeAttachment(framebuffer.depthStencilAttachment, w2, h2);
            framebuffer.width = reglFramebuffer.width = w2;
            framebuffer.height = reglFramebuffer.height = h2;
            updateFramebuffer(framebuffer);
            return reglFramebuffer;
          }
          reglFramebuffer(a0, a1);
          return extend3(reglFramebuffer, {
            resize,
            _reglType: "framebuffer",
            _framebuffer: framebuffer,
            destroy: function() {
              destroy(framebuffer);
              decFBORefs(framebuffer);
            },
            use: function(block) {
              framebufferState.setFBO({
                framebuffer: reglFramebuffer
              }, block);
            }
          });
        }
        function createCubeFBO(options) {
          var faces = Array(6);
          function reglFramebufferCube(a2) {
            var i2;
            check$1(faces.indexOf(framebufferState.next) < 0, "can not update framebuffer which is currently in use");
            var params = {
              color: null
            };
            var radius = 0;
            var colorBuffer = null;
            var colorFormat = "rgba";
            var colorType = "uint8";
            var colorCount = 1;
            if (typeof a2 === "number") {
              radius = a2 | 0;
            } else if (!a2) {
              radius = 1;
            } else {
              check$1.type(a2, "object", "invalid arguments for framebuffer");
              var options2 = a2;
              if ("shape" in options2) {
                var shape = options2.shape;
                check$1(Array.isArray(shape) && shape.length >= 2, "invalid shape for framebuffer");
                check$1(shape[0] === shape[1], "cube framebuffer must be square");
                radius = shape[0];
              } else {
                if ("radius" in options2) {
                  radius = options2.radius | 0;
                }
                if ("width" in options2) {
                  radius = options2.width | 0;
                  if ("height" in options2) {
                    check$1(options2.height === radius, "must be square");
                  }
                } else if ("height" in options2) {
                  radius = options2.height | 0;
                }
              }
              if ("color" in options2 || "colors" in options2) {
                colorBuffer = options2.color || options2.colors;
                if (Array.isArray(colorBuffer)) {
                  check$1(colorBuffer.length === 1 || extensions.webgl_draw_buffers, "multiple render targets not supported");
                }
              }
              if (!colorBuffer) {
                if ("colorCount" in options2) {
                  colorCount = options2.colorCount | 0;
                  check$1(colorCount > 0, "invalid color buffer count");
                }
                if ("colorType" in options2) {
                  check$1.oneOf(options2.colorType, colorTypes, "invalid color type");
                  colorType = options2.colorType;
                }
                if ("colorFormat" in options2) {
                  colorFormat = options2.colorFormat;
                  check$1.oneOf(options2.colorFormat, colorTextureFormats, "invalid color format for texture");
                }
              }
              if ("depth" in options2) {
                params.depth = options2.depth;
              }
              if ("stencil" in options2) {
                params.stencil = options2.stencil;
              }
              if ("depthStencil" in options2) {
                params.depthStencil = options2.depthStencil;
              }
            }
            var colorCubes;
            if (colorBuffer) {
              if (Array.isArray(colorBuffer)) {
                colorCubes = [];
                for (i2 = 0; i2 < colorBuffer.length; ++i2) {
                  colorCubes[i2] = colorBuffer[i2];
                }
              } else {
                colorCubes = [colorBuffer];
              }
            } else {
              colorCubes = Array(colorCount);
              var cubeMapParams = {
                radius,
                format: colorFormat,
                type: colorType
              };
              for (i2 = 0; i2 < colorCount; ++i2) {
                colorCubes[i2] = textureState.createCube(cubeMapParams);
              }
            }
            params.color = Array(colorCubes.length);
            for (i2 = 0; i2 < colorCubes.length; ++i2) {
              var cube = colorCubes[i2];
              check$1(typeof cube === "function" && cube._reglType === "textureCube", "invalid cube map");
              radius = radius || cube.width;
              check$1(cube.width === radius && cube.height === radius, "invalid cube map shape");
              params.color[i2] = {
                target: GL_TEXTURE_CUBE_MAP_POSITIVE_X$2,
                data: colorCubes[i2]
              };
            }
            for (i2 = 0; i2 < 6; ++i2) {
              for (var j2 = 0; j2 < colorCubes.length; ++j2) {
                params.color[j2].target = GL_TEXTURE_CUBE_MAP_POSITIVE_X$2 + i2;
              }
              if (i2 > 0) {
                params.depth = faces[0].depth;
                params.stencil = faces[0].stencil;
                params.depthStencil = faces[0].depthStencil;
              }
              if (faces[i2]) {
                faces[i2](params);
              } else {
                faces[i2] = createFBO(params);
              }
            }
            return extend3(reglFramebufferCube, {
              width: radius,
              height: radius,
              color: colorCubes
            });
          }
          function resize(radius_) {
            var i2;
            var radius = radius_ | 0;
            check$1(radius > 0 && radius <= limits.maxCubeMapSize, "invalid radius for cube fbo");
            if (radius === reglFramebufferCube.width) {
              return reglFramebufferCube;
            }
            var colors = reglFramebufferCube.color;
            for (i2 = 0; i2 < colors.length; ++i2) {
              colors[i2].resize(radius);
            }
            for (i2 = 0; i2 < 6; ++i2) {
              faces[i2].resize(radius);
            }
            reglFramebufferCube.width = reglFramebufferCube.height = radius;
            return reglFramebufferCube;
          }
          reglFramebufferCube(options);
          return extend3(reglFramebufferCube, {
            faces,
            resize,
            _reglType: "framebufferCube",
            destroy: function() {
              faces.forEach(function(f2) {
                f2.destroy();
              });
            }
          });
        }
        function restoreFramebuffers() {
          framebufferState.cur = null;
          framebufferState.next = null;
          framebufferState.dirty = true;
          values2(framebufferSet).forEach(function(fb) {
            fb.framebuffer = gl2.createFramebuffer();
            updateFramebuffer(fb);
          });
        }
        return extend3(framebufferState, {
          getFramebuffer: function(object) {
            if (typeof object === "function" && object._reglType === "framebuffer") {
              var fbo = object._framebuffer;
              if (fbo instanceof REGLFramebuffer) {
                return fbo;
              }
            }
            return null;
          },
          create: createFBO,
          createCube: createCubeFBO,
          clear: function() {
            values2(framebufferSet).forEach(destroy);
          },
          restore: restoreFramebuffers
        });
      }
      var GL_FLOAT$6 = 5126;
      var GL_ARRAY_BUFFER$1 = 34962;
      function AttributeRecord() {
        this.state = 0;
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
        this.buffer = null;
        this.size = 0;
        this.normalized = false;
        this.type = GL_FLOAT$6;
        this.offset = 0;
        this.stride = 0;
        this.divisor = 0;
      }
      function wrapAttributeState(gl2, extensions, limits, stats2, bufferState) {
        var NUM_ATTRIBUTES = limits.maxAttributes;
        var attributeBindings = new Array(NUM_ATTRIBUTES);
        for (var i2 = 0; i2 < NUM_ATTRIBUTES; ++i2) {
          attributeBindings[i2] = new AttributeRecord();
        }
        var vaoCount = 0;
        var vaoSet = {};
        var state = {
          Record: AttributeRecord,
          scope: {},
          state: attributeBindings,
          currentVAO: null,
          targetVAO: null,
          restore: extVAO() ? restoreVAO : function() {
          },
          createVAO,
          getVAO,
          destroyBuffer,
          setVAO: extVAO() ? setVAOEXT : setVAOEmulated,
          clear: extVAO() ? destroyVAOEXT : function() {
          }
        };
        function destroyBuffer(buffer) {
          for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
            var record = attributeBindings[i3];
            if (record.buffer === buffer) {
              gl2.disableVertexAttribArray(i3);
              record.buffer = null;
            }
          }
        }
        function extVAO() {
          return extensions.oes_vertex_array_object;
        }
        function extInstanced() {
          return extensions.angle_instanced_arrays;
        }
        function getVAO(vao) {
          if (typeof vao === "function" && vao._vao) {
            return vao._vao;
          }
          return null;
        }
        function setVAOEXT(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          var ext = extVAO();
          if (vao) {
            ext.bindVertexArrayOES(vao.vao);
          } else {
            ext.bindVertexArrayOES(null);
          }
          state.currentVAO = vao;
        }
        function setVAOEmulated(vao) {
          if (vao === state.currentVAO) {
            return;
          }
          if (vao) {
            vao.bindAttrs();
          } else {
            var exti = extInstanced();
            for (var i3 = 0; i3 < attributeBindings.length; ++i3) {
              var binding = attributeBindings[i3];
              if (binding.buffer) {
                gl2.enableVertexAttribArray(i3);
                gl2.vertexAttribPointer(i3, binding.size, binding.type, binding.normalized, binding.stride, binding.offfset);
                if (exti && binding.divisor) {
                  exti.vertexAttribDivisorANGLE(i3, binding.divisor);
                }
              } else {
                gl2.disableVertexAttribArray(i3);
                gl2.vertexAttrib4f(i3, binding.x, binding.y, binding.z, binding.w);
              }
            }
          }
          state.currentVAO = vao;
        }
        function destroyVAOEXT() {
          values2(vaoSet).forEach(function(vao) {
            vao.destroy();
          });
        }
        function REGLVAO() {
          this.id = ++vaoCount;
          this.attributes = [];
          var extension = extVAO();
          if (extension) {
            this.vao = extension.createVertexArrayOES();
          } else {
            this.vao = null;
          }
          vaoSet[this.id] = this;
          this.buffers = [];
        }
        REGLVAO.prototype.bindAttrs = function() {
          var exti = extInstanced();
          var attributes = this.attributes;
          for (var i3 = 0; i3 < attributes.length; ++i3) {
            var attr = attributes[i3];
            if (attr.buffer) {
              gl2.enableVertexAttribArray(i3);
              gl2.bindBuffer(GL_ARRAY_BUFFER$1, attr.buffer.buffer);
              gl2.vertexAttribPointer(i3, attr.size, attr.type, attr.normalized, attr.stride, attr.offset);
              if (exti && attr.divisor) {
                exti.vertexAttribDivisorANGLE(i3, attr.divisor);
              }
            } else {
              gl2.disableVertexAttribArray(i3);
              gl2.vertexAttrib4f(i3, attr.x, attr.y, attr.z, attr.w);
            }
          }
          for (var j2 = attributes.length; j2 < NUM_ATTRIBUTES; ++j2) {
            gl2.disableVertexAttribArray(j2);
          }
        };
        REGLVAO.prototype.refresh = function() {
          var ext = extVAO();
          if (ext) {
            ext.bindVertexArrayOES(this.vao);
            this.bindAttrs();
            state.currentVAO = this;
          }
        };
        REGLVAO.prototype.destroy = function() {
          if (this.vao) {
            var extension = extVAO();
            if (this === state.currentVAO) {
              state.currentVAO = null;
              extension.bindVertexArrayOES(null);
            }
            extension.deleteVertexArrayOES(this.vao);
            this.vao = null;
          }
          if (vaoSet[this.id]) {
            delete vaoSet[this.id];
            stats2.vaoCount -= 1;
          }
        };
        function restoreVAO() {
          var ext = extVAO();
          if (ext) {
            values2(vaoSet).forEach(function(vao) {
              vao.refresh();
            });
          }
        }
        function createVAO(_attr) {
          var vao = new REGLVAO();
          stats2.vaoCount += 1;
          function updateVAO(attributes) {
            check$1(Array.isArray(attributes), "arguments to vertex array constructor must be an array");
            check$1(attributes.length < NUM_ATTRIBUTES, "too many attributes");
            check$1(attributes.length > 0, "must specify at least one attribute");
            var bufUpdated = {};
            var nattributes = vao.attributes;
            nattributes.length = attributes.length;
            for (var i3 = 0; i3 < attributes.length; ++i3) {
              var spec = attributes[i3];
              var rec = nattributes[i3] = new AttributeRecord();
              var data = spec.data || spec;
              if (Array.isArray(data) || isTypedArray4(data) || isNDArrayLike(data)) {
                var buf;
                if (vao.buffers[i3]) {
                  buf = vao.buffers[i3];
                  if (isTypedArray4(data) && buf._buffer.byteLength >= data.byteLength) {
                    buf.subdata(data);
                  } else {
                    buf.destroy();
                    vao.buffers[i3] = null;
                  }
                }
                if (!vao.buffers[i3]) {
                  buf = vao.buffers[i3] = bufferState.create(spec, GL_ARRAY_BUFFER$1, false, true);
                }
                rec.buffer = bufferState.getBuffer(buf);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
                bufUpdated[i3] = 1;
              } else if (bufferState.getBuffer(spec)) {
                rec.buffer = bufferState.getBuffer(spec);
                rec.size = rec.buffer.dimension | 0;
                rec.normalized = false;
                rec.type = rec.buffer.dtype;
                rec.offset = 0;
                rec.stride = 0;
                rec.divisor = 0;
                rec.state = 1;
              } else if (bufferState.getBuffer(spec.buffer)) {
                rec.buffer = bufferState.getBuffer(spec.buffer);
                rec.size = (+spec.size || rec.buffer.dimension) | 0;
                rec.normalized = !!spec.normalized || false;
                if ("type" in spec) {
                  check$1.parameter(spec.type, glTypes, "invalid buffer type");
                  rec.type = glTypes[spec.type];
                } else {
                  rec.type = rec.buffer.dtype;
                }
                rec.offset = (spec.offset || 0) | 0;
                rec.stride = (spec.stride || 0) | 0;
                rec.divisor = (spec.divisor || 0) | 0;
                rec.state = 1;
                check$1(rec.size >= 1 && rec.size <= 4, "size must be between 1 and 4");
                check$1(rec.offset >= 0, "invalid offset");
                check$1(rec.stride >= 0 && rec.stride <= 255, "stride must be between 0 and 255");
                check$1(rec.divisor >= 0, "divisor must be positive");
                check$1(!rec.divisor || !!extensions.angle_instanced_arrays, "ANGLE_instanced_arrays must be enabled to use divisor");
              } else if ("x" in spec) {
                check$1(i3 > 0, "first attribute must not be a constant");
                rec.x = +spec.x || 0;
                rec.y = +spec.y || 0;
                rec.z = +spec.z || 0;
                rec.w = +spec.w || 0;
                rec.state = 2;
              } else {
                check$1(false, "invalid attribute spec for location " + i3);
              }
            }
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (!bufUpdated[j2] && vao.buffers[j2]) {
                vao.buffers[j2].destroy();
                vao.buffers[j2] = null;
              }
            }
            vao.refresh();
            return updateVAO;
          }
          updateVAO.destroy = function() {
            for (var j2 = 0; j2 < vao.buffers.length; ++j2) {
              if (vao.buffers[j2]) {
                vao.buffers[j2].destroy();
              }
            }
            vao.buffers.length = 0;
            vao.destroy();
          };
          updateVAO._vao = vao;
          updateVAO._reglType = "vao";
          return updateVAO(_attr);
        }
        return state;
      }
      var GL_FRAGMENT_SHADER = 35632;
      var GL_VERTEX_SHADER = 35633;
      var GL_ACTIVE_UNIFORMS = 35718;
      var GL_ACTIVE_ATTRIBUTES = 35721;
      function wrapShaderState(gl2, stringStore, stats2, config) {
        var fragShaders = {};
        var vertShaders = {};
        function ActiveInfo(name, id2, location, info) {
          this.name = name;
          this.id = id2;
          this.location = location;
          this.info = info;
        }
        function insertActiveInfo(list, info) {
          for (var i2 = 0; i2 < list.length; ++i2) {
            if (list[i2].id === info.id) {
              list[i2].location = info.location;
              return;
            }
          }
          list.push(info);
        }
        function getShader(type, id2, command) {
          var cache3 = type === GL_FRAGMENT_SHADER ? fragShaders : vertShaders;
          var shader = cache3[id2];
          if (!shader) {
            var source = stringStore.str(id2);
            shader = gl2.createShader(type);
            gl2.shaderSource(shader, source);
            gl2.compileShader(shader);
            check$1.shaderError(gl2, shader, source, type, command);
            cache3[id2] = shader;
          }
          return shader;
        }
        var programCache = {};
        var programList = [];
        var PROGRAM_COUNTER = 0;
        function REGLProgram(fragId, vertId) {
          this.id = PROGRAM_COUNTER++;
          this.fragId = fragId;
          this.vertId = vertId;
          this.program = null;
          this.uniforms = [];
          this.attributes = [];
          this.refCount = 1;
          if (config.profile) {
            this.stats = {
              uniformsCount: 0,
              attributesCount: 0
            };
          }
        }
        function linkProgram(desc, command, attributeLocations) {
          var i2, info;
          var fragShader = getShader(GL_FRAGMENT_SHADER, desc.fragId);
          var vertShader = getShader(GL_VERTEX_SHADER, desc.vertId);
          var program = desc.program = gl2.createProgram();
          gl2.attachShader(program, fragShader);
          gl2.attachShader(program, vertShader);
          if (attributeLocations) {
            for (i2 = 0; i2 < attributeLocations.length; ++i2) {
              var binding = attributeLocations[i2];
              gl2.bindAttribLocation(program, binding[0], binding[1]);
            }
          }
          gl2.linkProgram(program);
          check$1.linkError(gl2, program, stringStore.str(desc.fragId), stringStore.str(desc.vertId), command);
          var numUniforms = gl2.getProgramParameter(program, GL_ACTIVE_UNIFORMS);
          if (config.profile) {
            desc.stats.uniformsCount = numUniforms;
          }
          var uniforms = desc.uniforms;
          for (i2 = 0; i2 < numUniforms; ++i2) {
            info = gl2.getActiveUniform(program, i2);
            if (info) {
              if (info.size > 1) {
                for (var j2 = 0; j2 < info.size; ++j2) {
                  var name = info.name.replace("[0]", "[" + j2 + "]");
                  insertActiveInfo(uniforms, new ActiveInfo(name, stringStore.id(name), gl2.getUniformLocation(program, name), info));
                }
              } else {
                insertActiveInfo(uniforms, new ActiveInfo(info.name, stringStore.id(info.name), gl2.getUniformLocation(program, info.name), info));
              }
            }
          }
          var numAttributes = gl2.getProgramParameter(program, GL_ACTIVE_ATTRIBUTES);
          if (config.profile) {
            desc.stats.attributesCount = numAttributes;
          }
          var attributes = desc.attributes;
          for (i2 = 0; i2 < numAttributes; ++i2) {
            info = gl2.getActiveAttrib(program, i2);
            if (info) {
              insertActiveInfo(attributes, new ActiveInfo(info.name, stringStore.id(info.name), gl2.getAttribLocation(program, info.name), info));
            }
          }
        }
        if (config.profile) {
          stats2.getMaxUniformsCount = function() {
            var m2 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.uniformsCount > m2) {
                m2 = desc.stats.uniformsCount;
              }
            });
            return m2;
          };
          stats2.getMaxAttributesCount = function() {
            var m2 = 0;
            programList.forEach(function(desc) {
              if (desc.stats.attributesCount > m2) {
                m2 = desc.stats.attributesCount;
              }
            });
            return m2;
          };
        }
        function restoreShaders() {
          fragShaders = {};
          vertShaders = {};
          for (var i2 = 0; i2 < programList.length; ++i2) {
            linkProgram(programList[i2], null, programList[i2].attributes.map(function(info) {
              return [info.location, info.name];
            }));
          }
        }
        return {
          clear: function() {
            var deleteShader = gl2.deleteShader.bind(gl2);
            values2(fragShaders).forEach(deleteShader);
            fragShaders = {};
            values2(vertShaders).forEach(deleteShader);
            vertShaders = {};
            programList.forEach(function(desc) {
              gl2.deleteProgram(desc.program);
            });
            programList.length = 0;
            programCache = {};
            stats2.shaderCount = 0;
          },
          program: function(vertId, fragId, command, attribLocations) {
            check$1.command(vertId >= 0, "missing vertex shader", command);
            check$1.command(fragId >= 0, "missing fragment shader", command);
            var cache3 = programCache[fragId];
            if (!cache3) {
              cache3 = programCache[fragId] = {};
            }
            var prevProgram = cache3[vertId];
            if (prevProgram) {
              prevProgram.refCount++;
              if (!attribLocations) {
                return prevProgram;
              }
            }
            var program = new REGLProgram(fragId, vertId);
            stats2.shaderCount++;
            linkProgram(program, command, attribLocations);
            if (!prevProgram) {
              cache3[vertId] = program;
            }
            programList.push(program);
            return extend3(program, {
              destroy: function() {
                program.refCount--;
                if (program.refCount <= 0) {
                  gl2.deleteProgram(program.program);
                  var idx = programList.indexOf(program);
                  programList.splice(idx, 1);
                  stats2.shaderCount--;
                }
                if (cache3[program.vertId].refCount <= 0) {
                  gl2.deleteShader(vertShaders[program.vertId]);
                  delete vertShaders[program.vertId];
                  delete programCache[program.fragId][program.vertId];
                }
                if (!Object.keys(programCache[program.fragId]).length) {
                  gl2.deleteShader(fragShaders[program.fragId]);
                  delete fragShaders[program.fragId];
                  delete programCache[program.fragId];
                }
              }
            });
          },
          restore: restoreShaders,
          shader: getShader,
          frag: -1,
          vert: -1
        };
      }
      var GL_RGBA$3 = 6408;
      var GL_UNSIGNED_BYTE$7 = 5121;
      var GL_PACK_ALIGNMENT = 3333;
      var GL_FLOAT$7 = 5126;
      function wrapReadPixels(gl2, framebufferState, reglPoll, context, glAttributes, extensions, limits) {
        function readPixelsImpl(input) {
          var type;
          if (framebufferState.next === null) {
            check$1(glAttributes.preserveDrawingBuffer, 'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer');
            type = GL_UNSIGNED_BYTE$7;
          } else {
            check$1(framebufferState.next.colorAttachments[0].texture !== null, "You cannot read from a renderbuffer");
            type = framebufferState.next.colorAttachments[0].texture._texture.type;
            if (extensions.oes_texture_float) {
              check$1(type === GL_UNSIGNED_BYTE$7 || type === GL_FLOAT$7, "Reading from a framebuffer is only allowed for the types 'uint8' and 'float'");
              if (type === GL_FLOAT$7) {
                check$1(limits.readFloat, "Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float");
              }
            } else {
              check$1(type === GL_UNSIGNED_BYTE$7, "Reading from a framebuffer is only allowed for the type 'uint8'");
            }
          }
          var x2 = 0;
          var y2 = 0;
          var width = context.framebufferWidth;
          var height = context.framebufferHeight;
          var data = null;
          if (isTypedArray4(input)) {
            data = input;
          } else if (input) {
            check$1.type(input, "object", "invalid arguments to regl.read()");
            x2 = input.x | 0;
            y2 = input.y | 0;
            check$1(x2 >= 0 && x2 < context.framebufferWidth, "invalid x offset for regl.read");
            check$1(y2 >= 0 && y2 < context.framebufferHeight, "invalid y offset for regl.read");
            width = (input.width || context.framebufferWidth - x2) | 0;
            height = (input.height || context.framebufferHeight - y2) | 0;
            data = input.data || null;
          }
          if (data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              check$1(data instanceof Uint8Array, "buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'");
            } else if (type === GL_FLOAT$7) {
              check$1(data instanceof Float32Array, "buffer must be 'Float32Array' when reading from a framebuffer of type 'float'");
            }
          }
          check$1(width > 0 && width + x2 <= context.framebufferWidth, "invalid width for read pixels");
          check$1(height > 0 && height + y2 <= context.framebufferHeight, "invalid height for read pixels");
          reglPoll();
          var size2 = width * height * 4;
          if (!data) {
            if (type === GL_UNSIGNED_BYTE$7) {
              data = new Uint8Array(size2);
            } else if (type === GL_FLOAT$7) {
              data = data || new Float32Array(size2);
            }
          }
          check$1.isTypedArray(data, "data buffer for regl.read() must be a typedarray");
          check$1(data.byteLength >= size2, "data buffer for regl.read() too small");
          gl2.pixelStorei(GL_PACK_ALIGNMENT, 4);
          gl2.readPixels(x2, y2, width, height, GL_RGBA$3, type, data);
          return data;
        }
        function readPixelsFBO(options) {
          var result;
          framebufferState.setFBO({
            framebuffer: options.framebuffer
          }, function() {
            result = readPixelsImpl(options);
          });
          return result;
        }
        function readPixels(options) {
          if (!options || !("framebuffer" in options)) {
            return readPixelsImpl(options);
          } else {
            return readPixelsFBO(options);
          }
        }
        return readPixels;
      }
      function slice(x2) {
        return Array.prototype.slice.call(x2);
      }
      function join(x2) {
        return slice(x2).join("");
      }
      function createEnvironment() {
        var varCounter = 0;
        var linkedNames = [];
        var linkedValues = [];
        function link(value) {
          for (var i2 = 0; i2 < linkedValues.length; ++i2) {
            if (linkedValues[i2] === value) {
              return linkedNames[i2];
            }
          }
          var name = "g" + varCounter++;
          linkedNames.push(name);
          linkedValues.push(value);
          return name;
        }
        function block() {
          var code = [];
          function push() {
            code.push.apply(code, slice(arguments));
          }
          var vars = [];
          function def() {
            var name = "v" + varCounter++;
            vars.push(name);
            if (arguments.length > 0) {
              code.push(name, "=");
              code.push.apply(code, slice(arguments));
              code.push(";");
            }
            return name;
          }
          return extend3(push, {
            def,
            toString: function() {
              return join([
                vars.length > 0 ? "var " + vars.join(",") + ";" : "",
                join(code)
              ]);
            }
          });
        }
        function scope() {
          var entry = block();
          var exit = block();
          var entryToString = entry.toString;
          var exitToString = exit.toString;
          function save(object, prop) {
            exit(object, prop, "=", entry.def(object, prop), ";");
          }
          return extend3(function() {
            entry.apply(entry, slice(arguments));
          }, {
            def: entry.def,
            entry,
            exit,
            save,
            set: function(object, prop, value) {
              save(object, prop);
              entry(object, prop, "=", value, ";");
            },
            toString: function() {
              return entryToString() + exitToString();
            }
          });
        }
        function conditional() {
          var pred = join(arguments);
          var thenBlock = scope();
          var elseBlock = scope();
          var thenToString = thenBlock.toString;
          var elseToString = elseBlock.toString;
          return extend3(thenBlock, {
            then: function() {
              thenBlock.apply(thenBlock, slice(arguments));
              return this;
            },
            else: function() {
              elseBlock.apply(elseBlock, slice(arguments));
              return this;
            },
            toString: function() {
              var elseClause = elseToString();
              if (elseClause) {
                elseClause = "else{" + elseClause + "}";
              }
              return join([
                "if(",
                pred,
                "){",
                thenToString(),
                "}",
                elseClause
              ]);
            }
          });
        }
        var globalBlock = block();
        var procedures = {};
        function proc(name, count) {
          var args = [];
          function arg() {
            var name2 = "a" + args.length;
            args.push(name2);
            return name2;
          }
          count = count || 0;
          for (var i2 = 0; i2 < count; ++i2) {
            arg();
          }
          var body = scope();
          var bodyToString = body.toString;
          var result = procedures[name] = extend3(body, {
            arg,
            toString: function() {
              return join([
                "function(",
                args.join(),
                "){",
                bodyToString(),
                "}"
              ]);
            }
          });
          return result;
        }
        function compile() {
          var code = [
            '"use strict";',
            globalBlock,
            "return {"
          ];
          Object.keys(procedures).forEach(function(name) {
            code.push('"', name, '":', procedures[name].toString(), ",");
          });
          code.push("}");
          var src = join(code).replace(/;/g, ";\n").replace(/}/g, "}\n").replace(/{/g, "{\n");
          var proc2 = Function.apply(null, linkedNames.concat(src));
          return proc2.apply(null, linkedValues);
        }
        return {
          global: globalBlock,
          link,
          block,
          proc,
          scope,
          cond: conditional,
          compile
        };
      }
      var CUTE_COMPONENTS = "xyzw".split("");
      var GL_UNSIGNED_BYTE$8 = 5121;
      var ATTRIB_STATE_POINTER = 1;
      var ATTRIB_STATE_CONSTANT = 2;
      var DYN_FUNC$1 = 0;
      var DYN_PROP$1 = 1;
      var DYN_CONTEXT$1 = 2;
      var DYN_STATE$1 = 3;
      var DYN_THUNK = 4;
      var DYN_CONSTANT$1 = 5;
      var DYN_ARRAY$1 = 6;
      var S_DITHER = "dither";
      var S_BLEND_ENABLE = "blend.enable";
      var S_BLEND_COLOR = "blend.color";
      var S_BLEND_EQUATION = "blend.equation";
      var S_BLEND_FUNC = "blend.func";
      var S_DEPTH_ENABLE = "depth.enable";
      var S_DEPTH_FUNC = "depth.func";
      var S_DEPTH_RANGE = "depth.range";
      var S_DEPTH_MASK = "depth.mask";
      var S_COLOR_MASK = "colorMask";
      var S_CULL_ENABLE = "cull.enable";
      var S_CULL_FACE = "cull.face";
      var S_FRONT_FACE = "frontFace";
      var S_LINE_WIDTH = "lineWidth";
      var S_POLYGON_OFFSET_ENABLE = "polygonOffset.enable";
      var S_POLYGON_OFFSET_OFFSET = "polygonOffset.offset";
      var S_SAMPLE_ALPHA = "sample.alpha";
      var S_SAMPLE_ENABLE = "sample.enable";
      var S_SAMPLE_COVERAGE = "sample.coverage";
      var S_STENCIL_ENABLE = "stencil.enable";
      var S_STENCIL_MASK = "stencil.mask";
      var S_STENCIL_FUNC = "stencil.func";
      var S_STENCIL_OPFRONT = "stencil.opFront";
      var S_STENCIL_OPBACK = "stencil.opBack";
      var S_SCISSOR_ENABLE = "scissor.enable";
      var S_SCISSOR_BOX = "scissor.box";
      var S_VIEWPORT = "viewport";
      var S_PROFILE = "profile";
      var S_FRAMEBUFFER = "framebuffer";
      var S_VERT = "vert";
      var S_FRAG = "frag";
      var S_ELEMENTS = "elements";
      var S_PRIMITIVE = "primitive";
      var S_COUNT = "count";
      var S_OFFSET = "offset";
      var S_INSTANCES = "instances";
      var S_VAO = "vao";
      var SUFFIX_WIDTH = "Width";
      var SUFFIX_HEIGHT = "Height";
      var S_FRAMEBUFFER_WIDTH = S_FRAMEBUFFER + SUFFIX_WIDTH;
      var S_FRAMEBUFFER_HEIGHT = S_FRAMEBUFFER + SUFFIX_HEIGHT;
      var S_VIEWPORT_WIDTH = S_VIEWPORT + SUFFIX_WIDTH;
      var S_VIEWPORT_HEIGHT = S_VIEWPORT + SUFFIX_HEIGHT;
      var S_DRAWINGBUFFER = "drawingBuffer";
      var S_DRAWINGBUFFER_WIDTH = S_DRAWINGBUFFER + SUFFIX_WIDTH;
      var S_DRAWINGBUFFER_HEIGHT = S_DRAWINGBUFFER + SUFFIX_HEIGHT;
      var NESTED_OPTIONS = [
        S_BLEND_FUNC,
        S_BLEND_EQUATION,
        S_STENCIL_FUNC,
        S_STENCIL_OPFRONT,
        S_STENCIL_OPBACK,
        S_SAMPLE_COVERAGE,
        S_VIEWPORT,
        S_SCISSOR_BOX,
        S_POLYGON_OFFSET_OFFSET
      ];
      var GL_ARRAY_BUFFER$2 = 34962;
      var GL_ELEMENT_ARRAY_BUFFER$1 = 34963;
      var GL_FRAGMENT_SHADER$1 = 35632;
      var GL_VERTEX_SHADER$1 = 35633;
      var GL_TEXTURE_2D$3 = 3553;
      var GL_TEXTURE_CUBE_MAP$2 = 34067;
      var GL_CULL_FACE = 2884;
      var GL_BLEND = 3042;
      var GL_DITHER = 3024;
      var GL_STENCIL_TEST = 2960;
      var GL_DEPTH_TEST = 2929;
      var GL_SCISSOR_TEST = 3089;
      var GL_POLYGON_OFFSET_FILL = 32823;
      var GL_SAMPLE_ALPHA_TO_COVERAGE = 32926;
      var GL_SAMPLE_COVERAGE = 32928;
      var GL_FLOAT$8 = 5126;
      var GL_FLOAT_VEC2 = 35664;
      var GL_FLOAT_VEC3 = 35665;
      var GL_FLOAT_VEC4 = 35666;
      var GL_INT$3 = 5124;
      var GL_INT_VEC2 = 35667;
      var GL_INT_VEC3 = 35668;
      var GL_INT_VEC4 = 35669;
      var GL_BOOL = 35670;
      var GL_BOOL_VEC2 = 35671;
      var GL_BOOL_VEC3 = 35672;
      var GL_BOOL_VEC4 = 35673;
      var GL_FLOAT_MAT2 = 35674;
      var GL_FLOAT_MAT3 = 35675;
      var GL_FLOAT_MAT4 = 35676;
      var GL_SAMPLER_2D = 35678;
      var GL_SAMPLER_CUBE = 35680;
      var GL_TRIANGLES$1 = 4;
      var GL_FRONT = 1028;
      var GL_BACK = 1029;
      var GL_CW = 2304;
      var GL_CCW = 2305;
      var GL_MIN_EXT = 32775;
      var GL_MAX_EXT = 32776;
      var GL_ALWAYS = 519;
      var GL_KEEP = 7680;
      var GL_ZERO = 0;
      var GL_ONE = 1;
      var GL_FUNC_ADD = 32774;
      var GL_LESS = 513;
      var GL_FRAMEBUFFER$2 = 36160;
      var GL_COLOR_ATTACHMENT0$2 = 36064;
      var blendFuncs = {
        "0": 0,
        "1": 1,
        "zero": 0,
        "one": 1,
        "src color": 768,
        "one minus src color": 769,
        "src alpha": 770,
        "one minus src alpha": 771,
        "dst color": 774,
        "one minus dst color": 775,
        "dst alpha": 772,
        "one minus dst alpha": 773,
        "constant color": 32769,
        "one minus constant color": 32770,
        "constant alpha": 32771,
        "one minus constant alpha": 32772,
        "src alpha saturate": 776
      };
      var invalidBlendCombinations = [
        "constant color, constant alpha",
        "one minus constant color, constant alpha",
        "constant color, one minus constant alpha",
        "one minus constant color, one minus constant alpha",
        "constant alpha, constant color",
        "constant alpha, one minus constant color",
        "one minus constant alpha, constant color",
        "one minus constant alpha, one minus constant color"
      ];
      var compareFuncs = {
        "never": 512,
        "less": 513,
        "<": 513,
        "equal": 514,
        "=": 514,
        "==": 514,
        "===": 514,
        "lequal": 515,
        "<=": 515,
        "greater": 516,
        ">": 516,
        "notequal": 517,
        "!=": 517,
        "!==": 517,
        "gequal": 518,
        ">=": 518,
        "always": 519
      };
      var stencilOps = {
        "0": 0,
        "zero": 0,
        "keep": 7680,
        "replace": 7681,
        "increment": 7682,
        "decrement": 7683,
        "increment wrap": 34055,
        "decrement wrap": 34056,
        "invert": 5386
      };
      var shaderType = {
        "frag": GL_FRAGMENT_SHADER$1,
        "vert": GL_VERTEX_SHADER$1
      };
      var orientationType = {
        "cw": GL_CW,
        "ccw": GL_CCW
      };
      function isBufferArgs(x2) {
        return Array.isArray(x2) || isTypedArray4(x2) || isNDArrayLike(x2);
      }
      function sortState(state) {
        return state.sort(function(a2, b10) {
          if (a2 === S_VIEWPORT) {
            return -1;
          } else if (b10 === S_VIEWPORT) {
            return 1;
          }
          return a2 < b10 ? -1 : 1;
        });
      }
      function Declaration(thisDep, contextDep, propDep, append) {
        this.thisDep = thisDep;
        this.contextDep = contextDep;
        this.propDep = propDep;
        this.append = append;
      }
      function isStatic(decl) {
        return decl && !(decl.thisDep || decl.contextDep || decl.propDep);
      }
      function createStaticDecl(append) {
        return new Declaration(false, false, false, append);
      }
      function createDynamicDecl(dyn, append) {
        var type = dyn.type;
        if (type === DYN_FUNC$1) {
          var numArgs = dyn.data.length;
          return new Declaration(true, numArgs >= 1, numArgs >= 2, append);
        } else if (type === DYN_THUNK) {
          var data = dyn.data;
          return new Declaration(data.thisDep, data.contextDep, data.propDep, append);
        } else if (type === DYN_CONSTANT$1) {
          return new Declaration(false, false, false, append);
        } else if (type === DYN_ARRAY$1) {
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          for (var i2 = 0; i2 < dyn.data.length; ++i2) {
            var subDyn = dyn.data[i2];
            if (subDyn.type === DYN_PROP$1) {
              propDep = true;
            } else if (subDyn.type === DYN_CONTEXT$1) {
              contextDep = true;
            } else if (subDyn.type === DYN_STATE$1) {
              thisDep = true;
            } else if (subDyn.type === DYN_FUNC$1) {
              thisDep = true;
              var subArgs = subDyn.data;
              if (subArgs >= 1) {
                contextDep = true;
              }
              if (subArgs >= 2) {
                propDep = true;
              }
            } else if (subDyn.type === DYN_THUNK) {
              thisDep = thisDep || subDyn.data.thisDep;
              contextDep = contextDep || subDyn.data.contextDep;
              propDep = propDep || subDyn.data.propDep;
            }
          }
          return new Declaration(thisDep, contextDep, propDep, append);
        } else {
          return new Declaration(type === DYN_STATE$1, type === DYN_CONTEXT$1, type === DYN_PROP$1, append);
        }
      }
      var SCOPE_DECL = new Declaration(false, false, false, function() {
      });
      function reglCore(gl2, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer3, config) {
        var AttributeRecord2 = attributeState.Record;
        var blendEquations = {
          "add": 32774,
          "subtract": 32778,
          "reverse subtract": 32779
        };
        if (extensions.ext_blend_minmax) {
          blendEquations.min = GL_MIN_EXT;
          blendEquations.max = GL_MAX_EXT;
        }
        var extInstancing = extensions.angle_instanced_arrays;
        var extDrawBuffers = extensions.webgl_draw_buffers;
        var currentState = {
          dirty: true,
          profile: config.profile
        };
        var nextState = {};
        var GL_STATE_NAMES = [];
        var GL_FLAGS = {};
        var GL_VARIABLES = {};
        function propName(name) {
          return name.replace(".", "_");
        }
        function stateFlag(sname, cap, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          nextState[name] = currentState[name] = !!init;
          GL_FLAGS[name] = cap;
        }
        function stateVariable(sname, func, init) {
          var name = propName(sname);
          GL_STATE_NAMES.push(sname);
          if (Array.isArray(init)) {
            currentState[name] = init.slice();
            nextState[name] = init.slice();
          } else {
            currentState[name] = nextState[name] = init;
          }
          GL_VARIABLES[name] = func;
        }
        stateFlag(S_DITHER, GL_DITHER);
        stateFlag(S_BLEND_ENABLE, GL_BLEND);
        stateVariable(S_BLEND_COLOR, "blendColor", [0, 0, 0, 0]);
        stateVariable(S_BLEND_EQUATION, "blendEquationSeparate", [GL_FUNC_ADD, GL_FUNC_ADD]);
        stateVariable(S_BLEND_FUNC, "blendFuncSeparate", [GL_ONE, GL_ZERO, GL_ONE, GL_ZERO]);
        stateFlag(S_DEPTH_ENABLE, GL_DEPTH_TEST, true);
        stateVariable(S_DEPTH_FUNC, "depthFunc", GL_LESS);
        stateVariable(S_DEPTH_RANGE, "depthRange", [0, 1]);
        stateVariable(S_DEPTH_MASK, "depthMask", true);
        stateVariable(S_COLOR_MASK, S_COLOR_MASK, [true, true, true, true]);
        stateFlag(S_CULL_ENABLE, GL_CULL_FACE);
        stateVariable(S_CULL_FACE, "cullFace", GL_BACK);
        stateVariable(S_FRONT_FACE, S_FRONT_FACE, GL_CCW);
        stateVariable(S_LINE_WIDTH, S_LINE_WIDTH, 1);
        stateFlag(S_POLYGON_OFFSET_ENABLE, GL_POLYGON_OFFSET_FILL);
        stateVariable(S_POLYGON_OFFSET_OFFSET, "polygonOffset", [0, 0]);
        stateFlag(S_SAMPLE_ALPHA, GL_SAMPLE_ALPHA_TO_COVERAGE);
        stateFlag(S_SAMPLE_ENABLE, GL_SAMPLE_COVERAGE);
        stateVariable(S_SAMPLE_COVERAGE, "sampleCoverage", [1, false]);
        stateFlag(S_STENCIL_ENABLE, GL_STENCIL_TEST);
        stateVariable(S_STENCIL_MASK, "stencilMask", -1);
        stateVariable(S_STENCIL_FUNC, "stencilFunc", [GL_ALWAYS, 0, -1]);
        stateVariable(S_STENCIL_OPFRONT, "stencilOpSeparate", [GL_FRONT, GL_KEEP, GL_KEEP, GL_KEEP]);
        stateVariable(S_STENCIL_OPBACK, "stencilOpSeparate", [GL_BACK, GL_KEEP, GL_KEEP, GL_KEEP]);
        stateFlag(S_SCISSOR_ENABLE, GL_SCISSOR_TEST);
        stateVariable(S_SCISSOR_BOX, "scissor", [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]);
        stateVariable(S_VIEWPORT, S_VIEWPORT, [0, 0, gl2.drawingBufferWidth, gl2.drawingBufferHeight]);
        var sharedState = {
          gl: gl2,
          context: contextState,
          strings: stringStore,
          next: nextState,
          current: currentState,
          draw: drawState,
          elements: elementState,
          buffer: bufferState,
          shader: shaderState,
          attributes: attributeState.state,
          vao: attributeState,
          uniforms: uniformState,
          framebuffer: framebufferState,
          extensions,
          timer: timer3,
          isBufferArgs
        };
        var sharedConstants = {
          primTypes,
          compareFuncs,
          blendFuncs,
          blendEquations,
          stencilOps,
          glTypes,
          orientationType
        };
        check$1.optional(function() {
          sharedState.isArrayLike = isArrayLike2;
        });
        if (extDrawBuffers) {
          sharedConstants.backBuffer = [GL_BACK];
          sharedConstants.drawBuffer = loop(limits.maxDrawbuffers, function(i2) {
            if (i2 === 0) {
              return [0];
            }
            return loop(i2, function(j2) {
              return GL_COLOR_ATTACHMENT0$2 + j2;
            });
          });
        }
        var drawCallCounter = 0;
        function createREGLEnvironment() {
          var env = createEnvironment();
          var link = env.link;
          var global2 = env.global;
          env.id = drawCallCounter++;
          env.batchId = "0";
          var SHARED = link(sharedState);
          var shared = env.shared = {
            props: "a0"
          };
          Object.keys(sharedState).forEach(function(prop) {
            shared[prop] = global2.def(SHARED, ".", prop);
          });
          check$1.optional(function() {
            env.CHECK = link(check$1);
            env.commandStr = check$1.guessCommand();
            env.command = link(env.commandStr);
            env.assert = function(block, pred, message) {
              block("if(!(", pred, "))", this.CHECK, ".commandRaise(", link(message), ",", this.command, ");");
            };
            sharedConstants.invalidBlendCombinations = invalidBlendCombinations;
          });
          var nextVars = env.next = {};
          var currentVars = env.current = {};
          Object.keys(GL_VARIABLES).forEach(function(variable) {
            if (Array.isArray(currentState[variable])) {
              nextVars[variable] = global2.def(shared.next, ".", variable);
              currentVars[variable] = global2.def(shared.current, ".", variable);
            }
          });
          var constants = env.constants = {};
          Object.keys(sharedConstants).forEach(function(name) {
            constants[name] = global2.def(JSON.stringify(sharedConstants[name]));
          });
          env.invoke = function(block, x2) {
            switch (x2.type) {
              case DYN_FUNC$1:
                var argList = [
                  "this",
                  shared.context,
                  shared.props,
                  env.batchId
                ];
                return block.def(link(x2.data), ".call(", argList.slice(0, Math.max(x2.data.length + 1, 4)), ")");
              case DYN_PROP$1:
                return block.def(shared.props, x2.data);
              case DYN_CONTEXT$1:
                return block.def(shared.context, x2.data);
              case DYN_STATE$1:
                return block.def("this", x2.data);
              case DYN_THUNK:
                x2.data.append(env, block);
                return x2.data.ref;
              case DYN_CONSTANT$1:
                return x2.data.toString();
              case DYN_ARRAY$1:
                return x2.data.map(function(y2) {
                  return env.invoke(block, y2);
                });
            }
          };
          env.attribCache = {};
          var scopeAttribs = {};
          env.scopeAttrib = function(name) {
            var id2 = stringStore.id(name);
            if (id2 in scopeAttribs) {
              return scopeAttribs[id2];
            }
            var binding = attributeState.scope[id2];
            if (!binding) {
              binding = attributeState.scope[id2] = new AttributeRecord2();
            }
            var result = scopeAttribs[id2] = link(binding);
            return result;
          };
          return env;
        }
        function parseProfile(options) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var profileEnable;
          if (S_PROFILE in staticOptions) {
            var value = !!staticOptions[S_PROFILE];
            profileEnable = createStaticDecl(function(env, scope) {
              return value;
            });
            profileEnable.enable = value;
          } else if (S_PROFILE in dynamicOptions) {
            var dyn = dynamicOptions[S_PROFILE];
            profileEnable = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          }
          return profileEnable;
        }
        function parseFramebuffer(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_FRAMEBUFFER in staticOptions) {
            var framebuffer = staticOptions[S_FRAMEBUFFER];
            if (framebuffer) {
              framebuffer = framebufferState.getFramebuffer(framebuffer);
              check$1.command(framebuffer, "invalid framebuffer object");
              return createStaticDecl(function(env2, block) {
                var FRAMEBUFFER = env2.link(framebuffer);
                var shared = env2.shared;
                block.set(shared.framebuffer, ".next", FRAMEBUFFER);
                var CONTEXT = shared.context;
                block.set(CONTEXT, "." + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + ".width");
                block.set(CONTEXT, "." + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + ".height");
                return FRAMEBUFFER;
              });
            } else {
              return createStaticDecl(function(env2, scope) {
                var shared = env2.shared;
                scope.set(shared.framebuffer, ".next", "null");
                var CONTEXT = shared.context;
                scope.set(CONTEXT, "." + S_FRAMEBUFFER_WIDTH, CONTEXT + "." + S_DRAWINGBUFFER_WIDTH);
                scope.set(CONTEXT, "." + S_FRAMEBUFFER_HEIGHT, CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT);
                return "null";
              });
            }
          } else if (S_FRAMEBUFFER in dynamicOptions) {
            var dyn = dynamicOptions[S_FRAMEBUFFER];
            return createDynamicDecl(dyn, function(env2, scope) {
              var FRAMEBUFFER_FUNC = env2.invoke(scope, dyn);
              var shared = env2.shared;
              var FRAMEBUFFER_STATE = shared.framebuffer;
              var FRAMEBUFFER = scope.def(FRAMEBUFFER_STATE, ".getFramebuffer(", FRAMEBUFFER_FUNC, ")");
              check$1.optional(function() {
                env2.assert(scope, "!" + FRAMEBUFFER_FUNC + "||" + FRAMEBUFFER, "invalid framebuffer object");
              });
              scope.set(FRAMEBUFFER_STATE, ".next", FRAMEBUFFER);
              var CONTEXT = shared.context;
              scope.set(CONTEXT, "." + S_FRAMEBUFFER_WIDTH, FRAMEBUFFER + "?" + FRAMEBUFFER + ".width:" + CONTEXT + "." + S_DRAWINGBUFFER_WIDTH);
              scope.set(CONTEXT, "." + S_FRAMEBUFFER_HEIGHT, FRAMEBUFFER + "?" + FRAMEBUFFER + ".height:" + CONTEXT + "." + S_DRAWINGBUFFER_HEIGHT);
              return FRAMEBUFFER;
            });
          } else {
            return null;
          }
        }
        function parseViewportScissor(options, framebuffer, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseBox(param) {
            if (param in staticOptions) {
              var box2 = staticOptions[param];
              check$1.commandType(box2, "object", "invalid " + param, env.commandStr);
              var isStatic2 = true;
              var x2 = box2.x | 0;
              var y2 = box2.y | 0;
              var w2, h2;
              if ("width" in box2) {
                w2 = box2.width | 0;
                check$1.command(w2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              if ("height" in box2) {
                h2 = box2.height | 0;
                check$1.command(h2 >= 0, "invalid " + param, env.commandStr);
              } else {
                isStatic2 = false;
              }
              return new Declaration(!isStatic2 && framebuffer && framebuffer.thisDep, !isStatic2 && framebuffer && framebuffer.contextDep, !isStatic2 && framebuffer && framebuffer.propDep, function(env2, scope) {
                var CONTEXT = env2.shared.context;
                var BOX_W = w2;
                if (!("width" in box2)) {
                  BOX_W = scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", x2);
                }
                var BOX_H = h2;
                if (!("height" in box2)) {
                  BOX_H = scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", y2);
                }
                return [x2, y2, BOX_W, BOX_H];
              });
            } else if (param in dynamicOptions) {
              var dynBox = dynamicOptions[param];
              var result = createDynamicDecl(dynBox, function(env2, scope) {
                var BOX = env2.invoke(scope, dynBox);
                check$1.optional(function() {
                  env2.assert(scope, BOX + "&&typeof " + BOX + '==="object"', "invalid " + param);
                });
                var CONTEXT = env2.shared.context;
                var BOX_X = scope.def(BOX, ".x|0");
                var BOX_Y = scope.def(BOX, ".y|0");
                var BOX_W = scope.def('"width" in ', BOX, "?", BOX, ".width|0:", "(", CONTEXT, ".", S_FRAMEBUFFER_WIDTH, "-", BOX_X, ")");
                var BOX_H = scope.def('"height" in ', BOX, "?", BOX, ".height|0:", "(", CONTEXT, ".", S_FRAMEBUFFER_HEIGHT, "-", BOX_Y, ")");
                check$1.optional(function() {
                  env2.assert(scope, BOX_W + ">=0&&" + BOX_H + ">=0", "invalid " + param);
                });
                return [BOX_X, BOX_Y, BOX_W, BOX_H];
              });
              if (framebuffer) {
                result.thisDep = result.thisDep || framebuffer.thisDep;
                result.contextDep = result.contextDep || framebuffer.contextDep;
                result.propDep = result.propDep || framebuffer.propDep;
              }
              return result;
            } else if (framebuffer) {
              return new Declaration(framebuffer.thisDep, framebuffer.contextDep, framebuffer.propDep, function(env2, scope) {
                var CONTEXT = env2.shared.context;
                return [
                  0,
                  0,
                  scope.def(CONTEXT, ".", S_FRAMEBUFFER_WIDTH),
                  scope.def(CONTEXT, ".", S_FRAMEBUFFER_HEIGHT)
                ];
              });
            } else {
              return null;
            }
          }
          var viewport = parseBox(S_VIEWPORT);
          if (viewport) {
            var prevViewport = viewport;
            viewport = new Declaration(viewport.thisDep, viewport.contextDep, viewport.propDep, function(env2, scope) {
              var VIEWPORT = prevViewport.append(env2, scope);
              var CONTEXT = env2.shared.context;
              scope.set(CONTEXT, "." + S_VIEWPORT_WIDTH, VIEWPORT[2]);
              scope.set(CONTEXT, "." + S_VIEWPORT_HEIGHT, VIEWPORT[3]);
              return VIEWPORT;
            });
          }
          return {
            viewport,
            scissor_box: parseBox(S_SCISSOR_BOX)
          };
        }
        function parseAttribLocations(options, attributes) {
          var staticOptions = options.static;
          var staticProgram = typeof staticOptions[S_FRAG] === "string" && typeof staticOptions[S_VERT] === "string";
          if (staticProgram) {
            if (Object.keys(attributes.dynamic).length > 0) {
              return null;
            }
            var staticAttributes = attributes.static;
            var sAttributes = Object.keys(staticAttributes);
            if (sAttributes.length > 0 && typeof staticAttributes[sAttributes[0]] === "number") {
              var bindings = [];
              for (var i2 = 0; i2 < sAttributes.length; ++i2) {
                check$1(typeof staticAttributes[sAttributes[i2]] === "number", "must specify all vertex attribute locations when using vaos");
                bindings.push([staticAttributes[sAttributes[i2]] | 0, sAttributes[i2]]);
              }
              return bindings;
            }
          }
          return null;
        }
        function parseProgram(options, env, attribLocations) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseShader(name) {
            if (name in staticOptions) {
              var id2 = stringStore.id(staticOptions[name]);
              check$1.optional(function() {
                shaderState.shader(shaderType[name], id2, check$1.guessCommand());
              });
              var result = createStaticDecl(function() {
                return id2;
              });
              result.id = id2;
              return result;
            } else if (name in dynamicOptions) {
              var dyn = dynamicOptions[name];
              return createDynamicDecl(dyn, function(env2, scope) {
                var str7 = env2.invoke(scope, dyn);
                var id3 = scope.def(env2.shared.strings, ".id(", str7, ")");
                check$1.optional(function() {
                  scope(env2.shared.shader, ".shader(", shaderType[name], ",", id3, ",", env2.command, ");");
                });
                return id3;
              });
            }
            return null;
          }
          var frag = parseShader(S_FRAG);
          var vert = parseShader(S_VERT);
          var program = null;
          var progVar;
          if (isStatic(frag) && isStatic(vert)) {
            program = shaderState.program(vert.id, frag.id, null, attribLocations);
            progVar = createStaticDecl(function(env2, scope) {
              return env2.link(program);
            });
          } else {
            progVar = new Declaration(frag && frag.thisDep || vert && vert.thisDep, frag && frag.contextDep || vert && vert.contextDep, frag && frag.propDep || vert && vert.propDep, function(env2, scope) {
              var SHADER_STATE = env2.shared.shader;
              var fragId;
              if (frag) {
                fragId = frag.append(env2, scope);
              } else {
                fragId = scope.def(SHADER_STATE, ".", S_FRAG);
              }
              var vertId;
              if (vert) {
                vertId = vert.append(env2, scope);
              } else {
                vertId = scope.def(SHADER_STATE, ".", S_VERT);
              }
              var progDef = SHADER_STATE + ".program(" + vertId + "," + fragId;
              check$1.optional(function() {
                progDef += "," + env2.command;
              });
              return scope.def(progDef + ")");
            });
          }
          return {
            frag,
            vert,
            progVar,
            program
          };
        }
        function parseDraw(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          function parseElements() {
            if (S_ELEMENTS in staticOptions) {
              var elements2 = staticOptions[S_ELEMENTS];
              if (isBufferArgs(elements2)) {
                elements2 = elementState.getElements(elementState.create(elements2, true));
              } else if (elements2) {
                elements2 = elementState.getElements(elements2);
                check$1.command(elements2, "invalid elements", env.commandStr);
              }
              var result = createStaticDecl(function(env2, scope) {
                if (elements2) {
                  var result2 = env2.link(elements2);
                  env2.ELEMENTS = result2;
                  return result2;
                }
                env2.ELEMENTS = null;
                return null;
              });
              result.value = elements2;
              return result;
            } else if (S_ELEMENTS in dynamicOptions) {
              var dyn = dynamicOptions[S_ELEMENTS];
              return createDynamicDecl(dyn, function(env2, scope) {
                var shared = env2.shared;
                var IS_BUFFER_ARGS = shared.isBufferArgs;
                var ELEMENT_STATE = shared.elements;
                var elementDefn = env2.invoke(scope, dyn);
                var elements3 = scope.def("null");
                var elementStream = scope.def(IS_BUFFER_ARGS, "(", elementDefn, ")");
                var ifte = env2.cond(elementStream).then(elements3, "=", ELEMENT_STATE, ".createStream(", elementDefn, ");").else(elements3, "=", ELEMENT_STATE, ".getElements(", elementDefn, ");");
                check$1.optional(function() {
                  env2.assert(ifte.else, "!" + elementDefn + "||" + elements3, "invalid elements");
                });
                scope.entry(ifte);
                scope.exit(env2.cond(elementStream).then(ELEMENT_STATE, ".destroyStream(", elements3, ");"));
                env2.ELEMENTS = elements3;
                return elements3;
              });
            }
            return null;
          }
          var elements = parseElements();
          function parsePrimitive() {
            if (S_PRIMITIVE in staticOptions) {
              var primitive = staticOptions[S_PRIMITIVE];
              check$1.commandParameter(primitive, primTypes, "invalid primitve", env.commandStr);
              return createStaticDecl(function(env2, scope) {
                return primTypes[primitive];
              });
            } else if (S_PRIMITIVE in dynamicOptions) {
              var dynPrimitive = dynamicOptions[S_PRIMITIVE];
              return createDynamicDecl(dynPrimitive, function(env2, scope) {
                var PRIM_TYPES = env2.constants.primTypes;
                var prim3 = env2.invoke(scope, dynPrimitive);
                check$1.optional(function() {
                  env2.assert(scope, prim3 + " in " + PRIM_TYPES, "invalid primitive, must be one of " + Object.keys(primTypes));
                });
                return scope.def(PRIM_TYPES, "[", prim3, "]");
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements.value) {
                  return createStaticDecl(function(env2, scope) {
                    return scope.def(env2.ELEMENTS, ".primType");
                  });
                } else {
                  return createStaticDecl(function() {
                    return GL_TRIANGLES$1;
                  });
                }
              } else {
                return new Declaration(elements.thisDep, elements.contextDep, elements.propDep, function(env2, scope) {
                  var elements2 = env2.ELEMENTS;
                  return scope.def(elements2, "?", elements2, ".primType:", GL_TRIANGLES$1);
                });
              }
            }
            return null;
          }
          function parseParam(param, isOffset) {
            if (param in staticOptions) {
              var value = staticOptions[param] | 0;
              check$1.command(!isOffset || value >= 0, "invalid " + param, env.commandStr);
              return createStaticDecl(function(env2, scope) {
                if (isOffset) {
                  env2.OFFSET = value;
                }
                return value;
              });
            } else if (param in dynamicOptions) {
              var dynValue = dynamicOptions[param];
              return createDynamicDecl(dynValue, function(env2, scope) {
                var result = env2.invoke(scope, dynValue);
                if (isOffset) {
                  env2.OFFSET = result;
                  check$1.optional(function() {
                    env2.assert(scope, result + ">=0", "invalid " + param);
                  });
                }
                return result;
              });
            } else if (isOffset && elements) {
              return createStaticDecl(function(env2, scope) {
                env2.OFFSET = "0";
                return 0;
              });
            }
            return null;
          }
          var OFFSET = parseParam(S_OFFSET, true);
          function parseVertCount() {
            if (S_COUNT in staticOptions) {
              var count = staticOptions[S_COUNT] | 0;
              check$1.command(typeof count === "number" && count >= 0, "invalid vertex count", env.commandStr);
              return createStaticDecl(function() {
                return count;
              });
            } else if (S_COUNT in dynamicOptions) {
              var dynCount = dynamicOptions[S_COUNT];
              return createDynamicDecl(dynCount, function(env2, scope) {
                var result2 = env2.invoke(scope, dynCount);
                check$1.optional(function() {
                  env2.assert(scope, "typeof " + result2 + '==="number"&&' + result2 + ">=0&&" + result2 + "===(" + result2 + "|0)", "invalid vertex count");
                });
                return result2;
              });
            } else if (elements) {
              if (isStatic(elements)) {
                if (elements) {
                  if (OFFSET) {
                    return new Declaration(OFFSET.thisDep, OFFSET.contextDep, OFFSET.propDep, function(env2, scope) {
                      var result2 = scope.def(env2.ELEMENTS, ".vertCount-", env2.OFFSET);
                      check$1.optional(function() {
                        env2.assert(scope, result2 + ">=0", "invalid vertex offset/element buffer too small");
                      });
                      return result2;
                    });
                  } else {
                    return createStaticDecl(function(env2, scope) {
                      return scope.def(env2.ELEMENTS, ".vertCount");
                    });
                  }
                } else {
                  var result = createStaticDecl(function() {
                    return -1;
                  });
                  check$1.optional(function() {
                    result.MISSING = true;
                  });
                  return result;
                }
              } else {
                var variable = new Declaration(elements.thisDep || OFFSET.thisDep, elements.contextDep || OFFSET.contextDep, elements.propDep || OFFSET.propDep, function(env2, scope) {
                  var elements2 = env2.ELEMENTS;
                  if (env2.OFFSET) {
                    return scope.def(elements2, "?", elements2, ".vertCount-", env2.OFFSET, ":-1");
                  }
                  return scope.def(elements2, "?", elements2, ".vertCount:-1");
                });
                check$1.optional(function() {
                  variable.DYNAMIC = true;
                });
                return variable;
              }
            }
            return null;
          }
          return {
            elements,
            primitive: parsePrimitive(),
            count: parseVertCount(),
            instances: parseParam(S_INSTANCES, false),
            offset: OFFSET
          };
        }
        function parseGLState(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          var STATE = {};
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            function parseParam(parseStatic, parseDynamic) {
              if (prop in staticOptions) {
                var value = parseStatic(staticOptions[prop]);
                STATE[param] = createStaticDecl(function() {
                  return value;
                });
              } else if (prop in dynamicOptions) {
                var dyn = dynamicOptions[prop];
                STATE[param] = createDynamicDecl(dyn, function(env2, scope) {
                  return parseDynamic(env2, scope, env2.invoke(scope, dyn));
                });
              }
            }
            switch (prop) {
              case S_CULL_ENABLE:
              case S_BLEND_ENABLE:
              case S_DITHER:
              case S_STENCIL_ENABLE:
              case S_DEPTH_ENABLE:
              case S_SCISSOR_ENABLE:
              case S_POLYGON_OFFSET_ENABLE:
              case S_SAMPLE_ALPHA:
              case S_SAMPLE_ENABLE:
              case S_DEPTH_MASK:
                return parseParam(function(value) {
                  check$1.commandType(value, "boolean", prop, env.commandStr);
                  return value;
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, "typeof " + value + '==="boolean"', "invalid flag " + prop, env2.commandStr);
                  });
                  return value;
                });
              case S_DEPTH_FUNC:
                return parseParam(function(value) {
                  check$1.commandParameter(value, compareFuncs, "invalid " + prop, env.commandStr);
                  return compareFuncs[value];
                }, function(env2, scope, value) {
                  var COMPARE_FUNCS = env2.constants.compareFuncs;
                  check$1.optional(function() {
                    env2.assert(scope, value + " in " + COMPARE_FUNCS, "invalid " + prop + ", must be one of " + Object.keys(compareFuncs));
                  });
                  return scope.def(COMPARE_FUNCS, "[", value, "]");
                });
              case S_DEPTH_RANGE:
                return parseParam(function(value) {
                  check$1.command(isArrayLike2(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number" && value[0] <= value[1], "depth range is 2d array", env.commandStr);
                  return value;
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===2&&typeof " + value + '[0]==="number"&&typeof ' + value + '[1]==="number"&&' + value + "[0]<=" + value + "[1]", "depth range must be a 2d array");
                  });
                  var Z_NEAR = scope.def("+", value, "[0]");
                  var Z_FAR = scope.def("+", value, "[1]");
                  return [Z_NEAR, Z_FAR];
                });
              case S_BLEND_FUNC:
                return parseParam(function(value) {
                  check$1.commandType(value, "object", "blend.func", env.commandStr);
                  var srcRGB = "srcRGB" in value ? value.srcRGB : value.src;
                  var srcAlpha = "srcAlpha" in value ? value.srcAlpha : value.src;
                  var dstRGB = "dstRGB" in value ? value.dstRGB : value.dst;
                  var dstAlpha = "dstAlpha" in value ? value.dstAlpha : value.dst;
                  check$1.commandParameter(srcRGB, blendFuncs, param + ".srcRGB", env.commandStr);
                  check$1.commandParameter(srcAlpha, blendFuncs, param + ".srcAlpha", env.commandStr);
                  check$1.commandParameter(dstRGB, blendFuncs, param + ".dstRGB", env.commandStr);
                  check$1.commandParameter(dstAlpha, blendFuncs, param + ".dstAlpha", env.commandStr);
                  check$1.command(invalidBlendCombinations.indexOf(srcRGB + ", " + dstRGB) === -1, "unallowed blending combination (srcRGB, dstRGB) = (" + srcRGB + ", " + dstRGB + ")", env.commandStr);
                  return [
                    blendFuncs[srcRGB],
                    blendFuncs[dstRGB],
                    blendFuncs[srcAlpha],
                    blendFuncs[dstAlpha]
                  ];
                }, function(env2, scope, value) {
                  var BLEND_FUNCS = env2.constants.blendFuncs;
                  check$1.optional(function() {
                    env2.assert(scope, value + "&&typeof " + value + '==="object"', "invalid blend func, must be an object");
                  });
                  function read3(prefix, suffix) {
                    var func = scope.def('"', prefix, suffix, '" in ', value, "?", value, ".", prefix, suffix, ":", value, ".", prefix);
                    check$1.optional(function() {
                      env2.assert(scope, func + " in " + BLEND_FUNCS, "invalid " + prop + "." + prefix + suffix + ", must be one of " + Object.keys(blendFuncs));
                    });
                    return func;
                  }
                  var srcRGB = read3("src", "RGB");
                  var dstRGB = read3("dst", "RGB");
                  check$1.optional(function() {
                    var INVALID_BLEND_COMBINATIONS = env2.constants.invalidBlendCombinations;
                    env2.assert(scope, INVALID_BLEND_COMBINATIONS + ".indexOf(" + srcRGB + '+", "+' + dstRGB + ") === -1 ", "unallowed blending combination for (srcRGB, dstRGB)");
                  });
                  var SRC_RGB = scope.def(BLEND_FUNCS, "[", srcRGB, "]");
                  var SRC_ALPHA = scope.def(BLEND_FUNCS, "[", read3("src", "Alpha"), "]");
                  var DST_RGB = scope.def(BLEND_FUNCS, "[", dstRGB, "]");
                  var DST_ALPHA = scope.def(BLEND_FUNCS, "[", read3("dst", "Alpha"), "]");
                  return [SRC_RGB, DST_RGB, SRC_ALPHA, DST_ALPHA];
                });
              case S_BLEND_EQUATION:
                return parseParam(function(value) {
                  if (typeof value === "string") {
                    check$1.commandParameter(value, blendEquations, "invalid " + prop, env.commandStr);
                    return [
                      blendEquations[value],
                      blendEquations[value]
                    ];
                  } else if (typeof value === "object") {
                    check$1.commandParameter(value.rgb, blendEquations, prop + ".rgb", env.commandStr);
                    check$1.commandParameter(value.alpha, blendEquations, prop + ".alpha", env.commandStr);
                    return [
                      blendEquations[value.rgb],
                      blendEquations[value.alpha]
                    ];
                  } else {
                    check$1.commandRaise("invalid blend.equation", env.commandStr);
                  }
                }, function(env2, scope, value) {
                  var BLEND_EQUATIONS = env2.constants.blendEquations;
                  var RGB = scope.def();
                  var ALPHA = scope.def();
                  var ifte = env2.cond("typeof ", value, '==="string"');
                  check$1.optional(function() {
                    function checkProp(block, name, value2) {
                      env2.assert(block, value2 + " in " + BLEND_EQUATIONS, "invalid " + name + ", must be one of " + Object.keys(blendEquations));
                    }
                    checkProp(ifte.then, prop, value);
                    env2.assert(ifte.else, value + "&&typeof " + value + '==="object"', "invalid " + prop);
                    checkProp(ifte.else, prop + ".rgb", value + ".rgb");
                    checkProp(ifte.else, prop + ".alpha", value + ".alpha");
                  });
                  ifte.then(RGB, "=", ALPHA, "=", BLEND_EQUATIONS, "[", value, "];");
                  ifte.else(RGB, "=", BLEND_EQUATIONS, "[", value, ".rgb];", ALPHA, "=", BLEND_EQUATIONS, "[", value, ".alpha];");
                  scope(ifte);
                  return [RGB, ALPHA];
                });
              case S_BLEND_COLOR:
                return parseParam(function(value) {
                  check$1.command(isArrayLike2(value) && value.length === 4, "blend.color must be a 4d array", env.commandStr);
                  return loop(4, function(i2) {
                    return +value[i2];
                  });
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4", "blend.color must be a 4d array");
                  });
                  return loop(4, function(i2) {
                    return scope.def("+", value, "[", i2, "]");
                  });
                });
              case S_STENCIL_MASK:
                return parseParam(function(value) {
                  check$1.commandType(value, "number", param, env.commandStr);
                  return value | 0;
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, "typeof " + value + '==="number"', "invalid stencil.mask");
                  });
                  return scope.def(value, "|0");
                });
              case S_STENCIL_FUNC:
                return parseParam(function(value) {
                  check$1.commandType(value, "object", param, env.commandStr);
                  var cmp = value.cmp || "keep";
                  var ref = value.ref || 0;
                  var mask = "mask" in value ? value.mask : -1;
                  check$1.commandParameter(cmp, compareFuncs, prop + ".cmp", env.commandStr);
                  check$1.commandType(ref, "number", prop + ".ref", env.commandStr);
                  check$1.commandType(mask, "number", prop + ".mask", env.commandStr);
                  return [
                    compareFuncs[cmp],
                    ref,
                    mask
                  ];
                }, function(env2, scope, value) {
                  var COMPARE_FUNCS = env2.constants.compareFuncs;
                  check$1.optional(function() {
                    function assert() {
                      env2.assert(scope, Array.prototype.join.call(arguments, ""), "invalid stencil.func");
                    }
                    assert(value + "&&typeof ", value, '==="object"');
                    assert('!("cmp" in ', value, ")||(", value, ".cmp in ", COMPARE_FUNCS, ")");
                  });
                  var cmp = scope.def('"cmp" in ', value, "?", COMPARE_FUNCS, "[", value, ".cmp]", ":", GL_KEEP);
                  var ref = scope.def(value, ".ref|0");
                  var mask = scope.def('"mask" in ', value, "?", value, ".mask|0:-1");
                  return [cmp, ref, mask];
                });
              case S_STENCIL_OPFRONT:
              case S_STENCIL_OPBACK:
                return parseParam(function(value) {
                  check$1.commandType(value, "object", param, env.commandStr);
                  var fail = value.fail || "keep";
                  var zfail = value.zfail || "keep";
                  var zpass = value.zpass || "keep";
                  check$1.commandParameter(fail, stencilOps, prop + ".fail", env.commandStr);
                  check$1.commandParameter(zfail, stencilOps, prop + ".zfail", env.commandStr);
                  check$1.commandParameter(zpass, stencilOps, prop + ".zpass", env.commandStr);
                  return [
                    prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                    stencilOps[fail],
                    stencilOps[zfail],
                    stencilOps[zpass]
                  ];
                }, function(env2, scope, value) {
                  var STENCIL_OPS = env2.constants.stencilOps;
                  check$1.optional(function() {
                    env2.assert(scope, value + "&&typeof " + value + '==="object"', "invalid " + prop);
                  });
                  function read3(name) {
                    check$1.optional(function() {
                      env2.assert(scope, '!("' + name + '" in ' + value + ")||(" + value + "." + name + " in " + STENCIL_OPS + ")", "invalid " + prop + "." + name + ", must be one of " + Object.keys(stencilOps));
                    });
                    return scope.def('"', name, '" in ', value, "?", STENCIL_OPS, "[", value, ".", name, "]:", GL_KEEP);
                  }
                  return [
                    prop === S_STENCIL_OPBACK ? GL_BACK : GL_FRONT,
                    read3("fail"),
                    read3("zfail"),
                    read3("zpass")
                  ];
                });
              case S_POLYGON_OFFSET_OFFSET:
                return parseParam(function(value) {
                  check$1.commandType(value, "object", param, env.commandStr);
                  var factor = value.factor | 0;
                  var units = value.units | 0;
                  check$1.commandType(factor, "number", param + ".factor", env.commandStr);
                  check$1.commandType(units, "number", param + ".units", env.commandStr);
                  return [factor, units];
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, value + "&&typeof " + value + '==="object"', "invalid " + prop);
                  });
                  var FACTOR = scope.def(value, ".factor|0");
                  var UNITS = scope.def(value, ".units|0");
                  return [FACTOR, UNITS];
                });
              case S_CULL_FACE:
                return parseParam(function(value) {
                  var face = 0;
                  if (value === "front") {
                    face = GL_FRONT;
                  } else if (value === "back") {
                    face = GL_BACK;
                  }
                  check$1.command(!!face, param, env.commandStr);
                  return face;
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, value + '==="front"||' + value + '==="back"', "invalid cull.face");
                  });
                  return scope.def(value, '==="front"?', GL_FRONT, ":", GL_BACK);
                });
              case S_LINE_WIDTH:
                return parseParam(function(value) {
                  check$1.command(typeof value === "number" && value >= limits.lineWidthDims[0] && value <= limits.lineWidthDims[1], "invalid line width, must be a positive number between " + limits.lineWidthDims[0] + " and " + limits.lineWidthDims[1], env.commandStr);
                  return value;
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, "typeof " + value + '==="number"&&' + value + ">=" + limits.lineWidthDims[0] + "&&" + value + "<=" + limits.lineWidthDims[1], "invalid line width");
                  });
                  return value;
                });
              case S_FRONT_FACE:
                return parseParam(function(value) {
                  check$1.commandParameter(value, orientationType, param, env.commandStr);
                  return orientationType[value];
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, value + '==="cw"||' + value + '==="ccw"', "invalid frontFace, must be one of cw,ccw");
                  });
                  return scope.def(value + '==="cw"?' + GL_CW + ":" + GL_CCW);
                });
              case S_COLOR_MASK:
                return parseParam(function(value) {
                  check$1.command(isArrayLike2(value) && value.length === 4, "color.mask must be length 4 array", env.commandStr);
                  return value.map(function(v2) {
                    return !!v2;
                  });
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, env2.shared.isArrayLike + "(" + value + ")&&" + value + ".length===4", "invalid color.mask");
                  });
                  return loop(4, function(i2) {
                    return "!!" + value + "[" + i2 + "]";
                  });
                });
              case S_SAMPLE_COVERAGE:
                return parseParam(function(value) {
                  check$1.command(typeof value === "object" && value, param, env.commandStr);
                  var sampleValue = "value" in value ? value.value : 1;
                  var sampleInvert = !!value.invert;
                  check$1.command(typeof sampleValue === "number" && sampleValue >= 0 && sampleValue <= 1, "sample.coverage.value must be a number between 0 and 1", env.commandStr);
                  return [sampleValue, sampleInvert];
                }, function(env2, scope, value) {
                  check$1.optional(function() {
                    env2.assert(scope, value + "&&typeof " + value + '==="object"', "invalid sample.coverage");
                  });
                  var VALUE = scope.def('"value" in ', value, "?+", value, ".value:1");
                  var INVERT = scope.def("!!", value, ".invert");
                  return [VALUE, INVERT];
                });
            }
          });
          return STATE;
        }
        function parseUniforms(uniforms, env) {
          var staticUniforms = uniforms.static;
          var dynamicUniforms = uniforms.dynamic;
          var UNIFORMS = {};
          Object.keys(staticUniforms).forEach(function(name) {
            var value = staticUniforms[name];
            var result;
            if (typeof value === "number" || typeof value === "boolean") {
              result = createStaticDecl(function() {
                return value;
              });
            } else if (typeof value === "function") {
              var reglType = value._reglType;
              if (reglType === "texture2d" || reglType === "textureCube") {
                result = createStaticDecl(function(env2) {
                  return env2.link(value);
                });
              } else if (reglType === "framebuffer" || reglType === "framebufferCube") {
                check$1.command(value.color.length > 0, 'missing color attachment for framebuffer sent to uniform "' + name + '"', env.commandStr);
                result = createStaticDecl(function(env2) {
                  return env2.link(value.color[0]);
                });
              } else {
                check$1.commandRaise('invalid data for uniform "' + name + '"', env.commandStr);
              }
            } else if (isArrayLike2(value)) {
              result = createStaticDecl(function(env2) {
                var ITEM = env2.global.def("[", loop(value.length, function(i2) {
                  check$1.command(typeof value[i2] === "number" || typeof value[i2] === "boolean", "invalid uniform " + name, env2.commandStr);
                  return value[i2];
                }), "]");
                return ITEM;
              });
            } else {
              check$1.commandRaise('invalid or missing data for uniform "' + name + '"', env.commandStr);
            }
            result.value = value;
            UNIFORMS[name] = result;
          });
          Object.keys(dynamicUniforms).forEach(function(key) {
            var dyn = dynamicUniforms[key];
            UNIFORMS[key] = createDynamicDecl(dyn, function(env2, scope) {
              return env2.invoke(scope, dyn);
            });
          });
          return UNIFORMS;
        }
        function parseAttributes(attributes, env) {
          var staticAttributes = attributes.static;
          var dynamicAttributes = attributes.dynamic;
          var attributeDefs = {};
          Object.keys(staticAttributes).forEach(function(attribute) {
            var value = staticAttributes[attribute];
            var id2 = stringStore.id(attribute);
            var record = new AttributeRecord2();
            if (isBufferArgs(value)) {
              record.state = ATTRIB_STATE_POINTER;
              record.buffer = bufferState.getBuffer(bufferState.create(value, GL_ARRAY_BUFFER$2, false, true));
              record.type = 0;
            } else {
              var buffer = bufferState.getBuffer(value);
              if (buffer) {
                record.state = ATTRIB_STATE_POINTER;
                record.buffer = buffer;
                record.type = 0;
              } else {
                check$1.command(typeof value === "object" && value, "invalid data for attribute " + attribute, env.commandStr);
                if ("constant" in value) {
                  var constant = value.constant;
                  record.buffer = "null";
                  record.state = ATTRIB_STATE_CONSTANT;
                  if (typeof constant === "number") {
                    record.x = constant;
                  } else {
                    check$1.command(isArrayLike2(constant) && constant.length > 0 && constant.length <= 4, "invalid constant for attribute " + attribute, env.commandStr);
                    CUTE_COMPONENTS.forEach(function(c2, i2) {
                      if (i2 < constant.length) {
                        record[c2] = constant[i2];
                      }
                    });
                  }
                } else {
                  if (isBufferArgs(value.buffer)) {
                    buffer = bufferState.getBuffer(bufferState.create(value.buffer, GL_ARRAY_BUFFER$2, false, true));
                  } else {
                    buffer = bufferState.getBuffer(value.buffer);
                  }
                  check$1.command(!!buffer, 'missing buffer for attribute "' + attribute + '"', env.commandStr);
                  var offset = value.offset | 0;
                  check$1.command(offset >= 0, 'invalid offset for attribute "' + attribute + '"', env.commandStr);
                  var stride = value.stride | 0;
                  check$1.command(stride >= 0 && stride < 256, 'invalid stride for attribute "' + attribute + '", must be integer betweeen [0, 255]', env.commandStr);
                  var size2 = value.size | 0;
                  check$1.command(!("size" in value) || size2 > 0 && size2 <= 4, 'invalid size for attribute "' + attribute + '", must be 1,2,3,4', env.commandStr);
                  var normalized = !!value.normalized;
                  var type = 0;
                  if ("type" in value) {
                    check$1.commandParameter(value.type, glTypes, "invalid type for attribute " + attribute, env.commandStr);
                    type = glTypes[value.type];
                  }
                  var divisor = value.divisor | 0;
                  if ("divisor" in value) {
                    check$1.command(divisor === 0 || extInstancing, 'cannot specify divisor for attribute "' + attribute + '", instancing not supported', env.commandStr);
                    check$1.command(divisor >= 0, 'invalid divisor for attribute "' + attribute + '"', env.commandStr);
                  }
                  check$1.optional(function() {
                    var command = env.commandStr;
                    var VALID_KEYS = [
                      "buffer",
                      "offset",
                      "divisor",
                      "normalized",
                      "type",
                      "size",
                      "stride"
                    ];
                    Object.keys(value).forEach(function(prop) {
                      check$1.command(VALID_KEYS.indexOf(prop) >= 0, 'unknown parameter "' + prop + '" for attribute pointer "' + attribute + '" (valid parameters are ' + VALID_KEYS + ")", command);
                    });
                  });
                  record.buffer = buffer;
                  record.state = ATTRIB_STATE_POINTER;
                  record.size = size2;
                  record.normalized = normalized;
                  record.type = type || buffer.dtype;
                  record.offset = offset;
                  record.stride = stride;
                  record.divisor = divisor;
                }
              }
            }
            attributeDefs[attribute] = createStaticDecl(function(env2, scope) {
              var cache3 = env2.attribCache;
              if (id2 in cache3) {
                return cache3[id2];
              }
              var result = {
                isStream: false
              };
              Object.keys(record).forEach(function(key) {
                result[key] = record[key];
              });
              if (record.buffer) {
                result.buffer = env2.link(record.buffer);
                result.type = result.type || result.buffer + ".dtype";
              }
              cache3[id2] = result;
              return result;
            });
          });
          Object.keys(dynamicAttributes).forEach(function(attribute) {
            var dyn = dynamicAttributes[attribute];
            function appendAttributeCode(env2, block) {
              var VALUE = env2.invoke(block, dyn);
              var shared = env2.shared;
              var constants = env2.constants;
              var IS_BUFFER_ARGS = shared.isBufferArgs;
              var BUFFER_STATE = shared.buffer;
              check$1.optional(function() {
                env2.assert(block, VALUE + "&&(typeof " + VALUE + '==="object"||typeof ' + VALUE + '==="function")&&(' + IS_BUFFER_ARGS + "(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ")||" + BUFFER_STATE + ".getBuffer(" + VALUE + ".buffer)||" + IS_BUFFER_ARGS + "(" + VALUE + '.buffer)||("constant" in ' + VALUE + "&&(typeof " + VALUE + '.constant==="number"||' + shared.isArrayLike + "(" + VALUE + ".constant))))", 'invalid dynamic attribute "' + attribute + '"');
              });
              var result = {
                isStream: block.def(false)
              };
              var defaultRecord = new AttributeRecord2();
              defaultRecord.state = ATTRIB_STATE_POINTER;
              Object.keys(defaultRecord).forEach(function(key) {
                result[key] = block.def("" + defaultRecord[key]);
              });
              var BUFFER = result.buffer;
              var TYPE = result.type;
              block("if(", IS_BUFFER_ARGS, "(", VALUE, ")){", result.isStream, "=true;", BUFFER, "=", BUFFER_STATE, ".createStream(", GL_ARRAY_BUFFER$2, ",", VALUE, ");", TYPE, "=", BUFFER, ".dtype;", "}else{", BUFFER, "=", BUFFER_STATE, ".getBuffer(", VALUE, ");", "if(", BUFFER, "){", TYPE, "=", BUFFER, ".dtype;", '}else if("constant" in ', VALUE, "){", result.state, "=", ATTRIB_STATE_CONSTANT, ";", "if(typeof " + VALUE + '.constant === "number"){', result[CUTE_COMPONENTS[0]], "=", VALUE, ".constant;", CUTE_COMPONENTS.slice(1).map(function(n2) {
                return result[n2];
              }).join("="), "=0;", "}else{", CUTE_COMPONENTS.map(function(name, i2) {
                return result[name] + "=" + VALUE + ".constant.length>" + i2 + "?" + VALUE + ".constant[" + i2 + "]:0;";
              }).join(""), "}}else{", "if(", IS_BUFFER_ARGS, "(", VALUE, ".buffer)){", BUFFER, "=", BUFFER_STATE, ".createStream(", GL_ARRAY_BUFFER$2, ",", VALUE, ".buffer);", "}else{", BUFFER, "=", BUFFER_STATE, ".getBuffer(", VALUE, ".buffer);", "}", TYPE, '="type" in ', VALUE, "?", constants.glTypes, "[", VALUE, ".type]:", BUFFER, ".dtype;", result.normalized, "=!!", VALUE, ".normalized;");
              function emitReadRecord(name) {
                block(result[name], "=", VALUE, ".", name, "|0;");
              }
              emitReadRecord("size");
              emitReadRecord("offset");
              emitReadRecord("stride");
              emitReadRecord("divisor");
              block("}}");
              block.exit("if(", result.isStream, "){", BUFFER_STATE, ".destroyStream(", BUFFER, ");", "}");
              return result;
            }
            attributeDefs[attribute] = createDynamicDecl(dyn, appendAttributeCode);
          });
          return attributeDefs;
        }
        function parseVAO(options, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          if (S_VAO in staticOptions) {
            var vao = staticOptions[S_VAO];
            if (vao !== null && attributeState.getVAO(vao) === null) {
              vao = attributeState.createVAO(vao);
            }
            return createStaticDecl(function(env2) {
              return env2.link(attributeState.getVAO(vao));
            });
          } else if (S_VAO in dynamicOptions) {
            var dyn = dynamicOptions[S_VAO];
            return createDynamicDecl(dyn, function(env2, scope) {
              var vaoRef = env2.invoke(scope, dyn);
              return scope.def(env2.shared.vao + ".getVAO(" + vaoRef + ")");
            });
          }
          return null;
        }
        function parseContext(context) {
          var staticContext = context.static;
          var dynamicContext = context.dynamic;
          var result = {};
          Object.keys(staticContext).forEach(function(name) {
            var value = staticContext[name];
            result[name] = createStaticDecl(function(env, scope) {
              if (typeof value === "number" || typeof value === "boolean") {
                return "" + value;
              } else {
                return env.link(value);
              }
            });
          });
          Object.keys(dynamicContext).forEach(function(name) {
            var dyn = dynamicContext[name];
            result[name] = createDynamicDecl(dyn, function(env, scope) {
              return env.invoke(scope, dyn);
            });
          });
          return result;
        }
        function parseArguments(options, attributes, uniforms, context, env) {
          var staticOptions = options.static;
          var dynamicOptions = options.dynamic;
          check$1.optional(function() {
            var KEY_NAMES = [
              S_FRAMEBUFFER,
              S_VERT,
              S_FRAG,
              S_ELEMENTS,
              S_PRIMITIVE,
              S_OFFSET,
              S_COUNT,
              S_INSTANCES,
              S_PROFILE,
              S_VAO
            ].concat(GL_STATE_NAMES);
            function checkKeys(dict) {
              Object.keys(dict).forEach(function(key) {
                check$1.command(KEY_NAMES.indexOf(key) >= 0, 'unknown parameter "' + key + '"', env.commandStr);
              });
            }
            checkKeys(staticOptions);
            checkKeys(dynamicOptions);
          });
          var attribLocations = parseAttribLocations(options, attributes);
          var framebuffer = parseFramebuffer(options, env);
          var viewportAndScissor = parseViewportScissor(options, framebuffer, env);
          var draw4 = parseDraw(options, env);
          var state = parseGLState(options, env);
          var shader = parseProgram(options, env, attribLocations);
          function copyBox(name) {
            var defn = viewportAndScissor[name];
            if (defn) {
              state[name] = defn;
            }
          }
          copyBox(S_VIEWPORT);
          copyBox(propName(S_SCISSOR_BOX));
          var dirty = Object.keys(state).length > 0;
          var result = {
            framebuffer,
            draw: draw4,
            shader,
            state,
            dirty,
            scopeVAO: null,
            drawVAO: null,
            useVAO: false,
            attributes: {}
          };
          result.profile = parseProfile(options, env);
          result.uniforms = parseUniforms(uniforms, env);
          result.drawVAO = result.scopeVAO = parseVAO(options, env);
          if (!result.drawVAO && shader.program && !attribLocations && extensions.angle_instanced_arrays) {
            var useVAO = true;
            var staticBindings = shader.program.attributes.map(function(attr) {
              var binding = attributes.static[attr];
              useVAO = useVAO && !!binding;
              return binding;
            });
            if (useVAO && staticBindings.length > 0) {
              var vao = attributeState.getVAO(attributeState.createVAO(staticBindings));
              result.drawVAO = new Declaration(null, null, null, function(env2, scope) {
                return env2.link(vao);
              });
              result.useVAO = true;
            }
          }
          if (attribLocations) {
            result.useVAO = true;
          } else {
            result.attributes = parseAttributes(attributes, env);
          }
          result.context = parseContext(context, env);
          return result;
        }
        function emitContext(env, scope, context) {
          var shared = env.shared;
          var CONTEXT = shared.context;
          var contextEnter = env.scope();
          Object.keys(context).forEach(function(name) {
            scope.save(CONTEXT, "." + name);
            var defn = context[name];
            var value = defn.append(env, scope);
            if (Array.isArray(value)) {
              contextEnter(CONTEXT, ".", name, "=[", value.join(), "];");
            } else {
              contextEnter(CONTEXT, ".", name, "=", value, ";");
            }
          });
          scope(contextEnter);
        }
        function emitPollFramebuffer(env, scope, framebuffer, skipCheck) {
          var shared = env.shared;
          var GL = shared.gl;
          var FRAMEBUFFER_STATE = shared.framebuffer;
          var EXT_DRAW_BUFFERS;
          if (extDrawBuffers) {
            EXT_DRAW_BUFFERS = scope.def(shared.extensions, ".webgl_draw_buffers");
          }
          var constants = env.constants;
          var DRAW_BUFFERS = constants.drawBuffer;
          var BACK_BUFFER = constants.backBuffer;
          var NEXT;
          if (framebuffer) {
            NEXT = framebuffer.append(env, scope);
          } else {
            NEXT = scope.def(FRAMEBUFFER_STATE, ".next");
          }
          if (!skipCheck) {
            scope("if(", NEXT, "!==", FRAMEBUFFER_STATE, ".cur){");
          }
          scope("if(", NEXT, "){", GL, ".bindFramebuffer(", GL_FRAMEBUFFER$2, ",", NEXT, ".framebuffer);");
          if (extDrawBuffers) {
            scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", DRAW_BUFFERS, "[", NEXT, ".colorAttachments.length]);");
          }
          scope("}else{", GL, ".bindFramebuffer(", GL_FRAMEBUFFER$2, ",null);");
          if (extDrawBuffers) {
            scope(EXT_DRAW_BUFFERS, ".drawBuffersWEBGL(", BACK_BUFFER, ");");
          }
          scope("}", FRAMEBUFFER_STATE, ".cur=", NEXT, ";");
          if (!skipCheck) {
            scope("}");
          }
        }
        function emitPollState(env, scope, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var CURRENT_VARS = env.current;
          var NEXT_VARS = env.next;
          var CURRENT_STATE = shared.current;
          var NEXT_STATE = shared.next;
          var block = env.cond(CURRENT_STATE, ".dirty");
          GL_STATE_NAMES.forEach(function(prop) {
            var param = propName(prop);
            if (param in args.state) {
              return;
            }
            var NEXT, CURRENT;
            if (param in NEXT_VARS) {
              NEXT = NEXT_VARS[param];
              CURRENT = CURRENT_VARS[param];
              var parts = loop(currentState[param].length, function(i2) {
                return block.def(NEXT, "[", i2, "]");
              });
              block(env.cond(parts.map(function(p2, i2) {
                return p2 + "!==" + CURRENT + "[" + i2 + "]";
              }).join("||")).then(GL, ".", GL_VARIABLES[param], "(", parts, ");", parts.map(function(p2, i2) {
                return CURRENT + "[" + i2 + "]=" + p2;
              }).join(";"), ";"));
            } else {
              NEXT = block.def(NEXT_STATE, ".", param);
              var ifte = env.cond(NEXT, "!==", CURRENT_STATE, ".", param);
              block(ifte);
              if (param in GL_FLAGS) {
                ifte(env.cond(NEXT).then(GL, ".enable(", GL_FLAGS[param], ");").else(GL, ".disable(", GL_FLAGS[param], ");"), CURRENT_STATE, ".", param, "=", NEXT, ";");
              } else {
                ifte(GL, ".", GL_VARIABLES[param], "(", NEXT, ");", CURRENT_STATE, ".", param, "=", NEXT, ";");
              }
            }
          });
          if (Object.keys(args.state).length === 0) {
            block(CURRENT_STATE, ".dirty=false;");
          }
          scope(block);
        }
        function emitSetOptions(env, scope, options, filter2) {
          var shared = env.shared;
          var CURRENT_VARS = env.current;
          var CURRENT_STATE = shared.current;
          var GL = shared.gl;
          sortState(Object.keys(options)).forEach(function(param) {
            var defn = options[param];
            if (filter2 && !filter2(defn)) {
              return;
            }
            var variable = defn.append(env, scope);
            if (GL_FLAGS[param]) {
              var flag = GL_FLAGS[param];
              if (isStatic(defn)) {
                if (variable) {
                  scope(GL, ".enable(", flag, ");");
                } else {
                  scope(GL, ".disable(", flag, ");");
                }
              } else {
                scope(env.cond(variable).then(GL, ".enable(", flag, ");").else(GL, ".disable(", flag, ");"));
              }
              scope(CURRENT_STATE, ".", param, "=", variable, ";");
            } else if (isArrayLike2(variable)) {
              var CURRENT = CURRENT_VARS[param];
              scope(GL, ".", GL_VARIABLES[param], "(", variable, ");", variable.map(function(v2, i2) {
                return CURRENT + "[" + i2 + "]=" + v2;
              }).join(";"), ";");
            } else {
              scope(GL, ".", GL_VARIABLES[param], "(", variable, ");", CURRENT_STATE, ".", param, "=", variable, ";");
            }
          });
        }
        function injectExtensions(env, scope) {
          if (extInstancing) {
            env.instancing = scope.def(env.shared.extensions, ".angle_instanced_arrays");
          }
        }
        function emitProfile(env, scope, args, useScope, incrementCounter) {
          var shared = env.shared;
          var STATS = env.stats;
          var CURRENT_STATE = shared.current;
          var TIMER = shared.timer;
          var profileArg = args.profile;
          function perfCounter() {
            if (typeof performance === "undefined") {
              return "Date.now()";
            } else {
              return "performance.now()";
            }
          }
          var CPU_START, QUERY_COUNTER;
          function emitProfileStart(block) {
            CPU_START = scope.def();
            block(CPU_START, "=", perfCounter(), ";");
            if (typeof incrementCounter === "string") {
              block(STATS, ".count+=", incrementCounter, ";");
            } else {
              block(STATS, ".count++;");
            }
            if (timer3) {
              if (useScope) {
                QUERY_COUNTER = scope.def();
                block(QUERY_COUNTER, "=", TIMER, ".getNumPendingQueries();");
              } else {
                block(TIMER, ".beginQuery(", STATS, ");");
              }
            }
          }
          function emitProfileEnd(block) {
            block(STATS, ".cpuTime+=", perfCounter(), "-", CPU_START, ";");
            if (timer3) {
              if (useScope) {
                block(TIMER, ".pushScopeStats(", QUERY_COUNTER, ",", TIMER, ".getNumPendingQueries(),", STATS, ");");
              } else {
                block(TIMER, ".endQuery();");
              }
            }
          }
          function scopeProfile(value) {
            var prev = scope.def(CURRENT_STATE, ".profile");
            scope(CURRENT_STATE, ".profile=", value, ";");
            scope.exit(CURRENT_STATE, ".profile=", prev, ";");
          }
          var USE_PROFILE;
          if (profileArg) {
            if (isStatic(profileArg)) {
              if (profileArg.enable) {
                emitProfileStart(scope);
                emitProfileEnd(scope.exit);
                scopeProfile("true");
              } else {
                scopeProfile("false");
              }
              return;
            }
            USE_PROFILE = profileArg.append(env, scope);
            scopeProfile(USE_PROFILE);
          } else {
            USE_PROFILE = scope.def(CURRENT_STATE, ".profile");
          }
          var start = env.block();
          emitProfileStart(start);
          scope("if(", USE_PROFILE, "){", start, "}");
          var end2 = env.block();
          emitProfileEnd(end2);
          scope.exit("if(", USE_PROFILE, "){", end2, "}");
        }
        function emitAttributes(env, scope, args, attributes, filter2) {
          var shared = env.shared;
          function typeLength(x2) {
            switch (x2) {
              case GL_FLOAT_VEC2:
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                return 2;
              case GL_FLOAT_VEC3:
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                return 3;
              case GL_FLOAT_VEC4:
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                return 4;
              default:
                return 1;
            }
          }
          function emitBindAttribute(ATTRIBUTE, size2, record) {
            var GL = shared.gl;
            var LOCATION = scope.def(ATTRIBUTE, ".location");
            var BINDING = scope.def(shared.attributes, "[", LOCATION, "]");
            var STATE = record.state;
            var BUFFER = record.buffer;
            var CONST_COMPONENTS = [
              record.x,
              record.y,
              record.z,
              record.w
            ];
            var COMMON_KEYS = [
              "buffer",
              "normalized",
              "offset",
              "stride"
            ];
            function emitBuffer() {
              scope("if(!", BINDING, ".buffer){", GL, ".enableVertexAttribArray(", LOCATION, ");}");
              var TYPE = record.type;
              var SIZE;
              if (!record.size) {
                SIZE = size2;
              } else {
                SIZE = scope.def(record.size, "||", size2);
              }
              scope("if(", BINDING, ".type!==", TYPE, "||", BINDING, ".size!==", SIZE, "||", COMMON_KEYS.map(function(key) {
                return BINDING + "." + key + "!==" + record[key];
              }).join("||"), "){", GL, ".bindBuffer(", GL_ARRAY_BUFFER$2, ",", BUFFER, ".buffer);", GL, ".vertexAttribPointer(", [
                LOCATION,
                SIZE,
                TYPE,
                record.normalized,
                record.stride,
                record.offset
              ], ");", BINDING, ".type=", TYPE, ";", BINDING, ".size=", SIZE, ";", COMMON_KEYS.map(function(key) {
                return BINDING + "." + key + "=" + record[key] + ";";
              }).join(""), "}");
              if (extInstancing) {
                var DIVISOR = record.divisor;
                scope("if(", BINDING, ".divisor!==", DIVISOR, "){", env.instancing, ".vertexAttribDivisorANGLE(", [LOCATION, DIVISOR], ");", BINDING, ".divisor=", DIVISOR, ";}");
              }
            }
            function emitConstant() {
              scope("if(", BINDING, ".buffer){", GL, ".disableVertexAttribArray(", LOCATION, ");", BINDING, ".buffer=null;", "}if(", CUTE_COMPONENTS.map(function(c2, i2) {
                return BINDING + "." + c2 + "!==" + CONST_COMPONENTS[i2];
              }).join("||"), "){", GL, ".vertexAttrib4f(", LOCATION, ",", CONST_COMPONENTS, ");", CUTE_COMPONENTS.map(function(c2, i2) {
                return BINDING + "." + c2 + "=" + CONST_COMPONENTS[i2] + ";";
              }).join(""), "}");
            }
            if (STATE === ATTRIB_STATE_POINTER) {
              emitBuffer();
            } else if (STATE === ATTRIB_STATE_CONSTANT) {
              emitConstant();
            } else {
              scope("if(", STATE, "===", ATTRIB_STATE_POINTER, "){");
              emitBuffer();
              scope("}else{");
              emitConstant();
              scope("}");
            }
          }
          attributes.forEach(function(attribute) {
            var name = attribute.name;
            var arg = args.attributes[name];
            var record;
            if (arg) {
              if (!filter2(arg)) {
                return;
              }
              record = arg.append(env, scope);
            } else {
              if (!filter2(SCOPE_DECL)) {
                return;
              }
              var scopeAttrib = env.scopeAttrib(name);
              check$1.optional(function() {
                env.assert(scope, scopeAttrib + ".state", "missing attribute " + name);
              });
              record = {};
              Object.keys(new AttributeRecord2()).forEach(function(key) {
                record[key] = scope.def(scopeAttrib, ".", key);
              });
            }
            emitBindAttribute(env.link(attribute), typeLength(attribute.info.type), record);
          });
        }
        function emitUniforms(env, scope, args, uniforms, filter2) {
          var shared = env.shared;
          var GL = shared.gl;
          var infix;
          for (var i2 = 0; i2 < uniforms.length; ++i2) {
            var uniform = uniforms[i2];
            var name = uniform.name;
            var type = uniform.info.type;
            var arg = args.uniforms[name];
            var UNIFORM = env.link(uniform);
            var LOCATION = UNIFORM + ".location";
            var VALUE;
            if (arg) {
              if (!filter2(arg)) {
                continue;
              }
              if (isStatic(arg)) {
                var value = arg.value;
                check$1.command(value !== null && typeof value !== "undefined", 'missing uniform "' + name + '"', env.commandStr);
                if (type === GL_SAMPLER_2D || type === GL_SAMPLER_CUBE) {
                  check$1.command(typeof value === "function" && (type === GL_SAMPLER_2D && (value._reglType === "texture2d" || value._reglType === "framebuffer") || type === GL_SAMPLER_CUBE && (value._reglType === "textureCube" || value._reglType === "framebufferCube")), "invalid texture for uniform " + name, env.commandStr);
                  var TEX_VALUE = env.link(value._texture || value.color[0]._texture);
                  scope(GL, ".uniform1i(", LOCATION, ",", TEX_VALUE + ".bind());");
                  scope.exit(TEX_VALUE, ".unbind();");
                } else if (type === GL_FLOAT_MAT2 || type === GL_FLOAT_MAT3 || type === GL_FLOAT_MAT4) {
                  check$1.optional(function() {
                    check$1.command(isArrayLike2(value), "invalid matrix for uniform " + name, env.commandStr);
                    check$1.command(type === GL_FLOAT_MAT2 && value.length === 4 || type === GL_FLOAT_MAT3 && value.length === 9 || type === GL_FLOAT_MAT4 && value.length === 16, "invalid length for matrix uniform " + name, env.commandStr);
                  });
                  var MAT_VALUE = env.global.def("new Float32Array([" + Array.prototype.slice.call(value) + "])");
                  var dim = 2;
                  if (type === GL_FLOAT_MAT3) {
                    dim = 3;
                  } else if (type === GL_FLOAT_MAT4) {
                    dim = 4;
                  }
                  scope(GL, ".uniformMatrix", dim, "fv(", LOCATION, ",false,", MAT_VALUE, ");");
                } else {
                  switch (type) {
                    case GL_FLOAT$8:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1f";
                      break;
                    case GL_FLOAT_VEC2:
                      check$1.command(isArrayLike2(value) && value.length === 2, "uniform " + name, env.commandStr);
                      infix = "2f";
                      break;
                    case GL_FLOAT_VEC3:
                      check$1.command(isArrayLike2(value) && value.length === 3, "uniform " + name, env.commandStr);
                      infix = "3f";
                      break;
                    case GL_FLOAT_VEC4:
                      check$1.command(isArrayLike2(value) && value.length === 4, "uniform " + name, env.commandStr);
                      infix = "4f";
                      break;
                    case GL_BOOL:
                      check$1.commandType(value, "boolean", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_INT$3:
                      check$1.commandType(value, "number", "uniform " + name, env.commandStr);
                      infix = "1i";
                      break;
                    case GL_BOOL_VEC2:
                      check$1.command(isArrayLike2(value) && value.length === 2, "uniform " + name, env.commandStr);
                      infix = "2i";
                      break;
                    case GL_INT_VEC2:
                      check$1.command(isArrayLike2(value) && value.length === 2, "uniform " + name, env.commandStr);
                      infix = "2i";
                      break;
                    case GL_BOOL_VEC3:
                      check$1.command(isArrayLike2(value) && value.length === 3, "uniform " + name, env.commandStr);
                      infix = "3i";
                      break;
                    case GL_INT_VEC3:
                      check$1.command(isArrayLike2(value) && value.length === 3, "uniform " + name, env.commandStr);
                      infix = "3i";
                      break;
                    case GL_BOOL_VEC4:
                      check$1.command(isArrayLike2(value) && value.length === 4, "uniform " + name, env.commandStr);
                      infix = "4i";
                      break;
                    case GL_INT_VEC4:
                      check$1.command(isArrayLike2(value) && value.length === 4, "uniform " + name, env.commandStr);
                      infix = "4i";
                      break;
                  }
                  scope(GL, ".uniform", infix, "(", LOCATION, ",", isArrayLike2(value) ? Array.prototype.slice.call(value) : value, ");");
                }
                continue;
              } else {
                VALUE = arg.append(env, scope);
              }
            } else {
              if (!filter2(SCOPE_DECL)) {
                continue;
              }
              VALUE = scope.def(shared.uniforms, "[", stringStore.id(name), "]");
            }
            if (type === GL_SAMPLER_2D) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for textures");
              scope("if(", VALUE, "&&", VALUE, '._reglType==="framebuffer"){', VALUE, "=", VALUE, ".color[0];", "}");
            } else if (type === GL_SAMPLER_CUBE) {
              check$1(!Array.isArray(VALUE), "must specify a scalar prop for cube maps");
              scope("if(", VALUE, "&&", VALUE, '._reglType==="framebufferCube"){', VALUE, "=", VALUE, ".color[0];", "}");
            }
            check$1.optional(function() {
              function emitCheck(pred, message) {
                env.assert(scope, pred, 'bad data or missing for uniform "' + name + '".  ' + message);
              }
              function checkType(type2) {
                check$1(!Array.isArray(VALUE), "must not specify an array type for uniform");
                emitCheck("typeof " + VALUE + '==="' + type2 + '"', "invalid type, expected " + type2);
              }
              function checkVector(n2, type2) {
                if (Array.isArray(VALUE)) {
                  check$1(VALUE.length === n2, "must have length " + n2);
                } else {
                  emitCheck(shared.isArrayLike + "(" + VALUE + ")&&" + VALUE + ".length===" + n2, "invalid vector, should have length " + n2, env.commandStr);
                }
              }
              function checkTexture(target) {
                check$1(!Array.isArray(VALUE), "must not specify a value type");
                emitCheck("typeof " + VALUE + '==="function"&&' + VALUE + '._reglType==="texture' + (target === GL_TEXTURE_2D$3 ? "2d" : "Cube") + '"', "invalid texture type", env.commandStr);
              }
              switch (type) {
                case GL_INT$3:
                  checkType("number");
                  break;
                case GL_INT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_INT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_INT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT$8:
                  checkType("number");
                  break;
                case GL_FLOAT_VEC2:
                  checkVector(2, "number");
                  break;
                case GL_FLOAT_VEC3:
                  checkVector(3, "number");
                  break;
                case GL_FLOAT_VEC4:
                  checkVector(4, "number");
                  break;
                case GL_BOOL:
                  checkType("boolean");
                  break;
                case GL_BOOL_VEC2:
                  checkVector(2, "boolean");
                  break;
                case GL_BOOL_VEC3:
                  checkVector(3, "boolean");
                  break;
                case GL_BOOL_VEC4:
                  checkVector(4, "boolean");
                  break;
                case GL_FLOAT_MAT2:
                  checkVector(4, "number");
                  break;
                case GL_FLOAT_MAT3:
                  checkVector(9, "number");
                  break;
                case GL_FLOAT_MAT4:
                  checkVector(16, "number");
                  break;
                case GL_SAMPLER_2D:
                  checkTexture(GL_TEXTURE_2D$3);
                  break;
                case GL_SAMPLER_CUBE:
                  checkTexture(GL_TEXTURE_CUBE_MAP$2);
                  break;
              }
            });
            var unroll = 1;
            switch (type) {
              case GL_SAMPLER_2D:
              case GL_SAMPLER_CUBE:
                var TEX = scope.def(VALUE, "._texture");
                scope(GL, ".uniform1i(", LOCATION, ",", TEX, ".bind());");
                scope.exit(TEX, ".unbind();");
                continue;
              case GL_INT$3:
              case GL_BOOL:
                infix = "1i";
                break;
              case GL_INT_VEC2:
              case GL_BOOL_VEC2:
                infix = "2i";
                unroll = 2;
                break;
              case GL_INT_VEC3:
              case GL_BOOL_VEC3:
                infix = "3i";
                unroll = 3;
                break;
              case GL_INT_VEC4:
              case GL_BOOL_VEC4:
                infix = "4i";
                unroll = 4;
                break;
              case GL_FLOAT$8:
                infix = "1f";
                break;
              case GL_FLOAT_VEC2:
                infix = "2f";
                unroll = 2;
                break;
              case GL_FLOAT_VEC3:
                infix = "3f";
                unroll = 3;
                break;
              case GL_FLOAT_VEC4:
                infix = "4f";
                unroll = 4;
                break;
              case GL_FLOAT_MAT2:
                infix = "Matrix2fv";
                break;
              case GL_FLOAT_MAT3:
                infix = "Matrix3fv";
                break;
              case GL_FLOAT_MAT4:
                infix = "Matrix4fv";
                break;
            }
            scope(GL, ".uniform", infix, "(", LOCATION, ",");
            if (infix.charAt(0) === "M") {
              var matSize = Math.pow(type - GL_FLOAT_MAT2 + 2, 2);
              var STORAGE = env.global.def("new Float32Array(", matSize, ")");
              if (Array.isArray(VALUE)) {
                scope("false,(", loop(matSize, function(i3) {
                  return STORAGE + "[" + i3 + "]=" + VALUE[i3];
                }), ",", STORAGE, ")");
              } else {
                scope("false,(Array.isArray(", VALUE, ")||", VALUE, " instanceof Float32Array)?", VALUE, ":(", loop(matSize, function(i3) {
                  return STORAGE + "[" + i3 + "]=" + VALUE + "[" + i3 + "]";
                }), ",", STORAGE, ")");
              }
            } else if (unroll > 1) {
              scope(loop(unroll, function(i3) {
                return Array.isArray(VALUE) ? VALUE[i3] : VALUE + "[" + i3 + "]";
              }));
            } else {
              check$1(!Array.isArray(VALUE), "uniform value must not be an array");
              scope(VALUE);
            }
            scope(");");
          }
        }
        function emitDraw(env, outer, inner, args) {
          var shared = env.shared;
          var GL = shared.gl;
          var DRAW_STATE = shared.draw;
          var drawOptions = args.draw;
          function emitElements() {
            var defn = drawOptions.elements;
            var ELEMENTS2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              ELEMENTS2 = defn.append(env, scope);
            } else {
              ELEMENTS2 = scope.def(DRAW_STATE, ".", S_ELEMENTS);
            }
            if (ELEMENTS2) {
              scope("if(" + ELEMENTS2 + ")" + GL + ".bindBuffer(" + GL_ELEMENT_ARRAY_BUFFER$1 + "," + ELEMENTS2 + ".buffer.buffer);");
            }
            return ELEMENTS2;
          }
          function emitCount() {
            var defn = drawOptions.count;
            var COUNT2;
            var scope = outer;
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                scope = inner;
              }
              COUNT2 = defn.append(env, scope);
              check$1.optional(function() {
                if (defn.MISSING) {
                  env.assert(outer, "false", "missing vertex count");
                }
                if (defn.DYNAMIC) {
                  env.assert(scope, COUNT2 + ">=0", "missing vertex count");
                }
              });
            } else {
              COUNT2 = scope.def(DRAW_STATE, ".", S_COUNT);
              check$1.optional(function() {
                env.assert(scope, COUNT2 + ">=0", "missing vertex count");
              });
            }
            return COUNT2;
          }
          var ELEMENTS = emitElements();
          function emitValue(name) {
            var defn = drawOptions[name];
            if (defn) {
              if (defn.contextDep && args.contextDynamic || defn.propDep) {
                return defn.append(env, inner);
              } else {
                return defn.append(env, outer);
              }
            } else {
              return outer.def(DRAW_STATE, ".", name);
            }
          }
          var PRIMITIVE = emitValue(S_PRIMITIVE);
          var OFFSET = emitValue(S_OFFSET);
          var COUNT = emitCount();
          if (typeof COUNT === "number") {
            if (COUNT === 0) {
              return;
            }
          } else {
            inner("if(", COUNT, "){");
            inner.exit("}");
          }
          var INSTANCES, EXT_INSTANCING;
          if (extInstancing) {
            INSTANCES = emitValue(S_INSTANCES);
            EXT_INSTANCING = env.instancing;
          }
          var ELEMENT_TYPE = ELEMENTS + ".type";
          var elementsStatic = drawOptions.elements && isStatic(drawOptions.elements);
          function emitInstancing() {
            function drawElements() {
              inner(EXT_INSTANCING, ".drawElementsInstancedANGLE(", [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)",
                INSTANCES
              ], ");");
            }
            function drawArrays() {
              inner(EXT_INSTANCING, ".drawArraysInstancedANGLE(", [PRIMITIVE, OFFSET, COUNT, INSTANCES], ");");
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          function emitRegular() {
            function drawElements() {
              inner(GL + ".drawElements(" + [
                PRIMITIVE,
                COUNT,
                ELEMENT_TYPE,
                OFFSET + "<<((" + ELEMENT_TYPE + "-" + GL_UNSIGNED_BYTE$8 + ")>>1)"
              ] + ");");
            }
            function drawArrays() {
              inner(GL + ".drawArrays(" + [PRIMITIVE, OFFSET, COUNT] + ");");
            }
            if (ELEMENTS) {
              if (!elementsStatic) {
                inner("if(", ELEMENTS, "){");
                drawElements();
                inner("}else{");
                drawArrays();
                inner("}");
              } else {
                drawElements();
              }
            } else {
              drawArrays();
            }
          }
          if (extInstancing && (typeof INSTANCES !== "number" || INSTANCES >= 0)) {
            if (typeof INSTANCES === "string") {
              inner("if(", INSTANCES, ">0){");
              emitInstancing();
              inner("}else if(", INSTANCES, "<0){");
              emitRegular();
              inner("}");
            } else {
              emitInstancing();
            }
          } else {
            emitRegular();
          }
        }
        function createBody(emitBody, parentEnv, args, program, count) {
          var env = createREGLEnvironment();
          var scope = env.proc("body", count);
          check$1.optional(function() {
            env.commandStr = parentEnv.commandStr;
            env.command = env.link(parentEnv.commandStr);
          });
          if (extInstancing) {
            env.instancing = scope.def(env.shared.extensions, ".angle_instanced_arrays");
          }
          emitBody(env, scope, args, program);
          return env.compile().body;
        }
        function emitDrawBody(env, draw4, args, program) {
          injectExtensions(env, draw4);
          if (args.useVAO) {
            if (args.drawVAO) {
              draw4(env.shared.vao, ".setVAO(", args.drawVAO.append(env, draw4), ");");
            } else {
              draw4(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
            }
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            emitAttributes(env, draw4, args, program.attributes, function() {
              return true;
            });
          }
          emitUniforms(env, draw4, args, program.uniforms, function() {
            return true;
          });
          emitDraw(env, draw4, draw4, args);
        }
        function emitDrawProc(env, args) {
          var draw4 = env.proc("draw", 1);
          injectExtensions(env, draw4);
          emitContext(env, draw4, args.context);
          emitPollFramebuffer(env, draw4, args.framebuffer);
          emitPollState(env, draw4, args);
          emitSetOptions(env, draw4, args.state);
          emitProfile(env, draw4, args, false, true);
          var program = args.shader.progVar.append(env, draw4);
          draw4(env.shared.gl, ".useProgram(", program, ".program);");
          if (args.shader.program) {
            emitDrawBody(env, draw4, args, args.shader.program);
          } else {
            draw4(env.shared.vao, ".setVAO(null);");
            var drawCache = env.global.def("{}");
            var PROG_ID = draw4.def(program, ".id");
            var CACHED_PROC = draw4.def(drawCache, "[", PROG_ID, "]");
            draw4(env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0);").else(CACHED_PROC, "=", drawCache, "[", PROG_ID, "]=", env.link(function(program2) {
              return createBody(emitDrawBody, env, args, program2, 1);
            }), "(", program, ");", CACHED_PROC, ".call(this,a0);"));
          }
          if (Object.keys(args.state).length > 0) {
            draw4(env.shared.current, ".dirty=true;");
          }
        }
        function emitBatchDynamicShaderBody(env, scope, args, program) {
          env.batchId = "a1";
          injectExtensions(env, scope);
          function all() {
            return true;
          }
          emitAttributes(env, scope, args, program.attributes, all);
          emitUniforms(env, scope, args, program.uniforms, all);
          emitDraw(env, scope, scope, args);
        }
        function emitBatchBody(env, scope, args, program) {
          injectExtensions(env, scope);
          var contextDynamic = args.contextDep;
          var BATCH_ID = scope.def();
          var PROP_LIST = "a0";
          var NUM_PROPS = "a1";
          var PROPS = scope.def();
          env.shared.props = PROPS;
          env.batchId = BATCH_ID;
          var outer = env.scope();
          var inner = env.scope();
          scope(outer.entry, "for(", BATCH_ID, "=0;", BATCH_ID, "<", NUM_PROPS, ";++", BATCH_ID, "){", PROPS, "=", PROP_LIST, "[", BATCH_ID, "];", inner, "}", outer.exit);
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          function isOuterDefn(defn) {
            return !isInnerDefn(defn);
          }
          if (args.needsContext) {
            emitContext(env, inner, args.context);
          }
          if (args.needsFramebuffer) {
            emitPollFramebuffer(env, inner, args.framebuffer);
          }
          emitSetOptions(env, inner, args.state, isInnerDefn);
          if (args.profile && isInnerDefn(args.profile)) {
            emitProfile(env, inner, args, false, true);
          }
          if (!program) {
            var progCache = env.global.def("{}");
            var PROGRAM = args.shader.progVar.append(env, inner);
            var PROG_ID = inner.def(PROGRAM, ".id");
            var CACHED_PROC = inner.def(progCache, "[", PROG_ID, "]");
            inner(env.shared.gl, ".useProgram(", PROGRAM, ".program);", "if(!", CACHED_PROC, "){", CACHED_PROC, "=", progCache, "[", PROG_ID, "]=", env.link(function(program2) {
              return createBody(emitBatchDynamicShaderBody, env, args, program2, 2);
            }), "(", PROGRAM, ");}", CACHED_PROC, ".call(this,a0[", BATCH_ID, "],", BATCH_ID, ");");
          } else {
            if (args.useVAO) {
              if (args.drawVAO) {
                if (isInnerDefn(args.drawVAO)) {
                  inner(env.shared.vao, ".setVAO(", args.drawVAO.append(env, inner), ");");
                } else {
                  outer(env.shared.vao, ".setVAO(", args.drawVAO.append(env, outer), ");");
                }
              } else {
                outer(env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
              }
            } else {
              outer(env.shared.vao, ".setVAO(null);");
              emitAttributes(env, outer, args, program.attributes, isOuterDefn);
              emitAttributes(env, inner, args, program.attributes, isInnerDefn);
            }
            emitUniforms(env, outer, args, program.uniforms, isOuterDefn);
            emitUniforms(env, inner, args, program.uniforms, isInnerDefn);
            emitDraw(env, outer, inner, args);
          }
        }
        function emitBatchProc(env, args) {
          var batch = env.proc("batch", 2);
          env.batchId = "0";
          injectExtensions(env, batch);
          var contextDynamic = false;
          var needsContext = true;
          Object.keys(args.context).forEach(function(name) {
            contextDynamic = contextDynamic || args.context[name].propDep;
          });
          if (!contextDynamic) {
            emitContext(env, batch, args.context);
            needsContext = false;
          }
          var framebuffer = args.framebuffer;
          var needsFramebuffer = false;
          if (framebuffer) {
            if (framebuffer.propDep) {
              contextDynamic = needsFramebuffer = true;
            } else if (framebuffer.contextDep && contextDynamic) {
              needsFramebuffer = true;
            }
            if (!needsFramebuffer) {
              emitPollFramebuffer(env, batch, framebuffer);
            }
          } else {
            emitPollFramebuffer(env, batch, null);
          }
          if (args.state.viewport && args.state.viewport.propDep) {
            contextDynamic = true;
          }
          function isInnerDefn(defn) {
            return defn.contextDep && contextDynamic || defn.propDep;
          }
          emitPollState(env, batch, args);
          emitSetOptions(env, batch, args.state, function(defn) {
            return !isInnerDefn(defn);
          });
          if (!args.profile || !isInnerDefn(args.profile)) {
            emitProfile(env, batch, args, false, "a1");
          }
          args.contextDep = contextDynamic;
          args.needsContext = needsContext;
          args.needsFramebuffer = needsFramebuffer;
          var progDefn = args.shader.progVar;
          if (progDefn.contextDep && contextDynamic || progDefn.propDep) {
            emitBatchBody(env, batch, args, null);
          } else {
            var PROGRAM = progDefn.append(env, batch);
            batch(env.shared.gl, ".useProgram(", PROGRAM, ".program);");
            if (args.shader.program) {
              emitBatchBody(env, batch, args, args.shader.program);
            } else {
              batch(env.shared.vao, ".setVAO(null);");
              var batchCache = env.global.def("{}");
              var PROG_ID = batch.def(PROGRAM, ".id");
              var CACHED_PROC = batch.def(batchCache, "[", PROG_ID, "]");
              batch(env.cond(CACHED_PROC).then(CACHED_PROC, ".call(this,a0,a1);").else(CACHED_PROC, "=", batchCache, "[", PROG_ID, "]=", env.link(function(program) {
                return createBody(emitBatchBody, env, args, program, 2);
              }), "(", PROGRAM, ");", CACHED_PROC, ".call(this,a0,a1);"));
            }
          }
          if (Object.keys(args.state).length > 0) {
            batch(env.shared.current, ".dirty=true;");
          }
        }
        function emitScopeProc(env, args) {
          var scope = env.proc("scope", 3);
          env.batchId = "a2";
          var shared = env.shared;
          var CURRENT_STATE = shared.current;
          emitContext(env, scope, args.context);
          if (args.framebuffer) {
            args.framebuffer.append(env, scope);
          }
          sortState(Object.keys(args.state)).forEach(function(name) {
            var defn = args.state[name];
            var value = defn.append(env, scope);
            if (isArrayLike2(value)) {
              value.forEach(function(v2, i2) {
                scope.set(env.next[name], "[" + i2 + "]", v2);
              });
            } else {
              scope.set(shared.next, "." + name, value);
            }
          });
          emitProfile(env, scope, args, true, true);
          [S_ELEMENTS, S_OFFSET, S_COUNT, S_INSTANCES, S_PRIMITIVE].forEach(function(opt) {
            var variable = args.draw[opt];
            if (!variable) {
              return;
            }
            scope.set(shared.draw, "." + opt, "" + variable.append(env, scope));
          });
          Object.keys(args.uniforms).forEach(function(opt) {
            var value = args.uniforms[opt].append(env, scope);
            if (Array.isArray(value)) {
              value = "[" + value.join() + "]";
            }
            scope.set(shared.uniforms, "[" + stringStore.id(opt) + "]", value);
          });
          Object.keys(args.attributes).forEach(function(name) {
            var record = args.attributes[name].append(env, scope);
            var scopeAttrib = env.scopeAttrib(name);
            Object.keys(new AttributeRecord2()).forEach(function(prop) {
              scope.set(scopeAttrib, "." + prop, record[prop]);
            });
          });
          if (args.scopeVAO) {
            scope.set(shared.vao, ".targetVAO", args.scopeVAO.append(env, scope));
          }
          function saveShader(name) {
            var shader = args.shader[name];
            if (shader) {
              scope.set(shared.shader, "." + name, shader.append(env, scope));
            }
          }
          saveShader(S_VERT);
          saveShader(S_FRAG);
          if (Object.keys(args.state).length > 0) {
            scope(CURRENT_STATE, ".dirty=true;");
            scope.exit(CURRENT_STATE, ".dirty=true;");
          }
          scope("a1(", env.shared.context, ",a0,", env.batchId, ");");
        }
        function isDynamicObject(object) {
          if (typeof object !== "object" || isArrayLike2(object)) {
            return;
          }
          var props = Object.keys(object);
          for (var i2 = 0; i2 < props.length; ++i2) {
            if (dynamic.isDynamic(object[props[i2]])) {
              return true;
            }
          }
          return false;
        }
        function splatObject(env, options, name) {
          var object = options.static[name];
          if (!object || !isDynamicObject(object)) {
            return;
          }
          var globals = env.global;
          var keys2 = Object.keys(object);
          var thisDep = false;
          var contextDep = false;
          var propDep = false;
          var objectRef = env.global.def("{}");
          keys2.forEach(function(key) {
            var value = object[key];
            if (dynamic.isDynamic(value)) {
              if (typeof value === "function") {
                value = object[key] = dynamic.unbox(value);
              }
              var deps = createDynamicDecl(value, null);
              thisDep = thisDep || deps.thisDep;
              propDep = propDep || deps.propDep;
              contextDep = contextDep || deps.contextDep;
            } else {
              globals(objectRef, ".", key, "=");
              switch (typeof value) {
                case "number":
                  globals(value);
                  break;
                case "string":
                  globals('"', value, '"');
                  break;
                case "object":
                  if (Array.isArray(value)) {
                    globals("[", value.join(), "]");
                  }
                  break;
                default:
                  globals(env.link(value));
                  break;
              }
              globals(";");
            }
          });
          function appendBlock(env2, block) {
            keys2.forEach(function(key) {
              var value = object[key];
              if (!dynamic.isDynamic(value)) {
                return;
              }
              var ref = env2.invoke(block, value);
              block(objectRef, ".", key, "=", ref, ";");
            });
          }
          options.dynamic[name] = new dynamic.DynamicVariable(DYN_THUNK, {
            thisDep,
            contextDep,
            propDep,
            ref: objectRef,
            append: appendBlock
          });
          delete options.static[name];
        }
        function compileCommand(options, attributes, uniforms, context, stats2) {
          var env = createREGLEnvironment();
          env.stats = env.link(stats2);
          Object.keys(attributes.static).forEach(function(key) {
            splatObject(env, attributes, key);
          });
          NESTED_OPTIONS.forEach(function(name) {
            splatObject(env, options, name);
          });
          var args = parseArguments(options, attributes, uniforms, context, env);
          emitDrawProc(env, args);
          emitScopeProc(env, args);
          emitBatchProc(env, args);
          return extend3(env.compile(), {
            destroy: function() {
              args.shader.program.destroy();
            }
          });
        }
        return {
          next: nextState,
          current: currentState,
          procs: function() {
            var env = createREGLEnvironment();
            var poll = env.proc("poll");
            var refresh = env.proc("refresh");
            var common = env.block();
            poll(common);
            refresh(common);
            var shared = env.shared;
            var GL = shared.gl;
            var NEXT_STATE = shared.next;
            var CURRENT_STATE = shared.current;
            common(CURRENT_STATE, ".dirty=false;");
            emitPollFramebuffer(env, poll);
            emitPollFramebuffer(env, refresh, null, true);
            var INSTANCING;
            if (extInstancing) {
              INSTANCING = env.link(extInstancing);
            }
            if (extensions.oes_vertex_array_object) {
              refresh(env.link(extensions.oes_vertex_array_object), ".bindVertexArrayOES(null);");
            }
            for (var i2 = 0; i2 < limits.maxAttributes; ++i2) {
              var BINDING = refresh.def(shared.attributes, "[", i2, "]");
              var ifte = env.cond(BINDING, ".buffer");
              ifte.then(GL, ".enableVertexAttribArray(", i2, ");", GL, ".bindBuffer(", GL_ARRAY_BUFFER$2, ",", BINDING, ".buffer.buffer);", GL, ".vertexAttribPointer(", i2, ",", BINDING, ".size,", BINDING, ".type,", BINDING, ".normalized,", BINDING, ".stride,", BINDING, ".offset);").else(GL, ".disableVertexAttribArray(", i2, ");", GL, ".vertexAttrib4f(", i2, ",", BINDING, ".x,", BINDING, ".y,", BINDING, ".z,", BINDING, ".w);", BINDING, ".buffer=null;");
              refresh(ifte);
              if (extInstancing) {
                refresh(INSTANCING, ".vertexAttribDivisorANGLE(", i2, ",", BINDING, ".divisor);");
              }
            }
            refresh(env.shared.vao, ".currentVAO=null;", env.shared.vao, ".setVAO(", env.shared.vao, ".targetVAO);");
            Object.keys(GL_FLAGS).forEach(function(flag) {
              var cap = GL_FLAGS[flag];
              var NEXT = common.def(NEXT_STATE, ".", flag);
              var block = env.block();
              block("if(", NEXT, "){", GL, ".enable(", cap, ")}else{", GL, ".disable(", cap, ")}", CURRENT_STATE, ".", flag, "=", NEXT, ";");
              refresh(block);
              poll("if(", NEXT, "!==", CURRENT_STATE, ".", flag, "){", block, "}");
            });
            Object.keys(GL_VARIABLES).forEach(function(name) {
              var func = GL_VARIABLES[name];
              var init = currentState[name];
              var NEXT, CURRENT;
              var block = env.block();
              block(GL, ".", func, "(");
              if (isArrayLike2(init)) {
                var n2 = init.length;
                NEXT = env.global.def(NEXT_STATE, ".", name);
                CURRENT = env.global.def(CURRENT_STATE, ".", name);
                block(loop(n2, function(i3) {
                  return NEXT + "[" + i3 + "]";
                }), ");", loop(n2, function(i3) {
                  return CURRENT + "[" + i3 + "]=" + NEXT + "[" + i3 + "];";
                }).join(""));
                poll("if(", loop(n2, function(i3) {
                  return NEXT + "[" + i3 + "]!==" + CURRENT + "[" + i3 + "]";
                }).join("||"), "){", block, "}");
              } else {
                NEXT = common.def(NEXT_STATE, ".", name);
                CURRENT = common.def(CURRENT_STATE, ".", name);
                block(NEXT, ");", CURRENT_STATE, ".", name, "=", NEXT, ";");
                poll("if(", NEXT, "!==", CURRENT, "){", block, "}");
              }
              refresh(block);
            });
            return env.compile();
          }(),
          compile: compileCommand
        };
      }
      function stats() {
        return {
          vaoCount: 0,
          bufferCount: 0,
          elementsCount: 0,
          framebufferCount: 0,
          shaderCount: 0,
          textureCount: 0,
          cubeCount: 0,
          renderbufferCount: 0,
          maxTextureUnits: 0
        };
      }
      var GL_QUERY_RESULT_EXT = 34918;
      var GL_QUERY_RESULT_AVAILABLE_EXT = 34919;
      var GL_TIME_ELAPSED_EXT = 35007;
      var createTimer = function(gl2, extensions) {
        if (!extensions.ext_disjoint_timer_query) {
          return null;
        }
        var queryPool = [];
        function allocQuery() {
          return queryPool.pop() || extensions.ext_disjoint_timer_query.createQueryEXT();
        }
        function freeQuery(query) {
          queryPool.push(query);
        }
        var pendingQueries = [];
        function beginQuery(stats2) {
          var query = allocQuery();
          extensions.ext_disjoint_timer_query.beginQueryEXT(GL_TIME_ELAPSED_EXT, query);
          pendingQueries.push(query);
          pushScopeStats(pendingQueries.length - 1, pendingQueries.length, stats2);
        }
        function endQuery() {
          extensions.ext_disjoint_timer_query.endQueryEXT(GL_TIME_ELAPSED_EXT);
        }
        function PendingStats() {
          this.startQueryIndex = -1;
          this.endQueryIndex = -1;
          this.sum = 0;
          this.stats = null;
        }
        var pendingStatsPool = [];
        function allocPendingStats() {
          return pendingStatsPool.pop() || new PendingStats();
        }
        function freePendingStats(pendingStats2) {
          pendingStatsPool.push(pendingStats2);
        }
        var pendingStats = [];
        function pushScopeStats(start, end2, stats2) {
          var ps = allocPendingStats();
          ps.startQueryIndex = start;
          ps.endQueryIndex = end2;
          ps.sum = 0;
          ps.stats = stats2;
          pendingStats.push(ps);
        }
        var timeSum = [];
        var queryPtr = [];
        function update15() {
          var ptr, i2;
          var n2 = pendingQueries.length;
          if (n2 === 0) {
            return;
          }
          queryPtr.length = Math.max(queryPtr.length, n2 + 1);
          timeSum.length = Math.max(timeSum.length, n2 + 1);
          timeSum[0] = 0;
          queryPtr[0] = 0;
          var queryTime = 0;
          ptr = 0;
          for (i2 = 0; i2 < pendingQueries.length; ++i2) {
            var query = pendingQueries[i2];
            if (extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_AVAILABLE_EXT)) {
              queryTime += extensions.ext_disjoint_timer_query.getQueryObjectEXT(query, GL_QUERY_RESULT_EXT);
              freeQuery(query);
            } else {
              pendingQueries[ptr++] = query;
            }
            timeSum[i2 + 1] = queryTime;
            queryPtr[i2 + 1] = ptr;
          }
          pendingQueries.length = ptr;
          ptr = 0;
          for (i2 = 0; i2 < pendingStats.length; ++i2) {
            var stats2 = pendingStats[i2];
            var start = stats2.startQueryIndex;
            var end2 = stats2.endQueryIndex;
            stats2.sum += timeSum[end2] - timeSum[start];
            var startPtr = queryPtr[start];
            var endPtr = queryPtr[end2];
            if (endPtr === startPtr) {
              stats2.stats.gpuTime += stats2.sum / 1e6;
              freePendingStats(stats2);
            } else {
              stats2.startQueryIndex = startPtr;
              stats2.endQueryIndex = endPtr;
              pendingStats[ptr++] = stats2;
            }
          }
          pendingStats.length = ptr;
        }
        return {
          beginQuery,
          endQuery,
          pushScopeStats,
          update: update15,
          getNumPendingQueries: function() {
            return pendingQueries.length;
          },
          clear: function() {
            queryPool.push.apply(queryPool, pendingQueries);
            for (var i2 = 0; i2 < queryPool.length; i2++) {
              extensions.ext_disjoint_timer_query.deleteQueryEXT(queryPool[i2]);
            }
            pendingQueries.length = 0;
            queryPool.length = 0;
          },
          restore: function() {
            pendingQueries.length = 0;
            queryPool.length = 0;
          }
        };
      };
      var GL_COLOR_BUFFER_BIT = 16384;
      var GL_DEPTH_BUFFER_BIT = 256;
      var GL_STENCIL_BUFFER_BIT = 1024;
      var GL_ARRAY_BUFFER = 34962;
      var CONTEXT_LOST_EVENT = "webglcontextlost";
      var CONTEXT_RESTORED_EVENT = "webglcontextrestored";
      var DYN_PROP = 1;
      var DYN_CONTEXT = 2;
      var DYN_STATE = 3;
      function find2(haystack, needle) {
        for (var i2 = 0; i2 < haystack.length; ++i2) {
          if (haystack[i2] === needle) {
            return i2;
          }
        }
        return -1;
      }
      function wrapREGL(args) {
        var config = parseArgs(args);
        if (!config) {
          return null;
        }
        var gl2 = config.gl;
        var glAttributes = gl2.getContextAttributes();
        var contextLost = gl2.isContextLost();
        var extensionState = createExtensionCache(gl2, config);
        if (!extensionState) {
          return null;
        }
        var stringStore = createStringStore();
        var stats$$1 = stats();
        var extensions = extensionState.extensions;
        var timer3 = createTimer(gl2, extensions);
        var START_TIME = clock2();
        var WIDTH = gl2.drawingBufferWidth;
        var HEIGHT = gl2.drawingBufferHeight;
        var contextState = {
          tick: 0,
          time: 0,
          viewportWidth: WIDTH,
          viewportHeight: HEIGHT,
          framebufferWidth: WIDTH,
          framebufferHeight: HEIGHT,
          drawingBufferWidth: WIDTH,
          drawingBufferHeight: HEIGHT,
          pixelRatio: config.pixelRatio
        };
        var uniformState = {};
        var drawState = {
          elements: null,
          primitive: 4,
          count: -1,
          offset: 0,
          instances: -1
        };
        var limits = wrapLimits(gl2, extensions);
        var bufferState = wrapBufferState(gl2, stats$$1, config, destroyBuffer);
        var attributeState = wrapAttributeState(gl2, extensions, limits, stats$$1, bufferState);
        function destroyBuffer(buffer) {
          return attributeState.destroyBuffer(buffer);
        }
        var elementState = wrapElementsState(gl2, extensions, bufferState, stats$$1);
        var shaderState = wrapShaderState(gl2, stringStore, stats$$1, config);
        var textureState = createTextureSet(gl2, extensions, limits, function() {
          core.procs.poll();
        }, contextState, stats$$1, config);
        var renderbufferState = wrapRenderbuffers(gl2, extensions, limits, stats$$1, config);
        var framebufferState = wrapFBOState(gl2, extensions, limits, textureState, renderbufferState, stats$$1);
        var core = reglCore(gl2, stringStore, extensions, limits, bufferState, elementState, textureState, framebufferState, uniformState, attributeState, shaderState, drawState, contextState, timer3, config);
        var readPixels = wrapReadPixels(gl2, framebufferState, core.procs.poll, contextState, glAttributes, extensions, limits);
        var nextState = core.next;
        var canvas = gl2.canvas;
        var rafCallbacks = [];
        var lossCallbacks = [];
        var restoreCallbacks = [];
        var destroyCallbacks = [config.onDestroy];
        var activeRAF = null;
        function handleRAF() {
          if (rafCallbacks.length === 0) {
            if (timer3) {
              timer3.update();
            }
            activeRAF = null;
            return;
          }
          activeRAF = raf.next(handleRAF);
          poll();
          for (var i2 = rafCallbacks.length - 1; i2 >= 0; --i2) {
            var cb = rafCallbacks[i2];
            if (cb) {
              cb(contextState, null, 0);
            }
          }
          gl2.flush();
          if (timer3) {
            timer3.update();
          }
        }
        function startRAF() {
          if (!activeRAF && rafCallbacks.length > 0) {
            activeRAF = raf.next(handleRAF);
          }
        }
        function stopRAF() {
          if (activeRAF) {
            raf.cancel(handleRAF);
            activeRAF = null;
          }
        }
        function handleContextLoss(event) {
          event.preventDefault();
          contextLost = true;
          stopRAF();
          lossCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function handleContextRestored(event) {
          gl2.getError();
          contextLost = false;
          extensionState.restore();
          shaderState.restore();
          bufferState.restore();
          textureState.restore();
          renderbufferState.restore();
          framebufferState.restore();
          attributeState.restore();
          if (timer3) {
            timer3.restore();
          }
          core.procs.refresh();
          startRAF();
          restoreCallbacks.forEach(function(cb) {
            cb();
          });
        }
        if (canvas) {
          canvas.addEventListener(CONTEXT_LOST_EVENT, handleContextLoss, false);
          canvas.addEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored, false);
        }
        function destroy() {
          rafCallbacks.length = 0;
          stopRAF();
          if (canvas) {
            canvas.removeEventListener(CONTEXT_LOST_EVENT, handleContextLoss);
            canvas.removeEventListener(CONTEXT_RESTORED_EVENT, handleContextRestored);
          }
          shaderState.clear();
          framebufferState.clear();
          renderbufferState.clear();
          textureState.clear();
          elementState.clear();
          bufferState.clear();
          attributeState.clear();
          if (timer3) {
            timer3.clear();
          }
          destroyCallbacks.forEach(function(cb) {
            cb();
          });
        }
        function compileProcedure(options) {
          check$1(!!options, "invalid args to regl({...})");
          check$1.type(options, "object", "invalid args to regl({...})");
          function flattenNestedOptions(options2) {
            var result = extend3({}, options2);
            delete result.uniforms;
            delete result.attributes;
            delete result.context;
            delete result.vao;
            if ("stencil" in result && result.stencil.op) {
              result.stencil.opBack = result.stencil.opFront = result.stencil.op;
              delete result.stencil.op;
            }
            function merge2(name) {
              if (name in result) {
                var child = result[name];
                delete result[name];
                Object.keys(child).forEach(function(prop) {
                  result[name + "." + prop] = child[prop];
                });
              }
            }
            merge2("blend");
            merge2("depth");
            merge2("cull");
            merge2("stencil");
            merge2("polygonOffset");
            merge2("scissor");
            merge2("sample");
            if ("vao" in options2) {
              result.vao = options2.vao;
            }
            return result;
          }
          function separateDynamic(object, useArrays) {
            var staticItems = {};
            var dynamicItems = {};
            Object.keys(object).forEach(function(option) {
              var value = object[option];
              if (dynamic.isDynamic(value)) {
                dynamicItems[option] = dynamic.unbox(value, option);
                return;
              } else if (useArrays && Array.isArray(value)) {
                for (var i2 = 0; i2 < value.length; ++i2) {
                  if (dynamic.isDynamic(value[i2])) {
                    dynamicItems[option] = dynamic.unbox(value, option);
                    return;
                  }
                }
              }
              staticItems[option] = value;
            });
            return {
              dynamic: dynamicItems,
              static: staticItems
            };
          }
          var context = separateDynamic(options.context || {}, true);
          var uniforms = separateDynamic(options.uniforms || {}, true);
          var attributes = separateDynamic(options.attributes || {}, false);
          var opts = separateDynamic(flattenNestedOptions(options), false);
          var stats$$12 = {
            gpuTime: 0,
            cpuTime: 0,
            count: 0
          };
          var compiled = core.compile(opts, attributes, uniforms, context, stats$$12);
          var draw4 = compiled.draw;
          var batch = compiled.batch;
          var scope = compiled.scope;
          var EMPTY_ARRAY = [];
          function reserve(count) {
            while (EMPTY_ARRAY.length < count) {
              EMPTY_ARRAY.push(null);
            }
            return EMPTY_ARRAY;
          }
          function REGLCommand(args2, body) {
            var i2;
            if (contextLost) {
              check$1.raise("context lost");
            }
            if (typeof args2 === "function") {
              return scope.call(this, null, args2, 0);
            } else if (typeof body === "function") {
              if (typeof args2 === "number") {
                for (i2 = 0; i2 < args2; ++i2) {
                  scope.call(this, null, body, i2);
                }
              } else if (Array.isArray(args2)) {
                for (i2 = 0; i2 < args2.length; ++i2) {
                  scope.call(this, args2[i2], body, i2);
                }
              } else {
                return scope.call(this, args2, body, 0);
              }
            } else if (typeof args2 === "number") {
              if (args2 > 0) {
                return batch.call(this, reserve(args2 | 0), args2 | 0);
              }
            } else if (Array.isArray(args2)) {
              if (args2.length) {
                return batch.call(this, args2, args2.length);
              }
            } else {
              return draw4.call(this, args2);
            }
          }
          return extend3(REGLCommand, {
            stats: stats$$12,
            destroy: function() {
              compiled.destroy();
            }
          });
        }
        var setFBO = framebufferState.setFBO = compileProcedure({
          framebuffer: dynamic.define.call(null, DYN_PROP, "framebuffer")
        });
        function clearImpl(_2, options) {
          var clearFlags = 0;
          core.procs.poll();
          var c2 = options.color;
          if (c2) {
            gl2.clearColor(+c2[0] || 0, +c2[1] || 0, +c2[2] || 0, +c2[3] || 0);
            clearFlags |= GL_COLOR_BUFFER_BIT;
          }
          if ("depth" in options) {
            gl2.clearDepth(+options.depth);
            clearFlags |= GL_DEPTH_BUFFER_BIT;
          }
          if ("stencil" in options) {
            gl2.clearStencil(options.stencil | 0);
            clearFlags |= GL_STENCIL_BUFFER_BIT;
          }
          check$1(!!clearFlags, "called regl.clear with no buffer specified");
          gl2.clear(clearFlags);
        }
        function clear(options) {
          check$1(typeof options === "object" && options, "regl.clear() takes an object as input");
          if ("framebuffer" in options) {
            if (options.framebuffer && options.framebuffer_reglType === "framebufferCube") {
              for (var i2 = 0; i2 < 6; ++i2) {
                setFBO(extend3({
                  framebuffer: options.framebuffer.faces[i2]
                }, options), clearImpl);
              }
            } else {
              setFBO(options, clearImpl);
            }
          } else {
            clearImpl(null, options);
          }
        }
        function frame2(cb) {
          check$1.type(cb, "function", "regl.frame() callback must be a function");
          rafCallbacks.push(cb);
          function cancel() {
            var i2 = find2(rafCallbacks, cb);
            check$1(i2 >= 0, "cannot cancel a frame twice");
            function pendingCancel() {
              var index = find2(rafCallbacks, pendingCancel);
              rafCallbacks[index] = rafCallbacks[rafCallbacks.length - 1];
              rafCallbacks.length -= 1;
              if (rafCallbacks.length <= 0) {
                stopRAF();
              }
            }
            rafCallbacks[i2] = pendingCancel;
          }
          startRAF();
          return {
            cancel
          };
        }
        function pollViewport() {
          var viewport = nextState.viewport;
          var scissorBox = nextState.scissor_box;
          viewport[0] = viewport[1] = scissorBox[0] = scissorBox[1] = 0;
          contextState.viewportWidth = contextState.framebufferWidth = contextState.drawingBufferWidth = viewport[2] = scissorBox[2] = gl2.drawingBufferWidth;
          contextState.viewportHeight = contextState.framebufferHeight = contextState.drawingBufferHeight = viewport[3] = scissorBox[3] = gl2.drawingBufferHeight;
        }
        function poll() {
          contextState.tick += 1;
          contextState.time = now2();
          pollViewport();
          core.procs.poll();
        }
        function refresh() {
          textureState.refresh();
          pollViewport();
          core.procs.refresh();
          if (timer3) {
            timer3.update();
          }
        }
        function now2() {
          return (clock2() - START_TIME) / 1e3;
        }
        refresh();
        function addListener(event, callback) {
          check$1.type(callback, "function", "listener callback must be a function");
          var callbacks;
          switch (event) {
            case "frame":
              return frame2(callback);
            case "lost":
              callbacks = lossCallbacks;
              break;
            case "restore":
              callbacks = restoreCallbacks;
              break;
            case "destroy":
              callbacks = destroyCallbacks;
              break;
            default:
              check$1.raise("invalid event, must be one of frame,lost,restore,destroy");
          }
          callbacks.push(callback);
          return {
            cancel: function() {
              for (var i2 = 0; i2 < callbacks.length; ++i2) {
                if (callbacks[i2] === callback) {
                  callbacks[i2] = callbacks[callbacks.length - 1];
                  callbacks.pop();
                  return;
                }
              }
            }
          };
        }
        var regl2 = extend3(compileProcedure, {
          clear,
          prop: dynamic.define.bind(null, DYN_PROP),
          context: dynamic.define.bind(null, DYN_CONTEXT),
          this: dynamic.define.bind(null, DYN_STATE),
          draw: compileProcedure({}),
          buffer: function(options) {
            return bufferState.create(options, GL_ARRAY_BUFFER, false, false);
          },
          elements: function(options) {
            return elementState.create(options, false);
          },
          texture: textureState.create2D,
          cube: textureState.createCube,
          renderbuffer: renderbufferState.create,
          framebuffer: framebufferState.create,
          framebufferCube: framebufferState.createCube,
          vao: attributeState.createVAO,
          attributes: glAttributes,
          frame: frame2,
          on: addListener,
          limits,
          hasExtension: function(name) {
            return limits.extensions.indexOf(name.toLowerCase()) >= 0;
          },
          read: readPixels,
          destroy,
          _gl: gl2,
          _refresh: refresh,
          poll: function() {
            poll();
            if (timer3) {
              timer3.update();
            }
          },
          now: now2,
          stats: stats$$1
        });
        config.onDone(null, regl2);
        return regl2;
      }
      return wrapREGL;
    });
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js
var ReglAttribute;
var init_ReglAttribute = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglAttribute.js"() {
    init_classCallCheck();
    init_createClass();
    ReglAttribute = function() {
      function ReglAttribute2(gl2, options) {
        _classCallCheck(this, ReglAttribute2);
        this.attribute = void 0;
        this.buffer = void 0;
        var buffer = options.buffer, offset = options.offset, stride = options.stride, normalized = options.normalized, size2 = options.size, divisor = options.divisor;
        this.buffer = buffer;
        this.attribute = {
          buffer: buffer.get(),
          offset: offset || 0,
          stride: stride || 0,
          normalized: normalized || false,
          divisor: divisor || 0
        };
        if (size2) {
          this.attribute.size = size2;
        }
      }
      _createClass(ReglAttribute2, [{
        key: "get",
        value: function get2() {
          return this.attribute;
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(options) {
          this.buffer.subData(options);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }]);
      return ReglAttribute2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/constants.js
var _primitiveMap, _usageMap, _dataTypeMap, _formatMap, _mipmapMap, _filterMap, _wrapModeMap, _colorSpaceMap, _depthFuncMap, _blendEquationMap, _blendFuncMap, _stencilFuncMap, _stencilOpMap, _cullFaceMap, primitiveMap, usageMap, dataTypeMap, formatMap, mipmapMap, filterMap, wrapModeMap, colorSpaceMap, depthFuncMap, blendEquationMap, blendFuncMap, stencilFuncMap, stencilOpMap, cullFaceMap;
var init_constants = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/constants.js"() {
    init_defineProperty();
    init_es3();
    primitiveMap = (_primitiveMap = {}, _defineProperty(_primitiveMap, gl.POINTS, "points"), _defineProperty(_primitiveMap, gl.LINES, "lines"), _defineProperty(_primitiveMap, gl.LINE_LOOP, "line loop"), _defineProperty(_primitiveMap, gl.LINE_STRIP, "line strip"), _defineProperty(_primitiveMap, gl.TRIANGLES, "triangles"), _defineProperty(_primitiveMap, gl.TRIANGLE_FAN, "triangle fan"), _defineProperty(_primitiveMap, gl.TRIANGLE_STRIP, "triangle strip"), _primitiveMap);
    usageMap = (_usageMap = {}, _defineProperty(_usageMap, gl.STATIC_DRAW, "static"), _defineProperty(_usageMap, gl.DYNAMIC_DRAW, "dynamic"), _defineProperty(_usageMap, gl.STREAM_DRAW, "stream"), _usageMap);
    dataTypeMap = (_dataTypeMap = {}, _defineProperty(_dataTypeMap, gl.BYTE, "int8"), _defineProperty(_dataTypeMap, gl.UNSIGNED_INT, "int16"), _defineProperty(_dataTypeMap, gl.INT, "int32"), _defineProperty(_dataTypeMap, gl.UNSIGNED_BYTE, "uint8"), _defineProperty(_dataTypeMap, gl.UNSIGNED_SHORT, "uint16"), _defineProperty(_dataTypeMap, gl.UNSIGNED_INT, "uint32"), _defineProperty(_dataTypeMap, gl.FLOAT, "float"), _dataTypeMap);
    formatMap = (_formatMap = {}, _defineProperty(_formatMap, gl.ALPHA, "alpha"), _defineProperty(_formatMap, gl.LUMINANCE, "luminance"), _defineProperty(_formatMap, gl.LUMINANCE_ALPHA, "luminance alpha"), _defineProperty(_formatMap, gl.RGB, "rgb"), _defineProperty(_formatMap, gl.RGBA, "rgba"), _defineProperty(_formatMap, gl.RGBA4, "rgba4"), _defineProperty(_formatMap, gl.RGB5_A1, "rgb5 a1"), _defineProperty(_formatMap, gl.RGB565, "rgb565"), _defineProperty(_formatMap, gl.DEPTH_COMPONENT, "depth"), _defineProperty(_formatMap, gl.DEPTH_STENCIL, "depth stencil"), _formatMap);
    mipmapMap = (_mipmapMap = {}, _defineProperty(_mipmapMap, gl.DONT_CARE, "dont care"), _defineProperty(_mipmapMap, gl.NICEST, "nice"), _defineProperty(_mipmapMap, gl.FASTEST, "fast"), _mipmapMap);
    filterMap = (_filterMap = {}, _defineProperty(_filterMap, gl.NEAREST, "nearest"), _defineProperty(_filterMap, gl.LINEAR, "linear"), _defineProperty(_filterMap, gl.LINEAR_MIPMAP_LINEAR, "mipmap"), _defineProperty(_filterMap, gl.NEAREST_MIPMAP_LINEAR, "nearest mipmap linear"), _defineProperty(_filterMap, gl.LINEAR_MIPMAP_NEAREST, "linear mipmap nearest"), _defineProperty(_filterMap, gl.NEAREST_MIPMAP_NEAREST, "nearest mipmap nearest"), _filterMap);
    wrapModeMap = (_wrapModeMap = {}, _defineProperty(_wrapModeMap, gl.REPEAT, "repeat"), _defineProperty(_wrapModeMap, gl.CLAMP_TO_EDGE, "clamp"), _defineProperty(_wrapModeMap, gl.MIRRORED_REPEAT, "mirror"), _wrapModeMap);
    colorSpaceMap = (_colorSpaceMap = {}, _defineProperty(_colorSpaceMap, gl.NONE, "none"), _defineProperty(_colorSpaceMap, gl.BROWSER_DEFAULT_WEBGL, "browser"), _colorSpaceMap);
    depthFuncMap = (_depthFuncMap = {}, _defineProperty(_depthFuncMap, gl.NEVER, "never"), _defineProperty(_depthFuncMap, gl.ALWAYS, "always"), _defineProperty(_depthFuncMap, gl.LESS, "less"), _defineProperty(_depthFuncMap, gl.LEQUAL, "lequal"), _defineProperty(_depthFuncMap, gl.GREATER, "greater"), _defineProperty(_depthFuncMap, gl.GEQUAL, "gequal"), _defineProperty(_depthFuncMap, gl.EQUAL, "equal"), _defineProperty(_depthFuncMap, gl.NOTEQUAL, "notequal"), _depthFuncMap);
    blendEquationMap = (_blendEquationMap = {}, _defineProperty(_blendEquationMap, gl.FUNC_ADD, "add"), _defineProperty(_blendEquationMap, gl.MIN_EXT, "min"), _defineProperty(_blendEquationMap, gl.MAX_EXT, "max"), _defineProperty(_blendEquationMap, gl.FUNC_SUBTRACT, "subtract"), _defineProperty(_blendEquationMap, gl.FUNC_REVERSE_SUBTRACT, "reverse subtract"), _blendEquationMap);
    blendFuncMap = (_blendFuncMap = {}, _defineProperty(_blendFuncMap, gl.ZERO, "zero"), _defineProperty(_blendFuncMap, gl.ONE, "one"), _defineProperty(_blendFuncMap, gl.SRC_COLOR, "src color"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_SRC_COLOR, "one minus src color"), _defineProperty(_blendFuncMap, gl.SRC_ALPHA, "src alpha"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_SRC_ALPHA, "one minus src alpha"), _defineProperty(_blendFuncMap, gl.DST_COLOR, "dst color"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_DST_COLOR, "one minus dst color"), _defineProperty(_blendFuncMap, gl.DST_ALPHA, "dst alpha"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_DST_ALPHA, "one minus dst alpha"), _defineProperty(_blendFuncMap, gl.CONSTANT_COLOR, "constant color"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_CONSTANT_COLOR, "one minus constant color"), _defineProperty(_blendFuncMap, gl.CONSTANT_ALPHA, "constant alpha"), _defineProperty(_blendFuncMap, gl.ONE_MINUS_CONSTANT_ALPHA, "one minus constant alpha"), _defineProperty(_blendFuncMap, gl.SRC_ALPHA_SATURATE, "src alpha saturate"), _blendFuncMap);
    stencilFuncMap = (_stencilFuncMap = {}, _defineProperty(_stencilFuncMap, gl.NEVER, "never"), _defineProperty(_stencilFuncMap, gl.ALWAYS, "always"), _defineProperty(_stencilFuncMap, gl.LESS, "less"), _defineProperty(_stencilFuncMap, gl.LEQUAL, "lequal"), _defineProperty(_stencilFuncMap, gl.GREATER, "greater"), _defineProperty(_stencilFuncMap, gl.GEQUAL, "gequal"), _defineProperty(_stencilFuncMap, gl.EQUAL, "equal"), _defineProperty(_stencilFuncMap, gl.NOTEQUAL, "notequal"), _stencilFuncMap);
    stencilOpMap = (_stencilOpMap = {}, _defineProperty(_stencilOpMap, gl.ZERO, "zero"), _defineProperty(_stencilOpMap, gl.KEEP, "keep"), _defineProperty(_stencilOpMap, gl.REPLACE, "replace"), _defineProperty(_stencilOpMap, gl.INVERT, "invert"), _defineProperty(_stencilOpMap, gl.INCR, "increment"), _defineProperty(_stencilOpMap, gl.DECR, "decrement"), _defineProperty(_stencilOpMap, gl.INCR_WRAP, "increment wrap"), _defineProperty(_stencilOpMap, gl.DECR_WRAP, "decrement wrap"), _stencilOpMap);
    cullFaceMap = (_cullFaceMap = {}, _defineProperty(_cullFaceMap, gl.FRONT, "front"), _defineProperty(_cullFaceMap, gl.BACK, "back"), _cullFaceMap);
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js
var ReglBuffer;
var init_ReglBuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglBuffer.js"() {
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_constants();
    ReglBuffer = function() {
      function ReglBuffer2(reGl, options) {
        _classCallCheck(this, ReglBuffer2);
        this.buffer = void 0;
        var data = options.data, usage = options.usage, type = options.type;
        this.buffer = reGl.buffer({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE]
        });
      }
      _createClass(ReglBuffer2, [{
        key: "get",
        value: function get2() {
          return this.buffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "subData",
        value: function subData(_ref2) {
          var data = _ref2.data, offset = _ref2.offset;
          this.buffer.subdata(data, offset);
        }
      }]);
      return ReglBuffer2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/is-typedarray.js
function baseIsTypedArray3(value) {
  return isObjectLike4(value) && isLength3(value.length) && !!typedArrayTags3[objectToString3.call(value)];
}
function isLength3(value) {
  return typeof value === "number" && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER3;
}
function isObjectLike4(value) {
  return !!value && _typeof(value) === "object";
}
var MAX_SAFE_INTEGER3, argsTag3, arrayTag3, boolTag3, dateTag3, errorTag3, funcTag3, mapTag3, numberTag3, objectTag3, regexpTag3, setTag3, stringTag3, weakMapTag3, arrayBufferTag3, dataViewTag3, float32Tag3, float64Tag3, int8Tag3, int16Tag3, int32Tag3, uint8Tag3, uint8ClampedTag3, uint16Tag3, uint32Tag3, typedArrayTags3, objectProto4, objectToString3, isTypedArray3;
var init_is_typedarray3 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/is-typedarray.js"() {
    init_typeof();
    MAX_SAFE_INTEGER3 = 9007199254740991;
    argsTag3 = "[object Arguments]";
    arrayTag3 = "[object Array]";
    boolTag3 = "[object Boolean]";
    dateTag3 = "[object Date]";
    errorTag3 = "[object Error]";
    funcTag3 = "[object Function]";
    mapTag3 = "[object Map]";
    numberTag3 = "[object Number]";
    objectTag3 = "[object Object]";
    regexpTag3 = "[object RegExp]";
    setTag3 = "[object Set]";
    stringTag3 = "[object String]";
    weakMapTag3 = "[object WeakMap]";
    arrayBufferTag3 = "[object ArrayBuffer]";
    dataViewTag3 = "[object DataView]";
    float32Tag3 = "[object Float32Array]";
    float64Tag3 = "[object Float64Array]";
    int8Tag3 = "[object Int8Array]";
    int16Tag3 = "[object Int16Array]";
    int32Tag3 = "[object Int32Array]";
    uint8Tag3 = "[object Uint8Array]";
    uint8ClampedTag3 = "[object Uint8ClampedArray]";
    uint16Tag3 = "[object Uint16Array]";
    uint32Tag3 = "[object Uint32Array]";
    typedArrayTags3 = {};
    typedArrayTags3[float32Tag3] = typedArrayTags3[float64Tag3] = typedArrayTags3[int8Tag3] = typedArrayTags3[int16Tag3] = typedArrayTags3[int32Tag3] = typedArrayTags3[uint8Tag3] = typedArrayTags3[uint8ClampedTag3] = typedArrayTags3[uint16Tag3] = typedArrayTags3[uint32Tag3] = true;
    typedArrayTags3[argsTag3] = typedArrayTags3[arrayTag3] = typedArrayTags3[arrayBufferTag3] = typedArrayTags3[boolTag3] = typedArrayTags3[dataViewTag3] = typedArrayTags3[dateTag3] = typedArrayTags3[errorTag3] = typedArrayTags3[funcTag3] = typedArrayTags3[mapTag3] = typedArrayTags3[numberTag3] = typedArrayTags3[objectTag3] = typedArrayTags3[regexpTag3] = typedArrayTags3[setTag3] = typedArrayTags3[stringTag3] = typedArrayTags3[weakMapTag3] = false;
    objectProto4 = Object.prototype;
    objectToString3 = objectProto4.toString;
    isTypedArray3 = baseIsTypedArray3;
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js
function ownKeys7(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread7(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator12, quadVert, textureId, debug, ReglComputeModel;
var init_ReglComputeModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglComputeModel.js"() {
    init_toConsumableArray();
    init_defineProperty();
    import_regenerator12 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_is_typedarray3();
    quadVert = "attribute vec3 a_Position;\nattribute vec2 a_TexCoord;\n\nvarying vec2 v_TexCoord;\n\nvoid main() {\n  gl_Position = vec4(a_Position, 1.0);\n  v_TexCoord = a_TexCoord;\n}";
    textureId = 0;
    debug = false;
    ReglComputeModel = function() {
      function ReglComputeModel2(reGl, context) {
        var _this = this;
        _classCallCheck(this, ReglComputeModel2);
        this.reGl = reGl;
        this.context = context;
        this.entity = createEntity();
        this.texFBO = void 0;
        this.computeCommand = void 0;
        this.textureCache = {};
        this.outputTextureName = void 0;
        this.swapOutputTextureName = void 0;
        this.compiledPingpong = void 0;
        this.dynamicPingpong = void 0;
        var uniforms = {};
        this.context.uniforms.forEach(function(uniform) {
          var name = uniform.name, type = uniform.type, data = uniform.data, isReferer = uniform.isReferer, storageClass = uniform.storageClass;
          if (storageClass === STORAGE_CLASS.StorageBuffer) {
            if (!isReferer) {
              _this.textureCache[name] = _this.calcDataTexture(name, type, data);
              var _this$textureCache$na = _this.textureCache[name], width = _this$textureCache$na.textureWidth, isOutput = _this$textureCache$na.isOutput;
              uniforms["".concat(name, "Size")] = [width, width];
              if (isOutput) {
                _this.outputTextureName = name;
                if (_this.context.needPingpong) {
                  _this.outputTextureName = "".concat(name, "Output");
                  _this.textureCache[_this.outputTextureName] = _this.calcDataTexture(name, type, data);
                }
              }
            } else {
              _this.textureCache[name] = {
                data: void 0
              };
              uniforms["".concat(name, "Size")] = function() {
                return data.compiledBundle.context.output.textureSize;
              };
            }
            uniforms[name] = function() {
              if (debug) {
                console.log("[".concat(_this.entity, "]: ").concat(name, " ").concat(_this.textureCache[name].id));
              }
              return _this.textureCache[name].texture;
            };
          } else if (storageClass === STORAGE_CLASS.Uniform) {
            if (data && (Array.isArray(data) || isTypedArray3(data)) && data.length > 16) {
              throw new Error("invalid data type ".concat(type));
            }
            uniforms[name] = function() {
              return uniform.data;
            };
          }
        });
        var _this$getOuputDataTex = this.getOuputDataTexture(), textureWidth = _this$getOuputDataTex.textureWidth, texelCount = _this$getOuputDataTex.texelCount;
        uniforms.u_OutputTextureSize = [textureWidth, textureWidth];
        uniforms.u_OutputTexelCount = texelCount;
        this.context.output.textureSize = [textureWidth, textureWidth];
        var drawParams = {
          attributes: {
            a_Position: [[-1, 1, 0], [-1, -1, 0], [1, 1, 0], [1, -1, 0]],
            a_TexCoord: [[0, 1], [0, 0], [1, 1], [1, 0]]
          },
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(this.context.shader),
          uniforms,
          vert: quadVert,
          primitive: "triangle strip",
          count: 4
        };
        this.computeCommand = this.reGl(drawParams);
      }
      _createClass(ReglComputeModel2, [{
        key: "run",
        value: function run() {
          var _this2 = this;
          if (this.context.maxIteration > 1 && this.context.needPingpong) {
            this.compiledPingpong = true;
          }
          if (this.compiledPingpong || this.dynamicPingpong) {
            this.swap();
          }
          this.texFBO = this.reGl.framebuffer({
            color: this.getOuputDataTexture().texture
          });
          this.texFBO.use(function() {
            _this2.computeCommand();
          });
          if (debug) {
            console.log("[".concat(this.entity, "]: output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "readData",
        value: function() {
          var _readData = _asyncToGenerator(import_regenerator12.default.mark(function _callee() {
            var _this3 = this;
            var pixels, _this$getOuputDataTex2, originalDataLength, elementsPerTexel, _this$getOuputDataTex3, typedArrayConstructor, formattedPixels, i2;
            return import_regenerator12.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.reGl({
                      framebuffer: this.texFBO
                    })(function() {
                      pixels = _this3.reGl.read();
                    });
                    if (!pixels) {
                      _context.next = 6;
                      break;
                    }
                    _this$getOuputDataTex2 = this.getOuputDataTexture(), originalDataLength = _this$getOuputDataTex2.originalDataLength, elementsPerTexel = _this$getOuputDataTex2.elementsPerTexel, _this$getOuputDataTex3 = _this$getOuputDataTex2.typedArrayConstructor, typedArrayConstructor = _this$getOuputDataTex3 === void 0 ? Float32Array : _this$getOuputDataTex3;
                    formattedPixels = [];
                    if (elementsPerTexel !== 4) {
                      for (i2 = 0; i2 < pixels.length; i2 += 4) {
                        if (elementsPerTexel === 1) {
                          formattedPixels.push(pixels[i2]);
                        } else if (elementsPerTexel === 2) {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1]);
                        } else {
                          formattedPixels.push(pixels[i2], pixels[i2 + 1], pixels[i2 + 2]);
                        }
                      }
                    } else {
                      formattedPixels = pixels;
                    }
                    return _context.abrupt("return", new typedArrayConstructor(formattedPixels.slice(0, originalDataLength)));
                  case 6:
                    return _context.abrupt("return", new Float32Array());
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function readData() {
            return _readData.apply(this, arguments);
          }
          return readData;
        }()
      }, {
        key: "confirmInput",
        value: function confirmInput(model, inputName) {
          var inputModel;
          if (this.entity === model.entity) {
            this.dynamicPingpong = true;
            inputModel = this;
          } else {
            inputModel = model;
          }
          this.textureCache[inputName].id = inputModel.getOuputDataTexture().id;
          this.textureCache[inputName].texture = inputModel.getOuputDataTexture().texture;
          if (debug) {
            console.log("[".concat(this.entity, "]: confirm input ").concat(inputName, " from model ").concat(inputModel.entity, ", ").concat(inputModel.getOuputDataTexture().id));
          }
        }
      }, {
        key: "updateUniform",
        value: function updateUniform() {
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(bufferName, data) {
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var buffer = this.context.uniforms.find(function(_ref2) {
            var name = _ref2.name;
            return name === bufferName;
          });
          if (buffer) {
            var _this$calcDataTexture = this.calcDataTexture(bufferName, buffer.type, data), texture = _this$calcDataTexture.texture, paddingData = _this$calcDataTexture.data;
            this.textureCache[bufferName].data = paddingData;
            this.textureCache[bufferName].texture = texture;
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "swap",
        value: function swap() {
          if (!this.swapOutputTextureName) {
            this.createSwapOutputDataTexture();
          }
          if (this.compiledPingpong) {
            var outputTextureUniformName = this.context.output.name;
            this.textureCache[outputTextureUniformName].id = this.getOuputDataTexture().id;
            this.textureCache[outputTextureUniformName].texture = this.getOuputDataTexture().texture;
          }
          var tmp = this.outputTextureName;
          this.outputTextureName = this.swapOutputTextureName;
          this.swapOutputTextureName = tmp;
          if (debug) {
            console.log("[".concat(this.entity, "]: after swap, output ").concat(this.getOuputDataTexture().id));
          }
        }
      }, {
        key: "getOuputDataTexture",
        value: function getOuputDataTexture() {
          return this.textureCache[this.outputTextureName];
        }
      }, {
        key: "createSwapOutputDataTexture",
        value: function createSwapOutputDataTexture() {
          var texture = this.cloneDataTexture(this.getOuputDataTexture());
          this.swapOutputTextureName = "".concat(this.entity, "-swap");
          this.textureCache[this.swapOutputTextureName] = texture;
        }
      }, {
        key: "cloneDataTexture",
        value: function cloneDataTexture(texture) {
          var data = texture.data, textureWidth = texture.textureWidth;
          return _objectSpread7(_objectSpread7({}, texture), {}, {
            id: textureId++,
            texture: this.reGl.texture({
              width: textureWidth,
              height: textureWidth,
              data,
              type: "float"
            })
          });
        }
      }, {
        key: "calcDataTexture",
        value: function calcDataTexture(name, type, data) {
          var elementsPerTexel = 1;
          if (type === AST_TOKEN_TYPES.Vector4FloatArray) {
            elementsPerTexel = 4;
          }
          var paddingData = [];
          for (var i2 = 0; i2 < data.length; i2 += elementsPerTexel) {
            if (elementsPerTexel === 1) {
              paddingData.push(data[i2], 0, 0, 0);
            } else if (elementsPerTexel === 2) {
              paddingData.push(data[i2], data[i2 + 1], 0, 0);
            } else if (elementsPerTexel === 3) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], 0);
            } else if (elementsPerTexel === 4) {
              paddingData.push(data[i2], data[i2 + 1], data[i2 + 2], data[i2 + 3]);
            }
          }
          var originalDataLength = data.length;
          var texelCount = Math.ceil(originalDataLength / elementsPerTexel);
          var width = Math.ceil(Math.sqrt(texelCount));
          var paddingTexelCount = width * width;
          if (texelCount < paddingTexelCount) {
            paddingData.push.apply(paddingData, _toConsumableArray(new Array((paddingTexelCount - texelCount) * 4).fill(0)));
          }
          var texture = this.reGl.texture({
            width,
            height: width,
            data: paddingData,
            type: "float"
          });
          return {
            id: textureId++,
            data: paddingData,
            originalDataLength,
            typedArrayConstructor: isTypedArray3(data) ? data.constructor : void 0,
            textureWidth: width,
            texture,
            texelCount,
            elementsPerTexel,
            isOutput: name === this.context.output.name
          };
        }
      }]);
      return ReglComputeModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js
var ReglElements;
var init_ReglElements = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglElements.js"() {
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_constants();
    ReglElements = function() {
      function ReglElements2(reGl, options) {
        _classCallCheck(this, ReglElements2);
        this.elements = void 0;
        var data = options.data, usage = options.usage, type = options.type, count = options.count;
        this.elements = reGl.elements({
          data,
          usage: usageMap[usage || gl.STATIC_DRAW],
          type: dataTypeMap[type || gl.UNSIGNED_BYTE],
          count
        });
      }
      _createClass(ReglElements2, [{
        key: "get",
        value: function get2() {
          return this.elements;
        }
      }, {
        key: "subData",
        value: function subData(_ref2) {
          var data = _ref2.data;
          this.elements.subdata(data);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.elements.destroy();
        }
      }]);
      return ReglElements2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js
var ReglFramebuffer;
var init_ReglFramebuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglFramebuffer.js"() {
    init_classCallCheck();
    init_createClass();
    ReglFramebuffer = function() {
      function ReglFramebuffer2(reGl, options) {
        _classCallCheck(this, ReglFramebuffer2);
        this.framebuffer = void 0;
        var width = options.width, height = options.height, color3 = options.color, colors = options.colors, depth = options.depth, stencil = options.stencil;
        var framebufferOptions = {
          width,
          height
        };
        if (Array.isArray(colors)) {
          framebufferOptions.colors = colors.map(function(c2) {
            return c2.get();
          });
        }
        if (color3 && typeof color3 !== "boolean") {
          framebufferOptions.color = color3.get();
        }
        this.framebuffer = reGl.framebuffer(framebufferOptions);
      }
      _createClass(ReglFramebuffer2, [{
        key: "get",
        value: function get2() {
          return this.framebuffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.framebuffer.destroy();
        }
      }, {
        key: "resize",
        value: function resize(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          this.framebuffer.resize(width, height);
        }
      }]);
      return ReglFramebuffer2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/is-object.js
function isObject(value) {
  var type = _typeof(value);
  return value != null && (type === "object" || type === "function");
}
var init_is_object2 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/is-object.js"() {
    init_typeof();
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/uniform.js
function extractUniforms2(uniforms) {
  var extractedUniforms = {};
  Object.keys(uniforms).forEach(function(uniformName) {
    extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, "");
  });
  return extractedUniforms;
}
function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
  if (uniformValue === null || typeof uniformValue === "number" || typeof uniformValue === "boolean" || Array.isArray(uniformValue) && typeof uniformValue[0] === "number" || isTypedArray3(uniformValue) || uniformValue === "" || uniformValue.resize !== void 0) {
    uniforms["".concat(prefix && prefix + ".").concat(uniformName)] = uniformValue;
    return;
  }
  if (isObject(uniformValue)) {
    Object.keys(uniformValue).forEach(function(childName) {
      extractUniformsRecursively(childName, uniformValue[childName], uniforms, "".concat(prefix && prefix + ".").concat(uniformName));
    });
  }
  if (Array.isArray(uniformValue)) {
    uniformValue.forEach(function(child, idx) {
      Object.keys(child).forEach(function(childName) {
        extractUniformsRecursively(childName, child[childName], uniforms, "".concat(prefix && prefix + ".").concat(uniformName, "[").concat(idx, "]"));
      });
    });
  }
}
var init_uniform = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/uniform.js"() {
    init_is_object2();
    init_is_typedarray3();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js
function ownKeys8(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread8(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var ReglModel;
var init_ReglModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglModel.js"() {
    init_typeof();
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_uniform();
    init_constants();
    ReglModel = function() {
      function ReglModel2(reGl, options) {
        _classCallCheck(this, ReglModel2);
        this.reGl = void 0;
        this.drawCommand = void 0;
        this.uniforms = {};
        this.reGl = reGl;
        var vs = options.vs, fs = options.fs, defines = options.defines, attributes = options.attributes, uniforms = options.uniforms, primitive = options.primitive, count = options.count, elements = options.elements, depth = options.depth, blend = options.blend, stencil = options.stencil, cull = options.cull, instances = options.instances, scissor = options.scissor, viewport = options.viewport;
        var reglUniforms = {};
        if (uniforms) {
          this.uniforms = extractUniforms2(uniforms);
          Object.keys(uniforms).forEach(function(uniformName) {
            reglUniforms[uniformName] = reGl.prop(uniformName);
          });
        }
        var reglAttributes = {};
        Object.keys(attributes).forEach(function(name) {
          reglAttributes[name] = attributes[name].get();
        });
        var defineStmts = defines && this.generateDefines(defines) || "";
        var drawParams = {
          attributes: reglAttributes,
          frag: "#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n".concat(defineStmts, "\n").concat(fs),
          uniforms: reglUniforms,
          vert: "\n".concat(defineStmts, "\n").concat(vs),
          primitive: primitiveMap[primitive === void 0 ? gl.TRIANGLES : primitive]
        };
        if (instances) {
          drawParams.instances = instances;
        }
        if (count) {
          drawParams.count = count;
        }
        if (elements) {
          drawParams.elements = elements.get();
        }
        if (scissor) {
          drawParams.scissor = scissor;
        }
        if (viewport) {
          drawParams.viewport = viewport;
        }
        this.initDepthDrawParams({
          depth
        }, drawParams);
        this.initBlendDrawParams({
          blend
        }, drawParams);
        this.initStencilDrawParams({
          stencil
        }, drawParams);
        this.initCullDrawParams({
          cull
        }, drawParams);
        this.drawCommand = reGl(drawParams);
      }
      _createClass(ReglModel2, [{
        key: "addUniforms",
        value: function addUniforms(uniforms) {
          this.uniforms = _objectSpread8(_objectSpread8({}, this.uniforms), extractUniforms2(uniforms));
        }
      }, {
        key: "draw",
        value: function draw4(options) {
          var uniforms = _objectSpread8(_objectSpread8({}, this.uniforms), extractUniforms2(options.uniforms || {}));
          var reglDrawProps = {};
          Object.keys(uniforms).forEach(function(uniformName) {
            var type = _typeof(uniforms[uniformName]);
            if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || uniforms[uniformName].BYTES_PER_ELEMENT) {
              reglDrawProps[uniformName] = uniforms[uniformName];
            } else if (type === "string") {
            } else {
              reglDrawProps[uniformName] = uniforms[uniformName].get();
            }
          });
          this.drawCommand(reglDrawProps);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }, {
        key: "initDepthDrawParams",
        value: function initDepthDrawParams(_ref2, drawParams) {
          var depth = _ref2.depth;
          if (depth) {
            drawParams.depth = {
              enable: depth.enable === void 0 ? true : !!depth.enable,
              mask: depth.mask === void 0 ? true : !!depth.mask,
              func: depthFuncMap[depth.func || gl.LESS],
              range: depth.range || [0, 1]
            };
          }
        }
      }, {
        key: "initBlendDrawParams",
        value: function initBlendDrawParams(_ref2, drawParams) {
          var blend = _ref2.blend;
          if (blend) {
            var enable = blend.enable, func = blend.func, equation = blend.equation, _blend$color = blend.color, color3 = _blend$color === void 0 ? [0, 0, 0, 0] : _blend$color;
            drawParams.blend = {
              enable: !!enable,
              func: {
                srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
                srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
                dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
                dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
              },
              equation: {
                rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
                alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
              },
              color: color3
            };
          }
        }
      }, {
        key: "initStencilDrawParams",
        value: function initStencilDrawParams(_ref3, drawParams) {
          var stencil = _ref3.stencil;
          if (stencil) {
            var enable = stencil.enable, _stencil$mask = stencil.mask, mask = _stencil$mask === void 0 ? -1 : _stencil$mask, _stencil$func = stencil.func, func = _stencil$func === void 0 ? {
              cmp: gl.ALWAYS,
              ref: 0,
              mask: -1
            } : _stencil$func, _stencil$opFront = stencil.opFront, opFront = _stencil$opFront === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opFront, _stencil$opBack = stencil.opBack, opBack = _stencil$opBack === void 0 ? {
              fail: gl.KEEP,
              zfail: gl.KEEP,
              zpass: gl.KEEP
            } : _stencil$opBack;
            drawParams.stencil = {
              enable: !!enable,
              mask,
              func: _objectSpread8(_objectSpread8({}, func), {}, {
                cmp: stencilFuncMap[func.cmp]
              }),
              opFront: {
                fail: stencilOpMap[opFront.fail],
                zfail: stencilOpMap[opFront.zfail],
                zpass: stencilOpMap[opFront.zpass]
              },
              opBack: {
                fail: stencilOpMap[opBack.fail],
                zfail: stencilOpMap[opBack.zfail],
                zpass: stencilOpMap[opBack.zpass]
              }
            };
          }
        }
      }, {
        key: "initCullDrawParams",
        value: function initCullDrawParams(_ref4, drawParams) {
          var cull = _ref4.cull;
          if (cull) {
            var enable = cull.enable, _cull$face = cull.face, face = _cull$face === void 0 ? gl.BACK : _cull$face;
            drawParams.cull = {
              enable: !!enable,
              face: cullFaceMap[face]
            };
          }
        }
      }, {
        key: "generateDefines",
        value: function generateDefines(defines) {
          return Object.keys(defines).map(function(name) {
            return "#define ".concat(name, " ").concat(Number(defines[name]));
          }).join("\n");
        }
      }]);
      return ReglModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js
var ReglTexture2D;
var init_ReglTexture2D = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/ReglTexture2D.js"() {
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_constants();
    ReglTexture2D = function() {
      function ReglTexture2D2(reGl, options) {
        _classCallCheck(this, ReglTexture2D2);
        this.texture = void 0;
        this.width = void 0;
        this.height = void 0;
        var data = options.data, _options$type = options.type, type = _options$type === void 0 ? gl.UNSIGNED_BYTE : _options$type, width = options.width, height = options.height, _options$flipY = options.flipY, flipY = _options$flipY === void 0 ? false : _options$flipY, _options$format = options.format, format2 = _options$format === void 0 ? gl.RGBA : _options$format, _options$mipmap = options.mipmap, mipmap = _options$mipmap === void 0 ? false : _options$mipmap, _options$wrapS = options.wrapS, wrapS = _options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapS, _options$wrapT = options.wrapT, wrapT = _options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapT, _options$aniso = options.aniso, aniso = _options$aniso === void 0 ? 0 : _options$aniso, _options$alignment = options.alignment, alignment = _options$alignment === void 0 ? 1 : _options$alignment, _options$premultiplyA = options.premultiplyAlpha, premultiplyAlpha = _options$premultiplyA === void 0 ? false : _options$premultiplyA, _options$mag = options.mag, mag = _options$mag === void 0 ? gl.NEAREST : _options$mag, _options$min = options.min, min6 = _options$min === void 0 ? gl.NEAREST : _options$min, _options$colorSpace = options.colorSpace, colorSpace = _options$colorSpace === void 0 ? gl.BROWSER_DEFAULT_WEBGL : _options$colorSpace;
        this.width = width;
        this.height = height;
        var textureOptions = {
          width,
          height,
          type: dataTypeMap[type],
          format: formatMap[format2],
          wrapS: wrapModeMap[wrapS],
          wrapT: wrapModeMap[wrapT],
          mag: filterMap[mag],
          min: filterMap[min6],
          alignment,
          flipY,
          colorSpace: colorSpaceMap[colorSpace],
          premultiplyAlpha,
          aniso
        };
        if (data) {
          textureOptions.data = data;
        }
        if (typeof mipmap === "number") {
          textureOptions.mipmap = mipmapMap[mipmap];
        } else if (typeof mipmap === "boolean") {
          textureOptions.mipmap = mipmap;
        }
        this.texture = reGl.texture(textureOptions);
      }
      _createClass(ReglTexture2D2, [{
        key: "get",
        value: function get2() {
          return this.texture;
        }
      }, {
        key: "update",
        value: function update15() {
          this.texture._texture.bind();
        }
      }, {
        key: "resize",
        value: function resize(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          this.texture.resize(width, height);
          this.width = width;
          this.height = height;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.texture.destroy();
        }
      }]);
      return ReglTexture2D2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgl/index.js
var import_regenerator13, import_regl, _dec41, _class20, _temp18, WebGLEngine;
var init_webgl = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgl/index.js"() {
    import_regenerator13 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_es3();
    init_inversify();
    import_regl = __toESM(require_regl());
    init_ReglAttribute();
    init_ReglBuffer();
    init_ReglComputeModel();
    init_ReglElements();
    init_ReglFramebuffer();
    init_ReglModel();
    init_ReglTexture2D();
    WebGLEngine = (_dec41 = injectable(), _dec41(_class20 = (_temp18 = function() {
      function WebGLEngine2() {
        var _this = this;
        _classCallCheck(this, WebGLEngine2);
        this.supportWebGPU = false;
        this.useWGSL = false;
        this.$canvas = void 0;
        this.gl = void 0;
        this.inited = void 0;
        this.createModel = function() {
          var _ref2 = _asyncToGenerator(import_regenerator13.default.mark(function _callee2(options) {
            return import_regenerator13.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!options.uniforms) {
                      _context2.next = 3;
                      break;
                    }
                    _context2.next = 3;
                    return Promise.all(Object.keys(options.uniforms).map(function() {
                      var _ref22 = _asyncToGenerator(import_regenerator13.default.mark(function _callee(name) {
                        var texture;
                        return import_regenerator13.default.wrap(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                if (!(options.uniforms[name] && options.uniforms[name].load !== void 0)) {
                                  _context.next = 5;
                                  break;
                                }
                                _context.next = 3;
                                return options.uniforms[name].load();
                              case 3:
                                texture = _context.sent;
                                options.uniforms[name] = texture;
                              case 5:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, _callee);
                      }));
                      return function(_x2) {
                        return _ref22.apply(this, arguments);
                      };
                    }()));
                  case 3:
                    return _context2.abrupt("return", new ReglModel(_this.gl, options));
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }();
        this.createAttribute = function(options) {
          return new ReglAttribute(_this.gl, options);
        };
        this.createBuffer = function(options) {
          return new ReglBuffer(_this.gl, options);
        };
        this.createElements = function(options) {
          return new ReglElements(_this.gl, options);
        };
        this.createTexture2D = function(options) {
          return new ReglTexture2D(_this.gl, options);
        };
        this.createFramebuffer = function(options) {
          return new ReglFramebuffer(_this.gl, options);
        };
        this.useFramebuffer = function(framebuffer, drawCommands) {
          _this.gl({
            framebuffer: framebuffer ? framebuffer.get() : null
          })(drawCommands);
        };
        this.createComputeModel = function() {
          var _ref3 = _asyncToGenerator(import_regenerator13.default.mark(function _callee3(context) {
            return import_regenerator13.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    return _context3.abrupt("return", new ReglComputeModel(_this.gl, context));
                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          }));
          return function(_x3) {
            return _ref3.apply(this, arguments);
          };
        }();
        this.clear = function(options) {
          var color3 = options.color, depth = options.depth, stencil = options.stencil, _options$framebuffer = options.framebuffer, framebuffer = _options$framebuffer === void 0 ? null : _options$framebuffer;
          var reglClearOptions = {
            color: color3,
            depth,
            stencil
          };
          reglClearOptions.framebuffer = framebuffer === null ? framebuffer : framebuffer.get();
          _this.gl.clear(reglClearOptions);
        };
        this.setScissor = function(scissor) {
          if (_this.gl && _this.gl._gl) {
            if (scissor.enable && scissor.box) {
              _this.gl._gl.enable(gl.SCISSOR_TEST);
              _this.gl._gl.scissor(scissor.box.x, scissor.box.y, scissor.box.width, scissor.box.height);
            } else {
              _this.gl._gl.disable(gl.SCISSOR_TEST);
            }
            _this.gl._refresh();
          }
        };
        this.viewport = function(_ref4) {
          var x2 = _ref4.x, y2 = _ref4.y, width = _ref4.width, height = _ref4.height;
          if (_this.gl && _this.gl._gl) {
            _this.gl._gl.viewport(x2, y2, width, height);
            _this.gl._refresh();
          }
        };
        this.readPixels = function(options) {
          var framebuffer = options.framebuffer, x2 = options.x, y2 = options.y, width = options.width, height = options.height;
          var readPixelsOptions = {
            x: x2,
            y: y2,
            width,
            height
          };
          if (framebuffer) {
            readPixelsOptions.framebuffer = framebuffer.get();
          }
          return _this.gl.read(readPixelsOptions);
        };
        this.getCanvas = function() {
          return _this.$canvas;
        };
        this.getGLContext = function() {
          return _this.gl._gl;
        };
        this.destroy = function() {
          if (_this.gl) {
            _this.gl.destroy();
            _this.inited = false;
          }
        };
      }
      _createClass(WebGLEngine2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator13.default.mark(function _callee4(cfg) {
            return import_regenerator13.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (!this.inited) {
                      _context4.next = 2;
                      break;
                    }
                    return _context4.abrupt("return");
                  case 2:
                    this.$canvas = cfg.canvas;
                    _context4.next = 5;
                    return new Promise(function(resolve2, reject) {
                      (0, import_regl.default)({
                        canvas: cfg.canvas,
                        attributes: {
                          alpha: true,
                          antialias: cfg.antialias,
                          premultipliedAlpha: true
                        },
                        pixelRatio: 1,
                        extensions: [
                          "OES_element_index_uint",
                          "OES_texture_float",
                          "OES_standard_derivatives",
                          "angle_instanced_arrays"
                        ],
                        optionalExtensions: ["EXT_texture_filter_anisotropic", "EXT_blend_minmax", "WEBGL_depth_texture"],
                        profile: true,
                        onDone: function onDone(err, r2) {
                          if (err || !r2) {
                            reject(err);
                          }
                          resolve2(r2);
                        }
                      });
                    });
                  case 5:
                    this.gl = _context4.sent;
                    this.inited = true;
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function init(_x4) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "isFloatSupported",
        value: function isFloatSupported() {
          return this.gl.limits.readFloat;
        }
      }, {
        key: "beginFrame",
        value: function beginFrame() {
        }
      }, {
        key: "endFrame",
        value: function endFrame() {
        }
      }]);
      return WebGLEngine2;
    }(), _temp18)) || _class20);
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/dom.js
function isWindowObjectExist() {
  return typeof window !== "undefined";
}
function loadScript(scriptUrl, onSuccess, onError, scriptId) {
  if (!isWindowObjectExist()) {
    return;
  }
  var head2 = document.getElementsByTagName("head")[0];
  var script = document.createElement("script");
  script.setAttribute("type", "text/javascript");
  script.setAttribute("src", scriptUrl);
  if (scriptId) {
    script.id = scriptId;
  }
  script.onload = function() {
    if (onSuccess) {
      onSuccess();
    }
  };
  script.onerror = function(e8) {
    if (onError) {
      onError("Unable to load script '".concat(scriptUrl, "'"), e8);
    }
  };
  head2.appendChild(script);
}
function loadScriptAsync(scriptUrl, scriptId) {
  return new Promise(function(resolve2, reject) {
    loadScript(scriptUrl, function() {
      resolve2();
    }, function(message, exception) {
      reject(exception);
    });
  });
}
var init_dom = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/dom.js"() {
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/glslang.js
function glslang_default() {
  return _ref.apply(this, arguments);
}
function _ref() {
  _ref = _asyncToGenerator(import_regenerator14.default.mark(function _callee() {
    return import_regenerator14.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!glslang) {
              _context.next = 2;
              break;
            }
            return _context.abrupt("return", glslang);
          case 2:
            _context.next = 4;
            return loadScriptAsync("https://preview.babylonjs.com/glslang/glslang.js");
          case 4:
            glslang = window.glslang("https://preview.babylonjs.com/glslang/glslang.wasm");
            return _context.abrupt("return", glslang);
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ref.apply(this, arguments);
}
var import_regenerator14, glslang;
var init_glslang = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/glslang.js"() {
    import_regenerator14 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_dom();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUAttribute.js
var WebGPUAttribute;
var init_WebGPUAttribute = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUAttribute.js"() {
    init_classCallCheck();
    init_createClass();
    WebGPUAttribute = function() {
      function WebGPUAttribute2(engine, options) {
        _classCallCheck(this, WebGPUAttribute2);
        this.engine = engine;
        this.options = options;
        this.attribute = void 0;
        this.buffer = void 0;
        var _options = options, buffer = _options.buffer, offset = _options.offset, stride = _options.stride, normalized = _options.normalized, size2 = _options.size, divisor = _options.divisor, arrayStride = _options.arrayStride, attributes = _options.attributes, stepMode = _options.stepMode;
        this.buffer = buffer;
        this.attribute = {
          buffer: buffer.get(),
          offset: offset || 0,
          stride: stride || 0,
          normalized: normalized || false,
          divisor: divisor || 0,
          arrayStride: arrayStride || 0,
          attributes,
          stepMode: stepMode || "vertex"
        };
        if (size2) {
          this.attribute.size = size2;
        }
      }
      _createClass(WebGPUAttribute2, [{
        key: "get",
        value: function get2() {
          return this.attribute;
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(options) {
          this.buffer.subData(options);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }]);
      return WebGPUAttribute2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUBuffer.js
var WebGPUConstants2, WebGPUBuffer;
var init_WebGPUBuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUBuffer.js"() {
    init_classCallCheck();
    init_createClass();
    init_es3();
    WebGPUConstants2 = __toESM(require_constants2());
    WebGPUBuffer = function() {
      function WebGPUBuffer2(engine, options) {
        _classCallCheck(this, WebGPUBuffer2);
        this.engine = engine;
        this.options = options;
        this.buffer = void 0;
        var _options = options, data = _options.data, usage = _options.usage, type = _options.type;
        this.buffer = this.createBuffer(data instanceof Array ? new Float32Array(data) : data, usage || WebGPUConstants2.BufferUsage.Vertex | WebGPUConstants2.BufferUsage.CopyDst);
      }
      _createClass(WebGPUBuffer2, [{
        key: "get",
        value: function get2() {
          return this.buffer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }, {
        key: "subData",
        value: function subData(_ref2) {
          var data = _ref2.data, offset = _ref2.offset;
          this.setSubData(this.buffer, offset, data instanceof Array ? new Float32Array(data) : data);
        }
      }, {
        key: "createBuffer",
        value: function createBuffer(view, flags) {
          var padding = view.byteLength % 4;
          var verticesBufferDescriptor = {
            size: view.byteLength + padding,
            usage: flags
          };
          var buffer = this.engine.device.createBuffer(verticesBufferDescriptor);
          this.setSubData(buffer, 0, view);
          return buffer;
        }
      }, {
        key: "setSubData",
        value: function setSubData(destBuffer, destOffset, srcArrayBuffer) {
          var queue = isSafari ? this.engine.device.getQueue() : this.engine.device.defaultQueue;
          queue.writeBuffer(destBuffer, destOffset, srcArrayBuffer);
        }
      }]);
      return WebGPUBuffer2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/utils/is-number.js
function isNumber4(value) {
  return typeof value === "number";
}
var init_is_number4 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/utils/is-number.js"() {
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUComputeModel.js
var import_regenerator15, WebGPUConstants3, WebGPUComputeModel;
var init_WebGPUComputeModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUComputeModel.js"() {
    import_regenerator15 = __toESM(require_regenerator());
    init_toConsumableArray();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_es3();
    WebGPUConstants3 = __toESM(require_constants2());
    init_is_number4();
    init_WebGPUBuffer();
    WebGPUComputeModel = function() {
      function WebGPUComputeModel2(engine, context) {
        _classCallCheck(this, WebGPUComputeModel2);
        this.engine = engine;
        this.context = context;
        this.entity = createEntity();
        this.uniformGPUBufferLayout = [];
        this.uniformBuffer = void 0;
        this.vertexBuffers = {};
        this.outputBuffer = void 0;
        this.bindGroupEntries = void 0;
        this.bindGroup = void 0;
        this.computePipeline = void 0;
      }
      _createClass(WebGPUComputeModel2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator15.default.mark(function _callee() {
            var _this = this;
            var _yield$this$compileCo, computeStage, buffers, uniforms, bufferBindingIndex, offset, mergedUniformData;
            return import_regenerator15.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.compileComputePipelineStageDescriptor(this.context.shader);
                  case 2:
                    _yield$this$compileCo = _context.sent;
                    computeStage = _yield$this$compileCo.computeStage;
                    buffers = this.context.uniforms.filter(function(uniform) {
                      return uniform.storageClass === STORAGE_CLASS.StorageBuffer;
                    });
                    uniforms = this.context.uniforms.filter(function(uniform) {
                      return uniform.storageClass === STORAGE_CLASS.Uniform;
                    });
                    bufferBindingIndex = uniforms.length ? 1 : 0;
                    this.bindGroupEntries = [];
                    if (bufferBindingIndex) {
                      offset = 0;
                      mergedUniformData = [];
                      uniforms.forEach(function(uniform) {
                        if (isNumber4(uniform.data)) {
                          _this.uniformGPUBufferLayout.push({
                            name: uniform.name,
                            offset
                          });
                          offset += 4;
                          mergedUniformData.push(uniform.data);
                        } else {
                          var _uniform$data;
                          var originDataLength = ((_uniform$data = uniform.data) === null || _uniform$data === void 0 ? void 0 : _uniform$data.length) || 1;
                          if (originDataLength === 3) {
                            originDataLength = 4;
                            uniform.data.push(0);
                          }
                          var padding = offset / 4 % 4;
                          if (padding > 0) {
                            var space = 4 - padding;
                            if (originDataLength > 1 && originDataLength <= space) {
                              if (originDataLength === 2) {
                                if (space === 3) {
                                  offset += 4;
                                  mergedUniformData.push(0);
                                }
                                mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));
                                _this.uniformGPUBufferLayout.push({
                                  name: uniform.name,
                                  offset
                                });
                              }
                            } else {
                              for (var i2 = 0; i2 < space; i2++) {
                                offset += 4;
                                mergedUniformData.push(0);
                              }
                              mergedUniformData.push.apply(mergedUniformData, _toConsumableArray(uniform.data));
                              _this.uniformGPUBufferLayout.push({
                                name: uniform.name,
                                offset
                              });
                            }
                          }
                          offset += 4 * originDataLength;
                        }
                      });
                      this.uniformBuffer = new WebGPUBuffer(this.engine, {
                        data: mergedUniformData instanceof Array ? new Float32Array(mergedUniformData) : mergedUniformData,
                        usage: WebGPUConstants3.BufferUsage.Uniform | WebGPUConstants3.BufferUsage.CopyDst
                      });
                      this.bindGroupEntries.push({
                        binding: 0,
                        resource: {
                          buffer: this.uniformBuffer.get()
                        }
                      });
                    }
                    buffers.forEach(function(buffer) {
                      if (buffer.data !== null) {
                        if (buffer.type === AST_TOKEN_TYPES.Vector4FloatArray || buffer.type === AST_TOKEN_TYPES.FloatArray) {
                          var gpuBuffer;
                          if (buffer.name === _this.context.output.name) {
                            gpuBuffer = new WebGPUBuffer(_this.engine, {
                              data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,
                              usage: WebGPUConstants3.BufferUsage.Storage | WebGPUConstants3.BufferUsage.CopyDst | WebGPUConstants3.BufferUsage.CopySrc
                            });
                            _this.outputBuffer = gpuBuffer;
                            _this.context.output = {
                              name: buffer.name,
                              length: isFinite(Number(buffer.data)) ? 1 : buffer.data.length,
                              typedArrayConstructor: Float32Array,
                              gpuBuffer: gpuBuffer.get()
                            };
                          } else {
                            if (buffer.isReferer) {
                              if (buffer.data.model && buffer.data.model.outputBuffer) {
                                gpuBuffer = buffer.data.model.outputBuffer;
                              } else {
                              }
                            } else {
                              gpuBuffer = new WebGPUBuffer(_this.engine, {
                                data: isFinite(Number(buffer.data)) ? [buffer.data] : buffer.data,
                                usage: WebGPUConstants3.BufferUsage.Storage | WebGPUConstants3.BufferUsage.CopyDst | WebGPUConstants3.BufferUsage.CopySrc
                              });
                            }
                          }
                          _this.vertexBuffers[buffer.name] = gpuBuffer;
                          _this.bindGroupEntries.push({
                            binding: bufferBindingIndex,
                            resource: {
                              name: buffer.name,
                              refer: gpuBuffer ? void 0 : buffer.data,
                              buffer: gpuBuffer ? gpuBuffer.get() : void 0
                            }
                          });
                          bufferBindingIndex++;
                        }
                      }
                    });
                    this.computePipeline = this.engine.device.createComputePipeline({
                      computeStage
                    });
                    console.log(this.bindGroupEntries);
                    this.bindGroup = this.engine.device.createBindGroup({
                      layout: this.computePipeline.getBindGroupLayout(0),
                      entries: this.bindGroupEntries
                    });
                  case 13:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "destroy",
        value: function destroy() {
          var _this2 = this;
          if (this.uniformBuffer) {
            this.uniformBuffer.destroy();
          }
          Object.keys(this.vertexBuffers).forEach(function(bufferName) {
            return _this2.vertexBuffers[bufferName].destroy();
          });
        }
      }, {
        key: "readData",
        value: function() {
          var _readData = _asyncToGenerator(import_regenerator15.default.mark(function _callee2() {
            var output, length5, typedArrayConstructor, gpuBuffer, byteCount, gpuReadBuffer, encoder, queue, arraybuffer, typedArray;
            return import_regenerator15.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    output = this.context.output;
                    if (!output) {
                      _context2.next = 16;
                      break;
                    }
                    length5 = output.length, typedArrayConstructor = output.typedArrayConstructor, gpuBuffer = output.gpuBuffer;
                    if (!gpuBuffer) {
                      _context2.next = 16;
                      break;
                    }
                    byteCount = length5 * typedArrayConstructor.BYTES_PER_ELEMENT;
                    gpuReadBuffer = this.engine.device.createBuffer({
                      size: byteCount,
                      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                    });
                    encoder = this.engine.device.createCommandEncoder();
                    encoder.copyBufferToBuffer(gpuBuffer, 0, gpuReadBuffer, 0, byteCount);
                    queue = isSafari ? this.engine.device.getQueue() : this.engine.device.defaultQueue;
                    queue.submit([encoder.finish()]);
                    _context2.next = 12;
                    return gpuReadBuffer.mapAsync(WebGPUConstants3.MapMode.Read);
                  case 12:
                    arraybuffer = gpuReadBuffer.getMappedRange();
                    typedArray = new typedArrayConstructor(arraybuffer.slice(0));
                    gpuReadBuffer.unmap();
                    return _context2.abrupt("return", typedArray);
                  case 16:
                    return _context2.abrupt("return", new Float32Array());
                  case 17:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function readData() {
            return _readData.apply(this, arguments);
          }
          return readData;
        }()
      }, {
        key: "run",
        value: function run() {
          if (this.engine.currentComputePass) {
            var _this$engine$currentC;
            this.engine.currentComputePass.setPipeline(this.computePipeline);
            this.engine.currentComputePass.setBindGroup(0, this.bindGroup);
            (_this$engine$currentC = this.engine.currentComputePass).dispatch.apply(_this$engine$currentC, _toConsumableArray(this.context.dispatch));
          }
        }
      }, {
        key: "updateBuffer",
        value: function updateBuffer(bufferName, data) {
          var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var buffer = this.vertexBuffers[bufferName];
          if (buffer) {
            buffer.subData({
              data,
              offset
            });
          }
        }
      }, {
        key: "updateUniform",
        value: function updateUniform(uniformName, data) {
          var layout2 = this.uniformGPUBufferLayout.find(function(l2) {
            return l2.name === uniformName;
          });
          if (layout2) {
            this.uniformBuffer.subData({
              data: Number.isFinite(data) ? new Float32Array([data]) : new Float32Array(data),
              offset: layout2.offset
            });
          }
        }
      }, {
        key: "confirmInput",
        value: function confirmInput(model, inputName) {
          var inputBuffer = this.vertexBuffers[inputName];
          var outputBuffer = model.outputBuffer;
          if (inputBuffer && outputBuffer && inputBuffer !== outputBuffer) {
            var encoder = this.engine.device.createCommandEncoder();
            var _context$output = model.context.output, length5 = _context$output.length, typedArrayConstructor = _context$output.typedArrayConstructor;
            var byteCount = length5 * typedArrayConstructor.BYTES_PER_ELEMENT;
            encoder.copyBufferToBuffer(outputBuffer.get(), 0, inputBuffer.get(), 0, byteCount);
            var queue = isSafari ? this.engine.device.getQueue() : this.engine.device.defaultQueue;
            queue.submit([encoder.finish()]);
          }
        }
      }, {
        key: "compileShaderToSpirV",
        value: function compileShaderToSpirV(source, type, shaderVersion) {
          return this.compileRawShaderToSpirV(shaderVersion + source, type);
        }
      }, {
        key: "compileRawShaderToSpirV",
        value: function compileRawShaderToSpirV(source, type) {
          return this.engine.glslang.compileGLSL(source, type);
        }
      }, {
        key: "compileComputePipelineStageDescriptor",
        value: function() {
          var _compileComputePipelineStageDescriptor = _asyncToGenerator(import_regenerator15.default.mark(function _callee3(computeCode) {
            var computeShader, shaderVersion;
            return import_regenerator15.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    computeShader = computeCode;
                    shaderVersion = "#version 450\n";
                    if (this.engine.options.useWGSL) {
                      _context3.next = 6;
                      break;
                    }
                    _context3.next = 5;
                    return this.compileShaderToSpirV(computeCode, "compute", shaderVersion);
                  case 5:
                    computeShader = _context3.sent;
                  case 6:
                    return _context3.abrupt("return", {
                      computeStage: {
                        module: this.engine.device.createShaderModule({
                          code: computeShader,
                          isWHLSL: isSafari
                        }),
                        entryPoint: "main"
                      }
                    });
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function compileComputePipelineStageDescriptor(_x) {
            return _compileComputePipelineStageDescriptor.apply(this, arguments);
          }
          return compileComputePipelineStageDescriptor;
        }()
      }]);
      return WebGPUComputeModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUElements.js
var WebGPUConstants4, WebGPUElements;
var init_WebGPUElements = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUElements.js"() {
    init_classCallCheck();
    init_createClass();
    WebGPUConstants4 = __toESM(require_constants2());
    init_WebGPUBuffer();
    WebGPUElements = function() {
      function WebGPUElements2(engine, options) {
        _classCallCheck(this, WebGPUElements2);
        this.engine = engine;
        this.options = options;
        this.indexCount = void 0;
        this.buffer = void 0;
        var _options = options, data = _options.data, usage = _options.usage, type = _options.type, count = _options.count;
        this.indexCount = count || 0;
        this.buffer = new WebGPUBuffer(engine, {
          data: data instanceof Array ? new Uint16Array(data) : data,
          usage: WebGPUConstants4.BufferUsage.Index | WebGPUConstants4.BufferUsage.CopyDst
        });
      }
      _createClass(WebGPUElements2, [{
        key: "get",
        value: function get2() {
          return this.buffer;
        }
      }, {
        key: "subData",
        value: function subData(options) {
          this.buffer.subData(options);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.buffer.destroy();
        }
      }]);
      return WebGPUElements2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUFramebuffer.js
var WebGPUFramebuffer;
var init_WebGPUFramebuffer = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUFramebuffer.js"() {
    init_classCallCheck();
    init_createClass();
    WebGPUFramebuffer = function() {
      function WebGPUFramebuffer2(engine, options) {
        _classCallCheck(this, WebGPUFramebuffer2);
        this.engine = engine;
        this.options = options;
        this.colorTexture = void 0;
        this.depthTexture = void 0;
        this.width = 0;
        this.height = 0;
        var _options = options, width = _options.width, height = _options.height, color3 = _options.color, colors = _options.colors, depth = _options.depth, stencil = _options.stencil;
        if (color3) {
          this.colorTexture = color3;
        }
        if (depth) {
          this.depthTexture = depth;
        }
      }
      _createClass(WebGPUFramebuffer2, [{
        key: "get",
        value: function get2() {
          var _this$colorTexture, _this$depthTexture;
          return {
            color: (_this$colorTexture = this.colorTexture) === null || _this$colorTexture === void 0 ? void 0 : _this$colorTexture.get(),
            depth: (_this$depthTexture = this.depthTexture) === null || _this$depthTexture === void 0 ? void 0 : _this$depthTexture.get()
          };
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var _this$colorTexture2, _this$depthTexture2;
          (_this$colorTexture2 = this.colorTexture) === null || _this$colorTexture2 === void 0 ? void 0 : _this$colorTexture2.destroy();
          (_this$depthTexture2 = this.depthTexture) === null || _this$depthTexture2 === void 0 ? void 0 : _this$depthTexture2.destroy();
        }
      }, {
        key: "resize",
        value: function resize(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          if (width !== this.width || height !== this.height) {
            var _this$colorTexture3, _this$depthTexture3;
            (_this$colorTexture3 = this.colorTexture) === null || _this$colorTexture3 === void 0 ? void 0 : _this$colorTexture3.resize({
              width,
              height
            });
            (_this$depthTexture3 = this.depthTexture) === null || _this$depthTexture3 === void 0 ? void 0 : _this$depthTexture3.resize({
              width,
              height
            });
          }
          this.width = width;
          this.height = height;
        }
      }]);
      return WebGPUFramebuffer2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/constants.js
function getCullMode(_ref2) {
  var cull = _ref2.cull;
  if (!cull || !cull.enable) {
    return WebGPUConstants5.CullMode.None;
  }
  if (cull.face) {
    return cull.face === gl.FRONT ? WebGPUConstants5.CullMode.Front : WebGPUConstants5.CullMode.Back;
  }
}
function getDepthStencilStateDescriptor(_ref2) {
  var depth = _ref2.depth, stencil = _ref2.stencil;
  var stencilFrontBack = {
    compare: WebGPUConstants5.CompareFunction.Always,
    depthFailOp: WebGPUConstants5.StencilOperation.Keep,
    failOp: WebGPUConstants5.StencilOperation.Keep,
    passOp: WebGPUConstants5.StencilOperation.Keep
  };
  return {
    depthWriteEnabled: depth && depth.enable,
    depthCompare: depthFuncMap2[(depth === null || depth === void 0 ? void 0 : depth.func) || gl.ALWAYS],
    format: WebGPUConstants5.TextureFormat.Depth24PlusStencil8,
    stencilFront: stencilFrontBack,
    stencilBack: stencilFrontBack,
    stencilReadMask: 4294967295,
    stencilWriteMask: 4294967295
  };
}
function getColorStateDescriptors(_ref3, swapChainFormat) {
  var blend = _ref3.blend;
  return [{
    format: swapChainFormat,
    alphaBlend: {
      srcFactor: blendFuncMap2[blend && blend.func && blend.func.srcAlpha || gl.ONE],
      dstFactor: blendFuncMap2[blend && blend.func && blend.func.dstAlpha || gl.ZERO],
      operation: blendEquationMap2[blend && blend.equation && blend.equation.alpha || gl.FUNC_ADD]
    },
    colorBlend: {
      srcFactor: blendFuncMap2[blend && blend.func && blend.func.srcRGB || gl.ONE],
      dstFactor: blendFuncMap2[blend && blend.func && blend.func.dstRGB || gl.ZERO],
      operation: blendEquationMap2[blend && blend.equation && blend.equation.rgb || gl.FUNC_ADD]
    },
    writeMask: WebGPUConstants5.ColorWrite.All
  }];
}
var WebGPUConstants5, _primitiveMap2, _depthFuncMap2, _blendEquationMap2, _blendFuncMap2, _formatMap2, _filterMap2, _wrapModeMap2, primitiveMap2, depthFuncMap2, blendEquationMap2, blendFuncMap2, formatMap2, filterMap2, wrapModeMap2;
var init_constants2 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/constants.js"() {
    init_defineProperty();
    init_es3();
    WebGPUConstants5 = __toESM(require_constants2());
    primitiveMap2 = (_primitiveMap2 = {}, _defineProperty(_primitiveMap2, gl.POINTS, WebGPUConstants5.PrimitiveTopology.PointList), _defineProperty(_primitiveMap2, gl.LINES, WebGPUConstants5.PrimitiveTopology.LineList), _defineProperty(_primitiveMap2, gl.LINE_LOOP, WebGPUConstants5.PrimitiveTopology.LineList), _defineProperty(_primitiveMap2, gl.LINE_STRIP, WebGPUConstants5.PrimitiveTopology.LineStrip), _defineProperty(_primitiveMap2, gl.TRIANGLES, WebGPUConstants5.PrimitiveTopology.TriangleList), _defineProperty(_primitiveMap2, gl.TRIANGLE_FAN, WebGPUConstants5.PrimitiveTopology.TriangleList), _defineProperty(_primitiveMap2, gl.TRIANGLE_STRIP, WebGPUConstants5.PrimitiveTopology.TriangleStrip), _primitiveMap2);
    depthFuncMap2 = (_depthFuncMap2 = {}, _defineProperty(_depthFuncMap2, gl.NEVER, WebGPUConstants5.CompareFunction.Never), _defineProperty(_depthFuncMap2, gl.ALWAYS, WebGPUConstants5.CompareFunction.Always), _defineProperty(_depthFuncMap2, gl.LESS, WebGPUConstants5.CompareFunction.Less), _defineProperty(_depthFuncMap2, gl.LEQUAL, WebGPUConstants5.CompareFunction.LessEqual), _defineProperty(_depthFuncMap2, gl.GREATER, WebGPUConstants5.CompareFunction.Greater), _defineProperty(_depthFuncMap2, gl.GEQUAL, WebGPUConstants5.CompareFunction.GreaterEqual), _defineProperty(_depthFuncMap2, gl.EQUAL, WebGPUConstants5.CompareFunction.Equal), _defineProperty(_depthFuncMap2, gl.NOTEQUAL, WebGPUConstants5.CompareFunction.NotEqual), _depthFuncMap2);
    blendEquationMap2 = (_blendEquationMap2 = {}, _defineProperty(_blendEquationMap2, gl.FUNC_ADD, WebGPUConstants5.BlendOperation.Add), _defineProperty(_blendEquationMap2, gl.MIN_EXT, WebGPUConstants5.BlendOperation.Min), _defineProperty(_blendEquationMap2, gl.MAX_EXT, WebGPUConstants5.BlendOperation.Max), _defineProperty(_blendEquationMap2, gl.FUNC_SUBTRACT, WebGPUConstants5.BlendOperation.Subtract), _defineProperty(_blendEquationMap2, gl.FUNC_REVERSE_SUBTRACT, WebGPUConstants5.BlendOperation.ReverseSubtract), _blendEquationMap2);
    blendFuncMap2 = (_blendFuncMap2 = {}, _defineProperty(_blendFuncMap2, gl.ZERO, WebGPUConstants5.BlendFactor.Zero), _defineProperty(_blendFuncMap2, gl.ONE, WebGPUConstants5.BlendFactor.One), _defineProperty(_blendFuncMap2, gl.SRC_COLOR, WebGPUConstants5.BlendFactor.SrcColor), _defineProperty(_blendFuncMap2, gl.ONE_MINUS_SRC_COLOR, WebGPUConstants5.BlendFactor.OneMinusSrcColor), _defineProperty(_blendFuncMap2, gl.SRC_ALPHA, WebGPUConstants5.BlendFactor.SrcAlpha), _defineProperty(_blendFuncMap2, gl.ONE_MINUS_SRC_ALPHA, WebGPUConstants5.BlendFactor.OneMinusSrcAlpha), _defineProperty(_blendFuncMap2, gl.DST_COLOR, WebGPUConstants5.BlendFactor.DstColor), _defineProperty(_blendFuncMap2, gl.ONE_MINUS_DST_COLOR, WebGPUConstants5.BlendFactor.OneMinusDstColor), _defineProperty(_blendFuncMap2, gl.DST_ALPHA, WebGPUConstants5.BlendFactor.DstAlpha), _defineProperty(_blendFuncMap2, gl.ONE_MINUS_DST_ALPHA, WebGPUConstants5.BlendFactor.OneMinusDstAlpha), _defineProperty(_blendFuncMap2, gl.CONSTANT_COLOR, WebGPUConstants5.BlendFactor.BlendColor), _defineProperty(_blendFuncMap2, gl.ONE_MINUS_CONSTANT_COLOR, WebGPUConstants5.BlendFactor.OneMinusBlendColor), _defineProperty(_blendFuncMap2, gl.SRC_ALPHA_SATURATE, WebGPUConstants5.BlendFactor.SrcAlphaSaturated), _blendFuncMap2);
    formatMap2 = (_formatMap2 = {}, _defineProperty(_formatMap2, gl.ALPHA, "r8unorm"), _defineProperty(_formatMap2, gl.RGBA, "rgba8unorm"), _defineProperty(_formatMap2, gl.DEPTH_COMPONENT, "depth32float"), _defineProperty(_formatMap2, gl.DEPTH_STENCIL, "depth24plus-stencil8"), _formatMap2);
    filterMap2 = (_filterMap2 = {}, _defineProperty(_filterMap2, gl.NEAREST, "nearest"), _defineProperty(_filterMap2, gl.LINEAR, "linear"), _filterMap2);
    wrapModeMap2 = (_wrapModeMap2 = {}, _defineProperty(_wrapModeMap2, gl.REPEAT, "repeat"), _defineProperty(_wrapModeMap2, gl.CLAMP_TO_EDGE, "clamp-to-edge"), _defineProperty(_wrapModeMap2, gl.MIRRORED_REPEAT, "mirror-repeat"), _wrapModeMap2);
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUModel.js
function ownKeys9(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread9(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function concatenate(resultConstructor) {
  var totalLength = 0;
  for (var _len = arguments.length, arrays = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    arrays[_key - 1] = arguments[_key];
  }
  for (var _i2 = 0, _arrays = arrays; _i2 < _arrays.length; _i2++) {
    var arr = _arrays[_i2];
    totalLength += arr.length;
  }
  var result = new resultConstructor(totalLength);
  var offset = 0;
  for (var _i22 = 0, _arrays2 = arrays; _i22 < _arrays2.length; _i22++) {
    var _arr = _arrays2[_i22];
    result.set(_arr, offset);
    offset += _arr.length;
  }
  return result;
}
var import_regenerator16, WebGPUConstants6, WebGPUModel;
var init_WebGPUModel = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUModel.js"() {
    init_toConsumableArray();
    init_typeof();
    import_regenerator16 = __toESM(require_regenerator());
    init_defineProperty();
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_es3();
    WebGPUConstants6 = __toESM(require_constants2());
    init_uniform();
    init_constants2();
    init_WebGPUBuffer();
    WebGPUModel = function() {
      function WebGPUModel2(engine, options) {
        _classCallCheck(this, WebGPUModel2);
        this.engine = engine;
        this.options = options;
        this.pipelineLayout = void 0;
        this.renderPipeline = void 0;
        this.uniformsBindGroupLayout = void 0;
        this.uniformBindGroup = void 0;
        this.uniformBuffer = void 0;
        this.uniforms = {};
        this.uniformGPUBufferLayout = [];
        this.attributeCache = {};
        this.indexBuffer = void 0;
        this.indexCount = void 0;
      }
      _createClass(WebGPUModel2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator16.default.mark(function _callee() {
            var _this = this;
            var _this$options, vs, fs, attributes, uniforms, primitive, count, elements, depth, blend, stencil, cull, instances, _yield$this$compilePi, vertexStage, fragmentStage, vertexState, descriptor;
            return import_regenerator16.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _this$options = this.options, vs = _this$options.vs, fs = _this$options.fs, attributes = _this$options.attributes, uniforms = _this$options.uniforms, primitive = _this$options.primitive, count = _this$options.count, elements = _this$options.elements, depth = _this$options.depth, blend = _this$options.blend, stencil = _this$options.stencil, cull = _this$options.cull, instances = _this$options.instances;
                    _context.next = 3;
                    return this.compilePipelineStageDescriptor(vs, fs, null);
                  case 3:
                    _yield$this$compilePi = _context.sent;
                    vertexStage = _yield$this$compilePi.vertexStage;
                    fragmentStage = _yield$this$compilePi.fragmentStage;
                    if (uniforms) {
                      this.buildUniformBindGroup(uniforms);
                    }
                    if (elements) {
                      this.indexBuffer = elements.get();
                      this.indexCount = elements.indexCount;
                    }
                    vertexState = {
                      vertexBuffers: Object.keys(attributes).map(function(attributeName, i2) {
                        var attribute = attributes[attributeName];
                        var _attribute$get = attribute.get(), arrayStride = _attribute$get.arrayStride, stepMode = _attribute$get.stepMode, ats = _attribute$get.attributes;
                        _this.attributeCache[attributeName] = attribute;
                        return {
                          arrayStride,
                          stepMode,
                          attributes: ats
                        };
                      })
                    };
                    descriptor = {
                      sampleCount: this.engine.mainPassSampleCount,
                      primitiveTopology: primitiveMap2[primitive || gl.TRIANGLES],
                      rasterizationState: _objectSpread9(_objectSpread9({}, this.getDefaultRasterizationStateDescriptor()), {}, {
                        cullMode: getCullMode({
                          cull
                        })
                      }),
                      depthStencilState: getDepthStencilStateDescriptor({
                        depth,
                        stencil
                      }),
                      colorStates: getColorStateDescriptors({
                        blend
                      }, this.engine.options.swapChainFormat),
                      layout: this.pipelineLayout,
                      vertexStage,
                      fragmentStage,
                      vertexState
                    };
                    this.renderPipeline = this.engine.device.createRenderPipeline(descriptor);
                  case 11:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "addUniforms",
        value: function addUniforms(uniforms) {
          this.uniforms = _objectSpread9(_objectSpread9({}, this.uniforms), extractUniforms2(uniforms));
        }
      }, {
        key: "draw",
        value: function draw4(options) {
          var _this2 = this;
          var renderPass = this.engine.getCurrentRenderPass();
          var uniforms = _objectSpread9(_objectSpread9({}, this.uniforms), extractUniforms2(options.uniforms || {}));
          var bindGroupBindings = [];
          Object.keys(uniforms).forEach(function(uniformName) {
            var type = _typeof(uniforms[uniformName]);
            if (type === "boolean" || type === "number" || Array.isArray(uniforms[uniformName]) || uniforms[uniformName].BYTES_PER_ELEMENT) {
              var _this2$uniformGPUBuff;
              var offset = (_this2$uniformGPUBuff = _this2.uniformGPUBufferLayout.find(function(_ref2) {
                var name = _ref2.name;
                return name === uniformName;
              })) === null || _this2$uniformGPUBuff === void 0 ? void 0 : _this2$uniformGPUBuff.offset;
              if (offset !== null) {
                _this2.uniformBuffer.subData({
                  data: uniforms[uniformName],
                  offset
                });
              }
            } else {
              var _this2$uniformGPUBuff2;
              var _offset = (_this2$uniformGPUBuff2 = _this2.uniformGPUBufferLayout.find(function(_ref2) {
                var name = _ref2.name;
                return name === uniformName;
              })) === null || _this2$uniformGPUBuff2 === void 0 ? void 0 : _this2$uniformGPUBuff2.offset;
              if (_offset !== null) {
                var textureOrFramebuffer = uniforms[uniformName].get();
                var _ref3 = textureOrFramebuffer.color || textureOrFramebuffer, texture = _ref3.texture, sampler = _ref3.sampler;
                if (sampler) {
                  bindGroupBindings.push({
                    binding: _offset,
                    resource: sampler
                  });
                  _offset++;
                }
                bindGroupBindings.push({
                  binding: _offset,
                  resource: texture.createView()
                });
              }
            }
          });
          if (this.uniformBuffer) {
            bindGroupBindings[0] = {
              binding: 0,
              resource: {
                buffer: this.uniformBuffer.get()
              }
            };
          }
          this.uniformBindGroup = this.engine.device.createBindGroup({
            layout: this.uniformsBindGroupLayout,
            entries: bindGroupBindings
          });
          if (this.renderPipeline) {
            renderPass.setPipeline(this.renderPipeline);
          }
          renderPass.setBindGroup(0, this.uniformBindGroup);
          if (this.indexBuffer) {
            renderPass.setIndexBuffer(this.indexBuffer.get(), WebGPUConstants6.IndexFormat.Uint32, 0);
          }
          Object.keys(this.attributeCache).forEach(function(attributeName, i2) {
            renderPass.setVertexBuffer(0 + i2, _this2.attributeCache[attributeName].get().buffer, 0);
          });
          if (this.indexBuffer) {
            renderPass.drawIndexed(this.indexCount, this.options.instances || 1, 0, 0, 0);
          } else {
            renderPass.draw(this.options.count || 0, this.options.instances || 0, 0, 0);
          }
        }
      }, {
        key: "destroy",
        value: function destroy() {
          throw new Error("Method not implemented.");
        }
      }, {
        key: "compilePipelineStageDescriptor",
        value: function() {
          var _compilePipelineStageDescriptor = _asyncToGenerator(import_regenerator16.default.mark(function _callee2(vertexCode, fragmentCode, defines) {
            var shaderVersion, vertexShader, fragmentShader;
            return import_regenerator16.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    shaderVersion = "#version 450\n";
                    vertexShader = vertexCode;
                    fragmentShader = fragmentCode;
                    if (this.engine.options.useWGSL) {
                      _context2.next = 10;
                      break;
                    }
                    _context2.next = 6;
                    return this.compileShaderToSpirV(vertexCode, "vertex", shaderVersion);
                  case 6:
                    vertexShader = _context2.sent;
                    _context2.next = 9;
                    return this.compileShaderToSpirV(fragmentCode, "fragment", shaderVersion);
                  case 9:
                    fragmentShader = _context2.sent;
                  case 10:
                    return _context2.abrupt("return", this.createPipelineStageDescriptor(vertexShader, fragmentShader));
                  case 11:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function compilePipelineStageDescriptor(_x, _x2, _x3) {
            return _compilePipelineStageDescriptor.apply(this, arguments);
          }
          return compilePipelineStageDescriptor;
        }()
      }, {
        key: "compileShaderToSpirV",
        value: function compileShaderToSpirV(source, type, shaderVersion) {
          return this.compileRawShaderToSpirV(shaderVersion + source, type);
        }
      }, {
        key: "compileRawShaderToSpirV",
        value: function compileRawShaderToSpirV(source, type) {
          return this.engine.glslang.compileGLSL(source, type);
        }
      }, {
        key: "createPipelineStageDescriptor",
        value: function createPipelineStageDescriptor(vertexShader, fragmentShader) {
          return {
            vertexStage: {
              module: this.engine.device.createShaderModule({
                code: vertexShader,
                isWHLSL: isSafari
              }),
              entryPoint: "main"
            },
            fragmentStage: {
              module: this.engine.device.createShaderModule({
                code: fragmentShader,
                isWHLSL: isSafari
              }),
              entryPoint: "main"
            }
          };
        }
      }, {
        key: "getDefaultRasterizationStateDescriptor",
        value: function getDefaultRasterizationStateDescriptor() {
          return {
            frontFace: WebGPUConstants6.FrontFace.CCW,
            cullMode: WebGPUConstants6.CullMode.None,
            depthBias: 0,
            depthBiasSlopeScale: 0,
            depthBiasClamp: 0
          };
        }
      }, {
        key: "buildUniformBindGroup",
        value: function buildUniformBindGroup(uniforms) {
          var _this3 = this;
          var offset = 0;
          var mergedUniformData = concatenate.apply(void 0, [Float32Array].concat(_toConsumableArray(Object.keys(uniforms).map(function(uniformName) {
            if (uniforms[uniformName]) {
              _this3.uniformGPUBufferLayout.push({
                name: uniformName,
                offset
              });
              offset += (uniforms[uniformName].length || 1) * 4;
              return uniforms[uniformName];
            } else {
              return [];
            }
          }))));
          var entries = [];
          var hasUniform = false;
          if (mergedUniformData.length) {
            hasUniform = true;
            entries.push({
              binding: 0,
              visibility: WebGPUConstants6.ShaderStage.Fragment | WebGPUConstants6.ShaderStage.Vertex,
              type: WebGPUConstants6.BindingType.UniformBuffer
            });
          }
          Object.keys(uniforms).filter(function(uniformName) {
            return uniforms[uniformName] === null;
          }).forEach(function(uniformName, i2) {
            _this3.uniformGPUBufferLayout.push({
              name: uniformName,
              offset: i2 * 2 + (hasUniform ? 1 : 0)
            });
            entries.push({
              binding: i2 * 2 + (hasUniform ? 1 : 0),
              visibility: WebGPUConstants6.ShaderStage.Fragment,
              type: WebGPUConstants6.BindingType.Sampler
            }, {
              binding: i2 * 2 + (hasUniform ? 1 : 0) + 1,
              visibility: WebGPUConstants6.ShaderStage.Fragment,
              type: WebGPUConstants6.BindingType.SampledTexture
            });
          });
          this.uniformsBindGroupLayout = this.engine.device.createBindGroupLayout({
            entries
          });
          this.pipelineLayout = this.engine.device.createPipelineLayout({
            bindGroupLayouts: [this.uniformsBindGroupLayout]
          });
          if (hasUniform) {
            this.uniformBuffer = new WebGPUBuffer(this.engine, {
              data: mergedUniformData instanceof Array ? new Float32Array(mergedUniformData) : mergedUniformData,
              usage: WebGPUConstants6.BufferUsage.Uniform | WebGPUConstants6.BufferUsage.CopyDst
            });
          }
        }
      }]);
      return WebGPUModel2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUTexture2D.js
var WebGPUConstants7, WebGPUTexture2D;
var init_WebGPUTexture2D = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/WebGPUTexture2D.js"() {
    init_classCallCheck();
    init_createClass();
    init_es3();
    WebGPUConstants7 = __toESM(require_constants2());
    init_constants2();
    WebGPUTexture2D = function() {
      function WebGPUTexture2D2(engine, options) {
        _classCallCheck(this, WebGPUTexture2D2);
        this.engine = engine;
        this.options = options;
        this.texture = void 0;
        this.sampler = void 0;
        this.width = void 0;
        this.height = void 0;
        this.createTexture();
      }
      _createClass(WebGPUTexture2D2, [{
        key: "get",
        value: function get2() {
          return {
            texture: this.texture,
            sampler: this.sampler
          };
        }
      }, {
        key: "update",
        value: function update15() {
        }
      }, {
        key: "resize",
        value: function resize(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          if (width !== this.width || height !== this.height) {
            this.destroy();
            this.createTexture();
          }
          this.width = width;
          this.height = height;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.texture) {
            this.texture.destroy();
          }
        }
      }, {
        key: "createTexture",
        value: function createTexture() {
          var _this$options = this.options, data = _this$options.data, _this$options$type = _this$options.type, type = _this$options$type === void 0 ? gl.UNSIGNED_BYTE : _this$options$type, width = _this$options.width, height = _this$options.height, _this$options$flipY = _this$options.flipY, flipY = _this$options$flipY === void 0 ? false : _this$options$flipY, _this$options$format = _this$options.format, format2 = _this$options$format === void 0 ? gl.RGBA : _this$options$format, _this$options$mipmap = _this$options.mipmap, mipmap = _this$options$mipmap === void 0 ? false : _this$options$mipmap, _this$options$wrapS = _this$options.wrapS, wrapS = _this$options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _this$options$wrapS, _this$options$wrapT = _this$options.wrapT, wrapT = _this$options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _this$options$wrapT, _this$options$aniso = _this$options.aniso, aniso = _this$options$aniso === void 0 ? 0 : _this$options$aniso, _this$options$alignme = _this$options.alignment, alignment = _this$options$alignme === void 0 ? 1 : _this$options$alignme, _this$options$premult = _this$options.premultiplyAlpha, premultiplyAlpha = _this$options$premult === void 0 ? false : _this$options$premult, _this$options$mag = _this$options.mag, mag = _this$options$mag === void 0 ? gl.NEAREST : _this$options$mag, _this$options$min = _this$options.min, min6 = _this$options$min === void 0 ? gl.NEAREST : _this$options$min, _this$options$colorSp = _this$options.colorSpace, colorSpace = _this$options$colorSp === void 0 ? gl.BROWSER_DEFAULT_WEBGL : _this$options$colorSp, usage = _this$options.usage;
          this.width = width;
          this.height = height;
          this.texture = this.engine.device.createTexture({
            size: [width, height, 1],
            mipLevelCount: 1,
            sampleCount: 1,
            dimension: WebGPUConstants7.TextureDimension.E2d,
            format: formatMap2[format2],
            usage: usage || WebGPUConstants7.TextureUsage.Sampled | WebGPUConstants7.TextureUsage.CopyDst
          });
          if (!usage || usage & WebGPUConstants7.TextureUsage.Sampled) {
            this.sampler = this.engine.device.createSampler({
              addressModeU: wrapModeMap2[wrapS],
              addressModeV: wrapModeMap2[wrapT],
              addressModeW: wrapModeMap2[wrapS],
              magFilter: filterMap2[mag],
              minFilter: filterMap2[min6],
              maxAnisotropy: aniso
            });
          }
        }
      }]);
      return WebGPUTexture2D2;
    }();
  }
});

// node_modules/@antv/g-webgpu-engine/es/webgpu/index.js
var import_regenerator17, WebGPUConstants8, _dec49, _class21, _temp19, WebGPUEngine;
var init_webgpu = __esm({
  "node_modules/@antv/g-webgpu-engine/es/webgpu/index.js"() {
    import_regenerator17 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_classCallCheck();
    init_createClass();
    init_es3();
    WebGPUConstants8 = __toESM(require_constants2());
    init_inversify();
    init_glslang();
    init_WebGPUAttribute();
    init_WebGPUBuffer();
    init_WebGPUComputeModel();
    init_WebGPUElements();
    init_WebGPUFramebuffer();
    init_WebGPUModel();
    init_WebGPUTexture2D();
    WebGPUEngine = (_dec49 = injectable(), _dec49(_class21 = (_temp19 = function() {
      function WebGPUEngine2() {
        var _this = this;
        _classCallCheck(this, WebGPUEngine2);
        this.supportWebGPU = true;
        this.useWGSL = false;
        this.options = void 0;
        this.canvas = void 0;
        this.context = void 0;
        this.glslang = void 0;
        this.adapter = void 0;
        this.device = void 0;
        this.swapChain = void 0;
        this.mainPassSampleCount = void 0;
        this.mainTexture = void 0;
        this.depthTexture = void 0;
        this.mainColorAttachments = void 0;
        this.mainTextureExtends = void 0;
        this.mainDepthAttachment = void 0;
        this.uploadEncoder = void 0;
        this.renderEncoder = void 0;
        this.computeEncoder = void 0;
        this.renderTargetEncoder = void 0;
        this.commandBuffers = new Array(4).fill(void 0);
        this.currentRenderPass = null;
        this.mainRenderPass = null;
        this.currentRenderTargetViewDescriptor = void 0;
        this.currentComputePass = null;
        this.bundleEncoder = void 0;
        this.tempBuffers = [];
        this.currentRenderTarget = null;
        this.uploadEncoderDescriptor = {
          label: "upload"
        };
        this.renderEncoderDescriptor = {
          label: "render"
        };
        this.renderTargetEncoderDescriptor = {
          label: "renderTarget"
        };
        this.computeEncoderDescriptor = {
          label: "compute"
        };
        this.pipelines = {};
        this.computePipelines = {};
        this.defaultSampleCount = 4;
        this.clearDepthValue = 1;
        this.clearStencilValue = 0;
        this.transientViewport = {
          x: Infinity,
          y: 0,
          width: 0,
          height: 0
        };
        this.cachedViewport = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        this.clear = function(options) {
          var framebuffer = options.framebuffer, color3 = options.color, depth = options.depth, stencil = options.stencil;
          if (_this.options.supportCompute) {
            _this.startComputePass();
          }
          if (_this.currentRenderTarget) {
            if (_this.currentRenderPass) {
              _this.endRenderTargetRenderPass();
            }
            _this.startRenderTargetRenderPass(_this.currentRenderTarget, color3 ? color3 : null, !!depth, !!stencil);
          } else {
            _this.mainColorAttachments[0].loadValue = color3 ? color3 : WebGPUConstants8.LoadOp.Load;
            _this.mainDepthAttachment.depthLoadValue = depth ? depth : WebGPUConstants8.LoadOp.Load;
            _this.mainDepthAttachment.stencilLoadValue = stencil ? _this.clearStencilValue : WebGPUConstants8.LoadOp.Load;
            if (_this.mainRenderPass) {
              _this.endMainRenderPass();
            }
            _this.startMainRenderPass();
          }
        };
        this.createModel = function() {
          var _ref2 = _asyncToGenerator(import_regenerator17.default.mark(function _callee(options) {
            var model;
            return import_regenerator17.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    model = new WebGPUModel(_this, options);
                    _context.next = 3;
                    return model.init();
                  case 3:
                    return _context.abrupt("return", model);
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return function(_x) {
            return _ref2.apply(this, arguments);
          };
        }();
        this.createAttribute = function(options) {
          return new WebGPUAttribute(_this, options);
        };
        this.createBuffer = function(options) {
          return new WebGPUBuffer(_this, options);
        };
        this.createElements = function(options) {
          return new WebGPUElements(_this, options);
        };
        this.createTexture2D = function(options) {
          return new WebGPUTexture2D(_this, options);
        };
        this.createFramebuffer = function(options) {
          return new WebGPUFramebuffer(_this, options);
        };
        this.useFramebuffer = function(framebuffer, drawCommands) {
          if (_this.currentRenderTarget) {
            _this.unbindFramebuffer(_this.currentRenderTarget);
          }
          _this.currentRenderTarget = framebuffer;
          _this.currentRenderTargetViewDescriptor = {
            dimension: WebGPUConstants8.TextureViewDimension.E2d,
            arrayLayerCount: 1,
            aspect: WebGPUConstants8.TextureAspect.All
          };
          _this.currentRenderPass = null;
          drawCommands();
        };
        this.createComputeModel = function() {
          var _ref2 = _asyncToGenerator(import_regenerator17.default.mark(function _callee2(context) {
            var model;
            return import_regenerator17.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    model = new WebGPUComputeModel(_this, context);
                    _context2.next = 3;
                    return model.init();
                  case 3:
                    return _context2.abrupt("return", model);
                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));
          return function(_x2) {
            return _ref2.apply(this, arguments);
          };
        }();
        this.getCanvas = function() {
          return _this.canvas;
        };
        this.getGLContext = function() {
          throw new Error("Method not implemented.");
        };
        this.viewport = function(_ref3) {
          var x2 = _ref3.x, y2 = _ref3.y, width = _ref3.width, height = _ref3.height;
          if (!_this.currentRenderPass) {
            _this.transientViewport = {
              x: x2,
              y: y2,
              width,
              height
            };
          } else if (_this.transientViewport.x !== Infinity) {
            var renderPass = _this.getCurrentRenderPass();
            renderPass.setViewport(_this.transientViewport.x, _this.transientViewport.y, _this.transientViewport.width, _this.transientViewport.height, 0, 1);
          } else if (x2 !== _this.cachedViewport.x || y2 !== _this.cachedViewport.y || width !== _this.cachedViewport.width || height !== _this.cachedViewport.height) {
            _this.cachedViewport = {
              x: x2,
              y: y2,
              width,
              height
            };
            var _renderPass = _this.getCurrentRenderPass();
            _renderPass.setViewport(x2, y2, width, height, 0, 1);
          }
        };
        this.readPixels = function(options) {
          throw new Error("Method not implemented.");
        };
      }
      _createClass(WebGPUEngine2, [{
        key: "isFloatSupported",
        value: function isFloatSupported() {
          return true;
        }
      }, {
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator17.default.mark(function _callee3(config) {
            return import_regenerator17.default.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    this.canvas = config.canvas;
                    this.options = config;
                    this.useWGSL = !!config.useWGSL;
                    this.mainPassSampleCount = config.antialiasing ? this.defaultSampleCount : 1;
                    _context3.next = 6;
                    return this.initGlslang();
                  case 6:
                    this.initContextAndSwapChain();
                    this.initMainAttachments();
                  case 8:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function init(_x3) {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "setScissor",
        value: function setScissor(scissor) {
          throw new Error("Method not implemented.");
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.mainTexture) {
            this.mainTexture.destroy();
          }
          if (this.depthTexture) {
            this.depthTexture.destroy();
          }
          this.tempBuffers.forEach(function(buffer) {
            return buffer.destroy();
          });
          this.tempBuffers = [];
        }
      }, {
        key: "beginFrame",
        value: function beginFrame() {
          this.uploadEncoder = this.device.createCommandEncoder(this.uploadEncoderDescriptor);
          this.renderEncoder = this.device.createCommandEncoder(this.renderEncoderDescriptor);
          this.renderTargetEncoder = this.device.createCommandEncoder(this.renderTargetEncoderDescriptor);
          if (this.options.supportCompute) {
            this.computeEncoder = this.device.createCommandEncoder(this.computeEncoderDescriptor);
          }
        }
      }, {
        key: "endFrame",
        value: function endFrame() {
          if (this.options.supportCompute) {
            this.endComputePass();
          }
          this.endMainRenderPass();
          this.commandBuffers[0] = this.uploadEncoder.finish();
          this.commandBuffers[1] = this.renderEncoder.finish();
          if (this.options.supportCompute) {
            this.commandBuffers[2] = this.computeEncoder.finish();
          }
          this.commandBuffers[3] = this.renderTargetEncoder.finish();
          if (isSafari) {
            this.device.getQueue().submit(this.commandBuffers.filter(function(buffer) {
              return buffer;
            }));
          } else {
            this.device.defaultQueue.submit(this.commandBuffers.filter(function(buffer) {
              return buffer;
            }));
          }
        }
      }, {
        key: "getCurrentRenderPass",
        value: function getCurrentRenderPass() {
          if (this.currentRenderTarget && !this.currentRenderPass) {
            this.startRenderTargetRenderPass(this.currentRenderTarget, null, false, false);
          } else if (!this.currentRenderPass) {
            this.startMainRenderPass();
          }
          return this.currentRenderPass;
        }
      }, {
        key: "initGlslang",
        value: function() {
          var _initGlslang = _asyncToGenerator(import_regenerator17.default.mark(function _callee4() {
            var _navigator, _navigator$gpu;
            return import_regenerator17.default.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    _context4.next = 2;
                    return glslang_default();
                  case 2:
                    this.glslang = _context4.sent;
                    _context4.next = 5;
                    return (_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator$gpu = _navigator.gpu) === null || _navigator$gpu === void 0 ? void 0 : _navigator$gpu.requestAdapter();
                  case 5:
                    this.adapter = _context4.sent;
                    _context4.next = 8;
                    return this.adapter.requestDevice();
                  case 8:
                    this.device = _context4.sent;
                  case 9:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function initGlslang() {
            return _initGlslang.apply(this, arguments);
          }
          return initGlslang;
        }()
      }, {
        key: "initContextAndSwapChain",
        value: function initContextAndSwapChain() {
          this.context = this.canvas.getContext(isSafari ? "gpu" : "gpupresent");
          this.swapChain = this.context.configureSwapChain({
            device: this.device,
            format: this.options.swapChainFormat,
            usage: WebGPUConstants8.TextureUsage.OutputAttachment | WebGPUConstants8.TextureUsage.CopySrc
          });
        }
      }, {
        key: "initMainAttachments",
        value: function initMainAttachments() {
          this.mainTextureExtends = {
            width: this.canvas.width,
            height: this.canvas.height,
            depth: 1
          };
          if (this.options.antialiasing) {
            var mainTextureDescriptor = {
              size: this.mainTextureExtends,
              mipLevelCount: 1,
              sampleCount: this.mainPassSampleCount,
              dimension: WebGPUConstants8.TextureDimension.E2d,
              format: WebGPUConstants8.TextureFormat.BGRA8Unorm,
              usage: WebGPUConstants8.TextureUsage.OutputAttachment
            };
            if (this.mainTexture) {
              this.mainTexture.destroy();
            }
            this.mainTexture = this.device.createTexture(mainTextureDescriptor);
            this.mainColorAttachments = [{
              attachment: isSafari ? this.mainTexture.createDefaultView() : this.mainTexture.createView(),
              loadValue: [0, 0, 0, 1],
              storeOp: WebGPUConstants8.StoreOp.Store
            }];
          } else {
            this.mainColorAttachments = [{
              attachment: isSafari ? this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView(),
              loadValue: [0, 0, 0, 1],
              storeOp: WebGPUConstants8.StoreOp.Store
            }];
          }
          var depthTextureDescriptor = {
            size: this.mainTextureExtends,
            mipLevelCount: 1,
            sampleCount: this.mainPassSampleCount,
            dimension: WebGPUConstants8.TextureDimension.E2d,
            format: isSafari ? "depth32float-stencil8" : WebGPUConstants8.TextureFormat.Depth24PlusStencil8,
            usage: WebGPUConstants8.TextureUsage.OutputAttachment
          };
          if (this.depthTexture) {
            this.depthTexture.destroy();
          }
          this.depthTexture = this.device.createTexture(depthTextureDescriptor);
          this.mainDepthAttachment = {
            attachment: isSafari ? this.depthTexture.createDefaultView() : this.depthTexture.createView(),
            depthLoadValue: this.clearDepthValue,
            depthStoreOp: WebGPUConstants8.StoreOp.Store,
            stencilLoadValue: this.clearStencilValue,
            stencilStoreOp: WebGPUConstants8.StoreOp.Store
          };
        }
      }, {
        key: "startComputePass",
        value: function startComputePass() {
          if (this.currentComputePass) {
            this.endComputePass();
          }
          this.currentComputePass = this.computeEncoder.beginComputePass();
        }
      }, {
        key: "startMainRenderPass",
        value: function startMainRenderPass() {
          if (this.currentRenderPass && !this.currentRenderTarget) {
            this.endMainRenderPass();
          }
          if (this.options.antialiasing) {
            this.mainColorAttachments[0].resolveTarget = isSafari ? this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();
          } else {
            this.mainColorAttachments[0].attachment = isSafari ? this.swapChain.getCurrentTexture().createDefaultView() : this.swapChain.getCurrentTexture().createView();
          }
          this.currentRenderPass = this.renderEncoder.beginRenderPass({
            colorAttachments: this.mainColorAttachments,
            depthStencilAttachment: this.mainDepthAttachment
          });
          this.mainRenderPass = this.currentRenderPass;
          if (this.cachedViewport) {
            this.viewport(this.cachedViewport);
          }
        }
      }, {
        key: "startRenderTargetRenderPass",
        value: function startRenderTargetRenderPass(renderTarget, clearColor, clearDepth) {
          var _renderTarget$get$col, _renderTarget$get$dep;
          var clearStencil = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var gpuTexture = (_renderTarget$get$col = renderTarget.get().color) === null || _renderTarget$get$col === void 0 ? void 0 : _renderTarget$get$col.texture;
          var colorTextureView;
          if (gpuTexture) {
            colorTextureView = gpuTexture.createView(this.currentRenderTargetViewDescriptor);
          }
          var depthStencilTexture = (_renderTarget$get$dep = renderTarget.get().depth) === null || _renderTarget$get$dep === void 0 ? void 0 : _renderTarget$get$dep.texture;
          var depthStencilTextureView;
          if (depthStencilTexture) {
            depthStencilTextureView = depthStencilTexture.createView();
          }
          var renderPass = this.renderTargetEncoder.beginRenderPass({
            colorAttachments: [{
              attachment: colorTextureView,
              loadValue: clearColor !== null ? clearColor : WebGPUConstants8.LoadOp.Load,
              storeOp: WebGPUConstants8.StoreOp.Store
            }],
            depthStencilAttachment: depthStencilTexture && depthStencilTextureView ? {
              attachment: depthStencilTextureView,
              depthLoadValue: clearDepth ? this.clearDepthValue : WebGPUConstants8.LoadOp.Load,
              depthStoreOp: WebGPUConstants8.StoreOp.Store,
              stencilLoadValue: clearStencil ? this.clearStencilValue : WebGPUConstants8.LoadOp.Load,
              stencilStoreOp: WebGPUConstants8.StoreOp.Store
            } : void 0
          });
          this.currentRenderPass = renderPass;
          if (this.cachedViewport) {
            this.viewport(this.cachedViewport);
          }
        }
      }, {
        key: "endMainRenderPass",
        value: function endMainRenderPass() {
          if (this.currentRenderPass === this.mainRenderPass && this.currentRenderPass !== null) {
            this.currentRenderPass.endPass();
            this.resetCachedViewport();
            this.currentRenderPass = null;
            this.mainRenderPass = null;
          }
        }
      }, {
        key: "endComputePass",
        value: function endComputePass() {
          if (this.currentComputePass) {
            this.currentComputePass.endPass();
            this.currentComputePass = null;
          }
        }
      }, {
        key: "endRenderTargetRenderPass",
        value: function endRenderTargetRenderPass() {
          if (this.currentRenderPass) {
            this.currentRenderPass.endPass();
            this.resetCachedViewport();
          }
        }
      }, {
        key: "resetCachedViewport",
        value: function resetCachedViewport() {
          this.cachedViewport = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }, {
        key: "unbindFramebuffer",
        value: function unbindFramebuffer(framebuffer) {
          if (this.currentRenderPass && this.currentRenderPass !== this.mainRenderPass) {
            this.endRenderTargetRenderPass();
          }
          this.transientViewport.x = Infinity;
          this.currentRenderTarget = null;
          this.currentRenderPass = this.mainRenderPass;
        }
      }]);
      return WebGPUEngine2;
    }(), _temp19)) || _class21);
  }
});

// node_modules/@antv/g-webgpu-engine/es/index.js
var init_es4 = __esm({
  "node_modules/@antv/g-webgpu-engine/es/index.js"() {
    init_webgl();
    init_webgpu();
  }
});

// node_modules/@antv/g-webgpu/es/geometry/Box.js
function _createSuper10(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct10();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct10() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec50, _class30, primitiveUv1Padding, primitiveUv1PaddingScale, Box;
var init_Box = __esm({
  "node_modules/@antv/g-webgpu/es/geometry/Box.js"() {
    init_slicedToArray();
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_es3();
    init_esm2();
    init_inversify();
    init_geometry();
    primitiveUv1Padding = 4 / 64;
    primitiveUv1PaddingScale = 1 - primitiveUv1Padding * 2;
    Box = (_dec50 = injectable(), _dec50(_class30 = function(_Geometry) {
      _inherits2(Box2, _Geometry);
      var _super = _createSuper10(Box2);
      function Box2() {
        _classCallCheck(this, Box2);
        return _super.apply(this, arguments);
      }
      _createClass(Box2, [{
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var _this$config = this.config, _this$config$widthSeg = _this$config.widthSegments, widthSegments = _this$config$widthSeg === void 0 ? 1 : _this$config$widthSeg, _this$config$heightSe = _this$config.heightSegments, heightSegments = _this$config$heightSe === void 0 ? 1 : _this$config$heightSe, _this$config$depthSeg = _this$config.depthSegments, depthSegments = _this$config$depthSeg === void 0 ? 1 : _this$config$depthSeg, _this$config$halfExte = _this$config.halfExtents, halfExtents = _this$config$halfExte === void 0 ? vec3_exports.fromValues(0.5, 0.5, 0.5) : _this$config$halfExte;
          var ws = widthSegments;
          var hs = heightSegments;
          var ds = depthSegments;
          var _halfExtents = _slicedToArray(halfExtents, 3), hex2 = _halfExtents[0], hey = _halfExtents[1], hez = _halfExtents[2];
          var corners = [vec3_exports.fromValues(-hex2, -hey, hez), vec3_exports.fromValues(hex2, -hey, hez), vec3_exports.fromValues(hex2, hey, hez), vec3_exports.fromValues(-hex2, hey, hez), vec3_exports.fromValues(hex2, -hey, -hez), vec3_exports.fromValues(-hex2, -hey, -hez), vec3_exports.fromValues(-hex2, hey, -hez), vec3_exports.fromValues(hex2, hey, -hez)];
          var faceAxes = [
            [0, 1, 3],
            [4, 5, 7],
            [3, 2, 6],
            [1, 0, 4],
            [1, 4, 2],
            [5, 0, 6]
          ];
          var faceNormals = [
            [0, 0, 1],
            [0, 0, -1],
            [0, 1, 0],
            [0, -1, 0],
            [1, 0, 0],
            [-1, 0, 0]
          ];
          var sides = {
            FRONT: 0,
            BACK: 1,
            TOP: 2,
            BOTTOM: 3,
            RIGHT: 4,
            LEFT: 5
          };
          var positions = [];
          var normals = [];
          var uvs = [];
          var uvs1 = [];
          var indices = [];
          var vcounter = 0;
          var generateFace = function generateFace2(side, uSegments, vSegments) {
            var u2;
            var v2;
            var i2;
            var j2;
            for (i2 = 0; i2 <= uSegments; i2++) {
              for (j2 = 0; j2 <= vSegments; j2++) {
                var temp1 = vec3_exports.create();
                var temp2 = vec3_exports.create();
                var temp3 = vec3_exports.create();
                var r2 = vec3_exports.create();
                vec3_exports.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i2 / uSegments);
                vec3_exports.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j2 / vSegments);
                vec3_exports.sub(temp3, temp2, corners[faceAxes[side][0]]);
                vec3_exports.add(r2, temp1, temp3);
                u2 = i2 / uSegments;
                v2 = j2 / vSegments;
                positions.push(r2[0], r2[1], r2[2]);
                normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
                uvs.push(u2, v2);
                u2 /= 3;
                v2 /= 3;
                u2 = u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
                v2 = v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
                u2 += side % 3 / 3;
                v2 += Math.floor(side / 3) / 3;
                uvs1.push(u2, v2);
                if (i2 < uSegments && j2 < vSegments) {
                  indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
                  indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
                }
                vcounter++;
              }
            }
          };
          generateFace(sides.FRONT, ws, hs);
          generateFace(sides.BACK, ws, hs);
          generateFace(sides.TOP, ws, ds);
          generateFace(sides.BOTTOM, ws, ds);
          generateFace(sides.RIGHT, ds, hs);
          generateFace(sides.LEFT, ds, hs);
          var aabb = generateAABBFromVertices(positions);
          var component = this.getComponent();
          component.indices = Uint32Array.from(indices);
          component.aabb = aabb;
          component.vertexCount = vcounter;
          component.attributes = [{
            dirty: true,
            name: "position",
            data: Float32Array.from(positions),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "normal",
            data: Float32Array.from(normals),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 1,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "uv",
            data: Float32Array.from(uvs),
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 2,
              offset: 0,
              format: "float2"
            }]
          }];
        }
      }]);
      return Box2;
    }(Geometry)) || _class30);
  }
});

// node_modules/@antv/g-webgpu/es/utils/typedarray.js
function merge(a2, b10) {
  if (!a2 && !b10) {
    throw new Error("Please specify valid arguments for parameters a and b.");
  }
  if (!b10 || b10.length === 0) {
    return a2;
  }
  if (!a2 || a2.length === 0) {
    return b10;
  }
  if (Object.prototype.toString.call(a2) !== Object.prototype.toString.call(b10)) {
    throw new Error("The types of the two arguments passed for parameters a and b do not match.");
  }
  var c2 = new a2.constructor(a2.length + b10.length);
  c2.set(a2);
  c2.set(b10, a2.length);
  return c2;
}
var init_typedarray = __esm({
  "node_modules/@antv/g-webgpu/es/utils/typedarray.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/geometry/Merged.js
function _createSuper11(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct11();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct11() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec51, _class31, Merged;
var init_Merged = __esm({
  "node_modules/@antv/g-webgpu/es/geometry/Merged.js"() {
    init_toConsumableArray();
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_es3();
    init_inversify();
    init_geometry();
    init_is_number3();
    init_is_typedarray2();
    init_typedarray();
    Merged = (_dec51 = injectable(), _dec51(_class31 = function(_Geometry) {
      _inherits2(Merged2, _Geometry);
      var _super = _createSuper11(Merged2);
      function Merged2() {
        _classCallCheck(this, Merged2);
        return _super.apply(this, arguments);
      }
      _createClass(Merged2, [{
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var _this$config$geometri = this.config.geometries, geometries = _this$config$geometri === void 0 ? [] : _this$config$geometri;
          var mergedComponent = this.getComponent();
          mergedComponent.aabb = new AABB();
          var mergedAttributes = [];
          var mergedIndices = [];
          var indexOffset = 0;
          geometries.forEach(function(geometry) {
            var aabb = geometry.aabb, indices = geometry.indices, vertexCount = geometry.vertexCount, attributes = geometry.attributes;
            mergedComponent.aabb.add(aabb);
            mergedComponent.vertexCount += vertexCount;
            if (indices) {
              mergedIndices.push.apply(mergedIndices, _toConsumableArray(indices.map(function(index) {
                return index + indexOffset;
              })));
            }
            indexOffset += vertexCount;
            attributes.forEach(function(attribute, i2) {
              if (!mergedAttributes[i2]) {
                mergedAttributes[i2] = attribute;
                mergedAttributes[i2].dirty = true;
              } else {
                if (attribute.data) {
                  if (isNumber3(attribute.data)) {
                    mergedAttributes[i2].push(attribute.data);
                  } else if (isTypedArray2(attribute.data)) {
                    mergedAttributes[i2].data = merge(mergedAttributes[i2].data, attribute.data);
                  } else {
                    mergedAttributes[i2].data = mergedAttributes[i2].data.concat(attribute.data);
                  }
                }
              }
            });
          });
          mergedComponent.attributes = mergedAttributes;
          mergedComponent.indices = Uint32Array.from(mergedIndices);
          mergedComponent.dirty = true;
        }
      }]);
      return Merged2;
    }(Geometry)) || _class31);
  }
});

// node_modules/@antv/g-webgpu/es/geometry/Plane.js
function _createSuper12(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct12();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct12() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec57, _class39, Plane2;
var init_Plane2 = __esm({
  "node_modules/@antv/g-webgpu/es/geometry/Plane.js"() {
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_es3();
    init_inversify();
    init_geometry();
    Plane2 = (_dec57 = injectable(), _dec57(_class39 = function(_Geometry) {
      _inherits2(Plane3, _Geometry);
      var _super = _createSuper12(Plane3);
      function Plane3() {
        _classCallCheck(this, Plane3);
        return _super.apply(this, arguments);
      }
      _createClass(Plane3, [{
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var _this$config = this.config, _this$config$halfExte = _this$config.halfExtents, halfExtents = _this$config$halfExte === void 0 ? [0.5, 0.5] : _this$config$halfExte, _this$config$widthSeg = _this$config.widthSegments, widthSegments = _this$config$widthSeg === void 0 ? 5 : _this$config$widthSeg, _this$config$lengthSe = _this$config.lengthSegments, lengthSegments = _this$config$lengthSe === void 0 ? 5 : _this$config$lengthSe;
          var positions = [];
          var normals = [];
          var uvs = [];
          var indices = [];
          var vcounter = 0;
          for (var i2 = 0; i2 <= widthSegments; i2++) {
            for (var j2 = 0; j2 <= lengthSegments; j2++) {
              var x2 = -halfExtents[0] + 2 * halfExtents[0] * i2 / widthSegments;
              var y2 = 0;
              var z2 = -(-halfExtents[1] + 2 * halfExtents[1] * j2 / lengthSegments);
              var u2 = i2 / widthSegments;
              var v2 = j2 / lengthSegments;
              positions.push(x2, y2, z2);
              normals.push(0, 1, 0);
              uvs.push(u2, v2);
              if (i2 < widthSegments && j2 < lengthSegments) {
                indices.push(vcounter + lengthSegments + 1, vcounter + 1, vcounter);
                indices.push(vcounter + lengthSegments + 1, vcounter + lengthSegments + 2, vcounter + 1);
              }
              vcounter++;
            }
          }
          var aabb = generateAABBFromVertices(positions);
          var component = this.getComponent();
          component.indices = Uint32Array.from(indices);
          component.aabb = aabb;
          component.vertexCount = vcounter;
          component.attributes = [{
            dirty: true,
            name: "position",
            data: Float32Array.from(positions),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "normal",
            data: Float32Array.from(normals),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 1,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "uv",
            data: Float32Array.from(uvs),
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 2,
              offset: 0,
              format: "float2"
            }]
          }];
        }
      }]);
      return Plane3;
    }(Geometry)) || _class39);
  }
});

// node_modules/@antv/g-webgpu/es/geometry/Sphere.js
function _createSuper13(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct13();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct13() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec58, _class40, Sphere;
var init_Sphere = __esm({
  "node_modules/@antv/g-webgpu/es/geometry/Sphere.js"() {
    init_classCallCheck();
    init_createClass();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_es3();
    init_inversify();
    init_geometry();
    Sphere = (_dec58 = injectable(), _dec58(_class40 = function(_Geometry) {
      _inherits2(Sphere2, _Geometry);
      var _super = _createSuper13(Sphere2);
      function Sphere2() {
        _classCallCheck(this, Sphere2);
        return _super.apply(this, arguments);
      }
      _createClass(Sphere2, [{
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var _this$config = this.config, _this$config$radius = _this$config.radius, radius = _this$config$radius === void 0 ? 0.5 : _this$config$radius, _this$config$latitude = _this$config.latitudeBands, latitudeBands = _this$config$latitude === void 0 ? 16 : _this$config$latitude, _this$config$longitud = _this$config.longitudeBands, longitudeBands = _this$config$longitud === void 0 ? 16 : _this$config$longitud;
          var positions = [];
          var normals = [];
          var uvs = [];
          var indices = [];
          for (var lat = 0; lat <= latitudeBands; lat++) {
            var theta = lat * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);
            for (var lon = 0; lon <= longitudeBands; lon++) {
              var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
              var sinPhi = Math.sin(phi);
              var cosPhi = Math.cos(phi);
              var x2 = cosPhi * sinTheta;
              var y2 = cosTheta;
              var z2 = sinPhi * sinTheta;
              var u2 = 1 - lon / longitudeBands;
              var v2 = 1 - lat / latitudeBands;
              positions.push(x2 * radius, y2 * radius, z2 * radius);
              normals.push(x2, y2, z2);
              uvs.push(u2, v2);
            }
          }
          for (var _lat = 0; _lat < latitudeBands; ++_lat) {
            for (var _lon = 0; _lon < longitudeBands; ++_lon) {
              var first = _lat * (longitudeBands + 1) + _lon;
              var second = first + longitudeBands + 1;
              indices.push(first + 1, second, first);
              indices.push(first + 1, second + 1, second);
            }
          }
          var aabb = generateAABBFromVertices(positions);
          var component = this.getComponent();
          component.indices = Uint32Array.from(indices);
          component.aabb = aabb;
          component.vertexCount = positions.length / 3;
          component.attributes = [{
            dirty: true,
            name: "position",
            data: Float32Array.from(positions),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "normal",
            data: Float32Array.from(normals),
            arrayStride: 4 * 3,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 1,
              offset: 0,
              format: "float3"
            }]
          }, {
            dirty: true,
            name: "uv",
            data: Float32Array.from(uvs),
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 2,
              offset: 0,
              format: "float2"
            }]
          }];
        }
      }]);
      return Sphere2;
    }(Geometry)) || _class40);
  }
});

// node_modules/@antv/g-webgpu/es/material/basic/index.js
function _createSuper14(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct14();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct14() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec59, _dec216, _dec312, _class41, _class216, _descriptor20, _descriptor212, _temp20, webglFragmentShaderGLSL, webglVertexShaderGLSL, webgpuFragmentShaderGLSL, webgpuVertexShaderGLSL, Basic;
var init_basic = __esm({
  "node_modules/@antv/g-webgpu/es/material/basic/index.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_esm2();
    init_inversify();
    init_material();
    webglFragmentShaderGLSL = 'varying vec4 fragColor;\n\n#pragma include "uv.frag.declaration"\n#pragma include "map.frag.declaration"\n\nvoid main() {\n  vec4 diffuseColor = fragColor;\n\n  #pragma include "map.frag.main"\n\n  gl_FragColor = diffuseColor;\n}';
    webglVertexShaderGLSL = 'attribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform vec4 color;\n\nvarying vec4 fragColor;\n\n#pragma include "uv.vert.declaration"\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  fragColor = color;\n\n  #pragma include "uv.vert.main"\n}';
    webgpuFragmentShaderGLSL = "// layout(set = 0, binding = 1) uniform WireframeUniforms {\n//   float lineWidth;\n//   vec4 lineColor;\n// } wireframe;\n\nlayout(location = 0) in vec4 fragColor;\n// layout(location = 1) in vec3 v_Barycentric;\n\nlayout(location = 0) out vec4 outColor;\n\n// wireframe\n// float edgeFactor() {\n//   vec3 d = fwidth(v_Barycentric);\n//   vec3 a3 = smoothstep(vec3(0.0), d * wireframe.lineWidth, v_Barycentric);\n//   return min(min(a3.x, a3.y), a3.z);\n// }\n\nvoid main() {\n  // outColor = mix(fragColor, wireframe.lineColor, (1.0 - edgeFactor()));\n  outColor = fragColor;\n}";
    webgpuVertexShaderGLSL = "layout(set = 0, binding = 0) uniform Uniforms {\n  vec4 color;\n  mat4 projectionMatrix;\n  mat4 modelViewMatrix;\n} uniforms;\n\nlayout(location = 0) in vec3 position;\n// layout(location = 1) in vec3 barycentric;\n\nlayout(location = 0) out vec4 fragColor;\n// layout(location = 1) out vec3 v_Barycentric;\n\nvoid main() {\n  gl_Position = uniforms.projectionMatrix * uniforms.modelViewMatrix * vec4(position, 1.0);\n  fragColor = uniforms.color;\n  // v_Barycentric = barycentric;\n}";
    Basic = (_dec59 = injectable(), _dec216 = inject(IDENTIFIER.RenderEngine), _dec312 = inject(IDENTIFIER.ShaderModuleService), _dec59(_class41 = (_class216 = (_temp20 = function(_Material) {
      _inherits2(Basic2, _Material);
      var _super = _createSuper14(Basic2);
      function Basic2() {
        var _this;
        _classCallCheck(this, Basic2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _initializerDefineProperty(_this, "engine", _descriptor20, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "shaderModuleService", _descriptor212, _assertThisInitialized2(_this));
        return _this;
      }
      _createClass(Basic2, [{
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var component = this.getComponent();
          var vertexShaderGLSL = this.engine.supportWebGPU ? webgpuVertexShaderGLSL : webglVertexShaderGLSL;
          var fragmentShaderGLSL = this.engine.supportWebGPU ? webgpuFragmentShaderGLSL : webglFragmentShaderGLSL;
          this.shaderModuleService.registerModule("material-basic", {
            vs: vertexShaderGLSL,
            fs: fragmentShaderGLSL
          });
          var _this$shaderModuleSer = this.shaderModuleService.getModule("material-basic"), vs = _this$shaderModuleSer.vs, fs = _this$shaderModuleSer.fs, extractedUniforms = _this$shaderModuleSer.uniforms;
          component.vertexShaderGLSL = vs;
          component.fragmentShaderGLSL = fs;
          component.setUniform(extractedUniforms);
          if (this.config.map) {
            component.setDefines({
              USE_UV: 1,
              USE_MAP: 1
            });
            component.setUniform({
              map: this.config.map,
              uvTransform: mat3_exports.create()
            });
          }
        }
      }]);
      return Basic2;
    }(Material), _temp20), _descriptor20 = _applyDecoratedDescriptor(_class216.prototype, "engine", [_dec216], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor212 = _applyDecoratedDescriptor(_class216.prototype, "shaderModuleService", [_dec312], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class216)) || _class41);
  }
});

// node_modules/@antv/g-webgpu/es/renderable/grid/index.js
function _createSuper15(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct15();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct15() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec60, _dec217, _dec313, _dec410, _dec510, _dec65, _class42, _class217, _descriptor21, _descriptor213, _descriptor39, _temp21, gridFrag, gridVert, Grid;
var init_grid = __esm({
  "node_modules/@antv/g-webgpu/es/renderable/grid/index.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    init_Renderable();
    gridFrag = "// generate grid, borrow from clay.gl viewer\n// @see https://github.com/pissang/clay-viewer/blob/master/src/graphic/ground.glsl\n#extension GL_OES_standard_derivatives : enable\n\nvarying vec3 v_Position;\n// varying vec3 v_Normal;\n\nuniform float u_GridSize : 5;\nuniform float u_GridSize2 : .5;\nuniform vec4 u_GridColor : [0, 0, 0, 1];\nuniform vec4 u_GridColor2 : [0.3, 0.3, 0.3, 1];\nuniform bool u_GridEnabled : true;\n\n// uniform vec3 u_LightDirection;\n// uniform vec3 u_LightColor;\n// uniform vec3 u_Camera;\n\nvoid main() {\n  // vec3 n = v_Normal;\n  // vec3 l = normalize(u_LightDirection);\n  // float NdotL = clamp(dot(n, l), 0.001, 1.0);\n\n  gl_FragColor = vec4(1.);\n\n  if (u_GridEnabled) {\n    float wx = v_Position.x;\n    float wz = v_Position.z;\n    // float x0 = abs(fract(wx / u_GridSize - 0.5) - 0.5) / fwidth(wx) * u_GridSize / 2.0;\n    // float z0 = abs(fract(wz / u_GridSize - 0.5) - 0.5) / fwidth(wz) * u_GridSize / 2.0;\n\n    float x1 = abs(fract(wx / u_GridSize2 - 0.5) - 0.5) / fwidth(wx) * u_GridSize2;\n    float z1 = abs(fract(wz / u_GridSize2 - 0.5) - 0.5) / fwidth(wz) * u_GridSize2;\n\n    // float v0 = 1.0 - clamp(min(x0, z0), 0.0, 1.0);\n    float v1 = 1.0 - clamp(min(x1, z1), 0.0, 1.0);\n    // if (v0 > 0.1) {\n        // gl_FragColor = mix(gl_FragColor, u_GridColor, v0);\n    // }\n    // else {\n        gl_FragColor = mix(gl_FragColor, u_GridColor2, v1);\n    // }\n  }\n\n  // float shadowFactor = calcShadow(u_ShadowMap, v_PositionFromLight, l, n);\n  // vec3 diffuseColor = u_LightColor * NdotL * shadowFactor;\n\n  // gl_FragColor.rgb *= diffuseColor;\n}";
    gridVert = "attribute vec3 a_Position;\n\nvarying vec3 v_Position;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nvoid main() {\n  v_Position = a_Position;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(a_Position, 1.);\n}";
    Grid = (_dec60 = injectable(), _dec217 = inject(IDENTIFIER.Systems), _dec313 = named2(IDENTIFIER.MaterialSystem), _dec410 = inject(IDENTIFIER.Systems), _dec510 = named2(IDENTIFIER.GeometrySystem), _dec65 = inject(IDENTIFIER.ShaderModuleService), _dec60(_class42 = (_class217 = (_temp21 = function(_Renderable) {
      _inherits2(Grid4, _Renderable);
      var _super = _createSuper15(Grid4);
      function Grid4() {
        var _this;
        _classCallCheck(this, Grid4);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _initializerDefineProperty(_this, "materialSystem", _descriptor21, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "geometrySystem", _descriptor213, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "shaderModuleService", _descriptor39, _assertThisInitialized2(_this));
        return _this;
      }
      _createClass(Grid4, [{
        key: "onAttributeChanged",
        value: function onAttributeChanged(_ref2) {
          var name = _ref2.name, data = _ref2.data;
          var mesh = this.getMeshComponent();
          if (mesh && mesh.material) {
            if (name === "gridColor") {
              mesh.material.setUniform("u_GridColor", data);
              mesh.material.setUniform("u_GridColor2", data);
            } else if (name === "gridSize") {
              mesh.material.setUniform("u_GridSize", data);
              mesh.material.setUniform("u_GridSize2", data);
            }
          }
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
          this.shaderModuleService.registerModule("grid", {
            vs: gridVert,
            fs: gridFrag
          });
          var _this$shaderModuleSer = this.shaderModuleService.getModule("grid"), vs = _this$shaderModuleSer.vs, fs = _this$shaderModuleSer.fs, extractedUniforms = _this$shaderModuleSer.uniforms;
          var material = this.materialSystem.createShaderMaterial({
            vertexShader: vs,
            fragmentShader: fs
          });
          this.setMaterial(material);
          var geometry = this.geometrySystem.createBufferGeometry({
            vertexCount: 4
          });
          this.setGeometry(geometry);
          material.setCull({
            enable: false,
            face: gl.BACK
          }).setDepth({
            enable: true,
            func: gl.LESS
          });
          material.setUniform(extractedUniforms);
          this.setAttributes({
            gridColor: this.config.gridColor,
            gridSize: this.config.gridSize
          });
          geometry.setIndex([0, 3, 2, 2, 1, 0]);
          geometry.setAttribute("a_Position", Float32Array.from([-4, -1, -4, 4, -1, -4, 4, -1, 4, -4, -1, 4]), {
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float2"
            }]
          });
        }
      }]);
      return Grid4;
    }(Renderable), _temp21), _descriptor21 = _applyDecoratedDescriptor(_class217.prototype, "materialSystem", [_dec217, _dec313], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor213 = _applyDecoratedDescriptor(_class217.prototype, "geometrySystem", [_dec410, _dec510], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor39 = _applyDecoratedDescriptor(_class217.prototype, "shaderModuleService", [_dec65], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class217)) || _class42);
  }
});

// node_modules/gl-vec2/epsilon.js
var require_epsilon = __commonJS({
  "node_modules/gl-vec2/epsilon.js"(exports, module) {
    module.exports = 1e-6;
  }
});

// node_modules/gl-vec2/create.js
var require_create = __commonJS({
  "node_modules/gl-vec2/create.js"(exports, module) {
    module.exports = create8;
    function create8() {
      var out = new Float32Array(2);
      out[0] = 0;
      out[1] = 0;
      return out;
    }
  }
});

// node_modules/gl-vec2/clone.js
var require_clone = __commonJS({
  "node_modules/gl-vec2/clone.js"(exports, module) {
    module.exports = clone8;
    function clone8(a2) {
      var out = new Float32Array(2);
      out[0] = a2[0];
      out[1] = a2[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/fromValues.js
var require_fromValues = __commonJS({
  "node_modules/gl-vec2/fromValues.js"(exports, module) {
    module.exports = fromValues7;
    function fromValues7(x2, y2) {
      var out = new Float32Array(2);
      out[0] = x2;
      out[1] = y2;
      return out;
    }
  }
});

// node_modules/gl-vec2/copy.js
var require_copy = __commonJS({
  "node_modules/gl-vec2/copy.js"(exports, module) {
    module.exports = copy8;
    function copy8(out, a2) {
      out[0] = a2[0];
      out[1] = a2[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/set.js
var require_set = __commonJS({
  "node_modules/gl-vec2/set.js"(exports, module) {
    module.exports = set8;
    function set8(out, x2, y2) {
      out[0] = x2;
      out[1] = y2;
      return out;
    }
  }
});

// node_modules/gl-vec2/equals.js
var require_equals = __commonJS({
  "node_modules/gl-vec2/equals.js"(exports, module) {
    module.exports = equals7;
    var EPSILON3 = require_epsilon();
    function equals7(a2, b10) {
      var a0 = a2[0];
      var a1 = a2[1];
      var b02 = b10[0];
      var b12 = b10[1];
      return Math.abs(a0 - b02) <= EPSILON3 * Math.max(1, Math.abs(a0), Math.abs(b02)) && Math.abs(a1 - b12) <= EPSILON3 * Math.max(1, Math.abs(a1), Math.abs(b12));
    }
  }
});

// node_modules/gl-vec2/exactEquals.js
var require_exactEquals = __commonJS({
  "node_modules/gl-vec2/exactEquals.js"(exports, module) {
    module.exports = exactEquals7;
    function exactEquals7(a2, b10) {
      return a2[0] === b10[0] && a2[1] === b10[1];
    }
  }
});

// node_modules/gl-vec2/add.js
var require_add = __commonJS({
  "node_modules/gl-vec2/add.js"(exports, module) {
    module.exports = add7;
    function add7(out, a2, b10) {
      out[0] = a2[0] + b10[0];
      out[1] = a2[1] + b10[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/subtract.js
var require_subtract = __commonJS({
  "node_modules/gl-vec2/subtract.js"(exports, module) {
    module.exports = subtract6;
    function subtract6(out, a2, b10) {
      out[0] = a2[0] - b10[0];
      out[1] = a2[1] - b10[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/sub.js
var require_sub = __commonJS({
  "node_modules/gl-vec2/sub.js"(exports, module) {
    module.exports = require_subtract();
  }
});

// node_modules/gl-vec2/multiply.js
var require_multiply = __commonJS({
  "node_modules/gl-vec2/multiply.js"(exports, module) {
    module.exports = multiply7;
    function multiply7(out, a2, b10) {
      out[0] = a2[0] * b10[0];
      out[1] = a2[1] * b10[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/mul.js
var require_mul = __commonJS({
  "node_modules/gl-vec2/mul.js"(exports, module) {
    module.exports = require_multiply();
  }
});

// node_modules/gl-vec2/divide.js
var require_divide = __commonJS({
  "node_modules/gl-vec2/divide.js"(exports, module) {
    module.exports = divide4;
    function divide4(out, a2, b10) {
      out[0] = a2[0] / b10[0];
      out[1] = a2[1] / b10[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/div.js
var require_div = __commonJS({
  "node_modules/gl-vec2/div.js"(exports, module) {
    module.exports = require_divide();
  }
});

// node_modules/gl-vec2/inverse.js
var require_inverse = __commonJS({
  "node_modules/gl-vec2/inverse.js"(exports, module) {
    module.exports = inverse5;
    function inverse5(out, a2) {
      out[0] = 1 / a2[0];
      out[1] = 1 / a2[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/min.js
var require_min = __commonJS({
  "node_modules/gl-vec2/min.js"(exports, module) {
    module.exports = min6;
    function min6(out, a2, b10) {
      out[0] = Math.min(a2[0], b10[0]);
      out[1] = Math.min(a2[1], b10[1]);
      return out;
    }
  }
});

// node_modules/gl-vec2/max.js
var require_max = __commonJS({
  "node_modules/gl-vec2/max.js"(exports, module) {
    module.exports = max7;
    function max7(out, a2, b10) {
      out[0] = Math.max(a2[0], b10[0]);
      out[1] = Math.max(a2[1], b10[1]);
      return out;
    }
  }
});

// node_modules/gl-vec2/rotate.js
var require_rotate = __commonJS({
  "node_modules/gl-vec2/rotate.js"(exports, module) {
    module.exports = rotate7;
    function rotate7(out, a2, angle3) {
      var c2 = Math.cos(angle3), s2 = Math.sin(angle3);
      var x2 = a2[0], y2 = a2[1];
      out[0] = x2 * c2 - y2 * s2;
      out[1] = x2 * s2 + y2 * c2;
      return out;
    }
  }
});

// node_modules/gl-vec2/floor.js
var require_floor = __commonJS({
  "node_modules/gl-vec2/floor.js"(exports, module) {
    module.exports = floor4;
    function floor4(out, a2) {
      out[0] = Math.floor(a2[0]);
      out[1] = Math.floor(a2[1]);
      return out;
    }
  }
});

// node_modules/gl-vec2/ceil.js
var require_ceil = __commonJS({
  "node_modules/gl-vec2/ceil.js"(exports, module) {
    module.exports = ceil4;
    function ceil4(out, a2) {
      out[0] = Math.ceil(a2[0]);
      out[1] = Math.ceil(a2[1]);
      return out;
    }
  }
});

// node_modules/gl-vec2/round.js
var require_round = __commonJS({
  "node_modules/gl-vec2/round.js"(exports, module) {
    module.exports = round5;
    function round5(out, a2) {
      out[0] = Math.round(a2[0]);
      out[1] = Math.round(a2[1]);
      return out;
    }
  }
});

// node_modules/gl-vec2/scale.js
var require_scale = __commonJS({
  "node_modules/gl-vec2/scale.js"(exports, module) {
    module.exports = scale9;
    function scale9(out, a2, b10) {
      out[0] = a2[0] * b10;
      out[1] = a2[1] * b10;
      return out;
    }
  }
});

// node_modules/gl-vec2/scaleAndAdd.js
var require_scaleAndAdd = __commonJS({
  "node_modules/gl-vec2/scaleAndAdd.js"(exports, module) {
    module.exports = scaleAndAdd4;
    function scaleAndAdd4(out, a2, b10, scale9) {
      out[0] = a2[0] + b10[0] * scale9;
      out[1] = a2[1] + b10[1] * scale9;
      return out;
    }
  }
});

// node_modules/gl-vec2/distance.js
var require_distance = __commonJS({
  "node_modules/gl-vec2/distance.js"(exports, module) {
    module.exports = distance11;
    function distance11(a2, b10) {
      var x2 = b10[0] - a2[0], y2 = b10[1] - a2[1];
      return Math.sqrt(x2 * x2 + y2 * y2);
    }
  }
});

// node_modules/gl-vec2/dist.js
var require_dist = __commonJS({
  "node_modules/gl-vec2/dist.js"(exports, module) {
    module.exports = require_distance();
  }
});

// node_modules/gl-vec2/squaredDistance.js
var require_squaredDistance = __commonJS({
  "node_modules/gl-vec2/squaredDistance.js"(exports, module) {
    module.exports = squaredDistance4;
    function squaredDistance4(a2, b10) {
      var x2 = b10[0] - a2[0], y2 = b10[1] - a2[1];
      return x2 * x2 + y2 * y2;
    }
  }
});

// node_modules/gl-vec2/sqrDist.js
var require_sqrDist = __commonJS({
  "node_modules/gl-vec2/sqrDist.js"(exports, module) {
    module.exports = require_squaredDistance();
  }
});

// node_modules/gl-vec2/length.js
var require_length = __commonJS({
  "node_modules/gl-vec2/length.js"(exports, module) {
    module.exports = length5;
    function length5(a2) {
      var x2 = a2[0], y2 = a2[1];
      return Math.sqrt(x2 * x2 + y2 * y2);
    }
  }
});

// node_modules/gl-vec2/len.js
var require_len = __commonJS({
  "node_modules/gl-vec2/len.js"(exports, module) {
    module.exports = require_length();
  }
});

// node_modules/gl-vec2/squaredLength.js
var require_squaredLength = __commonJS({
  "node_modules/gl-vec2/squaredLength.js"(exports, module) {
    module.exports = squaredLength5;
    function squaredLength5(a2) {
      var x2 = a2[0], y2 = a2[1];
      return x2 * x2 + y2 * y2;
    }
  }
});

// node_modules/gl-vec2/sqrLen.js
var require_sqrLen = __commonJS({
  "node_modules/gl-vec2/sqrLen.js"(exports, module) {
    module.exports = require_squaredLength();
  }
});

// node_modules/gl-vec2/negate.js
var require_negate = __commonJS({
  "node_modules/gl-vec2/negate.js"(exports, module) {
    module.exports = negate4;
    function negate4(out, a2) {
      out[0] = -a2[0];
      out[1] = -a2[1];
      return out;
    }
  }
});

// node_modules/gl-vec2/normalize.js
var require_normalize2 = __commonJS({
  "node_modules/gl-vec2/normalize.js"(exports, module) {
    module.exports = normalize5;
    function normalize5(out, a2) {
      var x2 = a2[0], y2 = a2[1];
      var len5 = x2 * x2 + y2 * y2;
      if (len5 > 0) {
        len5 = 1 / Math.sqrt(len5);
        out[0] = a2[0] * len5;
        out[1] = a2[1] * len5;
      }
      return out;
    }
  }
});

// node_modules/gl-vec2/dot.js
var require_dot = __commonJS({
  "node_modules/gl-vec2/dot.js"(exports, module) {
    module.exports = dot6;
    function dot6(a2, b10) {
      return a2[0] * b10[0] + a2[1] * b10[1];
    }
  }
});

// node_modules/gl-vec2/cross.js
var require_cross = __commonJS({
  "node_modules/gl-vec2/cross.js"(exports, module) {
    module.exports = cross6;
    function cross6(out, a2, b10) {
      var z2 = a2[0] * b10[1] - a2[1] * b10[0];
      out[0] = out[1] = 0;
      out[2] = z2;
      return out;
    }
  }
});

// node_modules/gl-vec2/lerp.js
var require_lerp = __commonJS({
  "node_modules/gl-vec2/lerp.js"(exports, module) {
    module.exports = lerp7;
    function lerp7(out, a2, b10, t4) {
      var ax = a2[0], ay = a2[1];
      out[0] = ax + t4 * (b10[0] - ax);
      out[1] = ay + t4 * (b10[1] - ay);
      return out;
    }
  }
});

// node_modules/gl-vec2/random.js
var require_random2 = __commonJS({
  "node_modules/gl-vec2/random.js"(exports, module) {
    module.exports = random5;
    function random5(out, scale9) {
      scale9 = scale9 || 1;
      var r2 = Math.random() * 2 * Math.PI;
      out[0] = Math.cos(r2) * scale9;
      out[1] = Math.sin(r2) * scale9;
      return out;
    }
  }
});

// node_modules/gl-vec2/transformMat2.js
var require_transformMat2 = __commonJS({
  "node_modules/gl-vec2/transformMat2.js"(exports, module) {
    module.exports = transformMat22;
    function transformMat22(out, a2, m2) {
      var x2 = a2[0], y2 = a2[1];
      out[0] = m2[0] * x2 + m2[2] * y2;
      out[1] = m2[1] * x2 + m2[3] * y2;
      return out;
    }
  }
});

// node_modules/gl-vec2/transformMat2d.js
var require_transformMat2d = __commonJS({
  "node_modules/gl-vec2/transformMat2d.js"(exports, module) {
    module.exports = transformMat2d2;
    function transformMat2d2(out, a2, m2) {
      var x2 = a2[0], y2 = a2[1];
      out[0] = m2[0] * x2 + m2[2] * y2 + m2[4];
      out[1] = m2[1] * x2 + m2[3] * y2 + m2[5];
      return out;
    }
  }
});

// node_modules/gl-vec2/transformMat3.js
var require_transformMat3 = __commonJS({
  "node_modules/gl-vec2/transformMat3.js"(exports, module) {
    module.exports = transformMat33;
    function transformMat33(out, a2, m2) {
      var x2 = a2[0], y2 = a2[1];
      out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
      out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
      return out;
    }
  }
});

// node_modules/gl-vec2/transformMat4.js
var require_transformMat4 = __commonJS({
  "node_modules/gl-vec2/transformMat4.js"(exports, module) {
    module.exports = transformMat44;
    function transformMat44(out, a2, m2) {
      var x2 = a2[0], y2 = a2[1];
      out[0] = m2[0] * x2 + m2[4] * y2 + m2[12];
      out[1] = m2[1] * x2 + m2[5] * y2 + m2[13];
      return out;
    }
  }
});

// node_modules/gl-vec2/forEach.js
var require_forEach = __commonJS({
  "node_modules/gl-vec2/forEach.js"(exports, module) {
    module.exports = forEach4;
    var vec = require_create()();
    function forEach4(a2, stride, offset, count, fn2, arg) {
      var i2, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l2 = Math.min(count * stride + offset, a2.length);
      } else {
        l2 = a2.length;
      }
      for (i2 = offset; i2 < l2; i2 += stride) {
        vec[0] = a2[i2];
        vec[1] = a2[i2 + 1];
        fn2(vec, vec, arg);
        a2[i2] = vec[0];
        a2[i2 + 1] = vec[1];
      }
      return a2;
    }
  }
});

// node_modules/gl-vec2/limit.js
var require_limit = __commonJS({
  "node_modules/gl-vec2/limit.js"(exports, module) {
    module.exports = limit;
    function limit(out, a2, max7) {
      var mSq = a2[0] * a2[0] + a2[1] * a2[1];
      if (mSq > max7 * max7) {
        var n2 = Math.sqrt(mSq);
        out[0] = a2[0] / n2 * max7;
        out[1] = a2[1] / n2 * max7;
      } else {
        out[0] = a2[0];
        out[1] = a2[1];
      }
      return out;
    }
  }
});

// node_modules/gl-vec2/index.js
var require_gl_vec2 = __commonJS({
  "node_modules/gl-vec2/index.js"(exports, module) {
    module.exports = {
      EPSILON: require_epsilon(),
      create: require_create(),
      clone: require_clone(),
      fromValues: require_fromValues(),
      copy: require_copy(),
      set: require_set(),
      equals: require_equals(),
      exactEquals: require_exactEquals(),
      add: require_add(),
      subtract: require_subtract(),
      sub: require_sub(),
      multiply: require_multiply(),
      mul: require_mul(),
      divide: require_divide(),
      div: require_div(),
      inverse: require_inverse(),
      min: require_min(),
      max: require_max(),
      rotate: require_rotate(),
      floor: require_floor(),
      ceil: require_ceil(),
      round: require_round(),
      scale: require_scale(),
      scaleAndAdd: require_scaleAndAdd(),
      distance: require_distance(),
      dist: require_dist(),
      squaredDistance: require_squaredDistance(),
      sqrDist: require_sqrDist(),
      length: require_length(),
      len: require_len(),
      squaredLength: require_squaredLength(),
      sqrLen: require_sqrLen(),
      negate: require_negate(),
      normalize: require_normalize2(),
      dot: require_dot(),
      cross: require_cross(),
      lerp: require_lerp(),
      random: require_random2(),
      transformMat2: require_transformMat2(),
      transformMat2d: require_transformMat2d(),
      transformMat3: require_transformMat3(),
      transformMat4: require_transformMat4(),
      forEach: require_forEach(),
      limit: require_limit()
    };
  }
});

// node_modules/polyline-miter-util/index.js
var require_polyline_miter_util = __commonJS({
  "node_modules/polyline-miter-util/index.js"(exports, module) {
    var add7 = require_add();
    var set8 = require_set();
    var normalize5 = require_normalize2();
    var subtract6 = require_subtract();
    var dot6 = require_dot();
    var tmp = [0, 0];
    module.exports.computeMiter = function computeMiter2(tangent, miter, lineA, lineB, halfThick) {
      add7(tangent, lineA, lineB);
      normalize5(tangent, tangent);
      set8(miter, -tangent[1], tangent[0]);
      set8(tmp, -lineA[1], lineA[0]);
      return halfThick / dot6(miter, tmp);
    };
    module.exports.normal = function normal2(out, dir) {
      set8(out, -dir[1], dir[0]);
      return out;
    };
    module.exports.direction = function direction3(out, a2, b10) {
      subtract6(out, a2, b10);
      normalize5(out, out);
      return out;
    };
  }
});

// node_modules/@antv/g-webgpu/es/utils/polyline-normals.js
function extrusions(positions, out, point, normal2, scale9) {
  addNext(out, normal2, -scale9);
  addNext(out, normal2, scale9);
  positions.push(point);
  positions.push(point);
}
function addNext(out, normal2, length5) {
  out.push([[normal2[0], normal2[1]], length5]);
}
function polyline_normals_default(points, closed, indexOffset) {
  var lineA = [0, 0];
  var lineB = [0, 0];
  var tangent = [0, 0];
  var miter = [0, 0];
  var _lastFlip = -1;
  var _started = false;
  var _normal = null;
  var tmp = (0, import_gl_vec2.create)();
  var count = indexOffset || 0;
  var miterLimit = 3;
  var out = [];
  var attrPos = [];
  var attrIndex = [];
  var attrCounters = [0, 0];
  if (closed) {
    points = points.slice();
    points.push(points[0]);
  }
  var total = points.length;
  for (var i2 = 1; i2 < total; i2++) {
    var index = count;
    var last2 = points[i2 - 1];
    var cur = points[i2];
    var next = i2 < points.length - 1 ? points[i2 + 1] : null;
    attrCounters.push(i2 / total, i2 / total);
    (0, import_polyline_miter_util.direction)(lineA, cur, last2);
    if (!_normal) {
      _normal = [0, 0];
      (0, import_polyline_miter_util.normal)(_normal, lineA);
    }
    if (!_started) {
      _started = true;
      extrusions(attrPos, out, last2, _normal, 1);
    }
    attrIndex.push([index + 0, index + 1, index + 2]);
    if (!next) {
      (0, import_polyline_miter_util.normal)(_normal, lineA);
      extrusions(attrPos, out, cur, _normal, 1);
      attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);
      count += 2;
    } else {
      (0, import_polyline_miter_util.direction)(lineB, next, cur);
      var miterLen = (0, import_polyline_miter_util.computeMiter)(tangent, miter, lineA, lineB, 1);
      var flip = (0, import_gl_vec2.dot)(tangent, _normal) < 0 ? -1 : 1;
      var bevel = miterLen > miterLimit;
      if (!isFinite(miterLen)) {
        (0, import_polyline_miter_util.normal)(_normal, lineA);
        extrusions(attrPos, out, cur, _normal, 1);
        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);
        count += 2;
        _lastFlip = flip;
        continue;
      }
      if (bevel) {
        miterLen = miterLimit;
        attrCounters.push(i2 / total);
        addNext(out, _normal, -flip);
        attrPos.push(cur);
        addNext(out, miter, miterLen * flip);
        attrPos.push(cur);
        attrIndex.push(_lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);
        attrIndex.push([index + 2, index + 3, index + 4]);
        (0, import_polyline_miter_util.normal)(tmp, lineB);
        (0, import_gl_vec2.copy)(_normal, tmp);
        addNext(out, _normal, -flip);
        attrPos.push(cur);
        count += 3;
      } else {
        extrusions(attrPos, out, cur, miter, miterLen);
        attrIndex.push(_lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]);
        flip = -1;
        (0, import_gl_vec2.copy)(_normal, miter);
        count += 2;
      }
      _lastFlip = flip;
    }
  }
  return {
    normals: out,
    attrIndex,
    attrPos,
    attrCounters
  };
}
var import_gl_vec2, import_polyline_miter_util;
var init_polyline_normals = __esm({
  "node_modules/@antv/g-webgpu/es/utils/polyline-normals.js"() {
    import_gl_vec2 = __toESM(require_gl_vec2());
    import_polyline_miter_util = __toESM(require_polyline_miter_util());
  }
});

// node_modules/@antv/g-webgpu/es/renderable/line/index.js
function _createSuper16(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct16();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct16() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec61, _dec218, _dec314, _dec411, _dec511, _dec66, _class43, _class218, _descriptor30, _descriptor214, _descriptor310, _temp22, lineFrag, lineVert, Line4;
var init_line = __esm({
  "node_modules/@antv/g-webgpu/es/renderable/line/index.js"() {
    init_toConsumableArray();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    init_polyline_normals();
    init_Renderable();
    lineFrag = "uniform float u_dash_array : 0.02;\nuniform float u_dash_offset : 0;\nuniform float u_dash_ratio : 0;\nuniform float u_thickness : 0.02;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_counters;\n\nvoid main() {\n    float blur = 1. - smoothstep(0.98, 1., length(v_normal));\n\n    gl_FragColor = v_color;\n    gl_FragColor.a *= blur * ceil(mod(v_counters + u_dash_offset, u_dash_array) - (u_dash_array * u_dash_ratio));\n}";
    lineVert = "attribute vec2 a_pos;\nattribute vec4 a_color;\nattribute float a_line_miter;\nattribute vec2 a_line_normal;\nattribute float a_counters;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float u_thickness : 0.02;\nuniform vec2 u_viewport;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_counters;\n\nvoid main() {\n  v_color = a_color;\n  v_counters = a_counters;\n\n  vec3 normal = normalize(vec3(a_line_normal, 0.0));\n\n  vec4 offset = vec4(normal * u_thickness / 2.0 * a_line_miter, 0.0);\n\n  v_normal = vec2(normal * sign(a_line_miter));\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(a_pos, 0.0, 1.0) + offset;\n}\n";
    Line4 = (_dec61 = injectable(), _dec218 = inject(IDENTIFIER.Systems), _dec314 = named2(IDENTIFIER.MaterialSystem), _dec411 = inject(IDENTIFIER.Systems), _dec511 = named2(IDENTIFIER.GeometrySystem), _dec66 = inject(IDENTIFIER.ShaderModuleService), _dec61(_class43 = (_class218 = (_temp22 = function(_Renderable) {
      _inherits2(Line5, _Renderable);
      var _super = _createSuper16(Line5);
      function Line5() {
        var _this;
        _classCallCheck(this, Line5);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _initializerDefineProperty(_this, "materialSystem", _descriptor30, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "geometrySystem", _descriptor214, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "shaderModuleService", _descriptor310, _assertThisInitialized2(_this));
        _this.vertexCount = void 0;
        return _this;
      }
      _createClass(Line5, [{
        key: "onAttributeChanged",
        value: function onAttributeChanged(_ref2) {
          var name = _ref2.name, data = _ref2.data;
          var mesh = this.getMeshComponent();
          if (mesh && mesh.material) {
            switch (name) {
              case "dashArray":
                mesh.material.setUniform("u_dash_array", data);
                break;
              case "dashOffset":
                mesh.material.setUniform("u_dash_offset", data);
                break;
              case "dashRatio":
                mesh.material.setUniform("u_dash_ratio", data);
                break;
              case "thickness":
                mesh.material.setUniform("u_thickness", data);
                break;
              case "color":
                var colors = new Array(this.vertexCount).fill(void 0).map(function() {
                  return data;
                }).reduce(function(prev, cur) {
                  return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));
                }, []);
                mesh.geometry.setAttribute("a_color", Float32Array.from(colors), {
                  arrayStride: 4 * 4,
                  stepMode: "vertex",
                  attributes: [{
                    shaderLocation: 1,
                    offset: 0,
                    format: "float4"
                  }]
                });
                break;
            }
          }
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
          var _this2 = this;
          this.shaderModuleService.registerModule("line", {
            vs: lineVert,
            fs: lineFrag
          });
          var _this$shaderModuleSer = this.shaderModuleService.getModule("line"), vs = _this$shaderModuleSer.vs, fs = _this$shaderModuleSer.fs, extractedUniforms = _this$shaderModuleSer.uniforms;
          var material = this.materialSystem.createShaderMaterial({
            vertexShader: vs,
            fragmentShader: fs
          });
          var _getNormals = polyline_normals_default(this.config.points, false), normals = _getNormals.normals, attrIndex = _getNormals.attrIndex, attrPos = _getNormals.attrPos, attrCounters = _getNormals.attrCounters;
          var vertexCount = attrPos.length;
          this.vertexCount = vertexCount;
          var geometry = this.geometrySystem.createBufferGeometry({
            vertexCount
          });
          this.setMaterial(material);
          this.setGeometry(geometry);
          material.setCull({
            enable: false,
            face: gl.BACK
          }).setUniform(extractedUniforms);
          this.setAttributes({
            dashArray: this.config.dashArray,
            dashOffset: this.config.dashOffset,
            dashRatio: this.config.dashRatio,
            thickness: this.config.thickness
          });
          var attrNormal = [];
          var attrMiter = [];
          normals.forEach(function(n2) {
            var norm = n2[0];
            var miter = n2[1];
            attrNormal.push([norm[0], norm[1]]);
            attrMiter.push(miter);
          });
          geometry.setIndex(attrIndex.reduce(function(prev, cur) {
            return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));
          }, []));
          geometry.setAttribute("a_pos", Float32Array.from(attrPos.reduce(function(prev, cur) {
            return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));
          }, [])), {
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float2"
            }]
          });
          var colors = new Array(vertexCount).fill(void 0).map(function() {
            return _toConsumableArray(_this2.config.color);
          }).reduce(function(prev, cur) {
            return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));
          }, []);
          geometry.setAttribute("a_color", Float32Array.from(colors), {
            arrayStride: 4 * 4,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 1,
              offset: 0,
              format: "float4"
            }]
          });
          geometry.setAttribute("a_line_miter", Float32Array.from(attrMiter), {
            arrayStride: 4 * 1,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 2,
              offset: 0,
              format: "float"
            }]
          });
          geometry.setAttribute("a_line_normal", Float32Array.from(attrNormal.reduce(function(prev, cur) {
            return [].concat(_toConsumableArray(prev), _toConsumableArray(cur));
          }, [])), {
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 3,
              offset: 0,
              format: "float2"
            }]
          });
          geometry.setAttribute("a_counters", Float32Array.from(attrCounters), {
            arrayStride: 4 * 1,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 4,
              offset: 0,
              format: "float"
            }]
          });
        }
      }]);
      return Line5;
    }(Renderable), _temp22), _descriptor30 = _applyDecoratedDescriptor(_class218.prototype, "materialSystem", [_dec218, _dec314], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor214 = _applyDecoratedDescriptor(_class218.prototype, "geometrySystem", [_dec411, _dec511], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor310 = _applyDecoratedDescriptor(_class218.prototype, "shaderModuleService", [_dec66], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class218)) || _class43);
  }
});

// node_modules/@antv/g-webgpu/es/utils/picking.js
function encodePickingColor(featureIdx) {
  return [featureIdx + 1 & 255, featureIdx + 1 >> 8 & 255, featureIdx + 1 >> 8 >> 8 & 255];
}
var init_picking = __esm({
  "node_modules/@antv/g-webgpu/es/utils/picking.js"() {
  }
});

// node_modules/@antv/g-webgpu/es/renderable/point/index.js
function ownKeys10(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread10(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys10(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys10(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper17(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct17();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _isNativeReflectConstruct17() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e8) {
    return false;
  }
}
var _dec67, _dec219, _dec315, _dec412, _dec512, _dec68, _class44, _class219, _descriptor31, _descriptor215, _descriptor311, _temp23, pointFrag, pointVert, pointShapes, Point;
var init_point = __esm({
  "node_modules/@antv/g-webgpu/es/renderable/point/index.js"() {
    init_toConsumableArray();
    init_defineProperty();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_assertThisInitialized();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    init_picking();
    init_Renderable();
    pointFrag = `uniform float u_blur : 0.05;
uniform float u_opacity : 0.7;
uniform float u_stroke_width : 0.01;
uniform vec4 u_stroke_color : [0, 0, 0, 0];
uniform float u_stroke_opacity : 1;

varying vec4 v_color;
varying vec4 v_data;
varying float v_radius;

#pragma include "sdf2d"
#pragma include "picking"

void main() {
  int shape = int(floor(v_data.w + 0.5));

  float antialiasblur = v_data.z;
  float antialiased_blur = -max(u_blur, antialiasblur);
  float r = v_radius / (v_radius + u_stroke_width);

  float outer_df;
  float inner_df;
  // 'circle', 'triangle', 'square', 'pentagon', 'hexagon', 'octogon', 'hexagram', 'rhombus', 'vesica'
  // if (shape == 0) {
    outer_df = sdCircle(v_data.xy, 1.0);
    inner_df = sdCircle(v_data.xy, r);
  // } else if (shape == 1) {
  //   outer_df = sdEquilateralTriangle(1.1 * v_data.xy);
  //   inner_df = sdEquilateralTriangle(1.1 / r * v_data.xy);
  // } else if (shape == 2) {
  //   outer_df = sdBox(v_data.xy, vec2(1.));
  //   inner_df = sdBox(v_data.xy, vec2(r));
  // } else if (shape == 3) {
  //   outer_df = sdPentagon(v_data.xy, 0.8);
  //   inner_df = sdPentagon(v_data.xy, r * 0.8);
  // } else if (shape == 4) {
  //   outer_df = sdHexagon(v_data.xy, 0.8);
  //   inner_df = sdHexagon(v_data.xy, r * 0.8);
  // } else if (shape == 5) {
  //   outer_df = sdOctogon(v_data.xy, 1.0);
  //   inner_df = sdOctogon(v_data.xy, r);
  // } else if (shape == 6) {
  //   outer_df = sdHexagram(v_data.xy, 0.52);
  //   inner_df = sdHexagram(v_data.xy, r * 0.52);
  // } else if (shape == 7) {
  //   outer_df = sdRhombus(v_data.xy, vec2(1.0));
  //   inner_df = sdRhombus(v_data.xy, vec2(r));
  // } else if (shape == 8) {
  //   outer_df = sdVesica(v_data.xy, 1.1, 0.8);
  //   inner_df = sdVesica(v_data.xy, r * 1.1, r * 0.8);
  // }

  float opacity_t = smoothstep(0.0, antialiased_blur, outer_df);

  float color_t = u_stroke_width < 0.01 ? 0.0 : smoothstep(
    antialiased_blur,
    0.0,
    inner_df
  );
  vec4 strokeColor = u_stroke_color == vec4(0) ? v_color : u_stroke_color;

  gl_FragColor = mix(vec4(v_color.rgb, v_color.a * u_opacity), strokeColor * u_stroke_opacity, color_t);
  gl_FragColor.a = gl_FragColor.a * opacity_t;

  gl_FragColor = filterColor(gl_FragColor);
}`;
    pointVert = 'attribute vec2 position;\nattribute vec4 color;\nattribute float shape;\nattribute vec2 offset;\nattribute float size;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\n\nuniform float u_stroke_width : 0.01;\nuniform float u_device_pixel_ratio;\nuniform vec2 u_viewport;\n\nvarying vec4 v_color;\nvarying vec4 v_data;\nvarying float v_radius;\n\n#pragma include "picking"\n\nvoid main() {\n  v_color = color;\n  v_radius = size;\n\n  lowp float antialiasblur = 1.0 / u_device_pixel_ratio * (size + u_stroke_width);\n\n  // construct point coords\n  v_data = vec4(position, antialiasblur, shape);\n\n  gl_Position = projectionMatrix * modelViewMatrix\n    * vec4(position * size + offset, 0.0, 1.0);\n\n  setPickingColor(a_PickingColor);\n}';
    pointShapes = ["circle", "triangle", "square", "pentagon", "hexagon", "octogon", "hexagram", "rhombus", "vesica"];
    Point = (_dec67 = injectable(), _dec219 = inject(IDENTIFIER.Systems), _dec315 = named2(IDENTIFIER.MaterialSystem), _dec412 = inject(IDENTIFIER.Systems), _dec512 = named2(IDENTIFIER.GeometrySystem), _dec68 = inject(IDENTIFIER.ShaderModuleService), _dec67(_class44 = (_class219 = (_temp23 = function(_Renderable) {
      _inherits2(Point2, _Renderable);
      var _super = _createSuper17(Point2);
      function Point2() {
        var _this;
        _classCallCheck(this, Point2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _initializerDefineProperty(_this, "materialSystem", _descriptor31, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "geometrySystem", _descriptor215, _assertThisInitialized2(_this));
        _initializerDefineProperty(_this, "shaderModuleService", _descriptor311, _assertThisInitialized2(_this));
        return _this;
      }
      _createClass(Point2, [{
        key: "onAttributeChanged",
        value: function onAttributeChanged(_ref2) {
          var name = _ref2.name, data = _ref2.data;
          var mesh = this.getMeshComponent();
          if (mesh && mesh.material) {
            if (name === "strokeWidth") {
              mesh.material.setUniform("u_stroke_width", data);
            } else if (name === "strokeColor") {
              mesh.material.setUniform("u_stroke_color", data);
            } else if (name === "strokeOpacity") {
              mesh.material.setUniform("u_stroke_opacity", data);
            } else if (name === "opacity") {
              mesh.material.setUniform("u_opacity", data);
            } else if (name === "blur") {
              mesh.material.setUniform("u_blur", data);
            }
          }
        }
      }, {
        key: "onEntityCreated",
        value: function onEntityCreated() {
          this.shaderModuleService.registerModule("grid", {
            vs: pointVert,
            fs: pointFrag
          });
          var _this$shaderModuleSer = this.shaderModuleService.getModule("grid"), vs = _this$shaderModuleSer.vs, fs = _this$shaderModuleSer.fs, extractedUniforms = _this$shaderModuleSer.uniforms;
          var material = this.materialSystem.createShaderMaterial({
            vertexShader: vs,
            fragmentShader: fs,
            cull: {
              enable: false
            },
            depth: {
              enable: false
            },
            blend: {
              enable: true,
              func: {
                srcRGB: gl.SRC_ALPHA,
                dstRGB: gl.ONE_MINUS_SRC_ALPHA,
                srcAlpha: 1,
                dstAlpha: 1
              }
            }
          });
          material.setUniform(_objectSpread10({
            u_device_pixel_ratio: window.devicePixelRatio
          }, extractedUniforms));
          var attributes = this.buildAttributes();
          var geometry = this.geometrySystem.createInstancedBufferGeometry({
            maxInstancedCount: attributes.instancedOffsets.length / 2,
            vertexCount: 6
          });
          geometry.setIndex([0, 2, 1, 0, 3, 2]);
          geometry.setAttribute("position", Float32Array.from(attributes.positions), {
            arrayStride: 4 * 2,
            stepMode: "vertex",
            attributes: [{
              shaderLocation: 0,
              offset: 0,
              format: "float2"
            }]
          });
          geometry.setAttribute("offset", Float32Array.from(attributes.instancedOffsets), {
            arrayStride: 4 * 2,
            stepMode: "instance",
            attributes: [{
              shaderLocation: 1,
              offset: 0,
              format: "float2"
            }]
          });
          geometry.setAttribute("color", Float32Array.from(attributes.instancedColors), {
            arrayStride: 4 * 4,
            stepMode: "instance",
            attributes: [{
              shaderLocation: 2,
              offset: 0,
              format: "float4"
            }]
          });
          geometry.setAttribute("size", Float32Array.from(attributes.instancedSizes), {
            arrayStride: 4,
            stepMode: "instance",
            attributes: [{
              shaderLocation: 3,
              offset: 0,
              format: "float"
            }]
          });
          geometry.setAttribute("shape", Float32Array.from(attributes.instancedShapes), {
            arrayStride: 4,
            stepMode: "instance",
            attributes: [{
              shaderLocation: 4,
              offset: 0,
              format: "float"
            }]
          });
          geometry.setAttribute("a_PickingColor", Float32Array.from(attributes.instancedPickingColors), {
            arrayStride: 4 * 3,
            stepMode: "instance",
            attributes: [{
              shaderLocation: 6,
              offset: 0,
              format: "float3"
            }]
          });
          this.setMaterial(material);
          this.setGeometry(geometry);
        }
      }, {
        key: "buildAttribute",
        value: function buildAttribute(config, attributes, index) {
          var _attributes$instanced, _attributes$instanced2, _attributes$instanced3, _attributes$instanced4;
          (_attributes$instanced = attributes.instancedPickingColors).push.apply(_attributes$instanced, _toConsumableArray(encodePickingColor(config.id || index)));
          attributes.instancedShapes.push(pointShapes.indexOf(config.shape || "circle"));
          (_attributes$instanced2 = attributes.instancedColors).push.apply(_attributes$instanced2, _toConsumableArray(config.color || [1, 0, 0, 1]));
          (_attributes$instanced3 = attributes.instancedOffsets).push.apply(_attributes$instanced3, _toConsumableArray(config.position || [0, 0]));
          (_attributes$instanced4 = attributes.instancedSizes).push.apply(_attributes$instanced4, _toConsumableArray(config.size || [0.2, 0.2]));
        }
      }, {
        key: "buildAttributes",
        value: function buildAttributes() {
          var _this2 = this;
          var attributes = {
            positions: [1, 1, 1, -1, -1, -1, -1, 1],
            instancedOffsets: [],
            instancedColors: [],
            instancedSizes: [],
            instancedShapes: [],
            instancedPickingColors: []
          };
          if (Array.isArray(this.config)) {
            this.config.forEach(function(config, i2) {
              _this2.buildAttribute(config, attributes, i2);
            });
          } else {
            this.buildAttribute(this.config, attributes, 0);
          }
          return attributes;
        }
      }]);
      return Point2;
    }(Renderable), _temp23), _descriptor31 = _applyDecoratedDescriptor(_class219.prototype, "materialSystem", [_dec219, _dec315], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor215 = _applyDecoratedDescriptor(_class219.prototype, "geometrySystem", [_dec412, _dec512], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor311 = _applyDecoratedDescriptor(_class219.prototype, "shaderModuleService", [_dec68], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class219)) || _class44);
  }
});

// node_modules/@antv/g-webgpu/es/Renderer.js
function _createForOfIteratorHelper5(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray6(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i2 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e8(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s2() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e8(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray6(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray6(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray6(o2, minLen);
}
function _arrayLikeToArray6(arr, len5) {
  if (len5 == null || len5 > arr.length)
    len5 = arr.length;
  for (var i2 = 0, arr2 = new Array(len5); i2 < len5; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var import_regenerator18, WebGPUConstants9, _dec69, _dec220, _dec316, _dec413, _class45, _class220, _descriptor40, _descriptor216, _descriptor312, _temp24, mapFragDeclaration, mapFragMain, uvFragDeclaration, uvVertDeclaration, uvVertMain, Renderer;
var init_Renderer = __esm({
  "node_modules/@antv/g-webgpu/es/Renderer.js"() {
    import_regenerator18 = __toESM(require_regenerator());
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    WebGPUConstants9 = __toESM(require_constants2());
    init_inversify();
    mapFragDeclaration = "#ifdef USE_MAP\n  uniform sampler2D map;\n#endif";
    mapFragMain = "#ifdef USE_MAP\n  vec4 texelColor = texture2D(map, vUv);\n  // texelColor = mapTexelToLinear(texelColor);\n  diffuseColor *= texelColor;\n#endif";
    uvFragDeclaration = "#if (defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ))\n  varying vec2 vUv;\n#endif";
    uvVertDeclaration = "#ifdef USE_UV\n  attribute vec2 uv;\n	#ifdef UVS_VERTEX_ONLY\n    vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    uvVertMain = "#ifdef USE_UV\n  vUv = (uvTransform * vec3(uv, 1)).xy;\n#endif";
    Renderer = (_dec69 = injectable(), _dec220 = inject(IDENTIFIER.RenderEngine), _dec316 = inject(IDENTIFIER.ShaderModuleService), _dec413 = inject(IDENTIFIER.ConfigService), _dec69(_class45 = (_class220 = (_temp24 = function() {
      function Renderer2() {
        _classCallCheck(this, Renderer2);
        this.container = void 0;
        _initializerDefineProperty(this, "engine", _descriptor40, this);
        _initializerDefineProperty(this, "shaderModule", _descriptor216, this);
        _initializerDefineProperty(this, "configService", _descriptor312, this);
        this.inited = false;
        this.rendering = false;
        this.pendings = [];
        this.views = [];
        this.size = void 0;
      }
      _createClass(Renderer2, [{
        key: "init",
        value: function() {
          var _init = _asyncToGenerator(import_regenerator18.default.mark(function _callee() {
            var systems, config, _iterator, _step, system;
            return import_regenerator18.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    this.shaderModule.registerBuiltinModules();
                    this.shaderModule.registerModule("uv.vert.declaration", {
                      vs: uvVertDeclaration
                    });
                    this.shaderModule.registerModule("uv.vert.main", {
                      vs: uvVertMain
                    });
                    this.shaderModule.registerModule("uv.frag.declaration", {
                      fs: uvFragDeclaration
                    });
                    this.shaderModule.registerModule("map.frag.declaration", {
                      fs: mapFragDeclaration
                    });
                    this.shaderModule.registerModule("map.frag.main", {
                      fs: mapFragMain
                    });
                    systems = this.container.getAll(IDENTIFIER.Systems);
                    config = this.configService.get();
                    if (!config.canvas) {
                      _context.next = 30;
                      break;
                    }
                    _context.next = 11;
                    return this.engine.init({
                      canvas: config.canvas,
                      swapChainFormat: WebGPUConstants9.TextureFormat.BGRA8Unorm,
                      antialiasing: false
                    });
                  case 11:
                    _iterator = _createForOfIteratorHelper5(systems);
                    _context.prev = 12;
                    _iterator.s();
                  case 14:
                    if ((_step = _iterator.n()).done) {
                      _context.next = 21;
                      break;
                    }
                    system = _step.value;
                    if (!system.initialize) {
                      _context.next = 19;
                      break;
                    }
                    _context.next = 19;
                    return system.initialize();
                  case 19:
                    _context.next = 14;
                    break;
                  case 21:
                    _context.next = 26;
                    break;
                  case 23:
                    _context.prev = 23;
                    _context.t0 = _context["catch"](12);
                    _iterator.e(_context.t0);
                  case 26:
                    _context.prev = 26;
                    _iterator.f();
                    return _context.finish(26);
                  case 29:
                    this.inited = true;
                  case 30:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[12, 23, 26, 29]]);
          }));
          function init() {
            return _init.apply(this, arguments);
          }
          return init;
        }()
      }, {
        key: "render",
        value: function() {
          var _render = _asyncToGenerator(import_regenerator18.default.mark(function _callee2() {
            var systems, _len, views, _key, _iterator2, _step2, system, _args2 = arguments;
            return import_regenerator18.default.wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    if (!(!this.inited || this.rendering)) {
                      _context2.next = 2;
                      break;
                    }
                    return _context2.abrupt("return");
                  case 2:
                    if (this.pendings.length) {
                      this.pendings.forEach(function(pending) {
                        pending();
                      });
                    }
                    this.rendering = true;
                    this.engine.beginFrame();
                    systems = this.container.getAll(IDENTIFIER.Systems);
                    for (_len = _args2.length, views = new Array(_len), _key = 0; _key < _len; _key++) {
                      views[_key] = _args2[_key];
                    }
                    _iterator2 = _createForOfIteratorHelper5(systems);
                    _context2.prev = 8;
                    _iterator2.s();
                  case 10:
                    if ((_step2 = _iterator2.n()).done) {
                      _context2.next = 17;
                      break;
                    }
                    system = _step2.value;
                    if (!system.execute) {
                      _context2.next = 15;
                      break;
                    }
                    _context2.next = 15;
                    return system.execute(views);
                  case 15:
                    _context2.next = 10;
                    break;
                  case 17:
                    _context2.next = 22;
                    break;
                  case 19:
                    _context2.prev = 19;
                    _context2.t0 = _context2["catch"](8);
                    _iterator2.e(_context2.t0);
                  case 22:
                    _context2.prev = 22;
                    _iterator2.f();
                    return _context2.finish(22);
                  case 25:
                    this.engine.endFrame();
                    this.rendering = false;
                  case 27:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this, [[8, 19, 22, 25]]);
          }));
          function render() {
            return _render.apply(this, arguments);
          }
          return render;
        }()
      }, {
        key: "clear",
        value: function clear(options) {
          var _this = this;
          if (this.inited) {
            this.engine.clear(options);
          } else {
            this.pendings.unshift(function() {
              _this.engine.clear(options);
              _this.pendings.shift();
            });
          }
          return this;
        }
      }, {
        key: "setSize",
        value: function setSize(_ref2) {
          var width = _ref2.width, height = _ref2.height;
          var canvas = this.engine.getCanvas();
          this.size = {
            width,
            height
          };
          canvas.width = width;
          canvas.height = height;
          return this;
        }
      }, {
        key: "getSize",
        value: function getSize3() {
          return this.size;
        }
      }]);
      return Renderer2;
    }(), _temp24), _descriptor40 = _applyDecoratedDescriptor(_class220.prototype, "engine", [_dec220], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor216 = _applyDecoratedDescriptor(_class220.prototype, "shaderModule", [_dec316], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor312 = _applyDecoratedDescriptor(_class220.prototype, "configService", [_dec413], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class220)) || _class45);
  }
});

// node_modules/@antv/g-webgpu/es/Scene.js
var _dec70, _class46, _temp25, Scene;
var init_Scene = __esm({
  "node_modules/@antv/g-webgpu/es/Scene.js"() {
    init_classCallCheck();
    init_createClass();
    init_inversify();
    Scene = (_dec70 = injectable(), _dec70(_class46 = (_temp25 = function() {
      function Scene2() {
        _classCallCheck(this, Scene2);
        this.entities = [];
      }
      _createClass(Scene2, [{
        key: "getEntities",
        value: function getEntities() {
          return this.entities;
        }
      }, {
        key: "addRenderable",
        value: function addRenderable(renderable) {
          this.addEntity(renderable.getEntity());
          return this;
        }
      }, {
        key: "removeRenderable",
        value: function removeRenderable(renderable) {
          this.removeEntity(renderable.getEntity());
          return this;
        }
      }, {
        key: "addLight",
        value: function addLight() {
        }
      }, {
        key: "addEntity",
        value: function addEntity(entity) {
          if (this.entities.indexOf(entity) === -1) {
            this.entities.push(entity);
          }
          return this;
        }
      }, {
        key: "removeEntity",
        value: function removeEntity(entity) {
          var index = this.entities.indexOf(entity);
          this.entities.splice(index, 1);
          return this;
        }
      }]);
      return Scene2;
    }(), _temp25)) || _class46);
  }
});

// node_modules/@antv/g-webgpu/es/texture/Cache.js
var _dec71, _class47, _temp26, TextureCache;
var init_Cache = __esm({
  "node_modules/@antv/g-webgpu/es/texture/Cache.js"() {
    init_classCallCheck();
    init_createClass();
    init_inversify();
    TextureCache = (_dec71 = injectable(), _dec71(_class47 = (_temp26 = function() {
      function TextureCache2() {
        _classCallCheck(this, TextureCache2);
        this.cache = {};
      }
      _createClass(TextureCache2, [{
        key: "get",
        value: function get2(name) {
          return this.cache[name];
        }
      }, {
        key: "set",
        value: function set8(name, texture) {
          this.cache[name] = texture;
        }
      }]);
      return TextureCache2;
    }(), _temp26)) || _class47);
  }
});

// node_modules/@antv/g-webgpu/es/texture/Texture2D.js
function ownKeys11(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread11(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys11(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys11(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator19, _dec73, _dec221, _dec317, _class48, _class221, _descriptor41, _descriptor217, _temp27, Texture2D;
var init_Texture2D = __esm({
  "node_modules/@antv/g-webgpu/es/texture/Texture2D.js"() {
    import_regenerator19 = __toESM(require_regenerator());
    init_defineProperty();
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    init_Cache();
    Texture2D = (_dec73 = injectable(), _dec221 = inject(TextureCache), _dec317 = inject(IDENTIFIER.RenderEngine), _dec73(_class48 = (_class221 = (_temp27 = function() {
      function Texture2D2() {
        _classCallCheck(this, Texture2D2);
        _initializerDefineProperty(this, "textureCache", _descriptor41, this);
        _initializerDefineProperty(this, "engine", _descriptor217, this);
        this.config = void 0;
        this.loaded = false;
        this.texture = void 0;
      }
      _createClass(Texture2D2, [{
        key: "setConfig",
        value: function setConfig(config) {
          this.config = config;
        }
      }, {
        key: "isLoaded",
        value: function isLoaded() {
          return this.loaded;
        }
      }, {
        key: "load",
        value: function() {
          var _load = _asyncToGenerator(import_regenerator19.default.mark(function _callee() {
            var _this = this;
            return import_regenerator19.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!this.config.url) {
                      _context.next = 4;
                      break;
                    }
                    return _context.abrupt("return", new Promise(function(resolve2, reject) {
                      var existed = _this.textureCache.get(_this.config.url);
                      if (existed) {
                        resolve2(existed);
                      } else {
                        var image = new Image();
                        image.crossOrigin = "Anonymous";
                        image.src = _this.config.url;
                        image.onload = function() {
                          var texture = _this.engine.createTexture2D(_objectSpread11(_objectSpread11({}, _this.config), {}, {
                            data: image,
                            width: image.width,
                            height: image.height,
                            flipY: true
                          }));
                          _this.textureCache.set(_this.config.url, texture);
                          _this.texture = texture;
                          _this.loaded = true;
                          resolve2(texture);
                        };
                        image.onerror = function() {
                          reject();
                        };
                      }
                    }));
                  case 4:
                    this.loaded = true;
                    this.texture = this.engine.createTexture2D(this.config);
                    return _context.abrupt("return", this.texture);
                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function load() {
            return _load.apply(this, arguments);
          }
          return load;
        }()
      }]);
      return Texture2D2;
    }(), _temp27), _descriptor41 = _applyDecoratedDescriptor(_class221.prototype, "textureCache", [_dec221], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _descriptor217 = _applyDecoratedDescriptor(_class221.prototype, "engine", [_dec317], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class221)) || _class48);
  }
});

// node_modules/@antv/g-webgpu/es/View.js
var _dec74, _dec222, _dec318, _class49, _class222, _descriptor47, _temp28, View;
var init_View = __esm({
  "node_modules/@antv/g-webgpu/es/View.js"() {
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_inversify();
    View = (_dec74 = injectable(), _dec222 = inject(IDENTIFIER.Systems), _dec318 = named2(IDENTIFIER.RendererSystem), _dec74(_class49 = (_class222 = (_temp28 = function() {
      function View2() {
        _classCallCheck(this, View2);
        _initializerDefineProperty(this, "rendererSystem", _descriptor47, this);
        this.camera = void 0;
        this.scene = void 0;
        this.viewport = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        this.clearColor = [1, 1, 1, 1];
      }
      _createClass(View2, [{
        key: "getCamera",
        value: function getCamera() {
          return this.camera;
        }
      }, {
        key: "getScene",
        value: function getScene() {
          return this.scene;
        }
      }, {
        key: "getViewport",
        value: function getViewport() {
          return this.viewport;
        }
      }, {
        key: "getClearColor",
        value: function getClearColor() {
          return this.clearColor;
        }
      }, {
        key: "setCamera",
        value: function setCamera(camera) {
          this.camera = camera;
          return this;
        }
      }, {
        key: "setScene",
        value: function setScene(scene) {
          this.scene = scene;
          return this;
        }
      }, {
        key: "setViewport",
        value: function setViewport(viewport) {
          this.viewport = viewport;
          return this;
        }
      }, {
        key: "setClearColor",
        value: function setClearColor(clearColor) {
          this.clearColor = clearColor;
          return this;
        }
      }, {
        key: "pick",
        value: function pick(position) {
          return this.rendererSystem.pick(position, this);
        }
      }]);
      return View2;
    }(), _temp28), _descriptor47 = _applyDecoratedDescriptor(_class222.prototype, "rendererSystem", [_dec222, _dec318], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class222)) || _class49);
  }
});

// node_modules/@antv/g-webgpu/es/World.js
function ownKeys12(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread12(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys12(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var import_regenerator20, WebGPUConstants10, _dec75, _dec223, _class50, _class223, _descriptor48, _temp29, World;
var init_World = __esm({
  "node_modules/@antv/g-webgpu/es/World.js"() {
    import_regenerator20 = __toESM(require_regenerator());
    init_defineProperty();
    init_asyncToGenerator();
    init_initializerDefineProperty();
    init_classCallCheck();
    init_createClass();
    init_applyDecoratedDescriptor();
    init_initializerWarningHelper();
    init_es3();
    init_es4();
    WebGPUConstants10 = __toESM(require_constants2());
    init_inversify();
    init_Camera();
    init_geometry();
    init_Box();
    init_Merged();
    init_Plane2();
    init_Sphere();
    init_Kernel();
    init_material();
    init_basic();
    init_grid();
    init_line();
    init_point();
    init_Renderable();
    init_Renderer();
    init_Scene();
    init_Cache();
    init_Texture2D();
    init_canvas();
    init_View();
    World = (_dec75 = injectable(), _dec223 = inject(IDENTIFIER.ConfigService), _dec75(_class50 = (_class223 = (_temp29 = function() {
      function World2() {
        _classCallCheck(this, World2);
        _initializerDefineProperty(this, "configService", _descriptor48, this);
        this.container = void 0;
      }
      _createClass(World2, [{
        key: "getEngine",
        value: function() {
          var _getEngine = _asyncToGenerator(import_regenerator20.default.mark(function _callee() {
            var engine, _this$configService$g, canvas, engineOptions;
            return import_regenerator20.default.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    engine = this.container.get(IDENTIFIER.RenderEngine);
                    _this$configService$g = this.configService.get(), canvas = _this$configService$g.canvas, engineOptions = _this$configService$g.engineOptions;
                    _context.next = 4;
                    return engine.init(_objectSpread12({
                      canvas: canvas || createCanvas(),
                      swapChainFormat: WebGPUConstants10.TextureFormat.BGRA8Unorm,
                      antialiasing: false
                    }, engineOptions));
                  case 4:
                    return _context.abrupt("return", engine);
                  case 5:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function getEngine() {
            return _getEngine.apply(this, arguments);
          }
          return getEngine;
        }()
      }, {
        key: "getTransformComponent",
        value: function getTransformComponent(entity) {
          var manager = this.container.get(IDENTIFIER.TransformComponentManager);
          return manager.getComponentByEntity(entity);
        }
      }, {
        key: "getMeshComponent",
        value: function getMeshComponent(entity) {
          var manager = this.container.get(IDENTIFIER.MeshComponentManager);
          return manager.getComponentByEntity(entity);
        }
      }, {
        key: "setConfig",
        value: function setConfig(config) {
          this.configService.set(config);
        }
      }, {
        key: "setContainer",
        value: function setContainer(container2) {
          this.container = container2;
        }
      }, {
        key: "getContainer",
        value: function getContainer() {
          return this.container;
        }
      }, {
        key: "createEntity",
        value: function createEntity2() {
          return createEntity();
        }
      }, {
        key: "createScene",
        value: function createScene() {
          return this.container.get(Scene);
        }
      }, {
        key: "createCamera",
        value: function createCamera() {
          return this.container.get(Camera);
        }
      }, {
        key: "createView",
        value: function createView() {
          return this.container.get(View);
        }
      }, {
        key: "createRenderable",
        value: function createRenderable(type, config) {
          var renderable = type ? this.container.getNamed(IDENTIFIER.Renderable, type) : this.container.get(Renderable);
          var entity = createEntity();
          renderable.setConfig(config || {});
          renderable.setEntity(entity);
          return renderable;
        }
      }, {
        key: "createGeometry",
        value: function createGeometry(type, config) {
          var geometry = this.container.getNamed(IDENTIFIER.Geometry, type);
          var entity = createEntity();
          geometry.setConfig(config || {});
          geometry.setEntity(entity);
          return geometry.getComponent();
        }
      }, {
        key: "createMaterial",
        value: function createMaterial(type, config) {
          var material = this.container.getNamed(IDENTIFIER.Material, type);
          var entity = createEntity();
          material.setConfig(config || {});
          material.setEntity(entity, type);
          return material.getComponent();
        }
      }, {
        key: "createTexture2D",
        value: function createTexture2D(config) {
          var texture = this.container.get(Texture2D);
          texture.setConfig(config);
          return texture;
        }
      }, {
        key: "createBufferGeometry",
        value: function createBufferGeometry(params) {
          var geometrySystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.GeometrySystem);
          return geometrySystem.createBufferGeometry(params);
        }
      }, {
        key: "createInstancedBufferGeometry",
        value: function createInstancedBufferGeometry(params) {
          var geometrySystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.GeometrySystem);
          return geometrySystem.createInstancedBufferGeometry(params);
        }
      }, {
        key: "createShaderMaterial",
        value: function createShaderMaterial(params) {
          var materialSystem = this.container.getNamed(IDENTIFIER.Systems, IDENTIFIER.MaterialSystem);
          return materialSystem.createShaderMaterial(params);
        }
      }, {
        key: "createKernel",
        value: function createKernel(precompiledBundle) {
          var kernel = this.container.get(Kernel);
          if (typeof precompiledBundle === "string") {
            kernel.setBundle(JSON.parse(precompiledBundle));
          } else {
            kernel.setBundle(precompiledBundle);
          }
          kernel.init();
          return kernel;
        }
      }, {
        key: "createRenderer",
        value: function createRenderer() {
          var renderer = this.container.get(Renderer);
          renderer.container = this.container;
          renderer.init();
          return renderer;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          var systems = this.container.getAll(IDENTIFIER.Systems);
          systems.forEach(function(system) {
            if (system.tearDown) {
              system.tearDown();
            }
          });
          var engine = this.container.get(IDENTIFIER.RenderEngine);
          engine.destroy();
          var interactor = this.container.get(IDENTIFIER.InteractorService);
          interactor.destroy();
        }
      }], [{
        key: "create",
        value: function create8() {
          var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var worldContainer = createWorldContainer();
          var engineClazz = !navigator.gpu ? WebGLEngine : WebGPUEngine;
          if (!worldContainer.isBound(IDENTIFIER.RenderEngine)) {
            worldContainer.bind(IDENTIFIER.RenderEngine).to(engineClazz).inSingletonScope();
          }
          worldContainer.bind(Renderer).toSelf();
          worldContainer.bind(Kernel).toSelf();
          worldContainer.bind(Renderable).toSelf();
          worldContainer.bind(View).toSelf();
          worldContainer.bind(Camera).toSelf();
          worldContainer.bind(Scene).toSelf();
          worldContainer.bind(World2).toSelf();
          worldContainer.bind(TextureCache).toSelf();
          worldContainer.bind(Texture2D).toSelf();
          worldContainer.bind(IDENTIFIER.Geometry).to(Box).whenTargetNamed(Geometry.BOX);
          worldContainer.bind(IDENTIFIER.Geometry).to(Sphere).whenTargetNamed(Geometry.SPHERE);
          worldContainer.bind(IDENTIFIER.Geometry).to(Plane2).whenTargetNamed(Geometry.PLANE);
          worldContainer.bind(IDENTIFIER.Geometry).to(Merged).whenTargetNamed(Geometry.MERGED);
          worldContainer.bind(IDENTIFIER.Material).to(Basic).whenTargetNamed(Material.BASIC);
          worldContainer.bind(IDENTIFIER.Renderable).to(Point).whenTargetNamed(Renderable.POINT);
          worldContainer.bind(IDENTIFIER.Renderable).to(Line4).whenTargetNamed(Renderable.LINE);
          worldContainer.bind(IDENTIFIER.Renderable).to(Grid).whenTargetNamed(Renderable.GRID);
          var world = worldContainer.get(World2);
          world.setContainer(worldContainer);
          world.setConfig(config);
          return world;
        }
      }]);
      return World2;
    }(), _temp29), _descriptor48 = _applyDecoratedDescriptor(_class223.prototype, "configService", [_dec223], {
      configurable: true,
      enumerable: true,
      writable: true,
      initializer: null
    }), _class223)) || _class50);
  }
});

// node_modules/@antv/g-webgpu/es/index.js
var es_exports3 = {};
__export(es_exports3, {
  Camera: () => Camera,
  Geometry: () => Geometry,
  Kernel: () => Kernel,
  Material: () => Material,
  Renderable: () => Renderable,
  World: () => World
});
var init_es5 = __esm({
  "node_modules/@antv/g-webgpu/es/index.js"() {
    init_Camera();
    init_geometry();
    init_Kernel();
    init_material();
    init_Renderable();
    init_World();
  }
});

// node_modules/@antv/layout/lib/util/gpu.js
var require_gpu = __commonJS({
  "node_modules/@antv/layout/lib/util/gpu.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.arrayToTextureData = exports.attributesToTextureData = exports.buildTextureDataWithTwoEdgeAttr = exports.buildTextureData = exports.proccessToFunc = void 0;
    var _1 = require_util2();
    var math_1 = require_math();
    var proccessToFunc3 = function(value, defaultV) {
      var func;
      if (!value) {
        func = function() {
          return defaultV || 1;
        };
      } else if ((0, _1.isNumber)(value)) {
        func = function() {
          return value;
        };
      } else {
        func = value;
      }
      return func;
    };
    exports.proccessToFunc = proccessToFunc3;
    var buildTextureData3 = function(nodes, edges) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        nodeDict[mapIdPos[source]].push(mapIdPos[target]);
        nodeDict[mapIdPos[target]].push(mapIdPos[source]);
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len5 = dests.length;
        dataArray[i2 * 4 + 2] = offset;
        dataArray[i2 * 4 + 3] = dests.length;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);
        for (var j2 = 0; j2 < len5; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureData = buildTextureData3;
    var buildTextureDataWithTwoEdgeAttr3 = function(nodes, edges, attrs1, attrs2) {
      var dataArray = [];
      var nodeDict = [];
      var mapIdPos = {};
      var i2 = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var n2 = nodes[i2];
        mapIdPos[n2.id] = i2;
        dataArray.push(n2.x);
        dataArray.push(n2.y);
        dataArray.push(0);
        dataArray.push(0);
        nodeDict.push([]);
      }
      for (i2 = 0; i2 < edges.length; i2++) {
        var e8 = edges[i2];
        var source = (0, math_1.getEdgeTerminal)(e8, "source");
        var target = (0, math_1.getEdgeTerminal)(e8, "target");
        nodeDict[mapIdPos[source]].push(mapIdPos[target]);
        nodeDict[mapIdPos[source]].push(attrs1(e8));
        nodeDict[mapIdPos[source]].push(attrs2(e8));
        nodeDict[mapIdPos[source]].push(0);
        nodeDict[mapIdPos[target]].push(mapIdPos[source]);
        nodeDict[mapIdPos[target]].push(attrs1(e8));
        nodeDict[mapIdPos[target]].push(attrs2(e8));
        nodeDict[mapIdPos[target]].push(0);
      }
      var maxEdgePerVetex = 0;
      for (i2 = 0; i2 < nodes.length; i2++) {
        var offset = dataArray.length;
        var dests = nodeDict[i2];
        var len5 = dests.length;
        dataArray[i2 * 4 + 2] = offset + 1048576 * len5 / 4;
        dataArray[i2 * 4 + 3] = 0;
        maxEdgePerVetex = Math.max(maxEdgePerVetex, len5 / 4);
        for (var j2 = 0; j2 < len5; ++j2) {
          var dest = dests[j2];
          dataArray.push(+dest);
        }
      }
      while (dataArray.length % 4 !== 0) {
        dataArray.push(0);
      }
      return {
        maxEdgePerVetex,
        array: new Float32Array(dataArray)
      };
    };
    exports.buildTextureDataWithTwoEdgeAttr = buildTextureDataWithTwoEdgeAttr3;
    var attributesToTextureData3 = function(attributeNames, items) {
      var dataArray = [];
      var attributeNum = attributeNames.length;
      var attributteStringMap = {};
      items.forEach(function(item) {
        attributeNames.forEach(function(name, i2) {
          if (attributteStringMap[item[name]] === void 0) {
            attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
          }
          dataArray.push(attributteStringMap[item[name]]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      });
      return {
        array: new Float32Array(dataArray),
        count: Object.keys(attributteStringMap).length
      };
    };
    exports.attributesToTextureData = attributesToTextureData3;
    var arrayToTextureData3 = function(valueArrays) {
      var dataArray = [];
      var attributeNum = valueArrays.length;
      var itemNum = valueArrays[0].length;
      var _loop_1 = function(j3) {
        valueArrays.forEach(function(valueArray, i2) {
          dataArray.push(valueArray[j3]);
          if (i2 === attributeNum - 1) {
            while (dataArray.length % 4 !== 0) {
              dataArray.push(0);
            }
          }
        });
      };
      for (var j2 = 0; j2 < itemNum; j2++) {
        _loop_1(j2);
      }
      return new Float32Array(dataArray);
    };
    exports.arrayToTextureData = arrayToTextureData3;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js
var require_fruchtermanShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchtermanShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clusterBundle = exports.clusterCode = exports.fruchtermanBundle = exports.fruchtermanCode = void 0;
    exports.fruchtermanCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass Fruchterman {\n  @in @out\n  u_Data: vec4[];\n  @in\n  u_K: float;\n  @in\n  u_K2: float;\n  \n  @in\n  u_Center: vec2;\n  @in\n  u_Gravity: float;\n  @in\n  u_ClusterGravity: float;\n  @in\n  u_Speed: float;\n  @in\n  u_MaxDisplace: float;\n  @in\n  u_Clustering: float;\n  @in\n  u_AttributeArray: vec4[];\n  @in\n  u_ClusterCenters: vec4[];\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const xDist = currentNode[0] - nextNode[0];\n        const yDist = currentNode[1] - nextNode[1];\n        const dist = (xDist * xDist + yDist * yDist) + 0.01;\n        let param = this.u_K2 / dist;\n        \n        if (dist > 0.0) {\n          dx += param * xDist;\n          dy += param * yDist;\n          if (xDist == 0 && yDist == 0) {\n            const sign = i < j ? 1 : -1;\n            dx += param * sign;\n            dy += param * sign;\n          }\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  calcGravity(currentNode: vec4, nodeAttributes: vec4): vec2 { // \n    let dx = 0, dy = 0;\n    const vx = currentNode[0] - this.u_Center[0];\n    const vy = currentNode[1] - this.u_Center[1];\n    const gf = 0.01 * this.u_K * this.u_Gravity;\n    dx = gf * vx;\n    dy = gf * vy;\n    if (this.u_Clustering == 1) {\n      const clusterIdx = int(nodeAttributes[0]);\n      const center = this.u_ClusterCenters[clusterIdx];\n      const cvx = currentNode[0] - center[0];\n      const cvy = currentNode[1] - center[1];\n      const dist = sqrt(cvx * cvx + cvy * cvy) + 0.01;\n      const parma = this.u_K * this.u_ClusterGravity / dist;\n      dx += parma * cvx;\n      dy += parma * cvy;\n    }\n    return [dx, dy];\n  }\n  calcAttractive(i: int, currentNode: vec4): vec2 {\n    let dx = 0, dy = 0;\n    const arr_offset = int(floor(currentNode[2] + 0.5));\n    const length = int(floor(currentNode[3] + 0.5));\n    const node_buffer: vec4;\n    for (let p = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + p;\n      // when arr_idx % 4 == 0 update currentNodedx_buffer\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)];\n      }\n      const float_j = buf_offset == 0 ? node_buffer[0] :\n                      buf_offset == 1 ? node_buffer[1] :\n                      buf_offset == 2 ? node_buffer[2] :\n                                        node_buffer[3];\n      const nextNode = this.u_Data[int(float_j)];\n      const xDist = currentNode[0] - nextNode[0];\n      const yDist = currentNode[1] - nextNode[1];\n      const dist = sqrt(xDist * xDist + yDist * yDist) + 0.01;\n      let attractiveF = dist / this.u_K;\n    \n      if (dist > 0.0) {\n        dx -= xDist * attractiveF;\n        dy -= yDist * attractiveF;\n        if (xDist == 0 && yDist == 0) {\n          const sign = i < int(float_j) ? 1 : -1;\n          dx -= sign * attractiveF;\n          dy -= sign * attractiveF;\n        }\n      }\n    }\n    return [dx, dy];\n  }\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    let dx = 0, dy = 0;\n    if (i >= VERTEX_COUNT) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // [gravity, fx, fy, 0]\n    const nodeAttributes = this.u_AttributeArray[i];\n\n    if (nodeAttributes[1] != 0 && nodeAttributes[2] != 0) {\n      // the node is fixed\n      this.u_Data[i] = [\n        nodeAttributes[1],\n        nodeAttributes[2],\n        currentNode[2],\n        currentNode[3]\n      ];\n      return;\n    }\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    dx += repulsive[0];\n    dy += repulsive[1];\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode);\n    dx += attractive[0];\n    dy += attractive[1];\n    // gravity\n    const gravity = this.calcGravity(currentNode, nodeAttributes);\n    dx -= gravity[0];\n    dy -= gravity[1];\n    // speed\n    dx *= this.u_Speed;\n    dy *= this.u_Speed;\n\n    // move\n    const distLength = sqrt(dx * dx + dy * dy);\n    if (distLength > 0.0) {\n      const limitedDist = min(this.u_MaxDisplace * this.u_Speed, distLength);\n      this.u_Data[i] = [\n        currentNode[0] + dx / distLength * limitedDist,\n        currentNode[1] + dy / distLength * limitedDist,\n        currentNode[2],\n        currentNode[3]\n      ];\n    }\n  }\n}\n";
    exports.fruchtermanBundle = '{"shaders":{"WGSL":"import \\"GLSL.std.450\\" as std;\\n\\n\\n# var gWebGPUDebug : bool = false;\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\n\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\n\\ntype GWebGPUParams = [[block]] struct {\\n  [[offset 0]] u_K : f32;\\n  [[offset 4]] u_K2 : f32;\\n  [[offset 8]] u_Center : vec2<f32>;\\n  [[offset 16]] u_Gravity : f32;\\n  [[offset 20]] u_ClusterGravity : f32;\\n  [[offset 24]] u_Speed : f32;\\n  [[offset 28]] u_MaxDisplace : f32;\\n  [[offset 32]] u_Clustering : f32;\\n};\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\ntype GWebGPUBuffer0 = [[block]] struct {\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\ntype GWebGPUBuffer1 = [[block]] struct {\\n  [[offset 0]] u_AttributeArray : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\ntype GWebGPUBuffer2 = [[block]] struct {\\n  [[offset 0]] u_ClusterCenters : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 3, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\nvar dy : f32 = 0.0;\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\nvar xDist : f32 = currentNode.x - nextNode.x;\\nvar yDist : f32 = currentNode.y - nextNode.y;\\nvar dist : f32 = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nvar param : f32 = gWebGPUUniformParams.u_K2 / dist;\\nif (dist > 0.0) {dx = dx + param * xDist;\\ndy = dy + param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {var sign : f32 = select(1.0, -1.0, i < j);\\ndx = dx + param * std::sign;\\ndy = dy + param * std::sign;}}}}\\nreturn vec2<f32>(dx, dy);}\\nfn calcGravity(currentNode : vec4<f32>, nodeAttributes : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\nvar dy : f32 = 0.0;\\nvar vx : f32 = currentNode.x - gWebGPUUniformParams.u_Center.x;\\nvar vy : f32 = currentNode.y - gWebGPUUniformParams.u_Center.y;\\nvar gf : f32 = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (gWebGPUUniformParams.u_Clustering == 1.0) {var clusterIdx : i32 = i32(nodeAttributes.x);\\nvar center : vec4<f32> = gWebGPUBuffer2.u_ClusterCenters[clusterIdx];\\nvar cvx : f32 = currentNode.x - center.x;\\nvar cvy : f32 = currentNode.y - center.y;\\nvar dist : f32 = std::sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nvar parma : f32 = (gWebGPUUniformParams.u_K * gWebGPUUniformParams.u_ClusterGravity) / dist;\\ndx = dx + parma * cvx;\\ndy = dy + parma * cvy;}\\nreturn vec2<f32>(dx, dy);}\\nfn calcAttractive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var dx : f32 = 0.0;\\nvar dy : f32 = 0.0;\\nvar arr_offset : i32 = i32(std::floor(currentNode.z + 0.5));\\nvar length : i32 = i32(std::floor(currentNode.w + 0.5));\\nvar node_buffer : vec4<f32>;\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\nvar arr_idx : i32 = arr_offset + i32(p);\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\nvar float_j : f32 = select(node_buffer.x, select(node_buffer.y, select(node_buffer.z, node_buffer.w, buf_offset == 2), buf_offset == 1), buf_offset == 0);\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\nvar xDist : f32 = currentNode.x - nextNode.x;\\nvar yDist : f32 = currentNode.y - nextNode.y;\\nvar dist : f32 = std::sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nvar attractiveF : f32 = dist / gWebGPUUniformParams.u_K;\\nif (dist > 0.0) {dx = dx - xDist * attractiveF;\\ndy = dy - yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {var sign : f32 = select(1.0, -1.0, i < i32(float_j));\\ndx = dx - std::sign * attractiveF;\\ndy = dy - std::sign * attractiveF;}}}\\nreturn vec2<f32>(dx, dy);}\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\nvar dx : f32 = 0.0;\\nvar dy : f32 = 0.0;\\nif (i >= __DefineValuePlaceholder__VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\nreturn ;}\\nvar nodeAttributes : vec4<f32> = gWebGPUBuffer1.u_AttributeArray[i];\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4<f32>(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w);\\nreturn ;}\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\ndx = dx + repulsive.x;\\ndy = dy + repulsive.y;\\nvar attractive : vec2<f32> = calcAttractive(i, currentNode);\\ndx = dx + attractive.x;\\ndy = dy + attractive.y;\\nvar gravity : vec2<f32> = calcGravity(currentNode, nodeAttributes);\\ndx = dx - gravity.x;\\ndy = dy - gravity.y;\\ndx = dx * gWebGPUUniformParams.u_Speed;\\ndy = dy * gWebGPUUniformParams.u_Speed;\\nvar distLength : f32 = std::sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {var limitedDist : f32 = std::min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\ngWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}\\nreturn;}\\n\\nentry_point compute as \\"main\\" = main;\\n","GLSL450":"\\n\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\nivec3 workGroupSize = ivec3(1,1,1);\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\n\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\n  float u_K;\\n  float u_K2;\\n  vec2 u_Center;\\n  float u_Gravity;\\n  float u_ClusterGravity;\\n  float u_Speed;\\n  float u_MaxDisplace;\\n  float u_Clustering;\\n} gWebGPUUniformParams;\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\n  vec4 u_Data[];\\n} gWebGPUBuffer0;\\n\\nlayout(std430, set = 0, binding = 2) buffer readonly  GWebGPUBuffer1 {\\n  vec4 u_AttributeArray[];\\n} gWebGPUBuffer1;\\n\\nlayout(std430, set = 0, binding = 3) buffer readonly  GWebGPUBuffer2 {\\n  vec4 u_ClusterCenters[];\\n} gWebGPUBuffer2;\\n\\n\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\nlayout (\\n  local_size_x = 1,\\n  local_size_y = 1,\\n  local_size_z = 1\\n) in;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvec2 calcRepulsive(int i, vec4 currentNode) {float dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = gWebGPUUniformParams.u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {float dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - gWebGPUUniformParams.u_Center.x;\\nfloat vy = currentNode.y - gWebGPUUniformParams.u_Center.y;\\nfloat gf = (0.01 * gWebGPUUniformParams.u_K) * gWebGPUUniformParams.u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (gWebGPUUniformParams.u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = gWebGPUBuffer2.u_ClusterCenters[clusterIdx];\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (gWebGPUUniformParams.u_K * gWebGPUUniformParams.u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {float dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / gWebGPUUniformParams.u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {int i = globalInvocationID.x;\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gWebGPUBuffer0.u_Data[i] = currentNode;\\nreturn ;}\\nvec4 nodeAttributes = gWebGPUBuffer1.u_AttributeArray[i];\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w);\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= gWebGPUUniformParams.u_Speed;\\ndy *= gWebGPUUniformParams.u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(gWebGPUUniformParams.u_MaxDisplace * gWebGPUUniformParams.u_Speed, distLength);\\ngWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w);}}\\n","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_K;\\nuniform float u_K2;\\nuniform vec2 u_Center;\\nuniform float u_Gravity;\\nuniform float u_ClusterGravity;\\nuniform float u_Speed;\\nuniform float u_MaxDisplace;\\nuniform float u_Clustering;\\nuniform sampler2D u_AttributeArray;\\nuniform vec2 u_AttributeArraySize;\\nvec4 getDatau_AttributeArray(vec2 address2D) {\\n  return vec4(texture2D(u_AttributeArray, address2D).rgba);\\n}\\nvec4 getDatau_AttributeArray(float address1D) {\\n  return getDatau_AttributeArray(addrTranslation_1Dto2D(address1D, u_AttributeArraySize));\\n}\\nvec4 getDatau_AttributeArray(int address1D) {\\n  return getDatau_AttributeArray(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = ((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat param = u_K2 / dist;\\nif (dist > 0.0) {dx += param * xDist;\\ndy += param * yDist;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < j) ? (1.0) : (-1.0);\\ndx += param * sign;\\ndy += param * sign;}}}}\\nreturn vec2(dx, dy);}\\nvec2 calcGravity(vec4 currentNode, vec4 nodeAttributes) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nfloat vx = currentNode.x - u_Center.x;\\nfloat vy = currentNode.y - u_Center.y;\\nfloat gf = (0.01 * u_K) * u_Gravity;\\ndx = gf * vx;\\ndy = gf * vy;\\nif (u_Clustering == 1.0) {int clusterIdx = int(nodeAttributes.x);\\nvec4 center = getDatau_ClusterCenters(clusterIdx);\\nfloat cvx = currentNode.x - center.x;\\nfloat cvy = currentNode.y - center.y;\\nfloat dist = sqrt((cvx * cvx) + (cvy * cvy)) + 0.01;\\nfloat parma = (u_K * u_ClusterGravity) / dist;\\ndx += parma * cvx;\\ndy += parma * cvy;}\\nreturn vec2(dx, dy);}\\nvec2 calcAttractive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nint arr_offset = int(floor(currentNode.z + 0.5));\\nint length = int(floor(currentNode.w + 0.5));\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + int(p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = (buf_offset == 0) ? (node_buffer.x) : ((buf_offset == 1) ? (node_buffer.y) : ((buf_offset == 2) ? (node_buffer.z) : (node_buffer.w)));\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat xDist = currentNode.x - nextNode.x;\\nfloat yDist = currentNode.y - nextNode.y;\\nfloat dist = sqrt((xDist * xDist) + (yDist * yDist)) + 0.01;\\nfloat attractiveF = dist / u_K;\\nif (dist > 0.0) {dx -= xDist * attractiveF;\\ndy -= yDist * attractiveF;\\nif ((xDist == 0.0) && (yDist == 0.0)) {float sign = (i < int(float_j)) ? (1.0) : (-1.0);\\ndx -= sign * attractiveF;\\ndy -= sign * attractiveF;}}}\\nreturn vec2(dx, dy);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nfloat dx = 0.0;\\nfloat dy = 0.0;\\nif (i >= VERTEX_COUNT) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes = getDatau_AttributeArray(i);\\nif ((nodeAttributes.y != 0.0) && (nodeAttributes.z != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes.y, nodeAttributes.z, currentNode.z, currentNode.w));\\nreturn ;}\\nvec2 repulsive = calcRepulsive(i, currentNode);\\ndx += repulsive.x;\\ndy += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode);\\ndx += attractive.x;\\ndy += attractive.y;\\nvec2 gravity = calcGravity(currentNode, nodeAttributes);\\ndx -= gravity.x;\\ndy -= gravity.y;\\ndx *= u_Speed;\\ndy *= u_Speed;\\nfloat distLength = sqrt((dx * dx) + (dy * dy));\\nif (distLength > 0.0) {float limitedDist = min(u_MaxDisplace * u_Speed, distLength);\\ngl_FragColor = vec4(vec4(currentNode.x + ((dx / distLength) * limitedDist), currentNode.y + ((dy / distLength) * limitedDist), currentNode.z, currentNode.w));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_K","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_K2","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Center","type":"vec2<f32>","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Gravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterGravity","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Speed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_MaxDisplace","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_Clustering","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AttributeArray","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.clusterCode = "\nimport { globalInvocationID } from 'g-webgpu';\nconst VERTEX_COUNT;\nconst CLUSTER_COUNT;\n@numthreads(1, 1, 1)\nclass CalcCenter {\n  @in\n  u_Data: vec4[];\n  @in\n  u_NodeAttributes: vec4[]; // [[clusterIdx, 0, 0, 0], ...]\n  @in @out\n  u_ClusterCenters: vec4[]; // [[cx, cy, nodeCount, clusterIdx], ...]\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const center = this.u_ClusterCenters[i];\n    let sumx = 0;\n    let sumy = 0;\n    let count = 0;\n    for (let j = 0; j < VERTEX_COUNT; j++) {\n      const attributes = this.u_NodeAttributes[j];\n      const clusterIdx = int(attributes[0]);\n      const vertex = this.u_Data[j];\n      if (clusterIdx == i) {\n        sumx += vertex.x;\n        sumy += vertex.y;\n        count += 1;\n      }\n    }\n    this.u_ClusterCenters[i] = [\n      sumx / count,\n      sumy / count,\n      count,\n      i\n    ];\n  }\n}\n";
    exports.clusterBundle = '{"shaders":{"WGSL":"import \\"GLSL.std.450\\" as std;\\n\\n\\n# var gWebGPUDebug : bool = false;\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\n\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\n\\n\\ntype GWebGPUBuffer0 = [[block]] struct {\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 0, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\ntype GWebGPUBuffer1 = [[block]] struct {\\n  [[offset 0]] u_NodeAttributes : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\ntype GWebGPUBuffer2 = [[block]] struct {\\n  [[offset 0]] u_ClusterCenters : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\nvar center : vec4<f32> = gWebGPUBuffer2.u_ClusterCenters[i];\\nvar sumx : f32 = 0.0;\\nvar sumy : f32 = 0.0;\\nvar count : f32 = 0.0;\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {var attributes : vec4<f32> = gWebGPUBuffer1.u_NodeAttributes[j];\\nvar clusterIdx : i32 = i32(attributes.x);\\nvar vertex : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\nif (clusterIdx == i) {sumx = sumx + vertex.x;\\nsumy = sumy + vertex.y;\\ncount = count + 1.0;}}\\ngWebGPUBuffer2.u_ClusterCenters[i] = vec4<f32>(sumx / count, sumy / count, count, i);\\nreturn;}\\n\\nentry_point compute as \\"main\\" = main;\\n","GLSL450":"\\n\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\nivec3 workGroupSize = ivec3(1,1,1);\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\n\\n\\nlayout(std430, set = 0, binding = 0) buffer readonly  GWebGPUBuffer0 {\\n  vec4 u_Data[];\\n} gWebGPUBuffer0;\\n\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer1 {\\n  vec4 u_NodeAttributes[];\\n} gWebGPUBuffer1;\\n\\nlayout(std430, set = 0, binding = 2) buffer   GWebGPUBuffer2 {\\n  vec4 u_ClusterCenters[];\\n} gWebGPUBuffer2;\\n\\n\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\nlayout (\\n  local_size_x = 1,\\n  local_size_y = 1,\\n  local_size_z = 1\\n) in;\\n\\n\\n\\nvoid main() {int i = globalInvocationID.x;\\nvec4 center = gWebGPUBuffer2.u_ClusterCenters[i];\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = gWebGPUBuffer1.u_NodeAttributes[j];\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = gWebGPUBuffer0.u_Data[j];\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngWebGPUBuffer2.u_ClusterCenters[i] = vec4(sumx / count, sumy / count, count, i);}\\n","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define CLUSTER_COUNT __DefineValuePlaceholder__CLUSTER_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributes;\\nuniform vec2 u_NodeAttributesSize;\\nvec4 getDatau_NodeAttributes(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributes, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributes(float address1D) {\\n  return getDatau_NodeAttributes(addrTranslation_1Dto2D(address1D, u_NodeAttributesSize));\\n}\\nvec4 getDatau_NodeAttributes(int address1D) {\\n  return getDatau_NodeAttributes(float(address1D));\\n}\\nuniform sampler2D u_ClusterCenters;\\nuniform vec2 u_ClusterCentersSize;\\nvec4 getDatau_ClusterCenters(vec2 address2D) {\\n  return vec4(texture2D(u_ClusterCenters, address2D).rgba);\\n}\\nvec4 getDatau_ClusterCenters(float address1D) {\\n  return getDatau_ClusterCenters(addrTranslation_1Dto2D(address1D, u_ClusterCentersSize));\\n}\\nvec4 getDatau_ClusterCenters(int address1D) {\\n  return getDatau_ClusterCenters(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 center = getDatau_ClusterCenters(i);\\nfloat sumx = 0.0;\\nfloat sumy = 0.0;\\nfloat count = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 attributes = getDatau_NodeAttributes(j);\\nint clusterIdx = int(attributes.x);\\nvec4 vertex = getDatau_Data(j);\\nif (clusterIdx == i) {sumx += vertex.x;\\nsumy += vertex.y;\\ncount += 1.0;}}\\ngl_FragColor = vec4(vec4(sumx / count, sumy / count, count, i));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"CLUSTER_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributes","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_ClusterCenters","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_ClusterCenters","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/fruchterman.js
var require_fruchterman2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/fruchterman.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator3 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: [] }, f2, y2, t4, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t4 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op[1])).done)
              return t4;
            if (y2 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t4[1]) {
                  _2.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _2.label < t4[2]) {
                  _2.label = t4[2];
                  _2.ops.push(op);
                  break;
                }
                if (t4[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e8) {
            op = [6, e8];
            y2 = 0;
          } finally {
            f2 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FruchtermanGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es5(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var fruchtermanShader_1 = require_fruchtermanShader();
    var constants_1 = require_constants();
    var FruchtermanGPULayout2 = function(_super) {
      __extends19(FruchtermanGPULayout3, _super);
      function FruchtermanGPULayout3(options) {
        var _this = _super.call(this) || this;
        _this.maxIteration = 1e3;
        _this.gravity = 10;
        _this.speed = 1;
        _this.clustering = false;
        _this.clusterField = "cluster";
        _this.clusterGravity = 10;
        _this.workerEnabled = false;
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.nodeMap = {};
        _this.nodeIdxMap = {};
        _this.updateCfg(options);
        return _this;
      }
      FruchtermanGPULayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 1e3,
          gravity: 10,
          speed: 1,
          clustering: false,
          clusterGravity: 10
        };
      };
      FruchtermanGPULayout3.prototype.execute = function() {
        return __awaiter3(this, void 0, void 0, function() {
          var self2, nodes, center, nodeMap, nodeIdxMap;
          var _this = this;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                self2 = this;
                nodes = self2.nodes;
                if (!nodes || nodes.length === 0) {
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                  return [2];
                }
                if (!self2.width && typeof window !== "undefined") {
                  self2.width = window.innerWidth;
                }
                if (!self2.height && typeof window !== "undefined") {
                  self2.height = window.innerHeight;
                }
                if (!self2.center) {
                  self2.center = [self2.width / 2, self2.height / 2];
                }
                center = self2.center;
                if (nodes.length === 1) {
                  nodes[0].x = center[0];
                  nodes[0].y = center[1];
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                  return [2];
                }
                nodeMap = {};
                nodeIdxMap = {};
                nodes.forEach(function(node, i2) {
                  if (!(0, util_1.isNumber)(node.x))
                    node.x = Math.random() * _this.width;
                  if (!(0, util_1.isNumber)(node.y))
                    node.y = Math.random() * _this.height;
                  nodeMap[node.id] = node;
                  nodeIdxMap[node.id] = i2;
                });
                self2.nodeMap = nodeMap;
                self2.nodeIdxMap = nodeIdxMap;
                return [4, self2.run()];
              case 1:
                _a2.sent();
                return [2];
            }
          });
        });
      };
      FruchtermanGPULayout3.prototype.executeWithWorker = function(canvas, ctx2) {
        return __awaiter3(this, void 0, void 0, function() {
          var self2, nodes, center, nodeMap, nodeIdxMap;
          var _this = this;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                self2 = this;
                nodes = self2.nodes;
                center = self2.center;
                if (!nodes || nodes.length === 0) {
                  return [2];
                }
                if (nodes.length === 1) {
                  nodes[0].x = center[0];
                  nodes[0].y = center[1];
                  return [2];
                }
                nodeMap = {};
                nodeIdxMap = {};
                nodes.forEach(function(node, i2) {
                  if (!(0, util_1.isNumber)(node.x))
                    node.x = Math.random() * _this.width;
                  if (!(0, util_1.isNumber)(node.y))
                    node.y = Math.random() * _this.height;
                  nodeMap[node.id] = node;
                  nodeIdxMap[node.id] = i2;
                });
                self2.nodeMap = nodeMap;
                self2.nodeIdxMap = nodeIdxMap;
                return [4, self2.run(canvas, ctx2)];
              case 1:
                _a2.sent();
                return [2];
            }
          });
        });
      };
      FruchtermanGPULayout3.prototype.run = function(canvas, ctx2) {
        return __awaiter3(this, void 0, void 0, function() {
          var self2, nodes, edges, maxIteration, center, area, maxDisplace, k2, k3, speed, clustering, _a2, attributeArray, clusterCount, numParticles, _b, maxEdgePerVetex, nodesEdgesArray, workerEnabled, world, onLayoutEnd, clusterCenters, i2, kernelFruchterman, kernelCluster, execute;
          var _this = this;
          return __generator3(this, function(_c) {
            switch (_c.label) {
              case 0:
                self2 = this;
                nodes = self2.nodes;
                edges = self2.edges;
                maxIteration = self2.maxIteration;
                center = self2.center;
                area = self2.height * self2.width;
                maxDisplace = Math.sqrt(area) / 10;
                k2 = area / (nodes.length + 1);
                k3 = Math.sqrt(k2);
                speed = self2.speed;
                clustering = self2.clustering;
                _a2 = (0, gpu_1.attributesToTextureData)([self2.clusterField], nodes), attributeArray = _a2.array, clusterCount = _a2.count;
                nodes.forEach(function(node, i3) {
                  var fx = 0;
                  var fy = 0;
                  if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                    fx = node.fx || 1e-3;
                    fy = node.fy || 1e-3;
                  }
                  attributeArray[4 * i3 + 1] = fx;
                  attributeArray[4 * i3 + 2] = fy;
                });
                numParticles = nodes.length;
                _b = (0, gpu_1.buildTextureData)(nodes, edges), maxEdgePerVetex = _b.maxEdgePerVetex, nodesEdgesArray = _b.array;
                workerEnabled = self2.workerEnabled;
                if (workerEnabled) {
                  world = g_webgpu_1.World.create({
                    canvas,
                    engineOptions: {
                      supportCompute: true
                    }
                  });
                } else {
                  world = g_webgpu_1.World.create({
                    engineOptions: {
                      supportCompute: true
                    }
                  });
                }
                onLayoutEnd = self2.onLayoutEnd;
                clusterCenters = [];
                for (i2 = 0; i2 < clusterCount; i2++) {
                  clusterCenters.push(0, 0, 0, 0);
                }
                kernelFruchterman = world.createKernel(fruchtermanShader_1.fruchtermanBundle).setDispatch([numParticles, 1, 1]).setBinding({
                  u_Data: nodesEdgesArray,
                  u_K: k3,
                  u_K2: k2,
                  u_Gravity: self2.gravity,
                  u_ClusterGravity: self2.clusterGravity || self2.gravity || 1,
                  u_Speed: speed,
                  u_MaxDisplace: maxDisplace,
                  u_Clustering: clustering ? 1 : 0,
                  u_Center: center,
                  u_AttributeArray: attributeArray,
                  u_ClusterCenters: clusterCenters,
                  MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                  VERTEX_COUNT: numParticles
                });
                if (clustering) {
                  kernelCluster = world.createKernel(fruchtermanShader_1.clusterBundle).setDispatch([clusterCount, 1, 1]).setBinding({
                    u_Data: nodesEdgesArray,
                    u_NodeAttributes: attributeArray,
                    u_ClusterCenters: clusterCenters,
                    VERTEX_COUNT: numParticles,
                    CLUSTER_COUNT: clusterCount
                  });
                }
                execute = function() {
                  return __awaiter3(_this, void 0, void 0, function() {
                    var i3, finalParticleData;
                    return __generator3(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          i3 = 0;
                          _a3.label = 1;
                        case 1:
                          if (!(i3 < maxIteration))
                            return [3, 6];
                          return [4, kernelFruchterman.execute()];
                        case 2:
                          _a3.sent();
                          if (!clustering)
                            return [3, 4];
                          kernelCluster.setBinding({
                            u_Data: kernelFruchterman
                          });
                          return [4, kernelCluster.execute()];
                        case 3:
                          _a3.sent();
                          kernelFruchterman.setBinding({
                            u_ClusterCenters: kernelCluster
                          });
                          _a3.label = 4;
                        case 4:
                          kernelFruchterman.setBinding({
                            u_MaxDisplace: maxDisplace *= 0.99
                          });
                          _a3.label = 5;
                        case 5:
                          i3++;
                          return [3, 1];
                        case 6:
                          return [4, kernelFruchterman.getOutput()];
                        case 7:
                          finalParticleData = _a3.sent();
                          if (canvas) {
                            ctx2.postMessage({
                              type: constants_1.LAYOUT_MESSAGE.GPUEND,
                              vertexEdgeData: finalParticleData
                            });
                          } else {
                            nodes.forEach(function(node, i4) {
                              var x2 = finalParticleData[4 * i4];
                              var y2 = finalParticleData[4 * i4 + 1];
                              node.x = x2;
                              node.y = y2;
                            });
                          }
                          if (onLayoutEnd)
                            onLayoutEnd();
                          return [2];
                      }
                    });
                  });
                };
                return [4, execute()];
              case 1:
                _c.sent();
                return [2];
            }
          });
        });
      };
      FruchtermanGPULayout3.prototype.getType = function() {
        return "fruchterman-gpu";
      };
      return FruchtermanGPULayout3;
    }(base_1.Base);
    exports.FruchtermanGPULayout = FruchtermanGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForceShader.js
var require_gForceShader = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForceShader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.aveMovementBundle = exports.aveMovementCode = exports.gForceBundle = exports.gForceCode = void 0;
    exports.gForceCode = "\nimport { globalInvocationID } from 'g-webgpu';\n\nconst MAX_EDGE_PER_VERTEX;\nconst VERTEX_COUNT;\nconst SHIFT_20 = 1048576;\n\n@numthreads(1, 1, 1)\nclass GGForce {\n  @in @out\n  u_Data: vec4[];\n\n  @in\n  u_damping: float;\n  \n  @in\n  u_maxSpeed: float;\n\n  @in\n  u_minMovement: float;\n\n  @in\n  u_AveMovement: vec4[];\n\n  @in\n  u_coulombDisScale: float;\n\n  @in\n  u_factor: float;\n\n  @in\n  u_NodeAttributeArray1: vec4[];\n\n  @in\n  u_NodeAttributeArray2: vec4[];\n\n  @in\n  u_interval: float;\n\n  unpack_float(packedValue: float): ivec2 {\n    const packedIntValue = int(packedValue);\n    const v0 = packedIntValue / SHIFT_20;\n    return [v0, packedIntValue - v0 * SHIFT_20];\n  }\n\n  calcRepulsive(i: int, currentNode: vec4): vec2 {\n    let ax = 0, ay = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      if (i != j) {\n        const nextNode = this.u_Data[j];\n        const vx = currentNode[0] - nextNode[0];\n        const vy = currentNode[1] - nextNode[1];\n        const dist = sqrt(vx * vx + vy * vy) + 0.01;\n        const n_dist = (dist + 0.1) * this.u_coulombDisScale;\n        const direx = vx / dist;\n        const direy = vy / dist;\n        const attributesi = this.u_NodeAttributeArray1[i];\n        const attributesj = this.u_NodeAttributeArray1[j];\n        const massi = attributesi[0];\n        const nodeStrengthi = attributesi[2];\n        const nodeStrengthj = attributesj[2];\n        const nodeStrength = (nodeStrengthi + nodeStrengthj) / 2;\n        // const param = nodeStrength * this.u_factor / (n_dist * n_dist * massi);\n        const param = nodeStrength * this.u_factor / (n_dist * n_dist);\n        ax += direx * param;\n        ay += direy * param;\n      }\n    }\n    return [ax, ay];\n  }\n\n  calcGravity(i: int, currentNode: vec4, attributes2: vec4): vec2 {\n    // note: attributes2 = [centerX, centerY, gravity, 0]\n\n    const vx = currentNode[0] - attributes2[0];\n    const vy = currentNode[1] - attributes2[1];\n    \n    const ax = vx * attributes2[2];\n    const ay = vy * attributes2[2];\n    \n    return [ax, ay];\n  }\n\n  calcAttractive(i: int, currentNode: vec4, attributes1: vec4): vec2 {\n    // note: attributes1 = [mass, degree, nodeSterngth, 0]\n\n    const mass = attributes1[0];\n    let ax = 0, ay = 0;\n    // const arr_offset = int(floor(currentNode[2] + 0.5));\n    // const length = int(floor(currentNode[3] + 0.5));\n\n    const compressed = this.unpack_float(currentNode[2]);\n    const length = compressed[0];\n    const arr_offset = compressed[1];\n\n    const node_buffer: vec4;\n    for (let p: int = 0; p < MAX_EDGE_PER_VERTEX; p++) {\n      if (p >= length) break;\n      const arr_idx = arr_offset + 4 * p; // i \u8282\u70B9\u7684\u7B2C p \u6761\u8FB9\u5F00\u59CB\u7684\u5C0F\u683C\u5B50\u4F4D\u7F6E\n      const buf_offset = arr_idx - arr_idx / 4 * 4;\n      if (p == 0 || buf_offset == 0) {\n        node_buffer = this.u_Data[int(arr_idx / 4)]; // \u5927\u683C\u5B50\uFF0C\u5927\u683C\u5B50\u4F4D\u7F6E=\u5C0F\u4E2A\u5B50\u4F4D\u7F6E / 4\uFF0C\n      }\n\n      let float_j: float = node_buffer[0];\n\n      const nextNode = this.u_Data[int(float_j)];\n      const vx = nextNode[0] - currentNode[0];\n      const vy = nextNode[1] - currentNode[1];\n      const dist = sqrt(vx * vx + vy * vy) + 0.01;\n      const direx = vx / dist;\n      const direy = vy / dist;\n      const edgeLength = node_buffer[1];\n      const edgeStrength = node_buffer[2];\n      const diff: float = edgeLength - dist;//edgeLength\n      // const param = diff * this.u_stiffness / mass; //\n      const param = diff * edgeStrength / mass; // \n      ax -= direx * param;\n      ay -= direy * param;\n    }\n    return [ax, ay];\n  }\n\n  @main\n  compute() {\n    const i = globalInvocationID.x;\n    const currentNode = this.u_Data[i];\n    const movement = u_AveMovement[0];\n    let ax = 0, ay = 0;\n\n    if (i >= VERTEX_COUNT || movement.x < u_minMovement) {\n      this.u_Data[i] = currentNode;\n      return;\n    }\n\n    // \u6BCF\u4E2A\u8282\u70B9\u5C5E\u6027\u5360\u4E24\u4E2A\u6570\u7EC4\u4E2D\u5404\u4E00\u683C\n    // [mass, degree, nodeStrength, fx]\n    const nodeAttributes1 = this.u_NodeAttributeArray1[i];\n    // [centerX, centerY, centerGravity, fy]\n    const nodeAttributes2 = this.u_NodeAttributeArray2[i];\n\n    // repulsive\n    const repulsive = this.calcRepulsive(i, currentNode);\n    ax += repulsive[0];\n    ay += repulsive[1];\n\n    // attractive\n    const attractive = this.calcAttractive(i, currentNode, nodeAttributes1);\n    ax += attractive[0];\n    ay += attractive[1];\n\n    // gravity\n    const gravity = this.calcGravity(i, currentNode, nodeAttributes2);\n    ax -= gravity[0];\n    ay -= gravity[1];\n\n    // speed\n    const param = this.u_interval * this.u_damping;\n    let vx = ax * param;\n    let vy = ay * param;\n    const vlength = sqrt(vx * vx + vy * vy) + 0.0001;\n    if (vlength > this.u_maxSpeed) {\n      const param2 = this.u_maxSpeed / vlength;\n      vx = param2 * vx;\n      vy = param2 * vy;\n    }\n\n    // move\n    if (nodeAttributes1[3] != 0 && nodeAttributes2[3] != 0) {\n      this.u_Data[i] = [\n        nodeAttributes1[3],\n        nodeAttributes2[3],\n        currentNode[2],\n        0\n      ];\n    } else {\n      const distx = vx * this.u_interval;\n      const disty = vy * this.u_interval;\n      const distLength = sqrt(distx * distx + disty * disty);\n      this.u_Data[i] = [\n        currentNode[0] + distx,\n        currentNode[1] + disty,\n        currentNode[2],\n        distLength\n      ];\n    }\n    \n    // the avarage move distance\n    // need to share memory\n    \n  }\n}\n";
    exports.gForceBundle = '{"shaders":{"WGSL":"import \\"GLSL.std.450\\" as std;\\n\\n\\n# var gWebGPUDebug : bool = false;\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\n\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\n\\ntype GWebGPUParams = [[block]] struct {\\n  [[offset 0]] u_damping : f32;\\n  [[offset 4]] u_maxSpeed : f32;\\n  [[offset 8]] u_minMovement : f32;\\n  \\n  [[offset 12]] u_coulombDisScale : f32;\\n  [[offset 16]] u_factor : f32;\\n  \\n  \\n  [[offset 20]] u_interval : f32;\\n};\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\ntype GWebGPUBuffer0 = [[block]] struct {\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\ntype GWebGPUBuffer1 = [[block]] struct {\\n  [[offset 0]] u_AveMovement : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\ntype GWebGPUBuffer2 = [[block]] struct {\\n  [[offset 0]] u_NodeAttributeArray1 : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 3, set 0]] var<storage_buffer> gWebGPUBuffer2 : GWebGPUBuffer2;\\ntype GWebGPUBuffer3 = [[block]] struct {\\n  [[offset 0]] u_NodeAttributeArray2 : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 4, set 0]] var<storage_buffer> gWebGPUBuffer3 : GWebGPUBuffer3;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfn unpack_float(packedValue : f32) -> vec2<i32> {var packedIntValue : i32 = i32(packedValue);\\nvar v0 : i32 = packedIntValue / 1048576;\\nreturn vec2<i32>(v0, packedIntValue - (v0 * 1048576));}\\nfn calcRepulsive(i : i32, currentNode : vec4<f32>) -> vec2<f32> {var ax : f32 = 0.0;\\nvar ay : f32 = 0.0;\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {if (i != j) {var nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\nvar vx : f32 = currentNode.x - nextNode.x;\\nvar vy : f32 = currentNode.y - nextNode.y;\\nvar dist : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.01;\\nvar n_dist : f32 = (dist + 0.1) * gWebGPUUniformParams.u_coulombDisScale;\\nvar direx : f32 = vx / dist;\\nvar direy : f32 = vy / dist;\\nvar attributesi : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\nvar attributesj : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[j];\\nvar massi : f32 = attributesi.x;\\nvar nodeStrengthi : f32 = attributesi.z;\\nvar nodeStrengthj : f32 = attributesj.z;\\nvar nodeStrength : f32 = (nodeStrengthi + nodeStrengthj) / 2.0;\\nvar param : f32 = (nodeStrength * gWebGPUUniformParams.u_factor) / (n_dist * n_dist);\\nax = ax + direx * param;\\nay = ay + direy * param;}}\\nreturn vec2<f32>(ax, ay);}\\nfn calcGravity(i : i32, currentNode : vec4<f32>, attributes2 : vec4<f32>) -> vec2<f32> {var vx : f32 = currentNode.x - attributes2.x;\\nvar vy : f32 = currentNode.y - attributes2.y;\\nvar ax : f32 = vx * attributes2.z;\\nvar ay : f32 = vy * attributes2.z;\\nreturn vec2<f32>(ax, ay);}\\nfn calcAttractive(i : i32, currentNode : vec4<f32>, attributes1 : vec4<f32>) -> vec2<f32> {var mass : f32 = attributes1.x;\\nvar ax : f32 = 0.0;\\nvar ay : f32 = 0.0;\\nvar compressed : vec2<i32> = unpack_float(currentNode.z);\\nvar length : i32 = compressed.x;\\nvar arr_offset : i32 = compressed.y;\\nvar node_buffer : vec4<f32>;\\nfor (var p : i32 = 0; p < __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX; p = p + 1) {if (p >= length) {break;}\\nvar arr_idx : i32 = arr_offset + (4 * p);\\nvar buf_offset : i32 = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[i32(arr_idx / 4)];}\\nvar float_j : f32 = node_buffer.x;\\nvar nextNode : vec4<f32> = gWebGPUBuffer0.u_Data[i32(float_j)];\\nvar vx : f32 = nextNode.x - currentNode.x;\\nvar vy : f32 = nextNode.y - currentNode.y;\\nvar dist : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.01;\\nvar direx : f32 = vx / dist;\\nvar direy : f32 = vy / dist;\\nvar edgeLength : f32 = node_buffer.y;\\nvar edgeStrength : f32 = node_buffer.z;\\nvar diff : f32 = edgeLength - dist;\\nvar param : f32 = (diff * edgeStrength) / mass;\\nax = ax - direx * param;\\nay = ay - direy * param;}\\nreturn vec2<f32>(ax, ay);}\\nfn main() -> void {var i : i32 = globalInvocationID.x;\\nvar currentNode : vec4<f32> = gWebGPUBuffer0.u_Data[i];\\nvar movement : vec4<f32> = gWebGPUBuffer1.u_AveMovement[0];\\nvar ax : f32 = 0.0;\\nvar ay : f32 = 0.0;\\nif ((i >= __DefineValuePlaceholder__VERTEX_COUNT) || (movement.x < gWebGPUUniformParams.u_minMovement)) {gWebGPUBuffer0.u_Data[i] = currentNode;\\nreturn ;}\\nvar nodeAttributes1 : vec4<f32> = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\nvar nodeAttributes2 : vec4<f32> = gWebGPUBuffer3.u_NodeAttributeArray2[i];\\nvar repulsive : vec2<f32> = calcRepulsive(i, currentNode);\\nax = ax + repulsive.x;\\nay = ay + repulsive.y;\\nvar attractive : vec2<f32> = calcAttractive(i, currentNode, nodeAttributes1);\\nax = ax + attractive.x;\\nay = ay + attractive.y;\\nvar gravity : vec2<f32> = calcGravity(i, currentNode, nodeAttributes2);\\nax = ax - gravity.x;\\nay = ay - gravity.y;\\nvar param : f32 = gWebGPUUniformParams.u_interval * gWebGPUUniformParams.u_damping;\\nvar vx : f32 = ax * param;\\nvar vy : f32 = ay * param;\\nvar vlength : f32 = std::sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > gWebGPUUniformParams.u_maxSpeed) {var param2 : f32 = gWebGPUUniformParams.u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nvar distx : f32 = vx * gWebGPUUniformParams.u_interval;\\nvar disty : f32 = vy * gWebGPUUniformParams.u_interval;\\nvar distLength : f32 = std::sqrt((distx * distx) + (disty * disty));\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4<f32>(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0);}else {gWebGPUBuffer0.u_Data[i] = vec4<f32>(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength);}\\nreturn;}\\n\\nentry_point compute as \\"main\\" = main;\\n","GLSL450":"\\n\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\nivec3 workGroupSize = ivec3(1,1,1);\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\n\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\n  float u_damping;\\n  float u_maxSpeed;\\n  float u_minMovement;\\n  \\n  float u_coulombDisScale;\\n  float u_factor;\\n  \\n  \\n  float u_interval;\\n} gWebGPUUniformParams;\\nlayout(std430, set = 0, binding = 1) buffer   GWebGPUBuffer0 {\\n  vec4 u_Data[];\\n} gWebGPUBuffer0;\\n\\nlayout(std430, set = 0, binding = 2) buffer readonly  GWebGPUBuffer1 {\\n  vec4 u_AveMovement[];\\n} gWebGPUBuffer1;\\n\\nlayout(std430, set = 0, binding = 3) buffer readonly  GWebGPUBuffer2 {\\n  vec4 u_NodeAttributeArray1[];\\n} gWebGPUBuffer2;\\n\\nlayout(std430, set = 0, binding = 4) buffer readonly  GWebGPUBuffer3 {\\n  vec4 u_NodeAttributeArray2[];\\n} gWebGPUBuffer3;\\n\\n\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\nlayout (\\n  local_size_x = 1,\\n  local_size_y = 1,\\n  local_size_z = 1\\n) in;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nivec2 unpack_float(float packedValue) {int packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {float ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = gWebGPUBuffer0.u_Data[j];\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * gWebGPUUniformParams.u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\nvec4 attributesj = gWebGPUBuffer2.u_NodeAttributeArray1[j];\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * gWebGPUUniformParams.u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {float vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {float mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = gWebGPUBuffer0.u_Data[int(arr_idx / 4)];}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = gWebGPUBuffer0.u_Data[int(float_j)];\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {int i = globalInvocationID.x;\\nvec4 currentNode = gWebGPUBuffer0.u_Data[i];\\nvec4 movement = gWebGPUBuffer1.u_AveMovement[0];\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < gWebGPUUniformParams.u_minMovement)) {gWebGPUBuffer0.u_Data[i] = currentNode;\\nreturn ;}\\nvec4 nodeAttributes1 = gWebGPUBuffer2.u_NodeAttributeArray1[i];\\nvec4 nodeAttributes2 = gWebGPUBuffer3.u_NodeAttributeArray2[i];\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = gWebGPUUniformParams.u_interval * gWebGPUUniformParams.u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > gWebGPUUniformParams.u_maxSpeed) {float param2 = gWebGPUUniformParams.u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nfloat distx = vx * gWebGPUUniformParams.u_interval;\\nfloat disty = vy * gWebGPUUniformParams.u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gWebGPUBuffer0.u_Data[i] = vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0);}else {gWebGPUBuffer0.u_Data[i] = vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength);}}\\n","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define MAX_EDGE_PER_VERTEX __DefineValuePlaceholder__MAX_EDGE_PER_VERTEX\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n#define SHIFT_20 1048576.0\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_damping;\\nuniform float u_maxSpeed;\\nuniform float u_minMovement;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nuniform float u_coulombDisScale;\\nuniform float u_factor;\\nuniform sampler2D u_NodeAttributeArray1;\\nuniform vec2 u_NodeAttributeArray1Size;\\nvec4 getDatau_NodeAttributeArray1(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray1, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray1(float address1D) {\\n  return getDatau_NodeAttributeArray1(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray1Size));\\n}\\nvec4 getDatau_NodeAttributeArray1(int address1D) {\\n  return getDatau_NodeAttributeArray1(float(address1D));\\n}\\nuniform sampler2D u_NodeAttributeArray2;\\nuniform vec2 u_NodeAttributeArray2Size;\\nvec4 getDatau_NodeAttributeArray2(vec2 address2D) {\\n  return vec4(texture2D(u_NodeAttributeArray2, address2D).rgba);\\n}\\nvec4 getDatau_NodeAttributeArray2(float address1D) {\\n  return getDatau_NodeAttributeArray2(addrTranslation_1Dto2D(address1D, u_NodeAttributeArray2Size));\\n}\\nvec4 getDatau_NodeAttributeArray2(int address1D) {\\n  return getDatau_NodeAttributeArray2(float(address1D));\\n}\\nuniform float u_interval;\\nivec2 unpack_float(float packedValue) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint packedIntValue = int(packedValue);\\nint v0 = packedIntValue / int(SHIFT_20);\\nreturn ivec2(v0, packedIntValue - (v0 * int(SHIFT_20)));}\\nvec2 calcRepulsive(int i, vec4 currentNode) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {if (i != j) {vec4 nextNode = getDatau_Data(j);\\nfloat vx = currentNode.x - nextNode.x;\\nfloat vy = currentNode.y - nextNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat n_dist = (dist + 0.1) * u_coulombDisScale;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nvec4 attributesi = getDatau_NodeAttributeArray1(i);\\nvec4 attributesj = getDatau_NodeAttributeArray1(j);\\nfloat massi = attributesi.x;\\nfloat nodeStrengthi = attributesi.z;\\nfloat nodeStrengthj = attributesj.z;\\nfloat nodeStrength = (nodeStrengthi + nodeStrengthj) / 2.0;\\nfloat param = (nodeStrength * u_factor) / (n_dist * n_dist);\\nax += direx * param;\\nay += direy * param;}}\\nreturn vec2(ax, ay);}\\nvec2 calcGravity(int i, vec4 currentNode, vec4 attributes2) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat vx = currentNode.x - attributes2.x;\\nfloat vy = currentNode.y - attributes2.y;\\nfloat ax = vx * attributes2.z;\\nfloat ay = vy * attributes2.z;\\nreturn vec2(ax, ay);}\\nvec2 calcAttractive(int i, vec4 currentNode, vec4 attributes1) {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat mass = attributes1.x;\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nivec2 compressed = unpack_float(currentNode.z);\\nint length = compressed.x;\\nint arr_offset = compressed.y;\\nvec4 node_buffer;\\nfor (int p = 0; p < MAX_EDGE_PER_VERTEX; p++) {if (p >= length) {break;}\\nint arr_idx = arr_offset + (4 * p);\\nint buf_offset = arr_idx - ((arr_idx / 4) * 4);\\nif ((p == 0) || (buf_offset == 0)) {node_buffer = getDatau_Data(int(arr_idx / 4));}\\nfloat float_j = node_buffer.x;\\nvec4 nextNode = getDatau_Data(int(float_j));\\nfloat vx = nextNode.x - currentNode.x;\\nfloat vy = nextNode.y - currentNode.y;\\nfloat dist = sqrt((vx * vx) + (vy * vy)) + 0.01;\\nfloat direx = vx / dist;\\nfloat direy = vy / dist;\\nfloat edgeLength = node_buffer.y;\\nfloat edgeStrength = node_buffer.z;\\nfloat diff = edgeLength - dist;\\nfloat param = (diff * edgeStrength) / mass;\\nax -= direx * param;\\nay -= direy * param;}\\nreturn vec2(ax, ay);}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nint i = globalInvocationID.x;\\nvec4 currentNode = getDatau_Data(i);\\nvec4 movement = getDatau_AveMovement(0.0);\\nfloat ax = 0.0;\\nfloat ay = 0.0;\\nif ((i >= VERTEX_COUNT) || (movement.x < u_minMovement)) {gl_FragColor = vec4(currentNode);\\nreturn ;}\\nvec4 nodeAttributes1 = getDatau_NodeAttributeArray1(i);\\nvec4 nodeAttributes2 = getDatau_NodeAttributeArray2(i);\\nvec2 repulsive = calcRepulsive(i, currentNode);\\nax += repulsive.x;\\nay += repulsive.y;\\nvec2 attractive = calcAttractive(i, currentNode, nodeAttributes1);\\nax += attractive.x;\\nay += attractive.y;\\nvec2 gravity = calcGravity(i, currentNode, nodeAttributes2);\\nax -= gravity.x;\\nay -= gravity.y;\\nfloat param = u_interval * u_damping;\\nfloat vx = ax * param;\\nfloat vy = ay * param;\\nfloat vlength = sqrt((vx * vx) + (vy * vy)) + 0.0001;\\nif (vlength > u_maxSpeed) {float param2 = u_maxSpeed / vlength;\\nvx = param2 * vx;\\nvy = param2 * vy;}\\nfloat distx = vx * u_interval;\\nfloat disty = vy * u_interval;\\nfloat distLength = sqrt((distx * distx) + (disty * disty));\\nif ((nodeAttributes1.w != 0.0) && (nodeAttributes2.w != 0.0)) {gl_FragColor = vec4(vec4(nodeAttributes1.w, nodeAttributes2.w, currentNode.z, 0.0));}else {gl_FragColor = vec4(vec4(currentNode.x + distx, currentNode.y + disty, currentNode.z, distLength));}if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"MAX_EDGE_PER_VERTEX","type":"Float","runtime":true},{"name":"VERTEX_COUNT","type":"Float","runtime":true},{"name":"SHIFT_20","type":"Float","value":1048576,"runtime":false}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]},{"name":"u_damping","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_maxSpeed","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_minMovement","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_coulombDisScale","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_factor","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray1","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_NodeAttributeArray2","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_interval","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_Data","size":[1,1],"length":1},"needPingpong":true}}';
    exports.aveMovementCode = "\nconst VERTEX_COUNT;\n@numthreads(1, 1, 1)\nclass CalcAveMovement {\n  @in\n  u_Data: vec4[];\n  @in\n  u_iter: float;\n  @in @out\n  u_AveMovement: vec4[];\n  @main\n  compute() {\n    let movement = 0;\n    for (let j: int = 0; j < VERTEX_COUNT; j++) {\n      const vertex = this.u_Data[j];\n      movement += vertex[3];\n    }\n    movement = movement / float(VERTEX_COUNT);\n    this.u_AveMovement[0] = [movement, 0, 0, 0];\n  }\n}\n";
    exports.aveMovementBundle = '{"shaders":{"WGSL":"import \\"GLSL.std.450\\" as std;\\n\\n\\n# var gWebGPUDebug : bool = false;\\n# var gWebGPUDebugOutput : vec4<f32> = vec4<f32>(0.0);\\n\\n[[builtin global_invocation_id]] var<in> globalInvocationID : vec3<u32>;\\n# [[builtin work_group_size]] var<in> workGroupSize : vec3<u32>;\\n# [[builtin work_group_id]] var<in> workGroupID : vec3<u32>;\\n[[builtin local_invocation_id]] var<in> localInvocationID : vec3<u32>;\\n# [[builtin num_work_groups]] var<in> numWorkGroups : vec3<u32>;\\n[[builtin local_invocation_idx]] var<in> localInvocationIndex : u32;\\n\\ntype GWebGPUParams = [[block]] struct {\\n  [[offset 0]] u_iter : f32;\\n};\\n[[binding 0, set 0]] var<uniform> gWebGPUUniformParams : GWebGPUParams;\\ntype GWebGPUBuffer0 = [[block]] struct {\\n  [[offset 0]] u_Data : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 1, set 0]] var<storage_buffer> gWebGPUBuffer0 : GWebGPUBuffer0;\\ntype GWebGPUBuffer1 = [[block]] struct {\\n  [[offset 0]] u_AveMovement : [[stride 16]] array<vec4<f32>>;\\n};\\n[[binding 2, set 0]] var<storage_buffer> gWebGPUBuffer1 : GWebGPUBuffer1;\\n\\n\\n\\n\\n\\n\\n\\n\\nfn main() -> void {var movement : f32 = 0.0;\\nfor (var j : i32 = 0; j < __DefineValuePlaceholder__VERTEX_COUNT; j = j + 1) {var vertex : vec4<f32> = gWebGPUBuffer0.u_Data[j];\\nmovement = movement + vertex.w;}\\nmovement = movement / f32(__DefineValuePlaceholder__VERTEX_COUNT);\\ngWebGPUBuffer1.u_AveMovement[0] = vec4<f32>(movement, 0.0, 0.0, 0.0);\\nreturn;}\\n\\nentry_point compute as \\"main\\" = main;\\n","GLSL450":"\\n\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\nivec3 globalInvocationID = ivec3(gl_GlobalInvocationID);\\nivec3 workGroupSize = ivec3(1,1,1);\\nivec3 workGroupID = ivec3(gl_WorkGroupID);\\nivec3 localInvocationID = ivec3(gl_LocalInvocationID);\\nivec3 numWorkGroups = ivec3(gl_NumWorkGroups);\\nint localInvocationIndex = int(gl_LocalInvocationIndex);\\n\\nlayout(std140, set = 0, binding = 0) uniform GWebGPUParams {\\n  float u_iter;\\n} gWebGPUUniformParams;\\nlayout(std430, set = 0, binding = 1) buffer readonly  GWebGPUBuffer0 {\\n  vec4 u_Data[];\\n} gWebGPUBuffer0;\\n\\nlayout(std430, set = 0, binding = 2) buffer   GWebGPUBuffer1 {\\n  vec4 u_AveMovement[];\\n} gWebGPUBuffer1;\\n\\n\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\nlayout (\\n  local_size_x = 1,\\n  local_size_y = 1,\\n  local_size_z = 1\\n) in;\\n\\n\\n\\nvoid main() {float movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = gWebGPUBuffer0.u_Data[j];\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngWebGPUBuffer1.u_AveMovement[0] = vec4(movement, 0.0, 0.0, 0.0);}\\n","GLSL100":"\\n\\nfloat epsilon = 0.00001;\\nvec2 addrTranslation_1Dto2D(float address1D, vec2 texSize) {\\n  vec2 conv_const = vec2(1.0 / texSize.x, 1.0 / (texSize.x * texSize.y));\\n  vec2 normAddr2D = float(address1D) * conv_const;\\n  return vec2(fract(normAddr2D.x + epsilon), normAddr2D.y);\\n}\\n\\nvoid barrier() {}\\n  \\n\\nuniform vec2 u_OutputTextureSize;\\nuniform int u_OutputTexelCount;\\nvarying vec2 v_TexCoord;\\n\\nbool gWebGPUDebug = false;\\nvec4 gWebGPUDebugOutput = vec4(0.0);\\n\\n#define VERTEX_COUNT __DefineValuePlaceholder__VERTEX_COUNT\\n\\nuniform sampler2D u_Data;\\nuniform vec2 u_DataSize;\\nvec4 getDatau_Data(vec2 address2D) {\\n  return vec4(texture2D(u_Data, address2D).rgba);\\n}\\nvec4 getDatau_Data(float address1D) {\\n  return getDatau_Data(addrTranslation_1Dto2D(address1D, u_DataSize));\\n}\\nvec4 getDatau_Data(int address1D) {\\n  return getDatau_Data(float(address1D));\\n}\\nuniform float u_iter;\\nuniform sampler2D u_AveMovement;\\nuniform vec2 u_AveMovementSize;\\nvec4 getDatau_AveMovement(vec2 address2D) {\\n  return vec4(texture2D(u_AveMovement, address2D).rgba);\\n}\\nvec4 getDatau_AveMovement(float address1D) {\\n  return getDatau_AveMovement(addrTranslation_1Dto2D(address1D, u_AveMovementSize));\\n}\\nvec4 getDatau_AveMovement(int address1D) {\\n  return getDatau_AveMovement(float(address1D));\\n}\\nvoid main() {\\nivec3 workGroupSize = ivec3(1, 1, 1);\\nivec3 numWorkGroups = ivec3(1, 1, 1);     \\nint globalInvocationIndex = int(floor(v_TexCoord.x * u_OutputTextureSize.x))\\n  + int(floor(v_TexCoord.y * u_OutputTextureSize.y)) * int(u_OutputTextureSize.x);\\nint workGroupIDLength = globalInvocationIndex / (workGroupSize.x * workGroupSize.y * workGroupSize.z);\\nivec3 workGroupID = ivec3(workGroupIDLength / numWorkGroups.y / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.z, workGroupIDLength / numWorkGroups.x / numWorkGroups.y);\\nint localInvocationIDZ = globalInvocationIndex / (workGroupSize.x * workGroupSize.y);\\nint localInvocationIDY = (globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y) / workGroupSize.x;\\nint localInvocationIDX = globalInvocationIndex - localInvocationIDZ * workGroupSize.x * workGroupSize.y - localInvocationIDY * workGroupSize.x;\\nivec3 localInvocationID = ivec3(localInvocationIDX, localInvocationIDY, localInvocationIDZ);\\nivec3 globalInvocationID = workGroupID * workGroupSize + localInvocationID;\\nint localInvocationIndex = localInvocationID.z * workGroupSize.x * workGroupSize.y\\n                + localInvocationID.y * workGroupSize.x + localInvocationID.x;\\nfloat movement = 0.0;\\nfor (int j = 0; j < VERTEX_COUNT; j++) {vec4 vertex = getDatau_Data(j);\\nmovement += vertex.w;}\\nmovement = movement / float(VERTEX_COUNT);\\ngl_FragColor = vec4(vec4(movement, 0.0, 0.0, 0.0));if (gWebGPUDebug) {\\n  gl_FragColor = gWebGPUDebugOutput;\\n}}\\n"},"context":{"name":"","dispatch":[1,1,1],"threadGroupSize":[1,1,1],"maxIteration":1,"defines":[{"name":"VERTEX_COUNT","type":"Float","runtime":true}],"uniforms":[{"name":"u_Data","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_iter","type":"Float","storageClass":"Uniform","readonly":true,"writeonly":false,"size":[1,1]},{"name":"u_AveMovement","type":"vec4<f32>[]","storageClass":"StorageBuffer","readonly":false,"writeonly":false,"size":[1,1]}],"globalDeclarations":[],"output":{"name":"u_AveMovement","size":[1,1],"length":1},"needPingpong":true}}';
  }
});

// node_modules/@antv/layout/lib/layout/gpu/gForce.js
var require_gForce2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/gpu/gForce.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __awaiter3 = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e8) {
            reject(e8);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e8) {
            reject(e8);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator3 = exports && exports.__generator || function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t4[0] & 1)
          throw t4[1];
        return t4[1];
      }, trys: [], ops: [] }, f2, y2, t4, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t4 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op[1])).done)
              return t4;
            if (y2 = 0, t4)
              op = [op[0] & 2, t4.value];
            switch (op[0]) {
              case 0:
              case 1:
                t4 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t4[1]) {
                  _2.label = t4[1];
                  t4 = op;
                  break;
                }
                if (t4 && _2.label < t4[2]) {
                  _2.label = t4[2];
                  _2.ops.push(op);
                  break;
                }
                if (t4[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e8) {
            op = [6, e8];
            y2 = 0;
          } finally {
            f2 = t4 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GForceGPULayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var g_webgpu_1 = (init_es5(), __toCommonJS(es_exports3));
    var gpu_1 = require_gpu();
    var math_1 = require_math();
    var gForceShader_1 = require_gForceShader();
    var constants_1 = require_constants();
    var GForceGPULayout2 = function(_super) {
      __extends19(GForceGPULayout3, _super);
      function GForceGPULayout3(options) {
        var _this = _super.call(this) || this;
        _this.maxIteration = 1e3;
        _this.edgeStrength = 200;
        _this.nodeStrength = 1e3;
        _this.coulombDisScale = 5e-3;
        _this.damping = 0.9;
        _this.maxSpeed = 1e3;
        _this.minMovement = 0.5;
        _this.interval = 0.02;
        _this.factor = 1;
        _this.linkDistance = 1;
        _this.gravity = 10;
        _this.workerEnabled = false;
        _this.nodes = [];
        _this.edges = [];
        _this.width = 300;
        _this.height = 300;
        _this.nodeMap = {};
        _this.nodeIdxMap = {};
        _this.updateCfg(options);
        return _this;
      }
      GForceGPULayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 2e3,
          gravity: 10,
          clustering: false,
          clusterGravity: 10
        };
      };
      GForceGPULayout3.prototype.execute = function() {
        return __awaiter3(this, void 0, void 0, function() {
          var self2, nodes, center, nodeMap, nodeIdxMap;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                self2 = this;
                nodes = self2.nodes;
                if (!nodes || nodes.length === 0) {
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                  return [2];
                }
                if (!self2.width && typeof window !== "undefined") {
                  self2.width = window.innerWidth;
                }
                if (!self2.height && typeof window !== "undefined") {
                  self2.height = window.innerHeight;
                }
                if (!self2.center) {
                  self2.center = [self2.width / 2, self2.height / 2];
                }
                center = self2.center;
                if (nodes.length === 1) {
                  nodes[0].x = center[0];
                  nodes[0].y = center[1];
                  if (self2.onLayoutEnd)
                    self2.onLayoutEnd();
                  return [2];
                }
                nodeMap = {};
                nodeIdxMap = {};
                nodes.forEach(function(node, i2) {
                  if (!(0, util_1.isNumber)(node.x))
                    node.x = Math.random() * self2.width;
                  if (!(0, util_1.isNumber)(node.y))
                    node.y = Math.random() * self2.height;
                  nodeMap[node.id] = node;
                  nodeIdxMap[node.id] = i2;
                });
                self2.nodeMap = nodeMap;
                self2.nodeIdxMap = nodeIdxMap;
                self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
                self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
                return [4, self2.run()];
              case 1:
                _a2.sent();
                return [2];
            }
          });
        });
      };
      GForceGPULayout3.prototype.executeWithWorker = function(canvas, ctx2) {
        var self2 = this;
        var nodes = self2.nodes;
        var center = self2.center;
        if (!nodes || nodes.length === 0) {
          return;
        }
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          return;
        }
        var nodeMap = {};
        var nodeIdxMap = {};
        nodes.forEach(function(node, i2) {
          if (!(0, util_1.isNumber)(node.x))
            node.x = Math.random() * self2.width;
          if (!(0, util_1.isNumber)(node.y))
            node.y = Math.random() * self2.height;
          nodeMap[node.id] = node;
          nodeIdxMap[node.id] = i2;
        });
        self2.nodeMap = nodeMap;
        self2.nodeIdxMap = nodeIdxMap;
        self2.nodeStrength = (0, gpu_1.proccessToFunc)(self2.nodeStrength, 1);
        self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength, 1);
        self2.run(canvas, ctx2);
      };
      GForceGPULayout3.prototype.run = function(canvas, ctx2) {
        return __awaiter3(this, void 0, void 0, function() {
          var self2, nodes, edges, maxIteration, numParticles, _a2, maxEdgePerVetex, nodesEdgesArray, masses, nodeStrengths, centerXs, centerYs, centerGravities, fxs, fys, gravity, center, nodeAttributeArray1, nodeAttributeArray2, workerEnabled, world, onLayoutEnd, initPreviousData, i2, kernelGForce, kernelAveMovement, execute;
          var _this = this;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                self2 = this;
                nodes = self2.nodes;
                edges = self2.edges;
                maxIteration = self2.maxIteration;
                if (!self2.width && typeof window !== "undefined") {
                  self2.width = window.innerWidth;
                }
                if (!self2.height && typeof window !== "undefined") {
                  self2.height = window.innerHeight;
                }
                numParticles = nodes.length;
                self2.linkDistance = (0, gpu_1.proccessToFunc)(self2.linkDistance);
                self2.edgeStrength = (0, gpu_1.proccessToFunc)(self2.edgeStrength);
                _a2 = (0, gpu_1.buildTextureDataWithTwoEdgeAttr)(nodes, edges, self2.linkDistance, self2.edgeStrength), maxEdgePerVetex = _a2.maxEdgePerVetex, nodesEdgesArray = _a2.array;
                self2.degrees = (0, math_1.getDegree)(nodes.length, self2.nodeIdxMap, edges);
                masses = [];
                nodeStrengths = [];
                centerXs = [];
                centerYs = [];
                centerGravities = [];
                fxs = [];
                fys = [];
                if (!self2.getMass) {
                  self2.getMass = function(d2) {
                    return self2.degrees[self2.nodeIdxMap[d2.id]] || 1;
                  };
                }
                gravity = self2.gravity;
                center = self2.center;
                nodes.forEach(function(node, i3) {
                  masses.push(self2.getMass(node));
                  nodeStrengths.push(self2.nodeStrength(node));
                  if (!self2.degrees[i3])
                    self2.degrees[i3] = 0;
                  var nodeGravity = [center[0], center[1], gravity];
                  if (self2.getCenter) {
                    var customCenter = self2.getCenter(node, self2.degrees[i3]);
                    if (customCenter && (0, util_1.isNumber)(customCenter[0]) && (0, util_1.isNumber)(customCenter[1]) && (0, util_1.isNumber)(customCenter[2])) {
                      nodeGravity = customCenter;
                    }
                  }
                  centerXs.push(nodeGravity[0]);
                  centerYs.push(nodeGravity[1]);
                  centerGravities.push(nodeGravity[2]);
                  if ((0, util_1.isNumber)(node.fx) && (0, util_1.isNumber)(node.fy)) {
                    fxs.push(node.fx || 1e-3);
                    fys.push(node.fy || 1e-3);
                  } else {
                    fxs.push(0);
                    fys.push(0);
                  }
                });
                nodeAttributeArray1 = (0, gpu_1.arrayToTextureData)([
                  masses,
                  self2.degrees,
                  nodeStrengths,
                  fxs
                ]);
                nodeAttributeArray2 = (0, gpu_1.arrayToTextureData)([
                  centerXs,
                  centerYs,
                  centerGravities,
                  fys
                ]);
                workerEnabled = self2.workerEnabled;
                if (workerEnabled) {
                  world = g_webgpu_1.World.create({
                    canvas,
                    engineOptions: {
                      supportCompute: true
                    }
                  });
                } else {
                  world = g_webgpu_1.World.create({
                    engineOptions: {
                      supportCompute: true
                    }
                  });
                }
                onLayoutEnd = self2.onLayoutEnd;
                initPreviousData = [];
                nodesEdgesArray.forEach(function(value) {
                  initPreviousData.push(value);
                });
                for (i2 = 0; i2 < 4; i2++) {
                  initPreviousData.push(0);
                }
                kernelGForce = world.createKernel(gForceShader_1.gForceBundle).setDispatch([numParticles, 1, 1]).setBinding({
                  u_Data: nodesEdgesArray,
                  u_damping: self2.damping,
                  u_maxSpeed: self2.maxSpeed,
                  u_minMovement: self2.minMovement,
                  u_coulombDisScale: self2.coulombDisScale,
                  u_factor: self2.factor,
                  u_NodeAttributeArray1: nodeAttributeArray1,
                  u_NodeAttributeArray2: nodeAttributeArray2,
                  MAX_EDGE_PER_VERTEX: maxEdgePerVetex,
                  VERTEX_COUNT: numParticles,
                  u_AveMovement: initPreviousData,
                  u_interval: self2.interval
                });
                kernelAveMovement = world.createKernel(gForceShader_1.aveMovementBundle).setDispatch([1, 1, 1]).setBinding({
                  u_Data: nodesEdgesArray,
                  VERTEX_COUNT: numParticles,
                  u_AveMovement: [0, 0, 0, 0]
                });
                execute = function() {
                  return __awaiter3(_this, void 0, void 0, function() {
                    var i3, stepInterval, finalParticleData;
                    return __generator3(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          i3 = 0;
                          _a3.label = 1;
                        case 1:
                          if (!(i3 < maxIteration))
                            return [3, 5];
                          return [4, kernelGForce.execute()];
                        case 2:
                          _a3.sent();
                          kernelAveMovement.setBinding({
                            u_Data: kernelGForce
                          });
                          return [4, kernelAveMovement.execute()];
                        case 3:
                          _a3.sent();
                          stepInterval = Math.max(0.02, self2.interval - i3 * 2e-3);
                          kernelGForce.setBinding({
                            u_interval: stepInterval,
                            u_AveMovement: kernelAveMovement
                          });
                          _a3.label = 4;
                        case 4:
                          i3++;
                          return [3, 1];
                        case 5:
                          return [4, kernelGForce.getOutput()];
                        case 6:
                          finalParticleData = _a3.sent();
                          if (canvas) {
                            ctx2.postMessage({
                              type: constants_1.LAYOUT_MESSAGE.GPUEND,
                              vertexEdgeData: finalParticleData
                            });
                          } else {
                            nodes.forEach(function(node, i4) {
                              var x2 = finalParticleData[4 * i4];
                              var y2 = finalParticleData[4 * i4 + 1];
                              node.x = x2;
                              node.y = y2;
                            });
                          }
                          if (onLayoutEnd)
                            onLayoutEnd();
                          return [2];
                      }
                    });
                  });
                };
                return [4, execute()];
              case 1:
                _b.sent();
                return [2];
            }
          });
        });
      };
      GForceGPULayout3.prototype.getType = function() {
        return "gForce-gpu";
      };
      return GForceGPULayout3;
    }(base_1.Base);
    exports.GForceGPULayout = GForceGPULayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboForce.js
var require_comboForce = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboForce.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboForceLayout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var ComboForceLayout2 = function(_super) {
      __extends19(ComboForceLayout3, _super);
      function ComboForceLayout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.maxIteration = 100;
        _this.gravity = 10;
        _this.comboGravity = 10;
        _this.linkDistance = 10;
        _this.alpha = 1;
        _this.alphaMin = 1e-3;
        _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);
        _this.alphaTarget = 0;
        _this.velocityDecay = 0.6;
        _this.edgeStrength = 0.6;
        _this.nodeStrength = 30;
        _this.preventOverlap = false;
        _this.preventNodeOverlap = false;
        _this.preventComboOverlap = false;
        _this.collideStrength = void 0;
        _this.nodeCollideStrength = 0.5;
        _this.comboCollideStrength = 0.5;
        _this.comboSpacing = 20;
        _this.comboPadding = 10;
        _this.optimizeRangeFactor = 1;
        _this.onTick = function() {
        };
        _this.onLayoutEnd = function() {
        };
        _this.depthAttractiveForceScale = 1;
        _this.depthRepulsiveForceScale = 2;
        _this.nodes = [];
        _this.edges = [];
        _this.combos = [];
        _this.comboTrees = [];
        _this.width = 300;
        _this.height = 300;
        _this.bias = [];
        _this.nodeMap = {};
        _this.oriComboMap = {};
        _this.indexMap = {};
        _this.comboMap = {};
        _this.previousLayouted = false;
        _this.updateCfg(options);
        return _this;
      }
      ComboForceLayout3.prototype.getDefaultCfg = function() {
        return {
          maxIteration: 100,
          center: [0, 0],
          gravity: 10,
          speed: 1,
          comboGravity: 30,
          preventOverlap: false,
          preventComboOverlap: true,
          preventNodeOverlap: true,
          nodeSpacing: void 0,
          collideStrength: void 0,
          nodeCollideStrength: 0.5,
          comboCollideStrength: 0.5,
          comboSpacing: 20,
          comboPadding: 10,
          edgeStrength: 0.6,
          nodeStrength: 30,
          linkDistance: 10
        };
      };
      ComboForceLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var center = self2.center;
        self2.comboTree = {
          id: "comboTreeRoot",
          depth: -1,
          children: self2.comboTrees
        };
        if (!nodes || nodes.length === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        self2.initVals();
        self2.run();
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
      };
      ComboForceLayout3.prototype.run = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var maxIteration = self2.previousLayouted ? self2.maxIteration / 5 : self2.maxIteration;
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        var center = self2.center;
        var velocityDecay = self2.velocityDecay;
        var comboMap = self2.comboMap;
        if (!self2.previousLayouted)
          self2.initPos(comboMap);
        var _loop_1 = function(i3) {
          var displacements = [];
          nodes.forEach(function(_2, j2) {
            displacements[j2] = { x: 0, y: 0 };
          });
          self2.applyCalculate(displacements);
          self2.applyComboCenterForce(displacements);
          nodes.forEach(function(n2, j2) {
            if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
              return;
            n2.x += displacements[j2].x * velocityDecay;
            n2.y += displacements[j2].y * velocityDecay;
          });
          self2.alpha += (self2.alphaTarget - self2.alpha) * self2.alphaDecay;
          self2.onTick();
        };
        for (var i2 = 0; i2 < maxIteration; i2++) {
          _loop_1(i2);
        }
        var meanCenter = [0, 0];
        nodes.forEach(function(n2) {
          if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
            return;
          meanCenter[0] += n2.x;
          meanCenter[1] += n2.y;
        });
        meanCenter[0] /= nodes.length;
        meanCenter[1] /= nodes.length;
        var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];
        nodes.forEach(function(n2, j2) {
          if (!(0, util_1.isNumber)(n2.x) || !(0, util_1.isNumber)(n2.y))
            return;
          n2.x += centerOffset[0];
          n2.y += centerOffset[1];
        });
        self2.combos.forEach(function(combo) {
          var mapped = comboMap[combo.id];
          if (mapped && mapped.empty) {
            combo.x = mapped.cx || combo.x;
            combo.y = mapped.cy || combo.y;
          }
        });
        self2.previousLayouted = true;
      };
      ComboForceLayout3.prototype.initVals = function() {
        var self2 = this;
        var edges = self2.edges;
        var nodes = self2.nodes;
        var combos = self2.combos;
        var count = {};
        var nodeMap = {};
        var indexMap = {};
        nodes.forEach(function(node, i3) {
          nodeMap[node.id] = node;
          indexMap[node.id] = i3;
        });
        self2.nodeMap = nodeMap;
        self2.indexMap = indexMap;
        var oriComboMap = {};
        combos.forEach(function(combo) {
          oriComboMap[combo.id] = combo;
        });
        self2.oriComboMap = oriComboMap;
        self2.comboMap = self2.getComboMap();
        var preventOverlap = self2.preventOverlap;
        self2.preventComboOverlap = self2.preventComboOverlap || preventOverlap;
        self2.preventNodeOverlap = self2.preventNodeOverlap || preventOverlap;
        var collideStrength = self2.collideStrength;
        if (collideStrength) {
          self2.comboCollideStrength = collideStrength;
          self2.nodeCollideStrength = collideStrength;
        }
        self2.comboCollideStrength = self2.comboCollideStrength ? self2.comboCollideStrength : 0;
        self2.nodeCollideStrength = self2.nodeCollideStrength ? self2.nodeCollideStrength : 0;
        for (var i2 = 0; i2 < edges.length; ++i2) {
          var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
          var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
          if (count[source])
            count[source]++;
          else
            count[source] = 1;
          if (count[target])
            count[target]++;
          else
            count[target] = 1;
        }
        var bias = [];
        for (var i2 = 0; i2 < edges.length; ++i2) {
          var source = (0, util_1.getEdgeTerminal)(edges[i2], "source");
          var target = (0, util_1.getEdgeTerminal)(edges[i2], "target");
          bias[i2] = count[source] / (count[source] + count[target]);
        }
        this.bias = bias;
        var nodeSize = self2.nodeSize;
        var nodeSpacing = self2.nodeSpacing;
        var nodeSizeFunc;
        var nodeSpacingFunc;
        if ((0, util_1.isNumber)(nodeSpacing)) {
          nodeSpacingFunc = function() {
            return nodeSpacing;
          };
        } else if ((0, util_1.isFunction)(nodeSpacing)) {
          nodeSpacingFunc = nodeSpacing;
        } else {
          nodeSpacingFunc = function() {
            return 0;
          };
        }
        this.nodeSpacing = nodeSpacingFunc;
        if (!nodeSize) {
          nodeSizeFunc = function(d2) {
            if (d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                return res / 2;
              }
              if ((0, util_1.isObject)(d2.size)) {
                var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                return res / 2;
              }
              return d2.size / 2;
            }
            return 10;
          };
        } else if ((0, util_1.isFunction)(nodeSize)) {
          nodeSizeFunc = function(d2) {
            return nodeSize(d2);
          };
        } else if ((0, util_1.isArray)(nodeSize)) {
          var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
          var radius_1 = larger / 2;
          nodeSizeFunc = function(d2) {
            return radius_1;
          };
        } else {
          var radius_2 = nodeSize / 2;
          nodeSizeFunc = function(d2) {
            return radius_2;
          };
        }
        this.nodeSize = nodeSizeFunc;
        var comboSpacing = self2.comboSpacing;
        var comboSpacingFunc;
        if ((0, util_1.isNumber)(comboSpacing)) {
          comboSpacingFunc = function() {
            return comboSpacing;
          };
        } else if ((0, util_1.isFunction)(comboSpacing)) {
          comboSpacingFunc = comboSpacing;
        } else {
          comboSpacingFunc = function() {
            return 0;
          };
        }
        this.comboSpacing = comboSpacingFunc;
        var comboPadding = self2.comboPadding;
        var comboPaddingFunc;
        if ((0, util_1.isNumber)(comboPadding)) {
          comboPaddingFunc = function() {
            return comboPadding;
          };
        } else if ((0, util_1.isArray)(comboPadding)) {
          comboPaddingFunc = function() {
            return Math.max.apply(null, comboPadding);
          };
        } else if ((0, util_1.isFunction)(comboPadding)) {
          comboPaddingFunc = comboPadding;
        } else {
          comboPaddingFunc = function() {
            return 0;
          };
        }
        this.comboPadding = comboPaddingFunc;
        var linkDistance = this.linkDistance;
        var linkDistanceFunc;
        if (!linkDistance) {
          linkDistance = 10;
        }
        if ((0, util_1.isNumber)(linkDistance)) {
          linkDistanceFunc = function(d2) {
            return linkDistance;
          };
        } else {
          linkDistanceFunc = linkDistance;
        }
        this.linkDistance = linkDistanceFunc;
        var edgeStrength = this.edgeStrength;
        var edgeStrengthFunc;
        if (!edgeStrength) {
          edgeStrength = 1;
        }
        if ((0, util_1.isNumber)(edgeStrength)) {
          edgeStrengthFunc = function(d2) {
            return edgeStrength;
          };
        } else {
          edgeStrengthFunc = edgeStrength;
        }
        this.edgeStrength = edgeStrengthFunc;
        var nodeStrength = this.nodeStrength;
        var nodeStrengthFunc;
        if (!nodeStrength) {
          nodeStrength = 30;
        }
        if ((0, util_1.isNumber)(nodeStrength)) {
          nodeStrengthFunc = function(d2) {
            return nodeStrength;
          };
        } else {
          nodeStrengthFunc = nodeStrength;
        }
        this.nodeStrength = nodeStrengthFunc;
      };
      ComboForceLayout3.prototype.initPos = function(comboMap) {
        var self2 = this;
        var nodes = self2.nodes;
        nodes.forEach(function(node, i2) {
          var comboId = node.comboId;
          var combo = comboMap[comboId];
          if (comboId && combo) {
            node.x = combo.cx + 100 / (i2 + 1);
            node.y = combo.cy + 100 / (i2 + 1);
          } else {
            node.x = 100 / (i2 + 1);
            node.y = 100 / (i2 + 1);
          }
        });
      };
      ComboForceLayout3.prototype.getComboMap = function() {
        var self2 = this;
        var nodeMap = self2.nodeMap;
        var comboTrees = self2.comboTrees;
        var oriComboMap = self2.oriComboMap;
        var comboMap = {};
        (comboTrees || []).forEach(function(ctree) {
          var treeChildren = [];
          (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
            if (treeNode.itemType === "node")
              return true;
            if (!oriComboMap[treeNode.id])
              return true;
            if (comboMap[treeNode.id] === void 0) {
              var combo = {
                id: treeNode.id,
                name: treeNode.id,
                cx: 0,
                cy: 0,
                count: 0,
                depth: self2.oriComboMap[treeNode.id].depth || 0,
                children: []
              };
              comboMap[treeNode.id] = combo;
            }
            var children = treeNode.children;
            if (children) {
              children.forEach(function(child) {
                if (!comboMap[child.id] && !nodeMap[child.id])
                  return true;
                treeChildren.push(child);
              });
            }
            var c2 = comboMap[treeNode.id];
            c2.cx = 0;
            c2.cy = 0;
            if (treeChildren.length === 0) {
              c2.empty = true;
              var oriCombo = oriComboMap[treeNode.id];
              c2.cx = oriCombo.x;
              c2.cy = oriCombo.y;
            }
            treeChildren.forEach(function(child) {
              c2.count++;
              if (child.itemType !== "node") {
                var childCombo = comboMap[child.id];
                if ((0, util_1.isNumber)(childCombo.cx))
                  c2.cx += childCombo.cx;
                if ((0, util_1.isNumber)(childCombo.cy))
                  c2.cy += childCombo.cy;
                return;
              }
              var node = nodeMap[child.id];
              if (!node)
                return;
              if ((0, util_1.isNumber)(node.x)) {
                c2.cx += node.x;
              }
              if ((0, util_1.isNumber)(node.y)) {
                c2.cy += node.y;
              }
            });
            c2.cx /= c2.count || 1;
            c2.cy /= c2.count || 1;
            c2.children = treeChildren;
            return true;
          });
        });
        return comboMap;
      };
      ComboForceLayout3.prototype.applyComboCenterForce = function(displacements) {
        var self2 = this;
        var gravity = self2.gravity;
        var comboGravity = self2.comboGravity || gravity;
        var alpha = this.alpha;
        var comboTrees = self2.comboTrees;
        var indexMap = self2.indexMap;
        var nodeMap = self2.nodeMap;
        var comboMap = self2.comboMap;
        (comboTrees || []).forEach(function(ctree) {
          (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
            if (treeNode.itemType === "node")
              return true;
            var combo = comboMap[treeNode.id];
            if (!combo)
              return true;
            var c2 = comboMap[treeNode.id];
            var gravityScale = (c2.depth + 1) / 10 * 0.5;
            var comboX = c2.cx;
            var comboY = c2.cy;
            c2.cx = 0;
            c2.cy = 0;
            c2.children.forEach(function(child) {
              if (child.itemType !== "node") {
                var childCombo = comboMap[child.id];
                if (childCombo && (0, util_1.isNumber)(childCombo.cx))
                  c2.cx += childCombo.cx;
                if (childCombo && (0, util_1.isNumber)(childCombo.cy))
                  c2.cy += childCombo.cy;
                return;
              }
              var node = nodeMap[child.id];
              var vecX = node.x - comboX || 5e-3;
              var vecY = node.y - comboY || 5e-3;
              var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
              var childIdx = indexMap[node.id];
              var params = comboGravity * alpha / l2 * gravityScale;
              displacements[childIdx].x -= vecX * params;
              displacements[childIdx].y -= vecY * params;
              if ((0, util_1.isNumber)(node.x))
                c2.cx += node.x;
              if ((0, util_1.isNumber)(node.y))
                c2.cy += node.y;
            });
            c2.cx /= c2.count || 1;
            c2.cy /= c2.count || 1;
            return true;
          });
        });
      };
      ComboForceLayout3.prototype.applyCalculate = function(displacements) {
        var self2 = this;
        var comboMap = self2.comboMap;
        var nodes = self2.nodes;
        var vecMap = {};
        nodes.forEach(function(v2, i2) {
          nodes.forEach(function(u2, j2) {
            if (i2 < j2)
              return;
            var vx = v2.x - u2.x || 5e-3;
            var vy = v2.y - u2.y || 5e-3;
            var vl2 = vx * vx + vy * vy;
            var vl = Math.sqrt(vl2);
            if (vl2 < 1)
              vl2 = vl;
            vecMap["".concat(v2.id, "-").concat(u2.id)] = { vx, vy, vl2, vl };
            vecMap["".concat(u2.id, "-").concat(v2.id)] = { vl2, vl, vx: -vx, vy: -vy };
          });
        });
        self2.updateComboSizes(comboMap);
        self2.calRepulsive(displacements, vecMap);
        self2.calAttractive(displacements, vecMap);
        var preventComboOverlap = self2.preventComboOverlap;
        if (preventComboOverlap)
          self2.comboNonOverlapping(displacements, comboMap);
      };
      ComboForceLayout3.prototype.updateComboSizes = function(comboMap) {
        var self2 = this;
        var comboTrees = self2.comboTrees;
        var nodeMap = self2.nodeMap;
        var nodeSize = self2.nodeSize;
        var comboSpacing = self2.comboSpacing;
        var comboPadding = self2.comboPadding;
        (comboTrees || []).forEach(function(ctree) {
          var treeChildren = [];
          (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
            if (treeNode.itemType === "node")
              return true;
            var c2 = comboMap[treeNode.id];
            if (!c2)
              return false;
            var children = treeNode.children;
            if (children) {
              children.forEach(function(child) {
                if (!comboMap[child.id] && !nodeMap[child.id])
                  return;
                treeChildren.push(child);
              });
            }
            c2.minX = Infinity;
            c2.minY = Infinity;
            c2.maxX = -Infinity;
            c2.maxY = -Infinity;
            treeChildren.forEach(function(child) {
              if (child.itemType !== "node")
                return true;
              var node = nodeMap[child.id];
              if (!node)
                return true;
              var r2 = nodeSize(node);
              var nodeMinX = node.x - r2;
              var nodeMinY = node.y - r2;
              var nodeMaxX = node.x + r2;
              var nodeMaxY = node.y + r2;
              if (c2.minX > nodeMinX)
                c2.minX = nodeMinX;
              if (c2.minY > nodeMinY)
                c2.minY = nodeMinY;
              if (c2.maxX < nodeMaxX)
                c2.maxX = nodeMaxX;
              if (c2.maxY < nodeMaxY)
                c2.maxY = nodeMaxY;
            });
            var minSize = self2.oriComboMap[treeNode.id].size || 10;
            if ((0, util_1.isArray)(minSize))
              minSize = minSize[0];
            var maxLength = Math.max(c2.maxX - c2.minX, c2.maxY - c2.minY, minSize);
            c2.r = maxLength / 2 + comboSpacing(c2) / 2 + comboPadding(c2);
            return true;
          });
        });
      };
      ComboForceLayout3.prototype.comboNonOverlapping = function(displacements, comboMap) {
        var self2 = this;
        var comboTree = self2.comboTree;
        var comboCollideStrength = self2.comboCollideStrength;
        var indexMap = self2.indexMap;
        var nodeMap = self2.nodeMap;
        (0, util_1.traverseTreeUp)(comboTree, function(treeNode) {
          if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== "comboTreeRoot") {
            return false;
          }
          var children = treeNode.children;
          if (children && children.length > 1) {
            children.forEach(function(v2, i2) {
              if (v2.itemType === "node")
                return false;
              var cv = comboMap[v2.id];
              if (!cv)
                return;
              children.forEach(function(u2, j2) {
                if (i2 <= j2)
                  return false;
                if (u2.itemType === "node")
                  return false;
                var cu2 = comboMap[u2.id];
                if (!cu2)
                  return false;
                var vx = cv.cx - cu2.cx || 5e-3;
                var vy = cv.cy - cu2.cy || 5e-3;
                var l2 = vx * vx + vy * vy;
                var rv = cv.r || 1;
                var ru2 = cu2.r || 1;
                var r2 = rv + ru2;
                var ru22 = ru2 * ru2;
                var rv2 = rv * rv;
                if (l2 < r2 * r2) {
                  var vnodes = v2.children;
                  if (!vnodes || vnodes.length === 0)
                    return false;
                  var unodes_1 = u2.children;
                  if (!unodes_1 || unodes_1.length === 0)
                    return false;
                  var sqrtl = Math.sqrt(l2);
                  var ll = (r2 - sqrtl) / sqrtl * comboCollideStrength;
                  var xl_1 = vx * ll;
                  var yl_1 = vy * ll;
                  var rratio_1 = ru22 / (rv2 + ru22);
                  var irratio_1 = 1 - rratio_1;
                  vnodes.forEach(function(vn2) {
                    if (vn2.itemType !== "node")
                      return false;
                    if (!nodeMap[vn2.id])
                      return;
                    var vindex = indexMap[vn2.id];
                    unodes_1.forEach(function(un2) {
                      if (un2.itemType !== "node")
                        return false;
                      if (!nodeMap[un2.id])
                        return false;
                      var uindex = indexMap[un2.id];
                      displacements[vindex].x += xl_1 * rratio_1;
                      displacements[vindex].y += yl_1 * rratio_1;
                      displacements[uindex].x -= xl_1 * irratio_1;
                      displacements[uindex].y -= yl_1 * irratio_1;
                    });
                  });
                }
              });
            });
          }
          return true;
        });
      };
      ComboForceLayout3.prototype.calRepulsive = function(displacements, vecMap) {
        var self2 = this;
        var nodes = self2.nodes;
        var max7 = self2.width * self2.optimizeRangeFactor;
        var nodeStrength = self2.nodeStrength;
        var alpha = self2.alpha;
        var nodeCollideStrength = self2.nodeCollideStrength;
        var preventNodeOverlap = self2.preventNodeOverlap;
        var nodeSizeFunc = self2.nodeSize;
        var nodeSpacingFunc = self2.nodeSpacing;
        var scale9 = self2.depthRepulsiveForceScale;
        var center = self2.center;
        nodes.forEach(function(v2, i2) {
          if (!v2.x || !v2.y)
            return;
          if (center) {
            var gravity = self2.gravity;
            var vecX = v2.x - center[0] || 5e-3;
            var vecY = v2.y - center[1] || 5e-3;
            var l2 = Math.sqrt(vecX * vecX + vecY * vecY);
            displacements[i2].x -= vecX * gravity * alpha / l2;
            displacements[i2].y -= vecY * gravity * alpha / l2;
          }
          nodes.forEach(function(u2, j2) {
            if (i2 === j2) {
              return;
            }
            if (!u2.x || !u2.y)
              return;
            var _a2 = vecMap["".concat(v2.id, "-").concat(u2.id)], vl2 = _a2.vl2, vl = _a2.vl;
            if (vl > max7)
              return;
            var _b = vecMap["".concat(v2.id, "-").concat(u2.id)], vx = _b.vx, vy = _b.vy;
            var depthDiff = Math.log(Math.abs(u2.depth - v2.depth) / 10) + 1 || 1;
            depthDiff = depthDiff < 1 ? 1 : depthDiff;
            if (u2.comboId !== v2.comboId)
              depthDiff += 1;
            var depthParam = depthDiff ? Math.pow(scale9, depthDiff) : 1;
            var params = nodeStrength(u2) * alpha / vl2 * depthParam;
            displacements[i2].x += vx * params;
            displacements[i2].y += vy * params;
            if (i2 < j2 && preventNodeOverlap) {
              var ri2 = nodeSizeFunc(v2) + nodeSpacingFunc(v2) || 1;
              var rj = nodeSizeFunc(u2) + nodeSpacingFunc(u2) || 1;
              var r2 = ri2 + rj;
              if (vl2 < r2 * r2) {
                var ll = (r2 - vl) / vl * nodeCollideStrength;
                var rj2 = rj * rj;
                var rratio = rj2 / (ri2 * ri2 + rj2);
                var xl = vx * ll;
                var yl = vy * ll;
                displacements[i2].x += xl * rratio;
                displacements[i2].y += yl * rratio;
                rratio = 1 - rratio;
                displacements[j2].x -= xl * rratio;
                displacements[j2].y -= yl * rratio;
              }
            }
          });
        });
      };
      ComboForceLayout3.prototype.calAttractive = function(displacements, vecMap) {
        var self2 = this;
        var edges = self2.edges;
        var linkDistance = self2.linkDistance;
        var alpha = self2.alpha;
        var edgeStrength = self2.edgeStrength;
        var bias = self2.bias;
        var scale9 = self2.depthAttractiveForceScale;
        edges.forEach(function(e8, i2) {
          var source = (0, util_1.getEdgeTerminal)(e8, "source");
          var target = (0, util_1.getEdgeTerminal)(e8, "target");
          if (!source || !target || source === target)
            return;
          var uIndex = self2.indexMap[source];
          var vIndex = self2.indexMap[target];
          var u2 = self2.nodeMap[source];
          var v2 = self2.nodeMap[target];
          if (!u2 || !v2)
            return;
          var depthDiff = u2.depth === v2.depth ? 0 : Math.log(Math.abs(u2.depth - v2.depth) / 10);
          if (u2.comboId === v2.comboId) {
            depthDiff = depthDiff / 2;
          }
          var depthParam = depthDiff ? Math.pow(scale9, depthDiff) : 1;
          if (u2.comboId !== v2.comboId && depthParam === 1) {
            depthParam = scale9 / 2;
          } else if (u2.comboId === v2.comboId) {
            depthParam = 2;
          }
          if (!(0, util_1.isNumber)(v2.x) || !(0, util_1.isNumber)(u2.x) || !(0, util_1.isNumber)(v2.y) || !(0, util_1.isNumber)(u2.y)) {
            return;
          }
          var _a2 = vecMap["".concat(target, "-").concat(source)], vl = _a2.vl, vx = _a2.vx, vy = _a2.vy;
          var l2 = (vl - linkDistance(e8)) / vl * alpha * edgeStrength(e8) * depthParam;
          var vecX = vx * l2;
          var vecY = vy * l2;
          var b10 = bias[i2];
          displacements[vIndex].x -= vecX * b10;
          displacements[vIndex].y -= vecY * b10;
          displacements[uIndex].x += vecX * (1 - b10);
          displacements[uIndex].y += vecY * (1 - b10);
        });
      };
      ComboForceLayout3.prototype.getType = function() {
        return "comboForce";
      };
      return ComboForceLayout3;
    }(base_1.Base);
    exports.ComboForceLayout = ComboForceLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/comboCombined.js
var require_comboCombined = __commonJS({
  "node_modules/@antv/layout/lib/layout/comboCombined.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComboCombinedLayout = void 0;
    var constants_1 = require_constants();
    var base_1 = require_base();
    var util_1 = require_util2();
    var _1 = require_layout3();
    var ComboCombinedLayout2 = function(_super) {
      __extends19(ComboCombinedLayout3, _super);
      function ComboCombinedLayout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.nodes = [];
        _this.edges = [];
        _this.combos = [];
        _this.comboEdges = [];
        _this.comboPadding = 10;
        _this.comboTrees = [];
        _this.updateCfg(options);
        return _this;
      }
      ComboCombinedLayout3.prototype.getDefaultCfg = function() {
        return {};
      };
      ComboCombinedLayout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var center = self2.center;
        if (!nodes || nodes.length === 0) {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        if (nodes.length === 1) {
          nodes[0].x = center[0];
          nodes[0].y = center[1];
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
          return;
        }
        self2.initVals();
        self2.run();
        if (self2.onLayoutEnd)
          self2.onLayoutEnd();
      };
      ComboCombinedLayout3.prototype.run = function() {
        var _a2;
        var self2 = this;
        var nodes = self2.nodes, edges = self2.edges, combos = self2.combos, comboEdges = self2.comboEdges, center = self2.center;
        var innerGraphs = self2.getInnerGraphs();
        var nodeMap = {};
        nodes.forEach(function(node) {
          nodeMap[node.id] = node;
        });
        var comboMap = {};
        combos.forEach(function(combo) {
          comboMap[combo.id] = combo;
        });
        var outerNodeIds = [];
        var outerNodes = [];
        var nodeAncestorIdMap = {};
        var allHaveNoPosition = true;
        this.comboTrees.forEach(function(cTree) {
          var innerNode = innerGraphs[cTree.id];
          var oNode = {
            id: cTree.id,
            x: innerNode.x || comboMap[cTree.id].x,
            y: innerNode.y || comboMap[cTree.id].y,
            fx: innerNode.fx || comboMap[cTree.id].fx,
            fy: innerNode.fy || comboMap[cTree.id].fy,
            mass: innerNode.mass || comboMap[cTree.id].mass,
            size: innerNode.size
          };
          outerNodes.push(oNode);
          if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
            allHaveNoPosition = false;
          } else {
            oNode.x = Math.random() * 100;
            oNode.y = Math.random() * 100;
          }
          outerNodeIds.push(cTree.id);
          (0, util_1.traverseTreeUp)(cTree, function(child) {
            if (child.id !== cTree.id)
              nodeAncestorIdMap[child.id] = cTree.id;
            return true;
          });
        });
        nodes.forEach(function(node) {
          if (node.comboId && comboMap[node.comboId])
            return;
          var oNode = {
            id: node.id,
            x: node.x,
            y: node.y,
            fx: node.fx,
            fy: node.fy,
            mass: node.mass,
            size: node.size
          };
          outerNodes.push(oNode);
          if (!isNaN(oNode.x) && oNode.x !== 0 && !isNaN(oNode.y) && oNode.y !== 0) {
            allHaveNoPosition = false;
          } else {
            oNode.x = Math.random() * 100;
            oNode.y = Math.random() * 100;
          }
          outerNodeIds.push(node.id);
        });
        var outerEdges = [];
        edges.concat(comboEdges).forEach(function(edge) {
          var sourceAncestorId = nodeAncestorIdMap[edge.source] || edge.source;
          var targetAncestorId = nodeAncestorIdMap[edge.target] || edge.target;
          if (sourceAncestorId !== targetAncestorId && outerNodeIds.includes(sourceAncestorId) && outerNodeIds.includes(targetAncestorId)) {
            outerEdges.push({
              source: sourceAncestorId,
              target: targetAncestorId
            });
          }
        });
        if (outerNodes === null || outerNodes === void 0 ? void 0 : outerNodes.length) {
          if (outerNodes.length === 1) {
            outerNodes[0].x = center[0];
            outerNodes[0].y = center[1];
          } else {
            var outerData = {
              nodes: outerNodes,
              edges: outerEdges
            };
            var outerLayout = this.outerLayout || new _1.GForceLayout({
              gravity: 1,
              factor: 2,
              linkDistance: function(edge, source, target) {
                var _a3, _b;
                var nodeSize = ((((_a3 = source.size) === null || _a3 === void 0 ? void 0 : _a3[0]) || 30) + (((_b = target.size) === null || _b === void 0 ? void 0 : _b[0]) || 30)) / 2;
                return Math.min(nodeSize * 1.5, 700);
              }
            });
            var outerLayoutType = (_a2 = outerLayout.getType) === null || _a2 === void 0 ? void 0 : _a2.call(outerLayout);
            outerLayout.updateCfg({
              center,
              kg: 5,
              preventOverlap: true,
              animate: false
            });
            if (allHaveNoPosition && constants_1.FORCE_LAYOUT_TYPE_MAP[outerLayoutType]) {
              var outerLayoutPreset = outerNodes.length < 100 ? new _1.MDSLayout() : new _1.GridLayout();
              outerLayoutPreset.layout(outerData);
            }
            outerLayout.layout(outerData);
          }
          outerNodes.forEach(function(oNode) {
            var innerGraph = innerGraphs[oNode.id];
            if (!innerGraph) {
              var node = nodeMap[oNode.id];
              if (node) {
                node.x = oNode.x;
                node.y = oNode.y;
              }
              return;
            }
            innerGraph.visited = true;
            innerGraph.x = oNode.x;
            innerGraph.y = oNode.y;
            innerGraph.nodes.forEach(function(node2) {
              node2.x += oNode.x;
              node2.y += oNode.y;
            });
          });
        }
        var innerGraphIds = Object.keys(innerGraphs);
        var _loop_1 = function(i3) {
          var id2 = innerGraphIds[i3];
          var innerGraph = innerGraphs[id2];
          if (!innerGraph)
            return "continue";
          innerGraph.nodes.forEach(function(node) {
            if (!innerGraph.visited) {
              node.x += innerGraph.x || 0;
              node.y += innerGraph.y || 0;
            }
            if (nodeMap[node.id]) {
              nodeMap[node.id].x = node.x;
              nodeMap[node.id].y = node.y;
            }
          });
          if (comboMap[id2]) {
            comboMap[id2].x = innerGraph.x;
            comboMap[id2].y = innerGraph.y;
          }
        };
        for (var i2 = innerGraphIds.length - 1; i2 >= 0; i2--) {
          _loop_1(i2);
        }
        return { nodes, edges, combos, comboEdges };
      };
      ComboCombinedLayout3.prototype.getInnerGraphs = function() {
        var self2 = this;
        var comboTrees = self2.comboTrees, nodeSize = self2.nodeSize, edges = self2.edges, comboPadding = self2.comboPadding, spacing = self2.spacing;
        var innerGraphs = {};
        var innerGraphLayout = this.innerLayout || new _1.ConcentricLayout({ sortBy: "id" });
        innerGraphLayout.center = [0, 0];
        innerGraphLayout.preventOverlap = true;
        innerGraphLayout.nodeSpacing = spacing;
        (comboTrees || []).forEach(function(ctree) {
          (0, util_1.traverseTreeUp)(ctree, function(treeNode) {
            var _a2;
            var padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(treeNode)) || 10;
            if ((0, util_1.isArray)(padding))
              padding = Math.max.apply(Math, padding);
            if (!((_a2 = treeNode.children) === null || _a2 === void 0 ? void 0 : _a2.length)) {
              if (treeNode.itemType === "combo") {
                var treeNodeSize = padding ? [padding * 2, padding * 2] : [30, 30];
                innerGraphs[treeNode.id] = {
                  id: treeNode.id,
                  nodes: [],
                  size: treeNodeSize
                };
              }
            } else {
              var innerGraphNodes = treeNode.children.map(function(child) {
                if (child.itemType === "combo")
                  return innerGraphs[child.id];
                return __assign16({}, child);
              });
              var innerGraphNodeIds_1 = innerGraphNodes.map(function(node) {
                return node.id;
              });
              var innerGraphData = {
                nodes: innerGraphNodes,
                edges: edges.filter(function(edge) {
                  return innerGraphNodeIds_1.includes(edge.source) && innerGraphNodeIds_1.includes(edge.target);
                })
              };
              var minNodeSize_1 = Infinity;
              innerGraphNodes.forEach(function(node) {
                var _a3;
                if (!node.size)
                  node.size = ((_a3 = innerGraphs[node.id]) === null || _a3 === void 0 ? void 0 : _a3.size) || (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                if ((0, util_1.isNumber)(node.size))
                  node.size = [node.size, node.size];
                if (minNodeSize_1 > node.size[0])
                  minNodeSize_1 = node.size[0];
                if (minNodeSize_1 > node.size[1])
                  minNodeSize_1 = node.size[1];
              });
              innerGraphLayout.layout(innerGraphData);
              var _b = (0, util_1.findMinMaxNodeXY)(innerGraphNodes), minX = _b.minX, minY = _b.minY, maxX = _b.maxX, maxY = _b.maxY;
              var innerGraphSize = Math.max(maxX - minX, maxY - minY, minNodeSize_1) + padding * 2;
              innerGraphs[treeNode.id] = {
                id: treeNode.id,
                nodes: innerGraphNodes,
                size: [innerGraphSize, innerGraphSize]
              };
            }
            return true;
          });
        });
        return innerGraphs;
      };
      ComboCombinedLayout3.prototype.initVals = function() {
        var self2 = this;
        var nodeSize = self2.nodeSize;
        var spacing = self2.spacing;
        var nodeSizeFunc;
        var spacingFunc;
        if ((0, util_1.isNumber)(spacing)) {
          spacingFunc = function() {
            return spacing;
          };
        } else if ((0, util_1.isFunction)(spacing)) {
          spacingFunc = spacing;
        } else {
          spacingFunc = function() {
            return 0;
          };
        }
        this.spacing = spacingFunc;
        if (!nodeSize) {
          nodeSizeFunc = function(d2) {
            var spacing2 = spacingFunc(d2);
            if (d2.size) {
              if ((0, util_1.isArray)(d2.size)) {
                var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
                return (res + spacing2) / 2;
              }
              if ((0, util_1.isObject)(d2.size)) {
                var res = d2.size.width > d2.size.height ? d2.size.width : d2.size.height;
                return (res + spacing2) / 2;
              }
              return (d2.size + spacing2) / 2;
            }
            return 10 + spacing2 / 2;
          };
        } else if ((0, util_1.isFunction)(nodeSize)) {
          nodeSizeFunc = function(d2) {
            var size2 = nodeSize(d2);
            var spacing2 = spacingFunc(d2);
            if ((0, util_1.isArray)(d2.size)) {
              var res = d2.size[0] > d2.size[1] ? d2.size[0] : d2.size[1];
              return (res + spacing2) / 2;
            }
            return ((size2 || 10) + spacing2) / 2;
          };
        } else if ((0, util_1.isArray)(nodeSize)) {
          var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
          var radius_1 = larger / 2;
          nodeSizeFunc = function(d2) {
            return radius_1 + spacingFunc(d2) / 2;
          };
        } else {
          var radius_2 = nodeSize / 2;
          nodeSizeFunc = function(d2) {
            return radius_2 + spacingFunc(d2) / 2;
          };
        }
        this.nodeSize = nodeSizeFunc;
        var comboPadding = self2.comboPadding;
        var comboPaddingFunc;
        if ((0, util_1.isNumber)(comboPadding)) {
          comboPaddingFunc = function() {
            return comboPadding;
          };
        } else if ((0, util_1.isArray)(comboPadding)) {
          comboPaddingFunc = function() {
            return Math.max.apply(null, comboPadding);
          };
        } else if ((0, util_1.isFunction)(comboPadding)) {
          comboPaddingFunc = comboPadding;
        } else {
          comboPaddingFunc = function() {
            return 0;
          };
        }
        this.comboPadding = comboPaddingFunc;
      };
      ComboCombinedLayout3.prototype.getType = function() {
        return "comboCombined";
      };
      return ComboCombinedLayout3;
    }(base_1.Base);
    exports.ComboCombinedLayout = ComboCombinedLayout2;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/body.js
var require_body = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/body.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Body = function() {
      function Body2(params) {
        this.id = params.id || 0;
        this.rx = params.rx;
        this.ry = params.ry;
        this.fx = 0;
        this.fy = 0;
        this.mass = params.mass;
        this.degree = params.degree;
        this.g = params.g || 0;
      }
      Body2.prototype.distanceTo = function(bo2) {
        var dx = this.rx - bo2.rx;
        var dy = this.ry - bo2.ry;
        return Math.hypot(dx, dy);
      };
      Body2.prototype.setPos = function(x2, y2) {
        this.rx = x2;
        this.ry = y2;
      };
      Body2.prototype.resetForce = function() {
        this.fx = 0;
        this.fy = 0;
      };
      Body2.prototype.addForce = function(b10) {
        var dx = b10.rx - this.rx;
        var dy = b10.ry - this.ry;
        var dist4 = Math.hypot(dx, dy);
        dist4 = dist4 < 1e-4 ? 1e-4 : dist4;
        var F2 = this.g * (this.degree + 1) * (b10.degree + 1) / dist4;
        this.fx += F2 * dx / dist4;
        this.fy += F2 * dy / dist4;
      };
      Body2.prototype.in = function(quad) {
        return quad.contains(this.rx, this.ry);
      };
      Body2.prototype.add = function(bo2) {
        var nenwMass = this.mass + bo2.mass;
        var x2 = (this.rx * this.mass + bo2.rx * bo2.mass) / nenwMass;
        var y2 = (this.ry * this.mass + bo2.ry * bo2.mass) / nenwMass;
        var dg = this.degree + bo2.degree;
        var params = {
          rx: x2,
          ry: y2,
          mass: nenwMass,
          degree: dg
        };
        return new Body2(params);
      };
      return Body2;
    }();
    exports.default = Body;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js
var require_quad = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quad.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Quad = function() {
      function Quad2(params) {
        this.xmid = params.xmid;
        this.ymid = params.ymid;
        this.length = params.length;
        this.massCenter = params.massCenter || [0, 0];
        this.mass = params.mass || 1;
      }
      Quad2.prototype.getLength = function() {
        return this.length;
      };
      Quad2.prototype.contains = function(x2, y2) {
        var halfLen = this.length / 2;
        return x2 <= this.xmid + halfLen && x2 >= this.xmid - halfLen && y2 <= this.ymid + halfLen && y2 >= this.ymid - halfLen;
      };
      Quad2.prototype.NW = function() {
        var x2 = this.xmid - this.length / 4;
        var y2 = this.ymid + this.length / 4;
        var len5 = this.length / 2;
        var params = {
          xmid: x2,
          ymid: y2,
          length: len5
        };
        var NW = new Quad2(params);
        return NW;
      };
      Quad2.prototype.NE = function() {
        var x2 = this.xmid + this.length / 4;
        var y2 = this.ymid + this.length / 4;
        var len5 = this.length / 2;
        var params = {
          xmid: x2,
          ymid: y2,
          length: len5
        };
        var NE = new Quad2(params);
        return NE;
      };
      Quad2.prototype.SW = function() {
        var x2 = this.xmid - this.length / 4;
        var y2 = this.ymid - this.length / 4;
        var len5 = this.length / 2;
        var params = {
          xmid: x2,
          ymid: y2,
          length: len5
        };
        var SW = new Quad2(params);
        return SW;
      };
      Quad2.prototype.SE = function() {
        var x2 = this.xmid + this.length / 4;
        var y2 = this.ymid - this.length / 4;
        var len5 = this.length / 2;
        var params = {
          xmid: x2,
          ymid: y2,
          length: len5
        };
        var SE = new Quad2(params);
        return SE;
      };
      return Quad2;
    }();
    exports.default = Quad;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js
var require_quadTree = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/quadTree.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var QuadTree = function() {
      function QuadTree2(param) {
        this.body = null;
        this.quad = null;
        this.NW = null;
        this.NE = null;
        this.SW = null;
        this.SE = null;
        this.theta = 0.5;
        if (param != null)
          this.quad = param;
      }
      QuadTree2.prototype.insert = function(bo2) {
        if (this.body == null) {
          this.body = bo2;
          return;
        }
        if (!this._isExternal()) {
          this.body = this.body.add(bo2);
          this._putBody(bo2);
        } else {
          if (this.quad) {
            this.NW = new QuadTree2(this.quad.NW());
            this.NE = new QuadTree2(this.quad.NE());
            this.SW = new QuadTree2(this.quad.SW());
            this.SE = new QuadTree2(this.quad.SE());
          }
          this._putBody(this.body);
          this._putBody(bo2);
          this.body = this.body.add(bo2);
        }
      };
      QuadTree2.prototype._putBody = function(bo2) {
        if (!this.quad)
          return;
        if (bo2.in(this.quad.NW()) && this.NW)
          this.NW.insert(bo2);
        else if (bo2.in(this.quad.NE()) && this.NE)
          this.NE.insert(bo2);
        else if (bo2.in(this.quad.SW()) && this.SW)
          this.SW.insert(bo2);
        else if (bo2.in(this.quad.SE()) && this.SE)
          this.SE.insert(bo2);
      };
      QuadTree2.prototype._isExternal = function() {
        return this.NW == null && this.NE == null && this.SW == null && this.SE == null;
      };
      QuadTree2.prototype.updateForce = function(bo2) {
        if (this.body == null || bo2 === this.body) {
          return;
        }
        if (this._isExternal())
          bo2.addForce(this.body);
        else {
          var s2 = this.quad ? this.quad.getLength() : 0;
          var d2 = this.body.distanceTo(bo2);
          if (s2 / d2 < this.theta)
            bo2.addForce(this.body);
          else {
            this.NW && this.NW.updateForce(bo2);
            this.NE && this.NE.updateForce(bo2);
            this.SW && this.SW.updateForce(bo2);
            this.SE && this.SE.updateForce(bo2);
          }
        }
      };
      return QuadTree2;
    }();
    exports.default = QuadTree;
  }
});

// node_modules/@antv/layout/lib/layout/forceAtlas2/index.js
var require_forceAtlas2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/forceAtlas2/index.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ForceAtlas2Layout = void 0;
    var base_1 = require_base();
    var util_1 = require_util2();
    var body_1 = __importDefault(require_body());
    var quad_1 = __importDefault(require_quad());
    var quadTree_1 = __importDefault(require_quadTree());
    var ForceAtlas2Layout2 = function(_super) {
      __extends19(ForceAtlas2Layout3, _super);
      function ForceAtlas2Layout3(options) {
        var _this = _super.call(this) || this;
        _this.center = [0, 0];
        _this.width = 300;
        _this.height = 300;
        _this.nodes = [];
        _this.edges = [];
        _this.kr = 5;
        _this.kg = 1;
        _this.mode = "normal";
        _this.preventOverlap = false;
        _this.dissuadeHubs = false;
        _this.barnesHut = void 0;
        _this.maxIteration = 0;
        _this.ks = 0.1;
        _this.ksmax = 10;
        _this.tao = 0.1;
        _this.onLayoutEnd = function() {
        };
        _this.prune = void 0;
        _this.updateCfg(options);
        return _this;
      }
      ForceAtlas2Layout3.prototype.getDefaultCfg = function() {
        return {};
      };
      ForceAtlas2Layout3.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes, onLayoutEnd = self2.onLayoutEnd, prune = self2.prune;
        var maxIteration = self2.maxIteration;
        if (!self2.width && typeof window !== "undefined") {
          self2.width = window.innerWidth;
        }
        if (!self2.height && typeof window !== "undefined") {
          self2.height = window.innerHeight;
        }
        var sizes = [];
        var nodeNum = nodes.length;
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          var node = nodes[i2];
          var nodeWidth = 10;
          var nodeHeight = 10;
          if ((0, util_1.isNumber)(node.size)) {
            nodeWidth = node.size;
            nodeHeight = node.size;
          }
          if ((0, util_1.isArray)(node.size)) {
            if (!isNaN(node.size[0]))
              nodeWidth = node.size[0];
            if (!isNaN(node.size[1]))
              nodeHeight = node.size[1];
          } else if ((0, util_1.isObject)(node.size)) {
            nodeWidth = node.size.width;
            nodeHeight = node.size.height;
          }
          if (self2.getWidth && !isNaN(self2.getWidth(node)))
            nodeHeight = self2.getWidth(node);
          if (self2.getHeight && !isNaN(self2.getHeight(node)))
            nodeWidth = self2.getHeight(node);
          var maxSize = Math.max(nodeWidth, nodeHeight);
          sizes.push(maxSize);
        }
        if (self2.barnesHut === void 0 && nodeNum > 250)
          self2.barnesHut = true;
        if (self2.prune === void 0 && nodeNum > 100)
          self2.prune = true;
        if (this.maxIteration === 0 && !self2.prune) {
          maxIteration = 250;
          if (nodeNum <= 200 && nodeNum > 100)
            maxIteration = 1e3;
          else if (nodeNum > 200)
            maxIteration = 1200;
          this.maxIteration = maxIteration;
        } else if (this.maxIteration === 0 && prune) {
          maxIteration = 100;
          if (nodeNum <= 200 && nodeNum > 100)
            maxIteration = 500;
          else if (nodeNum > 200)
            maxIteration = 950;
          this.maxIteration = maxIteration;
        }
        if (!self2.kr) {
          self2.kr = 50;
          if (nodeNum > 100 && nodeNum <= 500)
            self2.kr = 20;
          else if (nodeNum > 500)
            self2.kr = 1;
        }
        if (!self2.kg) {
          self2.kg = 20;
          if (nodeNum > 100 && nodeNum <= 500)
            self2.kg = 10;
          else if (nodeNum > 500)
            self2.kg = 1;
        }
        this.nodes = self2.updateNodesByForces(sizes);
        onLayoutEnd();
      };
      ForceAtlas2Layout3.prototype.updateNodesByForces = function(sizes) {
        var self2 = this;
        var edges = self2.edges, maxIteration = self2.maxIteration;
        var nodes = self2.nodes;
        var nonLoopEdges = edges.filter(function(edge) {
          var source2 = (0, util_1.getEdgeTerminal)(edge, "source");
          var target2 = (0, util_1.getEdgeTerminal)(edge, "target");
          return source2 !== target2;
        });
        var size2 = nodes.length;
        var esize = nonLoopEdges.length;
        var degrees2 = [];
        var idMap = {};
        var edgeEndsIdMap = {};
        var Es = [];
        for (var i2 = 0; i2 < size2; i2 += 1) {
          idMap[nodes[i2].id] = i2;
          degrees2[i2] = 0;
          if (nodes[i2].x === void 0 || isNaN(nodes[i2].x)) {
            nodes[i2].x = Math.random() * 1e3;
          }
          if (nodes[i2].y === void 0 || isNaN(nodes[i2].y)) {
            nodes[i2].y = Math.random() * 1e3;
          }
          Es.push({ x: nodes[i2].x, y: nodes[i2].y });
        }
        for (var i2 = 0; i2 < esize; i2 += 1) {
          var node1 = void 0;
          var node2 = void 0;
          var sIdx = 0;
          var tIdx = 0;
          for (var j2 = 0; j2 < size2; j2 += 1) {
            var source = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "source");
            var target = (0, util_1.getEdgeTerminal)(nonLoopEdges[i2], "target");
            if (nodes[j2].id === source) {
              node1 = nodes[j2];
              sIdx = j2;
            } else if (nodes[j2].id === target) {
              node2 = nodes[j2];
              tIdx = j2;
            }
            edgeEndsIdMap[i2] = { sourceIdx: sIdx, targetIdx: tIdx };
          }
          if (node1)
            degrees2[idMap[node1.id]] += 1;
          if (node2)
            degrees2[idMap[node2.id]] += 1;
        }
        var iteration = maxIteration;
        nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees2, sizes);
        if (self2.prune) {
          for (var j2 = 0; j2 < esize; j2 += 1) {
            if (degrees2[edgeEndsIdMap[j2].sourceIdx] <= 1) {
              nodes[edgeEndsIdMap[j2].sourceIdx].x = nodes[edgeEndsIdMap[j2].targetIdx].x;
              nodes[edgeEndsIdMap[j2].sourceIdx].y = nodes[edgeEndsIdMap[j2].targetIdx].y;
            } else if (degrees2[edgeEndsIdMap[j2].targetIdx] <= 1) {
              nodes[edgeEndsIdMap[j2].targetIdx].x = nodes[edgeEndsIdMap[j2].sourceIdx].x;
              nodes[edgeEndsIdMap[j2].targetIdx].y = nodes[edgeEndsIdMap[j2].sourceIdx].y;
            }
          }
          self2.prune = false;
          self2.barnesHut = false;
          iteration = 100;
          nodes = this.iterate(iteration, idMap, edgeEndsIdMap, esize, degrees2, sizes);
        }
        return nodes;
      };
      ForceAtlas2Layout3.prototype.iterate = function(iteration, idMap, edgeEndsIdMap, esize, degrees2, sizes) {
        var self2 = this;
        var nodes = self2.nodes;
        var kr2 = self2.kr, preventOverlap = self2.preventOverlap;
        var barnesHut = self2.barnesHut;
        var nodeNum = nodes.length;
        var sg = 0;
        var krPrime = 100;
        var iter = iteration;
        var prevoIter = 50;
        var forces = [];
        var preForces = [];
        var bodies = [];
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          forces[2 * i2] = 0;
          forces[2 * i2 + 1] = 0;
          if (barnesHut) {
            var params = {
              id: i2,
              rx: nodes[i2].x,
              ry: nodes[i2].y,
              mass: 1,
              g: kr2,
              degree: degrees2[i2]
            };
            bodies[i2] = new body_1.default(params);
          }
        }
        while (iter > 0) {
          for (var i2 = 0; i2 < nodeNum; i2 += 1) {
            preForces[2 * i2] = forces[2 * i2];
            preForces[2 * i2 + 1] = forces[2 * i2 + 1];
            forces[2 * i2] = 0;
            forces[2 * i2 + 1] = 0;
          }
          forces = this.getAttrForces(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees2, sizes, forces);
          if (barnesHut && (preventOverlap && iter > prevoIter || !preventOverlap)) {
            forces = this.getOptRepGraForces(forces, bodies, degrees2);
          } else {
            forces = this.getRepGraForces(iter, prevoIter, forces, krPrime, sizes, degrees2);
          }
          var res = this.updatePos(forces, preForces, sg, degrees2);
          nodes = res.nodes;
          sg = res.sg;
          iter--;
          if (self2.tick)
            self2.tick();
        }
        return nodes;
      };
      ForceAtlas2Layout3.prototype.getAttrForces = function(iter, prevoIter, esize, idMap, edgeEndsIdMap, degrees2, sizes, forces) {
        var self2 = this;
        var nodes = self2.nodes, preventOverlap = self2.preventOverlap, dissuadeHubs = self2.dissuadeHubs, mode = self2.mode, prune = self2.prune;
        for (var i2 = 0; i2 < esize; i2 += 1) {
          var sourceNode = nodes[edgeEndsIdMap[i2].sourceIdx];
          var sourceIdx = edgeEndsIdMap[i2].sourceIdx;
          var targetNode = nodes[edgeEndsIdMap[i2].targetIdx];
          var targetIdx = edgeEndsIdMap[i2].targetIdx;
          if (prune && (degrees2[sourceIdx] <= 1 || degrees2[targetIdx] <= 1))
            continue;
          var dir = [targetNode.x - sourceNode.x, targetNode.y - sourceNode.y];
          var eucliDis = Math.hypot(dir[0], dir[1]);
          eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
          dir[0] = dir[0] / eucliDis;
          dir[1] = dir[1] / eucliDis;
          if (preventOverlap && iter < prevoIter)
            eucliDis = eucliDis - sizes[sourceIdx] - sizes[targetIdx];
          var Fa1 = eucliDis;
          var Fa2 = Fa1;
          if (mode === "linlog") {
            Fa1 = Math.log(1 + eucliDis);
            Fa2 = Fa1;
          }
          if (dissuadeHubs) {
            Fa1 = eucliDis / degrees2[sourceIdx];
            Fa2 = eucliDis / degrees2[targetIdx];
          }
          if (preventOverlap && iter < prevoIter && eucliDis <= 0) {
            Fa1 = 0;
            Fa2 = 0;
          } else if (preventOverlap && iter < prevoIter && eucliDis > 0) {
            Fa1 = eucliDis;
            Fa2 = eucliDis;
          }
          forces[2 * idMap[sourceNode.id]] += Fa1 * dir[0];
          forces[2 * idMap[targetNode.id]] -= Fa2 * dir[0];
          forces[2 * idMap[sourceNode.id] + 1] += Fa1 * dir[1];
          forces[2 * idMap[targetNode.id] + 1] -= Fa2 * dir[1];
        }
        return forces;
      };
      ForceAtlas2Layout3.prototype.getRepGraForces = function(iter, prevoIter, forces, krPrime, sizes, degrees2) {
        var self2 = this;
        var nodes = self2.nodes, preventOverlap = self2.preventOverlap, kr2 = self2.kr, kg = self2.kg, center = self2.center, prune = self2.prune;
        var nodeNum = nodes.length;
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          for (var j2 = i2 + 1; j2 < nodeNum; j2 += 1) {
            if (prune && (degrees2[i2] <= 1 || degrees2[j2] <= 1))
              continue;
            var dir_1 = [nodes[j2].x - nodes[i2].x, nodes[j2].y - nodes[i2].y];
            var eucliDis_1 = Math.hypot(dir_1[0], dir_1[1]);
            eucliDis_1 = eucliDis_1 < 1e-4 ? 1e-4 : eucliDis_1;
            dir_1[0] = dir_1[0] / eucliDis_1;
            dir_1[1] = dir_1[1] / eucliDis_1;
            if (preventOverlap && iter < prevoIter)
              eucliDis_1 = eucliDis_1 - sizes[i2] - sizes[j2];
            var Fr2 = kr2 * (degrees2[i2] + 1) * (degrees2[j2] + 1) / eucliDis_1;
            if (preventOverlap && iter < prevoIter && eucliDis_1 < 0) {
              Fr2 = krPrime * (degrees2[i2] + 1) * (degrees2[j2] + 1);
            } else if (preventOverlap && iter < prevoIter && eucliDis_1 === 0) {
              Fr2 = 0;
            } else if (preventOverlap && iter < prevoIter && eucliDis_1 > 0) {
              Fr2 = kr2 * (degrees2[i2] + 1) * (degrees2[j2] + 1) / eucliDis_1;
            }
            forces[2 * i2] -= Fr2 * dir_1[0];
            forces[2 * j2] += Fr2 * dir_1[0];
            forces[2 * i2 + 1] -= Fr2 * dir_1[1];
            forces[2 * j2 + 1] += Fr2 * dir_1[1];
          }
          var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
          var eucliDis = Math.hypot(dir[0], dir[1]);
          dir[0] = dir[0] / eucliDis;
          dir[1] = dir[1] / eucliDis;
          var Fg = kg * (degrees2[i2] + 1);
          forces[2 * i2] -= Fg * dir[0];
          forces[2 * i2 + 1] -= Fg * dir[1];
        }
        return forces;
      };
      ForceAtlas2Layout3.prototype.getOptRepGraForces = function(forces, bodies, degrees2) {
        var self2 = this;
        var nodes = self2.nodes, kg = self2.kg, center = self2.center, prune = self2.prune;
        var nodeNum = nodes.length;
        var minx = 9e10;
        var maxx = -9e10;
        var miny = 9e10;
        var maxy = -9e10;
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          if (prune && degrees2[i2] <= 1)
            continue;
          bodies[i2].setPos(nodes[i2].x, nodes[i2].y);
          if (nodes[i2].x >= maxx)
            maxx = nodes[i2].x;
          if (nodes[i2].x <= minx)
            minx = nodes[i2].x;
          if (nodes[i2].y >= maxy)
            maxy = nodes[i2].y;
          if (nodes[i2].y <= miny)
            miny = nodes[i2].y;
        }
        var width = Math.max(maxx - minx, maxy - miny);
        var quadParams = {
          xmid: (maxx + minx) / 2,
          ymid: (maxy + miny) / 2,
          length: width,
          massCenter: center,
          mass: nodeNum
        };
        var quad = new quad_1.default(quadParams);
        var quadTree = new quadTree_1.default(quad);
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          if (prune && degrees2[i2] <= 1)
            continue;
          if (bodies[i2].in(quad))
            quadTree.insert(bodies[i2]);
        }
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          if (prune && degrees2[i2] <= 1)
            continue;
          bodies[i2].resetForce();
          quadTree.updateForce(bodies[i2]);
          forces[2 * i2] -= bodies[i2].fx;
          forces[2 * i2 + 1] -= bodies[i2].fy;
          var dir = [nodes[i2].x - center[0], nodes[i2].y - center[1]];
          var eucliDis = Math.hypot(dir[0], dir[1]);
          eucliDis = eucliDis < 1e-4 ? 1e-4 : eucliDis;
          dir[0] = dir[0] / eucliDis;
          dir[1] = dir[1] / eucliDis;
          var Fg = kg * (degrees2[i2] + 1);
          forces[2 * i2] -= Fg * dir[0];
          forces[2 * i2 + 1] -= Fg * dir[1];
        }
        return forces;
      };
      ForceAtlas2Layout3.prototype.updatePos = function(forces, preForces, sg, degrees2) {
        var self2 = this;
        var nodes = self2.nodes, ks = self2.ks, tao = self2.tao, prune = self2.prune, ksmax = self2.ksmax;
        var nodeNum = nodes.length;
        var swgns = [];
        var trans = [];
        var swgG = 0;
        var traG = 0;
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          if (prune && degrees2[i2] <= 1)
            continue;
          var minus = [
            forces[2 * i2] - preForces[2 * i2],
            forces[2 * i2 + 1] - preForces[2 * i2 + 1]
          ];
          var minusNorm = Math.hypot(minus[0], minus[1]);
          var add7 = [
            forces[2 * i2] + preForces[2 * i2],
            forces[2 * i2 + 1] + preForces[2 * i2 + 1]
          ];
          var addNorm = Math.hypot(add7[0], add7[1]);
          swgns[i2] = minusNorm;
          trans[i2] = addNorm / 2;
          swgG += (degrees2[i2] + 1) * swgns[i2];
          traG += (degrees2[i2] + 1) * trans[i2];
        }
        var preSG = sg;
        sg = tao * traG / swgG;
        if (preSG !== 0) {
          sg = sg > 1.5 * preSG ? 1.5 * preSG : sg;
        }
        for (var i2 = 0; i2 < nodeNum; i2 += 1) {
          if (prune && degrees2[i2] <= 1)
            continue;
          var sn2 = ks * sg / (1 + sg * Math.sqrt(swgns[i2]));
          var absForce = Math.hypot(forces[2 * i2], forces[2 * i2 + 1]);
          absForce = absForce < 1e-4 ? 1e-4 : absForce;
          var max7 = ksmax / absForce;
          sn2 = sn2 > max7 ? max7 : sn2;
          var dnx = sn2 * forces[2 * i2];
          var dny = sn2 * forces[2 * i2 + 1];
          nodes[i2].x += dnx;
          nodes[i2].y += dny;
        }
        return { nodes, sg };
      };
      return ForceAtlas2Layout3;
    }(base_1.Base);
    exports.ForceAtlas2Layout = ForceAtlas2Layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/grid.js
var require_grid2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/grid.js"(exports) {
    "use strict";
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var Grid4 = function() {
      function Grid5() {
        this.cells = [];
        this.columnNum = 0;
        this.rowNum = 0;
        this.additionColumn = [];
        this.additionRow = [];
      }
      Grid5.prototype.init = function(width, height, gridSize) {
        this.cells = [];
        this.CELL_W = gridSize.CELL_W || Grid5.DEFAULT_CELL_W;
        this.CELL_H = gridSize.CELL_H || Grid5.DEFAULT_CELL_H;
        this.columnNum = Math.ceil(width / this.CELL_W);
        this.rowNum = Math.ceil(height / this.CELL_H);
        Grid5.MIN_DIST = Math.pow(width, 2) + Math.pow(height, 2);
        for (var i2 = 0; i2 < this.columnNum; i2++) {
          var tmp = [];
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            var cell = {
              dx: i2,
              dy: j2,
              x: i2 * this.CELL_W,
              y: j2 * this.CELL_H,
              occupied: false
            };
            tmp.push(cell);
          }
          this.cells.push(tmp);
        }
      };
      Grid5.prototype.findGridByNodeId = function(nodeId) {
        var _a2, _b;
        for (var i2 = 0; i2 < this.columnNum; i2++) {
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            if (this.cells[i2][j2].node) {
              if (((_b = (_a2 = this.cells[i2][j2]) === null || _a2 === void 0 ? void 0 : _a2.node) === null || _b === void 0 ? void 0 : _b.id) === nodeId) {
                return { column: i2, row: j2 };
              }
            }
          }
        }
        return null;
      };
      Grid5.prototype.sqdist = function(a2, b10) {
        return Math.pow(a2.x - b10.x, 2) + Math.pow(a2.y - b10.y, 2);
      };
      Grid5.prototype.occupyNearest = function(p2) {
        var minDist = Grid5.MIN_DIST;
        var d2;
        var candidate = null;
        for (var i2 = 0; i2 < this.columnNum; i2++) {
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            if (!this.cells[i2][j2].occupied && (d2 = this.sqdist(p2, this.cells[i2][j2])) < minDist) {
              minDist = d2;
              candidate = this.cells[i2][j2];
            }
          }
        }
        if (candidate) {
          candidate.occupied = true;
        }
        return candidate;
      };
      Grid5.prototype.insertColumn = function(columnIndex, length5) {
        if (length5 <= 0)
          return;
        for (var i2 = 0; i2 < length5; i2++) {
          this.cells[i2 + this.columnNum] = [];
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            this.cells[i2 + this.columnNum][j2] = {
              dx: i2,
              dy: j2,
              x: i2 * this.CELL_W,
              y: j2 * this.CELL_H,
              occupied: false,
              node: null
            };
          }
        }
        for (var i2 = this.columnNum - 1; i2 > columnIndex; i2--) {
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            this.cells[i2 + length5][j2] = __assign16(__assign16({}, this.cells[i2][j2]), { x: (i2 + length5) * this.CELL_W, y: j2 * this.CELL_H });
            this.cells[i2][j2] = {
              x: i2 * this.CELL_W,
              y: j2 * this.CELL_H,
              occupied: true,
              node: null
            };
          }
        }
        for (var j2 = 0; j2 < this.additionColumn.length; j2++) {
          if (this.additionColumn[j2] >= columnIndex) {
            this.additionColumn[j2] += length5;
          }
        }
        for (var i2 = 0; i2 < length5; i2++) {
          this.additionColumn.push(columnIndex + i2 + 1);
        }
        this.columnNum += length5;
      };
      Grid5.prototype.insertRow = function(rowIndex, length5) {
        if (length5 <= 0)
          return;
        for (var j2 = 0; j2 < length5; j2++) {
          for (var i2 = 0; i2 < this.columnNum; i2++) {
            this.cells[i2][j2 + this.rowNum] = {
              dx: i2,
              dy: j2,
              x: i2 * this.CELL_W,
              y: j2 * this.CELL_H,
              occupied: false,
              node: null
            };
          }
        }
        for (var i2 = 0; i2 < this.columnNum; i2++) {
          for (var j2 = this.rowNum - 1; j2 > rowIndex; j2--) {
            this.cells[i2][j2 + length5] = __assign16(__assign16({}, this.cells[i2][j2]), { dx: i2, dy: j2 + length5, x: i2 * this.CELL_W, y: (j2 + length5) * this.CELL_H });
            this.cells[i2][j2] = {
              dx: i2,
              dy: j2,
              x: i2 * this.CELL_W,
              y: j2 * this.CELL_H,
              occupied: false,
              node: null
            };
          }
        }
        for (var j2 = 0; j2 < this.additionRow.length; j2++) {
          if (this.additionRow[j2] >= rowIndex) {
            this.additionRow[j2] += length5;
          }
        }
        for (var i2 = 0; i2 < length5; i2++) {
          this.additionRow.push(rowIndex + i2 + 1);
        }
        this.rowNum += length5;
      };
      Grid5.prototype.getNodes = function() {
        var nodes = [];
        for (var i2 = 0; i2 < this.columnNum; i2++) {
          for (var j2 = 0; j2 < this.rowNum; j2++) {
            if (this.cells[i2][j2].node) {
              nodes.push(this.cells[i2][j2]);
            }
          }
        }
        return nodes;
      };
      Grid5.MIN_DIST = 50;
      Grid5.DEFAULT_CELL_W = 80;
      Grid5.DEFAULT_CELL_H = 80;
      return Grid5;
    }();
    exports.default = Grid4;
  }
});

// node_modules/@antv/layout/lib/layout/er/forceGrid.js
var require_forceGrid = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/forceGrid.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var grid_1 = __importDefault(require_grid2());
    function layout2(data, options) {
      if (!data.nodes || data.nodes.length === 0)
        return data;
      var width = options.width;
      var height = options.height;
      var nodeMinGap = options.nodeMinGap;
      var CELL_W = 1e4;
      var CELL_H = 1e4;
      data.nodes.forEach(function(node2) {
        var nodeWidth = node2.size[0] || 50;
        var nodeHeight = node2.size[1] || 50;
        CELL_W = Math.min(nodeWidth, CELL_W);
        CELL_H = Math.min(nodeHeight, CELL_H);
      });
      var grid = new grid_1.default();
      grid.init(width, height, {
        CELL_H,
        CELL_W
      });
      data.nodes.forEach(function(d2) {
        var gridpoint = grid.occupyNearest(d2);
        if (gridpoint) {
          gridpoint.node = {
            id: d2.id,
            size: d2.size
          };
          d2.x = gridpoint.x;
          d2.y = gridpoint.y;
          d2.dx = gridpoint.dx;
          d2.dy = gridpoint.dy;
        }
      });
      for (var i2 = 0; i2 < data.nodes.length; i2++) {
        var node = data.nodes[i2];
        var result = grid.findGridByNodeId(node.id);
        if (!result)
          throw new Error("can not find node cell");
        var column = result.column, row = result.row;
        if (node.size[0] + nodeMinGap > CELL_W) {
          var addGridSize = Math.ceil((node.size[0] + nodeMinGap) / CELL_W) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionColumn.indexOf(column + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column + j2 + 1][row].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertColumn(column, realAdd);
        }
        if (node.size[1] + nodeMinGap > CELL_H) {
          var addGridSize = Math.ceil((node.size[1] + nodeMinGap) / CELL_H) - 1;
          var realAdd = addGridSize;
          for (var j2 = 0; j2 < addGridSize; j2++) {
            var hasColumn = grid.additionRow.indexOf(row + j2 + 1) > -1;
            if (hasColumn && !grid.cells[column][row + j2 + 1].node) {
              realAdd--;
            } else {
              break;
            }
          }
          grid.insertRow(row, realAdd);
        }
      }
      for (var i2 = 0; i2 < grid.columnNum; i2++) {
        var _loop_1 = function(j3) {
          var cell = grid.cells[i2][j3];
          if (cell.node) {
            var node2 = data.nodes.find(function(node3) {
              var _a2;
              return node3.id === ((_a2 = cell === null || cell === void 0 ? void 0 : cell.node) === null || _a2 === void 0 ? void 0 : _a2.id);
            });
            if (node2) {
              node2.x = cell.x + node2.size[0] / 2;
              node2.y = cell.y + node2.size[1] / 2;
            }
          }
        };
        for (var j2 = 0; j2 < grid.rowNum; j2++) {
          _loop_1(j2);
        }
      }
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js
var require_mysqlWorkbench = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/mysqlWorkbench.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var graphWidth = 1200;
    var graphHeight = 800;
    var OVERLAP_QUOT = 1e7;
    var MIN_DIST = 10;
    var M_PI = 3.141592653589793;
    var M_PI_2 = 1.5707963267948966;
    var PI_38 = M_PI * 0.375;
    var PI_58 = M_PI * 0.625;
    var nodeEdgeMap = /* @__PURE__ */ new Map();
    var CELL_W = 10;
    var CELL_H = 10;
    var T2 = 0.8;
    var T_MIN = 0.1;
    var R2 = 0.5;
    function distanceToNode(node1, node2, isHoriz) {
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var dcx = cx2 - cx1;
      var qr2 = Math.atan2(dcx, cy2 - cy1);
      var dx = 0;
      var dy = 0;
      var l1 = 0;
      var l2 = 0;
      if (qr2 > M_PI_2) {
        dy = y11 - y22;
        dx = x21 - x12;
        l1 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
      } else if (0 < qr2 && qr2 <= M_PI_2) {
        dy = y21 - y12;
        dx = x21 - x12;
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else if (qr2 < -M_PI_2) {
        dy = y11 - y22;
        dx = -(x22 - x11);
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      } else {
        dy = y21 - y12;
        if (Math.abs(dcx) > (x12 - x11) / 2) {
          dx = x11 - x22;
        } else {
          dx = dcx;
        }
        if (dy > dx) {
          l1 = l2 = parseFloat(dy ? (dy / Math.cos(qr2)).toFixed(2) : dx.toFixed(2));
        } else {
          l1 = l2 = parseFloat(dx && qr2 !== 0 ? (dx / Math.sin(qr2)).toFixed(2) : dy.toFixed(2));
        }
      }
      var aqr = parseFloat(qr2.toFixed(2));
      var newHoriz = isHoriz;
      if (isHoriz) {
        newHoriz = PI_38 < aqr && aqr < PI_58;
      }
      return {
        distance: Math.abs(l1 < l2 ? l1 : l2),
        isHoriz: newHoriz
      };
    }
    function calcNodePair(nodeA, nodeB) {
      var edges = nodeEdgeMap.get(nodeA.id) || [];
      var isLinked = edges.find(function(edge) {
        return edge.source === nodeB.id || edge.target === nodeB.id;
      });
      var areaA = nodeA.size[0] * nodeA.size[1];
      var areaB = nodeB.size[0] * nodeB.size[1];
      var node1 = areaA > areaB ? nodeB : nodeA;
      var node2 = areaA > areaB ? nodeA : nodeB;
      var x11 = node1.x - node1.size[0] / 2;
      var y11 = node1.y - node1.size[1] / 2;
      var x12 = node1.x + node1.size[0] / 2;
      var y12 = node1.y + node1.size[1] / 2;
      var x21 = node2.x - node2.size[0] / 2;
      var y21 = node2.y - node2.size[1] / 2;
      var x22 = node2.x + node2.size[0] / 2;
      var y22 = node2.y + node2.size[1] / 2;
      var cx1 = node1.x;
      var cy1 = node1.y;
      var cx2 = node2.x;
      var cy2 = node2.y;
      var isoverlap = x12 >= x21 && x22 >= x11 && y12 >= y21 && y22 >= y11;
      var e8 = 0;
      var distance11 = 0;
      if (isoverlap) {
        distance11 = Math.sqrt(Math.pow(cx2 - cx1, 2) + Math.pow(cy2 - cy1, 2));
        var sx1 = x11 > x21 ? x11 : x21;
        var sy1 = y11 > y21 ? y11 : y21;
        var sx2 = x12 < x22 ? x12 : x22;
        var sy2 = y12 < y22 ? y12 : y22;
        var dsx = sx2 - sx1;
        var dsy = sy2 - sy1;
        var sov = dsx * dsy;
        if (distance11 === 0) {
          distance11 = 1e-7;
        }
        e8 = MIN_DIST * 1 / distance11 * 100 + sov;
        e8 *= OVERLAP_QUOT;
      } else {
        var isHoriz = false;
        var res = distanceToNode(node1, node2, isHoriz);
        distance11 = res.distance;
        isHoriz = res.isHoriz;
        if (distance11 <= MIN_DIST) {
          if (distance11 !== 0) {
            if (isLinked) {
              e8 += MIN_DIST + OVERLAP_QUOT * 1 / distance11;
            } else {
              e8 += MIN_DIST + OVERLAP_QUOT * MIN_DIST / distance11;
            }
          } else {
            e8 += OVERLAP_QUOT;
          }
        } else {
          e8 += distance11;
          if (isLinked) {
            e8 += distance11 * distance11;
          }
        }
      }
      return e8;
    }
    function calcEnergy(nodes) {
      var energy = 0;
      for (var i2 = 0; i2 < nodes.length; i2++) {
        var node = nodes[i2];
        if (node.x < 0 || node.y < 0 || node.x > graphWidth || node.y > graphHeight) {
          energy += 1e12;
        }
        for (var j2 = i2 + 1; j2 < nodes.length; j2++) {
          energy += calcNodePair(node, nodes[j2]);
        }
      }
      return energy;
    }
    function isCorrectPosition(node, newPosition, nodes, edges) {
      var nodeIdxMap = /* @__PURE__ */ new Map();
      nodes.forEach(function(o2, i3) {
        nodeIdxMap.set(o2.id, o2);
      });
      var relateEdges = edges.filter(function(edge) {
        return edge.source === node.id || edge.target === node.id;
      }) || [];
      var relateNodes = [];
      relateEdges.forEach(function(edge) {
        var otherNodeId = edge.source === node.id ? edge.target : edge.source;
        var otherNode = nodeIdxMap.get(otherNodeId);
        if (otherNode) {
          relateNodes.push(otherNode);
        }
      });
      var flag = true;
      for (var i2 = 0; i2 < relateNodes.length; i2++) {
        var item = relateNodes[i2];
        var delta = Math.atan((node.y - item.y) / (item.x - node.y)) * 180;
        var newDelta = Math.atan((newPosition.y - item.y) / (item.x - newPosition.y)) * 180;
        var isHor = delta < 30 || delta > 150;
        var newIsHor = newDelta < 30 || newDelta > 150;
        var isVer = delta > 70 && delta < 110;
        var newIsVer = newDelta > 70 && newDelta < 110;
        if (isHor && !newIsHor || delta * newDelta < 0) {
          flag = false;
          break;
        } else if (isVer && !newIsVer || delta * newDelta < 0) {
          flag = false;
          break;
        } else if ((item.x - node.x) * (item.x - newPosition.x) < 0) {
          flag = false;
          break;
        } else if ((item.y - node.y) * (item.y - newPosition.y) < 0) {
          flag = false;
          break;
        }
      }
      return flag;
    }
    function shuffle(nodes, edges) {
      var foundSmallerEnergy = false;
      var step = 1;
      var wstep = CELL_W * step;
      var hstep = CELL_H * step;
      var wsteps = [wstep, -wstep, 0, 0];
      var hsteps = [0, 0, hstep, -hstep];
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var node = nodes[i2];
        var nodeEnergy = calcNodeEnergy(node, nodes);
        for (var ns = 0; ns < wsteps.length; ns++) {
          var flag = isCorrectPosition(node, { x: node.x + wsteps[ns], y: node.y + hsteps[ns] }, nodes, edges);
          if (flag) {
            node.x += wsteps[ns];
            node.y += hsteps[ns];
            var energy = calcNodeEnergy(node, nodes);
            var rdm = Math.random();
            if (energy < nodeEnergy) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else if (rdm < T2 && rdm > T_MIN) {
              nodeEnergy = energy;
              foundSmallerEnergy = true;
            } else {
              node.x -= wsteps[ns];
              node.y -= hsteps[ns];
            }
          }
        }
      }
      if (T2 > T_MIN) {
        T2 *= R2;
      }
      if (foundSmallerEnergy) {
        return calcEnergy(nodes);
      }
      return 0;
    }
    function calcNodeEnergy(node, nodes) {
      var e8 = 0;
      if (node.x < 0 || node.y < 0 || node.x + node.size[0] + 20 > graphWidth || node.y + node.size[1] + 20 > graphHeight) {
        e8 += 1e12;
      }
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        if (node.id !== nodes[i2].id) {
          e8 += calcNodePair(node, nodes[i2]);
        }
      }
      return e8;
    }
    function layout2(nodes, edges) {
      if (nodes.length === 0) {
        return { nodes, edges };
      }
      nodes.forEach(function(node) {
        var relateEdge = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        nodeEdgeMap.set(node, relateEdge);
      });
      nodes.sort(function(node1, node2) {
        var _a2, _b;
        return ((_a2 = nodeEdgeMap.get(node1.id)) === null || _a2 === void 0 ? void 0 : _a2.length) - ((_b = nodeEdgeMap.get(node2.id)) === null || _b === void 0 ? void 0 : _b.length);
      });
      var minEnergy = calcEnergy(nodes);
      var deSameCount = 20;
      var de2 = 1;
      var prevEnergy = 0;
      var MAX_COUNT = 50;
      var count = 0;
      while (deSameCount > 0) {
        count++;
        if (count >= MAX_COUNT) {
          break;
        }
        var ea2 = shuffle(nodes, edges);
        if (ea2 !== 0) {
          prevEnergy = ea2;
        }
        de2 = prevEnergy - minEnergy;
        minEnergy = prevEnergy;
        if (de2 === 0) {
          --deSameCount;
        } else {
          deSameCount = 20;
        }
      }
      nodes.forEach(function(node) {
        node.x = node.x - node.size[0] / 2;
        node.y = node.y - node.size[1] / 2;
      });
      return {
        nodes,
        edges
      };
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/core.js
var require_core = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/core.js"(exports) {
    "use strict";
    var __assign16 = exports && exports.__assign || function() {
      __assign16 = Object.assign || function(t4) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t4[p2] = s2[p2];
        }
        return t4;
      };
      return __assign16.apply(this, arguments);
    };
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k2 in mod3)
          if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod3, k2))
            __createBinding(result, mod3, k2);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3Force = __importStar((init_src(), __toCommonJS(src_exports)));
    var forceGrid_1 = __importDefault(require_forceGrid());
    var mysqlWorkbench_1 = __importDefault(require_mysqlWorkbench());
    var dagre_1 = require_dagre2();
    function layout2(data, options) {
      var nodes = data.nodes, edges = data.edges;
      var width = options.width;
      var height = options.height;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return Promise.resolve();
      var noLeafNodes = [];
      nodes.forEach(function(node) {
        var relateEdges = edges.filter(function(edge) {
          return edge.source === node.id || edge.target === node.id;
        });
        if (relateEdges.length > 1) {
          var temp = __assign16({}, node);
          delete temp.size;
          noLeafNodes.push(temp);
        }
      });
      var noLeafEdge = [];
      edges.forEach(function(edge) {
        var sourceNode = noLeafNodes.find(function(node) {
          return node.id === edge.source;
        });
        var targetNode = noLeafNodes.find(function(node) {
          return node.id === edge.target;
        });
        if (sourceNode && targetNode) {
          noLeafEdge.push(edge);
        }
      });
      var graphLayout = new dagre_1.DagreLayout({
        type: "dagre",
        ranksep: options.nodeMinGap,
        nodesep: options.nodeMinGap
      });
      var nodesTmp = graphLayout.layout({
        nodes: noLeafNodes,
        edges: noLeafEdge
      }).nodes;
      nodes.forEach(function(n2) {
        var found = (nodesTmp || []).find(function(temp) {
          return temp.id === n2.id;
        });
        n2.x = (found === null || found === void 0 ? void 0 : found.x) || width / 2;
        n2.y = (found === null || found === void 0 ? void 0 : found.y) || height / 2;
      });
      var copyNodes = JSON.parse(JSON.stringify(nodes));
      var copyEdges = JSON.parse(JSON.stringify(edges));
      var simulation = d3Force.forceSimulation().nodes(copyNodes).force("link", d3Force.forceLink(copyEdges).id(function(d2) {
        return d2.id;
      }).distance(function(d2) {
        var edgeInfo = noLeafEdge.find(function(edge) {
          return edge.source === d2.source && edge.target === d2.target;
        });
        if (edgeInfo) {
          return 30;
        }
        return 20;
      })).force("charge", d3Force.forceManyBody()).force("center", d3Force.forceCenter(width / 2, height / 2)).force("x", d3Force.forceX(width / 2)).force("y", d3Force.forceY(height / 2)).alpha(0.3).alphaDecay(0.08).alphaMin(1e-3);
      var layoutPromise = new Promise(function(resolve2) {
        simulation.on("end", function() {
          nodes.forEach(function(node) {
            var nodeInfo = copyNodes.find(function(item) {
              return item.id === node.id;
            });
            if (nodeInfo) {
              node.x = nodeInfo.x;
              node.y = nodeInfo.y;
            }
          });
          var minX = Math.min.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var maxX = Math.max.apply(Math, nodes.map(function(node) {
            return node.x;
          }));
          var minY = Math.min.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var maxY = Math.max.apply(Math, nodes.map(function(node) {
            return node.y;
          }));
          var scalex = width / (maxX - minX);
          var scaley = height / (maxY - minY);
          nodes.forEach(function(node) {
            if (node.x !== void 0 && scalex < 1) {
              node.x = (node.x - minX) * scalex;
            }
            if (node.y !== void 0 && scaley < 1) {
              node.y = (node.y - minY) * scaley;
            }
          });
          nodes.forEach(function(node) {
            node.sizeTemp = node.size;
            node.size = [10, 10];
          });
          (0, mysqlWorkbench_1.default)(nodes, edges);
          nodes.forEach(function(node) {
            node.size = node.sizeTemp || [];
            delete node.sizeTemp;
          });
          (0, forceGrid_1.default)({
            nodes,
            edges
          }, options);
          resolve2();
        });
      });
      return layoutPromise;
    }
    exports.default = layout2;
  }
});

// node_modules/@antv/layout/lib/layout/er/index.js
var require_er = __commonJS({
  "node_modules/@antv/layout/lib/layout/er/index.js"(exports) {
    "use strict";
    var __extends19 = exports && exports.__extends || function() {
      var extendStatics7 = function(d2, b10) {
        extendStatics7 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
          d3.__proto__ = b11;
        } || function(d3, b11) {
          for (var p2 in b11)
            if (Object.prototype.hasOwnProperty.call(b11, p2))
              d3[p2] = b11[p2];
        };
        return extendStatics7(d2, b10);
      };
      return function(d2, b10) {
        if (typeof b10 !== "function" && b10 !== null)
          throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
        extendStatics7(d2, b10);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
      };
    }();
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = void 0;
    var base_1 = require_base();
    var core_1 = __importDefault(require_core());
    var ERLayout = function(_super) {
      __extends19(ERLayout2, _super);
      function ERLayout2(options) {
        var _this = _super.call(this) || this;
        _this.width = 300;
        _this.height = 300;
        _this.nodeMinGap = 50;
        _this.onLayoutEnd = function() {
        };
        if (options) {
          _this.updateCfg(options);
        }
        return _this;
      }
      ERLayout2.prototype.getDefaultCfg = function() {
        return {
          width: 300,
          height: 300,
          nodeMinGap: 50
        };
      };
      ERLayout2.prototype.execute = function() {
        var self2 = this;
        var nodes = self2.nodes;
        var edges = self2.edges;
        nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function(node) {
          if (!node.size) {
            node.size = [50, 50];
          }
        });
        return (0, core_1.default)({
          nodes,
          edges
        }, {
          width: this.width,
          height: this.height,
          nodeMinGap: this.nodeMinGap
        }).then(function() {
          if (self2.onLayoutEnd)
            self2.onLayoutEnd();
        });
      };
      ERLayout2.prototype.getType = function() {
        return "er";
      };
      return ERLayout2;
    }(base_1.Base);
    exports.ERLayout = ERLayout;
  }
});

// node_modules/@antv/layout/lib/layout/layout.js
var require_layout2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Layouts = exports.Layout = void 0;
    var registy_1 = require_registy();
    var grid_1 = require_grid();
    var random_1 = require_random();
    var gForce_1 = require_gForce();
    var force_1 = require_force2();
    var circular_1 = require_circular();
    var dagre_1 = require_dagre2();
    var radial_1 = require_radial2();
    var concentric_1 = require_concentric();
    var mds_1 = require_mds2();
    var fruchterman_1 = require_fruchterman();
    var fruchterman_2 = require_fruchterman2();
    var gForce_2 = require_gForce2();
    var comboForce_1 = require_comboForce();
    var comboCombined_1 = require_comboCombined();
    var forceAtlas2_1 = require_forceAtlas2();
    var er_1 = require_er();
    var dagreCompound_1 = require_dagreCompound();
    var Layout2 = function() {
      function Layout3(options) {
        var layoutClass = (0, registy_1.getLayoutByName)(options.type);
        this.layoutInstance = new layoutClass(options);
      }
      Layout3.prototype.layout = function(data) {
        return this.layoutInstance.layout(data);
      };
      Layout3.prototype.updateCfg = function(cfg) {
        this.layoutInstance.updateCfg(cfg);
      };
      Layout3.prototype.init = function(data) {
        this.layoutInstance.init(data);
      };
      Layout3.prototype.execute = function() {
        this.layoutInstance.execute();
      };
      Layout3.prototype.getDefaultCfg = function() {
        return this.layoutInstance.getDefaultCfg();
      };
      Layout3.prototype.destroy = function() {
        return this.layoutInstance.destroy();
      };
      return Layout3;
    }();
    exports.Layout = Layout2;
    exports.Layouts = {
      force: force_1.ForceLayout,
      fruchterman: fruchterman_1.FruchtermanLayout,
      forceAtlas2: forceAtlas2_1.ForceAtlas2Layout,
      gForce: gForce_1.GForceLayout,
      dagre: dagre_1.DagreLayout,
      dagreCompound: dagreCompound_1.DagreCompoundLayout,
      circular: circular_1.CircularLayout,
      radial: radial_1.RadialLayout,
      concentric: concentric_1.ConcentricLayout,
      grid: grid_1.GridLayout,
      mds: mds_1.MDSLayout,
      comboForce: comboForce_1.ComboForceLayout,
      comboCombined: comboCombined_1.ComboCombinedLayout,
      random: random_1.RandomLayout,
      "gForce-gpu": gForce_2.GForceGPULayout,
      "fruchterman-gpu": fruchterman_2.FruchtermanGPULayout,
      er: er_1.ERLayout
    };
  }
});

// node_modules/@antv/layout/lib/layout/types.js
var require_types2 = __commonJS({
  "node_modules/@antv/layout/lib/layout/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/@antv/layout/lib/layout/index.js
var require_layout3 = __commonJS({
  "node_modules/@antv/layout/lib/layout/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ERLayout = exports.ForceAtlas2Layout = exports.ComboCombinedLayout = exports.ComboForceLayout = exports.GForceGPULayout = exports.FruchtermanGPULayout = exports.FruchtermanLayout = exports.MDSLayout = exports.ConcentricLayout = exports.RadialLayout = exports.DagreCompoundLayout = exports.DagreLayout = exports.CircularLayout = exports.ForceLayout = exports.GForceLayout = exports.RandomLayout = exports.GridLayout = exports.Layouts = exports.Layout = void 0;
    var grid_1 = require_grid();
    Object.defineProperty(exports, "GridLayout", { enumerable: true, get: function() {
      return grid_1.GridLayout;
    } });
    var random_1 = require_random();
    Object.defineProperty(exports, "RandomLayout", { enumerable: true, get: function() {
      return random_1.RandomLayout;
    } });
    var gForce_1 = require_gForce();
    Object.defineProperty(exports, "GForceLayout", { enumerable: true, get: function() {
      return gForce_1.GForceLayout;
    } });
    var force_1 = require_force2();
    Object.defineProperty(exports, "ForceLayout", { enumerable: true, get: function() {
      return force_1.ForceLayout;
    } });
    var circular_1 = require_circular();
    Object.defineProperty(exports, "CircularLayout", { enumerable: true, get: function() {
      return circular_1.CircularLayout;
    } });
    var dagre_1 = require_dagre2();
    Object.defineProperty(exports, "DagreLayout", { enumerable: true, get: function() {
      return dagre_1.DagreLayout;
    } });
    var dagreCompound_1 = require_dagreCompound();
    Object.defineProperty(exports, "DagreCompoundLayout", { enumerable: true, get: function() {
      return dagreCompound_1.DagreCompoundLayout;
    } });
    var radial_1 = require_radial2();
    Object.defineProperty(exports, "RadialLayout", { enumerable: true, get: function() {
      return radial_1.RadialLayout;
    } });
    var concentric_1 = require_concentric();
    Object.defineProperty(exports, "ConcentricLayout", { enumerable: true, get: function() {
      return concentric_1.ConcentricLayout;
    } });
    var mds_1 = require_mds2();
    Object.defineProperty(exports, "MDSLayout", { enumerable: true, get: function() {
      return mds_1.MDSLayout;
    } });
    var fruchterman_1 = require_fruchterman();
    Object.defineProperty(exports, "FruchtermanLayout", { enumerable: true, get: function() {
      return fruchterman_1.FruchtermanLayout;
    } });
    var fruchterman_2 = require_fruchterman2();
    Object.defineProperty(exports, "FruchtermanGPULayout", { enumerable: true, get: function() {
      return fruchterman_2.FruchtermanGPULayout;
    } });
    var gForce_2 = require_gForce2();
    Object.defineProperty(exports, "GForceGPULayout", { enumerable: true, get: function() {
      return gForce_2.GForceGPULayout;
    } });
    var comboForce_1 = require_comboForce();
    Object.defineProperty(exports, "ComboForceLayout", { enumerable: true, get: function() {
      return comboForce_1.ComboForceLayout;
    } });
    var comboCombined_1 = require_comboCombined();
    Object.defineProperty(exports, "ComboCombinedLayout", { enumerable: true, get: function() {
      return comboCombined_1.ComboCombinedLayout;
    } });
    var forceAtlas2_1 = require_forceAtlas2();
    Object.defineProperty(exports, "ForceAtlas2Layout", { enumerable: true, get: function() {
      return forceAtlas2_1.ForceAtlas2Layout;
    } });
    var er_1 = require_er();
    Object.defineProperty(exports, "ERLayout", { enumerable: true, get: function() {
      return er_1.ERLayout;
    } });
    var layout_1 = require_layout2();
    Object.defineProperty(exports, "Layout", { enumerable: true, get: function() {
      return layout_1.Layout;
    } });
    Object.defineProperty(exports, "Layouts", { enumerable: true, get: function() {
      return layout_1.Layouts;
    } });
    __exportStar(require_types2(), exports);
  }
});

// node_modules/@antv/layout/lib/index.js
var require_lib = __commonJS({
  "node_modules/@antv/layout/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m2, k2);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k2];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2)
        if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2))
          __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLayoutByName = exports.unRegisterLayout = exports.registerLayout = void 0;
    var registy_1 = require_registy();
    Object.defineProperty(exports, "registerLayout", { enumerable: true, get: function() {
      return registy_1.registerLayout;
    } });
    Object.defineProperty(exports, "unRegisterLayout", { enumerable: true, get: function() {
      return registy_1.unRegisterLayout;
    } });
    Object.defineProperty(exports, "getLayoutByName", { enumerable: true, get: function() {
      return registy_1.getLayoutByName;
    } });
    __exportStar(require_layout3(), exports);
  }
});

// node_modules/@antv/hierarchy/lib/util.js
var require_util5 = __commonJS({
  "node_modules/@antv/hierarchy/lib/util.js"(exports, module) {
    var _require = (init_esm(), __toCommonJS(esm_exports));
    var mix2 = _require.mix;
    module.exports = {
      assign: mix2
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/hierarchy.js
var require_hierarchy = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/hierarchy.js"(exports, module) {
    var util = require_util5();
    var PEM = 18;
    var DEFAULT_HEIGHT = PEM * 2;
    var DEFAULT_GAP = PEM;
    var DEFAULT_OPTIONS = {
      getId: function getId(d2) {
        return d2.id || d2.name;
      },
      getPreH: function getPreH(d2) {
        return d2.preH || 0;
      },
      getPreV: function getPreV(d2) {
        return d2.preV || 0;
      },
      getHGap: function getHGap(d2) {
        return d2.hgap || DEFAULT_GAP;
      },
      getVGap: function getVGap(d2) {
        return d2.vgap || DEFAULT_GAP;
      },
      getChildren: function getChildren(d2) {
        return d2.children;
      },
      getHeight: function getHeight3(d2) {
        return d2.height || DEFAULT_HEIGHT;
      },
      getWidth: function getWidth(d2) {
        var label = d2.label || " ";
        return d2.width || label.split("").length * PEM;
      }
    };
    function Node3(data, options) {
      var me2 = this;
      me2.vgap = me2.hgap = 0;
      if (data instanceof Node3)
        return data;
      me2.data = data;
      var hgap = options.getHGap(data);
      var vgap = options.getVGap(data);
      me2.preH = options.getPreH(data);
      me2.preV = options.getPreV(data);
      me2.width = options.getWidth(data);
      me2.height = options.getHeight(data);
      me2.width += me2.preH;
      me2.height += me2.preV;
      me2.id = options.getId(data);
      me2.x = me2.y = 0;
      me2.depth = 0;
      if (!me2.children) {
        me2.children = [];
      }
      me2.addGap(hgap, vgap);
      return me2;
    }
    util.assign(Node3.prototype, {
      isRoot: function isRoot() {
        return this.depth === 0;
      },
      isLeaf: function isLeaf() {
        return this.children.length === 0;
      },
      addGap: function addGap(hgap, vgap) {
        var me2 = this;
        me2.hgap += hgap;
        me2.vgap += vgap;
        me2.width += 2 * hgap;
        me2.height += 2 * vgap;
      },
      eachNode: function eachNode(callback) {
        var me2 = this;
        var nodes = [me2];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = current.children.concat(nodes);
        }
      },
      DFTraverse: function DFTraverse(callback) {
        this.eachNode(callback);
      },
      BFTraverse: function BFTraverse(callback) {
        var me2 = this;
        var nodes = [me2];
        var current;
        while (current = nodes.shift()) {
          callback(current);
          nodes = nodes.concat(current.children);
        }
      },
      getBoundingBox: function getBoundingBox() {
        var bb = {
          left: Number.MAX_VALUE,
          top: Number.MAX_VALUE,
          width: 0,
          height: 0
        };
        this.eachNode(function(node) {
          bb.left = Math.min(bb.left, node.x);
          bb.top = Math.min(bb.top, node.y);
          bb.width = Math.max(bb.width, node.x + node.width);
          bb.height = Math.max(bb.height, node.y + node.height);
        });
        return bb;
      },
      translate: function translate5(tx, ty) {
        if (tx === void 0) {
          tx = 0;
        }
        if (ty === void 0) {
          ty = 0;
        }
        this.eachNode(function(node) {
          node.x += tx;
          node.y += ty;
          node.x += node.preH;
          node.y += node.preV;
        });
      },
      right2left: function right2left() {
        var me2 = this;
        var bb = me2.getBoundingBox();
        me2.eachNode(function(node) {
          node.x = node.x - (node.x - bb.left) * 2 - node.width;
        });
        me2.translate(bb.width, 0);
      },
      bottom2top: function bottom2top() {
        var me2 = this;
        var bb = me2.getBoundingBox();
        me2.eachNode(function(node) {
          node.y = node.y - (node.y - bb.top) * 2 - node.height;
        });
        me2.translate(0, bb.height);
      }
    });
    function hierarchy(data, options, isolated) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var root = new Node3(data, options);
      var nodes = [root];
      var node;
      if (!isolated && !data.collapsed) {
        while (node = nodes.shift()) {
          if (!node.data.collapsed) {
            var children = options.getChildren(node.data);
            var length5 = children ? children.length : 0;
            node.children = new Array(length5);
            if (children && length5) {
              for (var i2 = 0; i2 < length5; i2++) {
                var child = new Node3(children[i2], options);
                node.children[i2] = child;
                nodes.push(child);
                child.parent = node;
                child.depth = node.depth + 1;
              }
            }
          }
        }
      }
      return root;
    }
    module.exports = hierarchy;
  }
});

// node_modules/@antv/hierarchy/lib/layout/base.js
var require_base2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/base.js"(exports, module) {
    var hierarchy = require_hierarchy();
    var Layout2 = function() {
      function Layout3(root, options) {
        if (options === void 0) {
          options = {};
        }
        var me2 = this;
        me2.options = options;
        me2.rootNode = hierarchy(root, options);
      }
      var _proto = Layout3.prototype;
      _proto.execute = function execute() {
        throw new Error("please override this method");
      };
      return Layout3;
    }();
    module.exports = Layout2;
  }
});

// node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js
var require_non_layered_tidy = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js"(exports, module) {
    function WrappedTree(w2, h2, y2, c2) {
      if (c2 === void 0) {
        c2 = [];
      }
      var me2 = this;
      me2.w = w2 || 0;
      me2.h = h2 || 0;
      me2.y = y2 || 0;
      me2.x = 0;
      me2.c = c2 || [];
      me2.cs = c2.length;
      me2.prelim = 0;
      me2.mod = 0;
      me2.shift = 0;
      me2.change = 0;
      me2.tl = null;
      me2.tr = null;
      me2.el = null;
      me2.er = null;
      me2.msel = 0;
      me2.mser = 0;
    }
    WrappedTree.fromNode = function(root, isHorizontal) {
      if (!root)
        return null;
      var children = [];
      root.children.forEach(function(child) {
        children.push(WrappedTree.fromNode(child, isHorizontal));
      });
      if (isHorizontal)
        return new WrappedTree(root.height, root.width, root.x, children);
      return new WrappedTree(root.width, root.height, root.y, children);
    };
    function moveRight(node, move3, isHorizontal) {
      if (isHorizontal) {
        node.y += move3;
      } else {
        node.x += move3;
      }
      node.children.forEach(function(child) {
        moveRight(child, move3, isHorizontal);
      });
    }
    function getMin(node, isHorizontal) {
      var res = isHorizontal ? node.y : node.x;
      node.children.forEach(function(child) {
        res = Math.min(getMin(child, isHorizontal), res);
      });
      return res;
    }
    function normalize5(node, isHorizontal) {
      var min6 = getMin(node, isHorizontal);
      moveRight(node, -min6, isHorizontal);
    }
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.y = converted.x;
      } else {
        root.x = converted.x;
      }
      converted.c.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    function layer(node, isHorizontal, d2) {
      if (d2 === void 0) {
        d2 = 0;
      }
      if (isHorizontal) {
        node.x = d2;
        d2 += node.width;
      } else {
        node.y = d2;
        d2 += node.height;
      }
      node.children.forEach(function(child) {
        layer(child, isHorizontal, d2);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      var isHorizontal = options.isHorizontal;
      function firstWalk(t4) {
        if (t4.cs === 0) {
          setExtremes(t4);
          return;
        }
        firstWalk(t4.c[0]);
        var ih = updateIYL(bottom(t4.c[0].el), 0, null);
        for (var i2 = 1; i2 < t4.cs; ++i2) {
          firstWalk(t4.c[i2]);
          var min6 = bottom(t4.c[i2].er);
          separate(t4, i2, ih);
          ih = updateIYL(min6, i2, ih);
        }
        positionRoot(t4);
        setExtremes(t4);
      }
      function setExtremes(t4) {
        if (t4.cs === 0) {
          t4.el = t4;
          t4.er = t4;
          t4.msel = t4.mser = 0;
        } else {
          t4.el = t4.c[0].el;
          t4.msel = t4.c[0].msel;
          t4.er = t4.c[t4.cs - 1].er;
          t4.mser = t4.c[t4.cs - 1].mser;
        }
      }
      function separate(t4, i2, ih) {
        var sr2 = t4.c[i2 - 1];
        var mssr = sr2.mod;
        var cl = t4.c[i2];
        var mscl = cl.mod;
        while (sr2 !== null && cl !== null) {
          if (bottom(sr2) > ih.low)
            ih = ih.nxt;
          var dist4 = mssr + sr2.prelim + sr2.w - (mscl + cl.prelim);
          if (dist4 > 0) {
            mscl += dist4;
            moveSubtree(t4, i2, ih.index, dist4);
          }
          var sy = bottom(sr2);
          var cy = bottom(cl);
          if (sy <= cy) {
            sr2 = nextRightContour(sr2);
            if (sr2 !== null)
              mssr += sr2.mod;
          }
          if (sy >= cy) {
            cl = nextLeftContour(cl);
            if (cl !== null)
              mscl += cl.mod;
          }
        }
        if (!sr2 && !!cl) {
          setLeftThread(t4, i2, cl, mscl);
        } else if (!!sr2 && !cl) {
          setRightThread(t4, i2, sr2, mssr);
        }
      }
      function moveSubtree(t4, i2, si2, dist4) {
        t4.c[i2].mod += dist4;
        t4.c[i2].msel += dist4;
        t4.c[i2].mser += dist4;
        distributeExtra(t4, i2, si2, dist4);
      }
      function nextLeftContour(t4) {
        return t4.cs === 0 ? t4.tl : t4.c[0];
      }
      function nextRightContour(t4) {
        return t4.cs === 0 ? t4.tr : t4.c[t4.cs - 1];
      }
      function bottom(t4) {
        return t4.y + t4.h;
      }
      function setLeftThread(t4, i2, cl, modsumcl) {
        var li2 = t4.c[0].el;
        li2.tl = cl;
        var diff = modsumcl - cl.mod - t4.c[0].msel;
        li2.mod += diff;
        li2.prelim -= diff;
        t4.c[0].el = t4.c[i2].el;
        t4.c[0].msel = t4.c[i2].msel;
      }
      function setRightThread(t4, i2, sr2, modsumsr) {
        var ri2 = t4.c[i2].er;
        ri2.tr = sr2;
        var diff = modsumsr - sr2.mod - t4.c[i2].mser;
        ri2.mod += diff;
        ri2.prelim -= diff;
        t4.c[i2].er = t4.c[i2 - 1].er;
        t4.c[i2].mser = t4.c[i2 - 1].mser;
      }
      function positionRoot(t4) {
        t4.prelim = (t4.c[0].prelim + t4.c[0].mod + t4.c[t4.cs - 1].mod + t4.c[t4.cs - 1].prelim + t4.c[t4.cs - 1].w) / 2 - t4.w / 2;
      }
      function secondWalk(t4, modsum) {
        modsum += t4.mod;
        t4.x = t4.prelim + modsum;
        addChildSpacing(t4);
        for (var i2 = 0; i2 < t4.cs; i2++) {
          secondWalk(t4.c[i2], modsum);
        }
      }
      function distributeExtra(t4, i2, si2, dist4) {
        if (si2 !== i2 - 1) {
          var nr2 = i2 - si2;
          t4.c[si2 + 1].shift += dist4 / nr2;
          t4.c[i2].shift -= dist4 / nr2;
          t4.c[i2].change -= dist4 - dist4 / nr2;
        }
      }
      function addChildSpacing(t4) {
        var d2 = 0;
        var modsumdelta = 0;
        for (var i2 = 0; i2 < t4.cs; i2++) {
          d2 += t4.c[i2].shift;
          modsumdelta += d2 + t4.c[i2].change;
          t4.c[i2].mod += modsumdelta;
        }
      }
      function updateIYL(low, index, ih) {
        while (ih !== null && low >= ih.low) {
          ih = ih.nxt;
        }
        return {
          low,
          index,
          nxt: ih
        };
      }
      layer(root, isHorizontal);
      var wt2 = WrappedTree.fromNode(root, isHorizontal);
      firstWalk(wt2);
      secondWalk(wt2, 0);
      convertBack(wt2, root, isHorizontal);
      normalize5(root, isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/separate-root.js
var require_separate_root = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/separate-root.js"(exports, module) {
    var hierarchy = require_hierarchy();
    module.exports = function(root, options) {
      var left = hierarchy(root.data, options, true);
      var right = hierarchy(root.data, options, true);
      var treeSize = root.children.length;
      var rightTreeSize = Math.round(treeSize / 2);
      var getSide = options.getSide || function(child2, index) {
        if (index < rightTreeSize) {
          return "right";
        }
        return "left";
      };
      for (var i2 = 0; i2 < treeSize; i2++) {
        var child = root.children[i2];
        var side = getSide(child, i2);
        if (side === "right") {
          right.children.push(child);
        } else {
          left.children.push(child);
        }
      }
      left.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "left";
        }
      });
      right.eachNode(function(node) {
        if (!node.isRoot()) {
          node.side = "right";
        }
      });
      return {
        left,
        right
      };
    };
  }
});

// node_modules/@antv/hierarchy/lib/layout/do-layout.js
var require_do_layout = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/do-layout.js"(exports, module) {
    var separateTree = require_separate_root();
    var VALID_DIRECTIONS = [
      "LR",
      "RL",
      "TB",
      "BT",
      "H",
      "V"
    ];
    var HORIZONTAL_DIRECTIONS = ["LR", "RL", "H"];
    var isHorizontal = function isHorizontal2(direction3) {
      return HORIZONTAL_DIRECTIONS.indexOf(direction3) > -1;
    };
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    module.exports = function(root, options, layoutAlgrithm) {
      var direction3 = options.direction || DEFAULT_DIRECTION;
      options.isHorizontal = isHorizontal(direction3);
      if (direction3 && VALID_DIRECTIONS.indexOf(direction3) === -1) {
        throw new TypeError("Invalid direction: " + direction3);
      }
      if (direction3 === VALID_DIRECTIONS[0]) {
        layoutAlgrithm(root, options);
      } else if (direction3 === VALID_DIRECTIONS[1]) {
        layoutAlgrithm(root, options);
        root.right2left();
      } else if (direction3 === VALID_DIRECTIONS[2]) {
        layoutAlgrithm(root, options);
      } else if (direction3 === VALID_DIRECTIONS[3]) {
        layoutAlgrithm(root, options);
        root.bottom2top();
      } else if (direction3 === VALID_DIRECTIONS[4] || direction3 === VALID_DIRECTIONS[5]) {
        var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
        layoutAlgrithm(left, options);
        layoutAlgrithm(right, options);
        options.isHorizontal ? left.right2left() : left.bottom2top();
        right.translate(left.x - right.x, left.y - right.y);
        root.x = left.x;
        root.y = right.y;
        var bb = root.getBoundingBox();
        if (options.isHorizontal) {
          if (bb.top < 0) {
            root.translate(0, -bb.top);
          }
        } else {
          if (bb.left < 0) {
            root.translate(-bb.left, 0);
          }
        }
      }
      var fixedRoot = options.fixedRoot;
      if (fixedRoot === void 0)
        fixedRoot = true;
      if (fixedRoot) {
        root.translate(-(root.x + root.width / 2 + root.hgap), -(root.y + root.height / 2 + root.vgap));
      }
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/compact-box.js
var require_compact_box = __commonJS({
  "node_modules/@antv/hierarchy/lib/compact-box.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout2 = require_base2();
    var nonLayeredTidyTree = require_non_layered_tidy();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var CompactBoxTreeLayout = function(_TreeLayout) {
      _inheritsLoose(CompactBoxTreeLayout2, _TreeLayout);
      function CompactBoxTreeLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = CompactBoxTreeLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        return doTreeLayout(me2.rootNode, me2.options, nonLayeredTidyTree);
      };
      return CompactBoxTreeLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function compactBoxLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new CompactBoxTreeLayout(root, options).execute();
    }
    module.exports = compactBoxLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/dendrogram.js
var require_dendrogram = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/dendrogram.js"(exports, module) {
    var util = require_util5();
    function WrappedTree(height, children) {
      if (height === void 0) {
        height = 0;
      }
      if (children === void 0) {
        children = [];
      }
      var me2 = this;
      me2.x = me2.y = 0;
      me2.leftChild = me2.rightChild = null;
      me2.height = 0;
      me2.children = children;
    }
    var DEFAULT_OPTIONS = {
      isHorizontal: true,
      nodeSep: 20,
      nodeSize: 20,
      rankSep: 200,
      subTreeSep: 10
    };
    function convertBack(converted, root, isHorizontal) {
      if (isHorizontal) {
        root.x = converted.x;
        root.y = converted.y;
      } else {
        root.x = converted.y;
        root.y = converted.x;
      }
      converted.children.forEach(function(child, i2) {
        convertBack(child, root.children[i2], isHorizontal);
      });
    }
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      var maxDepth = 0;
      function wrappedTreeFromNode(n2) {
        if (!n2)
          return null;
        n2.width = 0;
        if (n2.depth && n2.depth > maxDepth) {
          maxDepth = n2.depth;
        }
        var children = n2.children;
        var childrenCount = children.length;
        var t4 = new WrappedTree(n2.height, []);
        children.forEach(function(child, i2) {
          var childWT = wrappedTreeFromNode(child);
          t4.children.push(childWT);
          if (i2 === 0) {
            t4.leftChild = childWT;
          }
          if (i2 === childrenCount - 1) {
            t4.rightChild = childWT;
          }
        });
        t4.originNode = n2;
        t4.isLeaf = n2.isLeaf();
        return t4;
      }
      function getDrawingDepth(t4) {
        if (t4.isLeaf || t4.children.length === 0) {
          t4.drawingDepth = maxDepth;
        } else {
          var depths = t4.children.map(function(child) {
            return getDrawingDepth(child);
          });
          var minChildDepth = Math.min.apply(null, depths);
          t4.drawingDepth = minChildDepth - 1;
        }
        return t4.drawingDepth;
      }
      var prevLeaf;
      function position(t4) {
        t4.x = t4.drawingDepth * options.rankSep;
        if (t4.isLeaf) {
          t4.y = 0;
          if (prevLeaf) {
            t4.y = prevLeaf.y + prevLeaf.height + options.nodeSep;
            if (t4.originNode.parent !== prevLeaf.originNode.parent) {
              t4.y += options.subTreeSep;
            }
          }
          prevLeaf = t4;
        } else {
          t4.children.forEach(function(child) {
            position(child);
          });
          t4.y = (t4.leftChild.y + t4.rightChild.y) / 2;
        }
      }
      var wt2 = wrappedTreeFromNode(root);
      getDrawingDepth(wt2);
      position(wt2);
      convertBack(wt2, root, options.isHorizontal);
      return root;
    };
  }
});

// node_modules/@antv/hierarchy/lib/dendrogram.js
var require_dendrogram2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/dendrogram.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout2 = require_base2();
    var dendrogram = require_dendrogram();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var DendrogramLayout = function(_TreeLayout) {
      _inheritsLoose(DendrogramLayout2, _TreeLayout);
      function DendrogramLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = DendrogramLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        me2.rootNode.width = 0;
        return doTreeLayout(me2.rootNode, me2.options, dendrogram);
      };
      return DendrogramLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function dendrogramLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new DendrogramLayout(root, options).execute();
    }
    module.exports = dendrogramLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/indented.js
var require_indented = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/indented.js"(exports, module) {
    function positionNode(node, previousNode, indent2, dropCap) {
      var displacementX = typeof indent2 === "function" ? indent2(node) : indent2 * node.depth;
      if (!dropCap) {
        try {
          if (node.id === node.parent.children[0].id) {
            node.x += displacementX;
            node.y = previousNode ? previousNode.y : 0;
            return;
          }
        } catch (e8) {
        }
      }
      node.x += displacementX;
      node.y = previousNode ? previousNode.y + previousNode.height : 0;
      return;
    }
    module.exports = function(root, indent2, dropCap) {
      var previousNode = null;
      root.eachNode(function(node) {
        positionNode(node, previousNode, indent2, dropCap);
        previousNode = node;
      });
    };
  }
});

// node_modules/@antv/hierarchy/lib/indented.js
var require_indented2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/indented.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout2 = require_base2();
    var indentedTree = require_indented();
    var separateTree = require_separate_root();
    var util = require_util5();
    var VALID_DIRECTIONS = [
      "LR",
      "RL",
      "H"
    ];
    var DEFAULT_DIRECTION = VALID_DIRECTIONS[0];
    var IndentedLayout = function(_TreeLayout) {
      _inheritsLoose(IndentedLayout2, _TreeLayout);
      function IndentedLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = IndentedLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        var options = me2.options;
        var root = me2.rootNode;
        options.isHorizontal = true;
        var _options$indent = options.indent, indent2 = _options$indent === void 0 ? 20 : _options$indent, _options$dropCap = options.dropCap, dropCap = _options$dropCap === void 0 ? true : _options$dropCap;
        var direction3 = options.direction || DEFAULT_DIRECTION;
        if (direction3 && VALID_DIRECTIONS.indexOf(direction3) === -1) {
          throw new TypeError("Invalid direction: " + direction3);
        }
        if (direction3 === VALID_DIRECTIONS[0]) {
          indentedTree(root, indent2, dropCap);
        } else if (direction3 === VALID_DIRECTIONS[1]) {
          indentedTree(root, indent2, dropCap);
          root.right2left();
        } else if (direction3 === VALID_DIRECTIONS[2]) {
          var _separateTree = separateTree(root, options), left = _separateTree.left, right = _separateTree.right;
          indentedTree(left, indent2, dropCap);
          left.right2left();
          indentedTree(right, indent2, dropCap);
          var bbox = left.getBoundingBox();
          right.translate(bbox.width, 0);
          root.x = right.x - root.width / 2;
        }
        return root;
      };
      return IndentedLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function indentedLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new IndentedLayout(root, options).execute();
    }
    module.exports = indentedLayout;
  }
});

// node_modules/@antv/hierarchy/lib/layout/mindmap.js
var require_mindmap = __commonJS({
  "node_modules/@antv/hierarchy/lib/layout/mindmap.js"(exports, module) {
    var util = require_util5();
    function secondWalk(node, options) {
      var totalHeight = 0;
      if (!node.children.length) {
        totalHeight = node.height;
      } else {
        node.children.forEach(function(c2) {
          totalHeight += secondWalk(c2, options);
        });
      }
      node._subTreeSep = options.getSubTreeSep(node.data);
      node.totalHeight = Math.max(node.height, totalHeight) + 2 * node._subTreeSep;
      return node.totalHeight;
    }
    function thirdWalk(node) {
      var children = node.children;
      var len5 = children.length;
      if (len5) {
        children.forEach(function(c2) {
          thirdWalk(c2);
        });
        var first = children[0];
        var last2 = children[len5 - 1];
        var childrenHeight = last2.y - first.y + last2.height;
        var childrenTotalHeight = 0;
        children.forEach(function(child) {
          childrenTotalHeight += child.totalHeight;
        });
        if (childrenHeight > node.height) {
          node.y = first.y + childrenHeight / 2 - node.height / 2;
        } else if (children.length !== 1 || node.height > childrenTotalHeight) {
          var offset = node.y + (node.height - childrenHeight) / 2 - first.y;
          children.forEach(function(c2) {
            c2.translate(0, offset);
          });
        } else {
          node.y = (first.y + first.height / 2 + last2.y + last2.height / 2) / 2 - node.height / 2;
        }
      }
    }
    var DEFAULT_OPTIONS = {
      getSubTreeSep: function getSubTreeSep() {
        return 0;
      }
    };
    module.exports = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      options = util.assign({}, DEFAULT_OPTIONS, options);
      root.parent = {
        x: 0,
        width: 0,
        height: 0,
        y: 0
      };
      root.BFTraverse(function(node) {
        node.x = node.parent.x + node.parent.width;
      });
      root.parent = null;
      secondWalk(root, options);
      root.startY = 0;
      root.y = root.totalHeight / 2 - root.height / 2;
      root.eachNode(function(node) {
        var children = node.children;
        var len5 = children.length;
        if (len5) {
          var first = children[0];
          first.startY = node.startY + node._subTreeSep;
          if (len5 === 1) {
            first.y = node.y + node.height / 2 - first.height / 2;
          } else {
            first.y = first.startY + first.totalHeight / 2 - first.height / 2;
            for (var i2 = 1; i2 < len5; i2++) {
              var c2 = children[i2];
              c2.startY = children[i2 - 1].startY + children[i2 - 1].totalHeight;
              c2.y = c2.startY + c2.totalHeight / 2 - c2.height / 2;
            }
          }
        }
      });
      thirdWalk(root);
    };
  }
});

// node_modules/@antv/hierarchy/lib/mindmap.js
var require_mindmap2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/mindmap.js"(exports, module) {
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var TreeLayout2 = require_base2();
    var mindmap = require_mindmap();
    var doTreeLayout = require_do_layout();
    var util = require_util5();
    var MindmapLayout = function(_TreeLayout) {
      _inheritsLoose(MindmapLayout2, _TreeLayout);
      function MindmapLayout2() {
        return _TreeLayout.apply(this, arguments) || this;
      }
      var _proto = MindmapLayout2.prototype;
      _proto.execute = function execute() {
        var me2 = this;
        return doTreeLayout(me2.rootNode, me2.options, mindmap);
      };
      return MindmapLayout2;
    }(TreeLayout2);
    var DEFAULT_OPTIONS = {};
    function mindmapLayout(root, options) {
      options = util.assign({}, DEFAULT_OPTIONS, options);
      return new MindmapLayout(root, options).execute();
    }
    module.exports = mindmapLayout;
  }
});

// node_modules/@antv/hierarchy/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@antv/hierarchy/lib/index.js"(exports, module) {
    var hierarchy = {
      compactBox: require_compact_box(),
      dendrogram: require_dendrogram2(),
      indented: require_indented2(),
      mindmap: require_mindmap2()
    };
    module.exports = hierarchy;
  }
});

// node_modules/insert-css/index.js
var require_insert_css = __commonJS({
  "node_modules/insert-css/index.js"(exports, module) {
    var containers = [];
    var styleElements = [];
    var usage = "insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).";
    function insertCss4(css, options) {
      options = options || {};
      if (css === void 0) {
        throw new Error(usage);
      }
      var position = options.prepend === true ? "prepend" : "append";
      var container2 = options.container !== void 0 ? options.container : document.querySelector("head");
      var containerId = containers.indexOf(container2);
      if (containerId === -1) {
        containerId = containers.push(container2) - 1;
        styleElements[containerId] = {};
      }
      var styleElement;
      if (styleElements[containerId] !== void 0 && styleElements[containerId][position] !== void 0) {
        styleElement = styleElements[containerId][position];
      } else {
        styleElement = styleElements[containerId][position] = createStyleElement();
        if (position === "prepend") {
          container2.insertBefore(styleElement, container2.childNodes[0]);
        } else {
          container2.appendChild(styleElement);
        }
      }
      if (css.charCodeAt(0) === 65279) {
        css = css.substr(1, css.length);
      }
      if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css;
      } else {
        styleElement.textContent += css;
      }
      return styleElement;
    }
    function createStyleElement() {
      var styleElement = document.createElement("style");
      styleElement.setAttribute("type", "text/css");
      return styleElement;
    }
    module.exports = insertCss4;
    module.exports.insertCss = insertCss4;
  }
});

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b10) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (b11.hasOwnProperty(p2))
        d3[p2] = b11[p2];
  };
  return extendStatics(d2, b10);
};
function __extends(d2, b10) {
  extendStatics(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign16(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e8) {
  var t4 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e8) {
        reject(e8);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e8) {
        reject(e8);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t4[0] & 1)
      throw t4[1];
    return t4[1];
  }, trys: [], ops: [] }, f2, y2, t4, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t4 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t4 = y2["return"]) && t4.call(y2), 0) : y2.next) && !(t4 = t4.call(y2, op[1])).done)
          return t4;
        if (y2 = 0, t4)
          op = [op[0] & 2, t4.value];
        switch (op[0]) {
          case 0:
          case 1:
            t4 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t4 = _2.trys, t4 = t4.length > 0 && t4[t4.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t4 || op[1] > t4[0] && op[1] < t4[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t4[1]) {
              _2.label = t4[1];
              t4 = op;
              break;
            }
            if (t4 && _2.label < t4[2]) {
              _2.label = t4[2];
              _2.ops.push(op);
              break;
            }
            if (t4[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e8) {
        op = [6, e8];
        y2 = 0;
      } finally {
        f2 = t4 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// node_modules/@antv/g6-core/es/behavior/behavior.js
init_esm();

// node_modules/@antv/g6-core/es/behavior/behaviorOption.js
init_esm();
var behaviorOption_default = {
  getDefaultCfg: function getDefaultCfg() {
    return {};
  },
  getEvents: function getEvents() {
    return {};
  },
  updateCfg: function updateCfg(cfg) {
    Object.assign(this, cfg);
    return true;
  },
  shouldBegin: function shouldBegin() {
    return true;
  },
  shouldUpdate: function shouldUpdate() {
    return true;
  },
  shouldEnd: function shouldEnd() {
    return true;
  },
  bind: function bind(graph) {
    var _this = this;
    var events = this.events;
    this.graph = graph;
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", true);
    }
    each_default(events, function(handler, event) {
      graph.on(event, handler);
    });
    document.addEventListener("visibilitychange", function() {
      _this.keydown = false;
    });
  },
  unbind: function unbind(graph) {
    var events = this.events;
    var draggable = graph.get("canvas").get("draggable");
    if (this.type === "drag-canvas" || this.type === "brush-select" || this.type === "lasso-select") {
      graph.get("canvas").set("draggable", false);
    }
    each_default(events, function(handler, event) {
      graph.off(event, handler);
    });
    graph.get("canvas").set("draggable", draggable);
  },
  get: function get(val) {
    return this[val];
  },
  set: function set(key, val) {
    this[key] = val;
    return this;
  }
};

// node_modules/@antv/g6-core/es/behavior/behavior.js
var Behavior = function() {
  function Behavior2() {
  }
  Behavior2.registerBehavior = function(type, behavior) {
    if (!behavior) {
      throw new Error("please specify handler for this behavior: ".concat(type));
    }
    var prototype = clone_default(behaviorOption_default);
    Object.assign(prototype, behavior);
    var base = function base2(cfg) {
      var _this = this;
      Object.assign(this, this.getDefaultCfg(), cfg);
      var events = this.getEvents();
      this.events = null;
      var eventsToBind = {};
      if (events) {
        each_default(events, function(handle, event) {
          eventsToBind[event] = wrap_behavior_default(_this, handle);
        });
        this.events = eventsToBind;
      }
    };
    base.prototype = prototype;
    Behavior2.types[type] = base;
  };
  Behavior2.hasBehavior = function(type) {
    return !!Behavior2.types[type];
  };
  Behavior2.getBehavior = function(type) {
    return Behavior2.types[type];
  };
  Behavior2.types = {};
  return Behavior2;
}();
var behavior_default = Behavior;

// node_modules/@antv/g6-core/es/behavior/index.js
var behavior_default2 = behavior_default;

// node_modules/@antv/g6-core/node_modules/tslib/tslib.es6.js
var extendStatics2 = function(d2, b10) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics2(d2, b10);
};
function __extends2(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics2(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign16(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s2, e8) {
  var t4 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}

// node_modules/@antv/event-emitter/esm/index.js
var WILDCARD = "*";
var EventEmitter = function() {
  function EventEmitter2() {
    this._events = {};
  }
  EventEmitter2.prototype.on = function(evt, callback, once) {
    if (!this._events[evt]) {
      this._events[evt] = [];
    }
    this._events[evt].push({
      callback,
      once: !!once
    });
    return this;
  };
  EventEmitter2.prototype.once = function(evt, callback) {
    return this.on(evt, callback, true);
  };
  EventEmitter2.prototype.emit = function(evt) {
    var _this = this;
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    var events = this._events[evt] || [];
    var wildcardEvents = this._events[WILDCARD] || [];
    var doEmit = function(es) {
      var length5 = es.length;
      for (var i2 = 0; i2 < length5; i2++) {
        if (!es[i2]) {
          continue;
        }
        var _a2 = es[i2], callback = _a2.callback, once = _a2.once;
        if (once) {
          es.splice(i2, 1);
          if (es.length === 0) {
            delete _this._events[evt];
          }
          length5--;
          i2--;
        }
        callback.apply(_this, args);
      }
    };
    doEmit(events);
    doEmit(wildcardEvents);
  };
  EventEmitter2.prototype.off = function(evt, callback) {
    if (!evt) {
      this._events = {};
    } else {
      if (!callback) {
        delete this._events[evt];
      } else {
        var events = this._events[evt] || [];
        var length_1 = events.length;
        for (var i2 = 0; i2 < length_1; i2++) {
          if (events[i2].callback === callback) {
            events.splice(i2, 1);
            length_1--;
            i2--;
          }
        }
        if (events.length === 0) {
          delete this._events[evt];
        }
      }
    }
    return this;
  };
  EventEmitter2.prototype.getEvents = function() {
    return this._events;
  };
  return EventEmitter2;
}();
var esm_default = EventEmitter;

// node_modules/@antv/matrix-util/esm/index.js
init_esm2();

// node_modules/@antv/matrix-util/esm/ext.js
var ext_exports = {};
__export(ext_exports, {
  angleTo: () => angleTo,
  direction: () => direction,
  leftRotate: () => leftRotate,
  leftScale: () => leftScale,
  leftTranslate: () => leftTranslate,
  transform: () => transform,
  vertical: () => vertical
});
init_esm2();
function leftTranslate(out, a2, v2) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromTranslation(transMat, v2);
  return mat3_exports.multiply(out, transMat, a2);
}
function leftRotate(out, a2, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromRotation(rotateMat, rad);
  return mat3_exports.multiply(out, rotateMat, a2);
}
function leftScale(out, a2, v2) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  mat3_exports.fromScaling(scaleMat, v2);
  return mat3_exports.multiply(out, scaleMat, a2);
}
function leftMultiply(out, a2, a1) {
  return mat3_exports.multiply(out, a1, a2);
}
function transform(m2, actions) {
  var matrix = m2 ? [].concat(m2) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0, len5 = actions.length; i2 < len5; i2++) {
    var action = actions[i2];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
      default:
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = vec2_exports.angle(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function vertical(out, v2, flag) {
  if (flag) {
    out[0] = v2[1];
    out[1] = -1 * v2[0];
  } else {
    out[0] = -1 * v2[1];
    out[1] = v2[0];
  }
  return out;
}

// node_modules/@antv/g6-core/es/graph/graph.js
init_esm();

// node_modules/@antv/algorithm/es/index.js
var es_exports = {};
__export(es_exports, {
  GADDI: () => gaddi_default,
  Stack: () => stack_default,
  breadthFirstSearch: () => bfs_default,
  connectedComponent: () => getConnectedComponents,
  cosineSimilarity: () => cosine_similarity_default,
  default: () => es_default,
  depthFirstSearch: () => depthFirstSearch,
  detectAllCycles: () => detectAllCycles,
  detectAllDirectedCycle: () => detectAllDirectedCycle,
  detectAllUndirectedCycle: () => detectAllUndirectedCycle,
  detectCycle: () => detect_cycle_default,
  detectDirectedCycle: () => detectDirectedCycle3,
  dijkstra: () => dijkstra_default,
  findAllPath: () => findAllPath,
  findShortestPath: () => findShortestPath,
  floydWarshall: () => floydWarshall_default,
  getAdjMatrix: () => adjacent_matrix_default,
  getDegree: () => degree_default,
  getInDegree: () => getInDegree,
  getNeighbors: () => getNeighbors,
  getOutDegree: () => getOutDegree,
  iLouvain: () => i_louvain_default,
  kCore: () => k_core_default,
  kMeans: () => k_means_default,
  labelPropagation: () => label_propagation_default,
  louvain: () => louvain_default,
  minimumSpanningTree: () => mts_default,
  nodesCosineSimilarity: () => nodes_cosine_similarity_default,
  pageRank: () => pageRank_default
});

// node_modules/@antv/algorithm/es/adjacent-matrix.js
var adjMatrix = function adjMatrix2(graphData, directed) {
  var nodes = graphData.nodes, edges = graphData.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(edge) {
      var source = edge.source, target = edge.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      if (!sIndex && sIndex !== 0 || !tIndex && tIndex !== 0)
        return;
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var adjacent_matrix_default = adjMatrix;

// node_modules/@antv/algorithm/es/structs/linked-list.js
var defaultComparator = function defaultComparator2(a2, b10) {
  if (a2 === b10) {
    return true;
  }
  return false;
};
var LinkedListNode = function() {
  function LinkedListNode2(value, next) {
    if (next === void 0) {
      next = null;
    }
    this.value = value;
    this.next = next;
  }
  LinkedListNode2.prototype.toString = function(callback) {
    return callback ? callback(this.value) : "".concat(this.value);
  };
  return LinkedListNode2;
}();
var LinkedList = function() {
  function LinkedList2(comparator) {
    if (comparator === void 0) {
      comparator = defaultComparator;
    }
    this.head = null;
    this.tail = null;
    this.compare = comparator;
  }
  LinkedList2.prototype.prepend = function(value) {
    var newNode = new LinkedListNode(value, this.head);
    this.head = newNode;
    if (!this.tail) {
      this.tail = newNode;
    }
    return this;
  };
  LinkedList2.prototype.append = function(value) {
    var newNode = new LinkedListNode(value);
    if (!this.head) {
      this.head = newNode;
      this.tail = newNode;
      return this;
    }
    this.tail.next = newNode;
    this.tail = newNode;
    return this;
  };
  LinkedList2.prototype.delete = function(value) {
    if (!this.head) {
      return null;
    }
    var deleteNode = null;
    while (this.head && this.compare(this.head.value, value)) {
      deleteNode = this.head;
      this.head = this.head.next;
    }
    var currentNode = this.head;
    if (currentNode !== null) {
      while (currentNode.next) {
        if (this.compare(currentNode.next.value, value)) {
          deleteNode = currentNode.next;
          currentNode.next = currentNode.next.next;
        } else {
          currentNode = currentNode.next;
        }
      }
    }
    if (this.compare(this.tail.value, value)) {
      this.tail = currentNode;
    }
    return deleteNode;
  };
  LinkedList2.prototype.find = function(_a2) {
    var _b = _a2.value, value = _b === void 0 ? void 0 : _b, _c = _a2.callback, callback = _c === void 0 ? void 0 : _c;
    if (!this.head) {
      return null;
    }
    var currentNode = this.head;
    while (currentNode) {
      if (callback && callback(currentNode.value)) {
        return currentNode;
      }
      if (value !== void 0 && this.compare(currentNode.value, value)) {
        return currentNode;
      }
      currentNode = currentNode.next;
    }
    return null;
  };
  LinkedList2.prototype.deleteTail = function() {
    var deletedTail = this.tail;
    if (this.head === this.tail) {
      this.head = null;
      this.tail = null;
      return deletedTail;
    }
    var currentNode = this.head;
    while (currentNode.next) {
      if (!currentNode.next.next) {
        currentNode.next = null;
      } else {
        currentNode = currentNode.next;
      }
    }
    this.tail = currentNode;
    return deletedTail;
  };
  LinkedList2.prototype.deleteHead = function() {
    if (!this.head) {
      return null;
    }
    var deletedHead = this.head;
    if (this.head.next) {
      this.head = this.head.next;
    } else {
      this.head = null;
      this.tail = null;
    }
    return deletedHead;
  };
  LinkedList2.prototype.fromArray = function(values2) {
    var _this = this;
    values2.forEach(function(value) {
      return _this.append(value);
    });
    return this;
  };
  LinkedList2.prototype.toArray = function() {
    var nodes = [];
    var currentNode = this.head;
    while (currentNode) {
      nodes.push(currentNode);
      currentNode = currentNode.next;
    }
    return nodes;
  };
  LinkedList2.prototype.reverse = function() {
    var currentNode = this.head;
    var prevNode = null;
    var nextNode = null;
    while (currentNode) {
      nextNode = currentNode.next;
      currentNode.next = prevNode;
      prevNode = currentNode;
      currentNode = nextNode;
    }
    this.tail = this.head;
    this.head = prevNode;
  };
  LinkedList2.prototype.toString = function(callback) {
    if (callback === void 0) {
      callback = void 0;
    }
    return this.toArray().map(function(node) {
      return node.toString(callback);
    }).toString();
  };
  return LinkedList2;
}();
var linked_list_default = LinkedList;

// node_modules/@antv/algorithm/es/structs/queue.js
var Queue = function() {
  function Queue2() {
    this.linkedList = new linked_list_default();
  }
  Queue2.prototype.isEmpty = function() {
    return !this.linkedList.head;
  };
  Queue2.prototype.peek = function() {
    if (!this.linkedList.head) {
      return null;
    }
    return this.linkedList.head.value;
  };
  Queue2.prototype.enqueue = function(value) {
    this.linkedList.append(value);
  };
  Queue2.prototype.dequeue = function() {
    var removeHead = this.linkedList.deleteHead();
    return removeHead ? removeHead.value : null;
  };
  Queue2.prototype.toString = function(callback) {
    return this.linkedList.toString(callback);
  };
  return Queue2;
}();
var queue_default = Queue;

// node_modules/@antv/algorithm/es/util.js
var getNeighbors = function getNeighbors2(nodeId, edges, type) {
  if (edges === void 0) {
    edges = [];
  }
  var currentEdges = edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
  if (type === "target") {
    var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
      return edge.source === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_1).map(function(edge) {
      return edge.target;
    });
  }
  if (type === "source") {
    var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
      return edge.target === nodeId;
    };
    return currentEdges.filter(neighhborsConverter_2).map(function(edge) {
      return edge.source;
    });
  }
  var neighhborsConverter = function neighhborsConverter2(edge) {
    return edge.source === nodeId ? edge.target : edge.source;
  };
  return currentEdges.map(neighhborsConverter);
};
var getOutEdgesNodeId = function getOutEdgesNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId;
  });
};
var getEdgesByNodeId = function getEdgesByNodeId2(nodeId, edges) {
  return edges.filter(function(edge) {
    return edge.source === nodeId || edge.target === nodeId;
  });
};
var uniqueId = function uniqueId2(index) {
  if (index === void 0) {
    index = 0;
  }
  var random1 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  var random22 = "".concat(Math.random()).split(".")[1].substr(0, 5);
  return "".concat(index, "-").concat(random1).concat(random22);
};

// node_modules/@antv/algorithm/es/bfs.js
function initCallbacks(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      var id2 = next;
      if (!seen[id2]) {
        seen[id2] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
var breadthFirstSearch = function breadthFirstSearch2(graphData, startNodeId, originalCallbacks, directed) {
  if (directed === void 0) {
    directed = true;
  }
  var callbacks = initCallbacks(originalCallbacks);
  var nodeQueue = new queue_default();
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  nodeQueue.enqueue(startNodeId);
  var previousNode = "";
  var _loop_1 = function _loop_12() {
    var currentNode = nodeQueue.dequeue();
    callbacks.enter({
      current: currentNode,
      previous: previousNode
    });
    getNeighbors(currentNode, edges, directed ? "target" : void 0).forEach(function(nextNode) {
      if (callbacks.allowTraversal({
        previous: previousNode,
        current: currentNode,
        next: nextNode
      })) {
        nodeQueue.enqueue(nextNode);
      }
    });
    callbacks.leave({
      current: currentNode,
      previous: previousNode
    });
    previousNode = currentNode;
  };
  while (!nodeQueue.isEmpty()) {
    _loop_1();
  }
};
var bfs_default = breadthFirstSearch;

// node_modules/@antv/algorithm/es/connected-component.js
var detectConnectedComponents = function detectConnectedComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allComponents = [];
  var visited = {};
  var nodeStack = [];
  var getComponent = function getComponent2(node2) {
    nodeStack.push(node2);
    visited[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges);
    var _loop_1 = function _loop_12(i4) {
      var neighbor = neighbors[i4];
      if (!visited[neighbor]) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === neighbor;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
      }
    };
    for (var i3 = 0; i3 < neighbors.length; ++i3) {
      _loop_1(i3);
    }
  };
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var node = nodes[i2];
    if (!visited[node.id]) {
      getComponent(node);
      var component = [];
      while (nodeStack.length > 0) {
        component.push(nodeStack.pop());
      }
      allComponents.push(component);
    }
  }
  return allComponents;
};
var detectStrongConnectComponents = function detectStrongConnectComponents2(graphData) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeStack = [];
  var inStack = {};
  var indices = {};
  var lowLink = {};
  var allComponents = [];
  var index = 0;
  var getComponent = function getComponent2(node2) {
    indices[node2.id] = index;
    lowLink[node2.id] = index;
    index += 1;
    nodeStack.push(node2);
    inStack[node2.id] = true;
    var neighbors = getNeighbors(node2.id, edges, "target").filter(function(n2) {
      return nodes.map(function(node3) {
        return node3.id;
      }).indexOf(n2) > -1;
    });
    var _loop_2 = function _loop_22(i3) {
      var targetNodeID = neighbors[i3];
      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {
        var targetNode = nodes.filter(function(node3) {
          return node3.id === targetNodeID;
        });
        if (targetNode.length > 0) {
          getComponent2(targetNode[0]);
        }
        lowLink[node2.id] = Math.min(lowLink[node2.id], lowLink[targetNodeID]);
      } else if (inStack[targetNodeID]) {
        lowLink[node2.id] = Math.min(lowLink[node2.id], indices[targetNodeID]);
      }
    };
    for (var i2 = 0; i2 < neighbors.length; i2++) {
      _loop_2(i2);
    }
    if (lowLink[node2.id] === indices[node2.id]) {
      var component = [];
      while (nodeStack.length > 0) {
        var tmpNode = nodeStack.pop();
        inStack[tmpNode.id] = false;
        component.push(tmpNode);
        if (tmpNode === node2)
          break;
      }
      if (component.length > 0) {
        allComponents.push(component);
      }
    }
  };
  for (var _i2 = 0, nodes_1 = nodes; _i2 < nodes_1.length; _i2++) {
    var node = nodes_1[_i2];
    if (!indices[node.id] && indices[node.id] !== 0) {
      getComponent(node);
    }
  }
  return allComponents;
};
function getConnectedComponents(graphData, directed) {
  if (directed)
    return detectStrongConnectComponents(graphData);
  return detectConnectedComponents(graphData);
}

// node_modules/@antv/algorithm/es/degree.js
var degree2 = function degree3(graphData) {
  var degrees2 = {};
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  nodes.forEach(function(node) {
    degrees2[node.id] = {
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
  });
  edges.forEach(function(edge) {
    degrees2[edge.source].degree++;
    degrees2[edge.source].outDegree++;
    degrees2[edge.target].degree++;
    degrees2[edge.target].inDegree++;
  });
  return degrees2;
};
var degree_default = degree2;
var getInDegree = function getInDegree2(graphData, nodeId) {
  var nodeDegree = degree2(graphData);
  if (nodeDegree[nodeId]) {
    return degree2(graphData)[nodeId].inDegree;
  }
  return 0;
};
var getOutDegree = function getOutDegree2(graphData, nodeId) {
  var nodeDegree = degree2(graphData);
  if (nodeDegree[nodeId]) {
    return degree2(graphData)[nodeId].outDegree;
  }
  return 0;
};

// node_modules/@antv/algorithm/es/dfs.js
function initCallbacks2(callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var initiatedCallback = callbacks;
  var stubCallback = function stubCallback2() {
  };
  var allowTraversalCallback = function() {
    var seen = {};
    return function(_a2) {
      var next = _a2.next;
      if (!seen[next]) {
        seen[next] = true;
        return true;
      }
      return false;
    };
  }();
  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;
  initiatedCallback.enter = callbacks.enter || stubCallback;
  initiatedCallback.leave = callbacks.leave || stubCallback;
  return initiatedCallback;
}
function depthFirstSearchRecursive(graphData, currentNode, previousNode, callbacks) {
  callbacks.enter({
    current: currentNode,
    previous: previousNode
  });
  var _a2 = graphData.edges, edges = _a2 === void 0 ? [] : _a2;
  getNeighbors(currentNode, edges, "target").forEach(function(nextNode) {
    if (callbacks.allowTraversal({
      previous: previousNode,
      current: currentNode,
      next: nextNode
    })) {
      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);
    }
  });
  callbacks.leave({
    current: currentNode,
    previous: previousNode
  });
}
function depthFirstSearch(graphData, startNodeId, callbacks) {
  depthFirstSearchRecursive(graphData, startNodeId, "", initCallbacks2(callbacks));
}

// node_modules/@antv/algorithm/es/detect-cycle.js
var detectDirectedCycle = function detectDirectedCycle2(graphData) {
  var cycle = null;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  var dfsParentMap = {};
  var unvisitedSet = {};
  var visitingSet = {};
  var visitedSet = {};
  nodes.forEach(function(node) {
    unvisitedSet[node.id] = node;
  });
  var callbacks = {
    enter: function enter(_a3) {
      var currentNode = _a3.current, previousNode = _a3.previous;
      if (visitingSet[currentNode]) {
        cycle = {};
        var currentCycleNode = currentNode;
        var previousCycleNode = previousNode;
        while (previousCycleNode !== currentNode) {
          cycle[currentCycleNode] = previousCycleNode;
          currentCycleNode = previousCycleNode;
          previousCycleNode = dfsParentMap[previousCycleNode];
        }
        cycle[currentCycleNode] = previousCycleNode;
      } else {
        visitingSet[currentNode] = currentNode;
        delete unvisitedSet[currentNode];
        dfsParentMap[currentNode] = previousNode;
      }
    },
    leave: function leave(_a3) {
      var currentNode = _a3.current;
      visitedSet[currentNode] = currentNode;
      delete visitingSet[currentNode];
    },
    allowTraversal: function allowTraversal(_a3) {
      var nextNode = _a3.next;
      if (cycle) {
        return false;
      }
      return !visitedSet[nextNode];
    }
  };
  while (Object.keys(unvisitedSet).length) {
    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];
    depthFirstSearch(graphData, firsetUnVisitedKey, callbacks);
  }
  return cycle;
};
var detectAllUndirectedCycle = function detectAllUndirectedCycle2(graphData, nodeIds, include) {
  var _a2, _b;
  if (include === void 0) {
    include = true;
  }
  var allCycles = [];
  var components3 = getConnectedComponents(graphData, false);
  for (var _i2 = 0, components_1 = components3; _i2 < components_1.length; _i2++) {
    var component = components_1[_i2];
    if (!component.length)
      continue;
    var root = component[0];
    var rootId = root.id;
    var stack = [root];
    var parent_1 = (_a2 = {}, _a2[rootId] = root, _a2);
    var used = (_b = {}, _b[rootId] = /* @__PURE__ */ new Set(), _b);
    while (stack.length > 0) {
      var curNode = stack.pop();
      var curNodeId = curNode.id;
      var neighbors = getNeighbors(curNodeId, graphData.edges);
      var _loop_1 = function _loop_12(i3) {
        var _c;
        var neighborId = neighbors[i3];
        var neighbor = graphData.nodes.find(function(node) {
          return node.id === neighborId;
        });
        if (neighborId === curNodeId) {
          allCycles.push((_c = {}, _c[neighborId] = curNode, _c));
        } else if (!(neighborId in used)) {
          parent_1[neighborId] = curNode;
          stack.push(neighbor);
          used[neighborId] = /* @__PURE__ */ new Set([curNode]);
        } else if (!used[curNodeId].has(neighbor)) {
          var cycleValid = true;
          var cyclePath = [neighbor, curNode];
          var p2 = parent_1[curNodeId];
          while (used[neighborId].size && !used[neighborId].has(p2)) {
            cyclePath.push(p2);
            if (p2 === parent_1[p2.id])
              break;
            else
              p2 = parent_1[p2.id];
          }
          cyclePath.push(p2);
          if (nodeIds && include) {
            cycleValid = false;
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = true;
            }
          } else if (nodeIds && !include) {
            if (cyclePath.findIndex(function(node) {
              return nodeIds.indexOf(node.id) > -1;
            }) > -1) {
              cycleValid = false;
            }
          }
          if (cycleValid) {
            var cycle = {};
            for (var index = 1; index < cyclePath.length; index += 1) {
              cycle[cyclePath[index - 1].id] = cyclePath[index];
            }
            if (cyclePath.length) {
              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];
            }
            allCycles.push(cycle);
          }
          used[neighborId].add(curNode);
        }
      };
      for (var i2 = 0; i2 < neighbors.length; i2 += 1) {
        _loop_1(i2);
      }
    }
  }
  return allCycles;
};
var detectAllDirectedCycle = function detectAllDirectedCycle2(graphData, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  var path = [];
  var blocked = /* @__PURE__ */ new Set();
  var B3 = [];
  var allCycles = [];
  var idx2Node = {};
  var node2Idx = {};
  var unblock = function unblock2(thisNode) {
    var stack = [thisNode];
    while (stack.length > 0) {
      var node2 = stack.pop();
      if (blocked.has(node2)) {
        blocked.delete(node2);
        B3[node2.id].forEach(function(n2) {
          stack.push(n2);
        });
        B3[node2.id].clear();
      }
    }
  };
  var circuit = function circuit2(node2, start, adjList2) {
    var closed = false;
    if (nodeIds && include === false && nodeIds.indexOf(node2.id) > -1)
      return closed;
    path.push(node2);
    blocked.add(node2);
    var neighbors = adjList2[node2.id];
    for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
      var neighbor = idx2Node[neighbors[i3]];
      if (neighbor === start) {
        var cycle = {};
        for (var index = 1; index < path.length; index += 1) {
          cycle[path[index - 1].id] = path[index];
        }
        if (path.length) {
          cycle[path[path.length - 1].id] = path[0];
        }
        allCycles.push(cycle);
        closed = true;
      } else if (!blocked.has(neighbor)) {
        if (circuit2(neighbor, start, adjList2)) {
          closed = true;
        }
      }
    }
    if (closed) {
      unblock(node2);
    } else {
      for (var i3 = 0; i3 < neighbors.length; i3 += 1) {
        var neighbor = idx2Node[neighbors[i3]];
        if (!B3[neighbor.id].has(node2)) {
          B3[neighbor.id].add(node2);
        }
      }
    }
    path.pop();
    return closed;
  };
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2;
  for (var i2 = 0; i2 < nodes.length; i2 += 1) {
    var node = nodes[i2];
    var nodeId = node.id;
    node2Idx[nodeId] = i2;
    idx2Node[i2] = node;
  }
  if (nodeIds && include) {
    var _loop_2 = function _loop_22(i3) {
      var nodeId2 = nodeIds[i3];
      node2Idx[nodes[i3].id] = node2Idx[nodeId2];
      node2Idx[nodeId2] = 0;
      idx2Node[0] = nodes.find(function(node2) {
        return node2.id === nodeId2;
      });
      idx2Node[node2Idx[nodes[i3].id]] = nodes[i3];
    };
    for (var i2 = 0; i2 < nodeIds.length; i2++) {
      _loop_2(i2);
    }
  }
  var getMinComponentAdj = function getMinComponentAdj2(components3) {
    var _a3;
    var minCompIdx;
    var minIdx2 = Infinity;
    for (var i3 = 0; i3 < components3.length; i3 += 1) {
      var comp = components3[i3];
      for (var j2 = 0; j2 < comp.length; j2++) {
        var nodeIdx_1 = node2Idx[comp[j2].id];
        if (nodeIdx_1 < minIdx2) {
          minIdx2 = nodeIdx_1;
          minCompIdx = i3;
        }
      }
    }
    var component2 = components3[minCompIdx];
    var adjList2 = [];
    for (var i3 = 0; i3 < component2.length; i3 += 1) {
      var node2 = component2[i3];
      adjList2[node2.id] = [];
      for (var _i2 = 0, _b = getNeighbors(node2.id, graphData.edges, "target").filter(function(n2) {
        return component2.map(function(c2) {
          return c2.id;
        }).indexOf(n2) > -1;
      }); _i2 < _b.length; _i2++) {
        var neighbor = _b[_i2];
        if (neighbor === node2.id && !(include === false && nodeIds.indexOf(node2.id) > -1)) {
          allCycles.push((_a3 = {}, _a3[node2.id] = node2, _a3));
        } else {
          adjList2[node2.id].push(node2Idx[neighbor]);
        }
      }
    }
    return {
      component: component2,
      adjList: adjList2,
      minIdx: minIdx2
    };
  };
  var nodeIdx = 0;
  while (nodeIdx < nodes.length) {
    var subgraphNodes = nodes.filter(function(n2) {
      return node2Idx[n2.id] >= nodeIdx;
    });
    var sccs = detectStrongConnectComponents({
      nodes: subgraphNodes,
      edges: graphData.edges
    }).filter(function(component2) {
      return component2.length > 1;
    });
    if (sccs.length === 0)
      break;
    var scc = getMinComponentAdj(sccs);
    var minIdx = scc.minIdx, adjList = scc.adjList, component = scc.component;
    if (component.length > 1) {
      component.forEach(function(node2) {
        B3[node2.id] = /* @__PURE__ */ new Set();
      });
      var startNode = idx2Node[minIdx];
      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1)
        return allCycles;
      circuit(startNode, startNode, adjList);
      nodeIdx = minIdx + 1;
    } else {
      break;
    }
  }
  return allCycles;
};
var detectAllCycles = function detectAllCycles2(graphData, directed, nodeIds, include) {
  if (include === void 0) {
    include = true;
  }
  if (directed)
    return detectAllDirectedCycle(graphData, nodeIds, include);
  return detectAllUndirectedCycle(graphData, nodeIds, include);
};
var detect_cycle_default = detectDirectedCycle;

// node_modules/@antv/algorithm/node_modules/tslib/tslib.es6.js
function __spreadArray2(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}

// node_modules/@antv/algorithm/es/dijkstra.js
init_esm();
var minVertex = function minVertex2(D3, nodes, marks) {
  var minDis = Infinity;
  var minNode;
  for (var i2 = 0; i2 < nodes.length; i2++) {
    var nodeId = nodes[i2].id;
    if (!marks[nodeId] && D3[nodeId] <= minDis) {
      minDis = D3[nodeId];
      minNode = nodes[i2];
    }
  }
  return minNode;
};
var dijkstra = function dijkstra2(graphData, source, directed, weightPropertyName) {
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodeIds = [];
  var marks = {};
  var D3 = {};
  var prevs = {};
  nodes.forEach(function(node, i3) {
    var id2 = node.id;
    nodeIds.push(id2);
    D3[id2] = Infinity;
    if (id2 === source)
      D3[id2] = 0;
  });
  var nodeNum = nodes.length;
  var _loop_1 = function _loop_12(i3) {
    var minNode = minVertex(D3, nodes, marks);
    var minNodeId = minNode.id;
    marks[minNodeId] = true;
    if (D3[minNodeId] === Infinity)
      return "continue";
    var relatedEdges = [];
    if (directed)
      relatedEdges = getOutEdgesNodeId(minNodeId, edges);
    else
      relatedEdges = getEdgesByNodeId(minNodeId, edges);
    relatedEdges.forEach(function(edge) {
      var edgeTarget = edge.target;
      var edgeSource = edge.source;
      var w2 = edgeTarget === minNodeId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;
      if (D3[w2] > D3[minNode.id] + weight) {
        D3[w2] = D3[minNode.id] + weight;
        prevs[w2] = [minNode.id];
      } else if (D3[w2] === D3[minNode.id] + weight) {
        prevs[w2].push(minNode.id);
      }
    });
  };
  for (var i2 = 0; i2 < nodeNum; i2++) {
    _loop_1(i2);
  }
  prevs[source] = [source];
  var paths = {};
  for (var target in D3) {
    if (D3[target] !== Infinity) {
      findAllPaths(source, target, prevs, paths);
    }
  }
  var path = {};
  for (var target in paths) {
    path[target] = paths[target][0];
  }
  return {
    length: D3,
    path,
    allPath: paths
  };
};
var dijkstra_default = dijkstra;
function findAllPaths(source, target, prevs, foundPaths) {
  if (source === target) {
    return [source];
  }
  if (foundPaths[target]) {
    return foundPaths[target];
  }
  var paths = [];
  for (var _i2 = 0, _a2 = prevs[target]; _i2 < _a2.length; _i2++) {
    var prev = _a2[_i2];
    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);
    if (!prevPaths)
      return;
    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {
      var prePath = prevPaths_1[_b];
      if (is_array_default(prePath))
        paths.push(__spreadArray2(__spreadArray2([], prePath, true), [target], false));
      else
        paths.push([prePath, target]);
    }
  }
  foundPaths[target] = paths;
  return foundPaths[target];
}

// node_modules/@antv/algorithm/es/find-path.js
var findShortestPath = function findShortestPath2(graphData, start, end2, directed, weightPropertyName) {
  var _a2 = dijkstra_default(graphData, start, directed, weightPropertyName), length5 = _a2.length, path = _a2.path, allPath = _a2.allPath;
  return {
    length: length5[end2],
    path: path[end2],
    allPath: allPath[end2]
  };
};
var findAllPath = function findAllPath2(graphData, start, end2, directed) {
  var _a2;
  if (start === end2)
    return [[start]];
  var _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var visited = [start];
  var isVisited = (_a2 = {}, _a2[start] = true, _a2);
  var stack = [];
  var allPath = [];
  var neighbors = directed ? getNeighbors(start, edges, "target") : getNeighbors(start, edges);
  stack.push(neighbors);
  while (visited.length > 0 && stack.length > 0) {
    var children = stack[stack.length - 1];
    if (children.length) {
      var child = children.shift();
      if (child) {
        visited.push(child);
        isVisited[child] = true;
        neighbors = directed ? getNeighbors(child, edges, "target") : getNeighbors(child, edges);
        stack.push(neighbors.filter(function(neighbor) {
          return !isVisited[neighbor];
        }));
      }
    } else {
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
      continue;
    }
    if (visited[visited.length - 1] === end2) {
      var path = visited.map(function(node2) {
        return node2;
      });
      allPath.push(path);
      var node = visited.pop();
      isVisited[node] = false;
      stack.pop();
    }
  }
  return allPath;
};

// node_modules/@antv/algorithm/es/floydWarshall.js
var floydWarshall = function floydWarshall2(graphData, directed) {
  var adjacentMatrix = adjacent_matrix_default(graphData, directed);
  var dist4 = [];
  var size2 = adjacentMatrix.length;
  for (var i2 = 0; i2 < size2; i2 += 1) {
    dist4[i2] = [];
    for (var j2 = 0; j2 < size2; j2 += 1) {
      if (i2 === j2) {
        dist4[i2][j2] = 0;
      } else if (adjacentMatrix[i2][j2] === 0 || !adjacentMatrix[i2][j2]) {
        dist4[i2][j2] = Infinity;
      } else {
        dist4[i2][j2] = adjacentMatrix[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size2; k2 += 1) {
    for (var i2 = 0; i2 < size2; i2 += 1) {
      for (var j2 = 0; j2 < size2; j2 += 1) {
        if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
          dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
        }
      }
    }
  }
  return dist4;
};
var floydWarshall_default = floydWarshall;

// node_modules/@antv/algorithm/es/label-propagation.js
var labelPropagation = function labelPropagation2(graphData, directed, weightPropertyName, maxIteration) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (maxIteration === void 0) {
    maxIteration = 1e3;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = uniqueId();
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry)
        return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
    });
    ks.push(k2);
  });
  var iter = 0;
  var _loop_1 = function _loop_12() {
    var changed = false;
    nodes.forEach(function(node) {
      var neighborClusters = {};
      Object.keys(neighbors[node.id]).forEach(function(neighborId) {
        var neighborWeight = neighbors[node.id][neighborId];
        var neighborNode = nodeMap[neighborId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (!neighborClusters[neighborClusterId])
          neighborClusters[neighborClusterId] = 0;
        neighborClusters[neighborClusterId] += neighborWeight;
      });
      var maxWeight = -Infinity;
      var bestClusterIds = [];
      Object.keys(neighborClusters).forEach(function(clusterId) {
        if (maxWeight < neighborClusters[clusterId]) {
          maxWeight = neighborClusters[clusterId];
          bestClusterIds = [clusterId];
        } else if (maxWeight === neighborClusters[clusterId]) {
          bestClusterIds.push(clusterId);
        }
      });
      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId)
        return;
      var selfClusterIdx = bestClusterIds.indexOf(node.clusterId);
      if (selfClusterIdx >= 0)
        bestClusterIds.splice(selfClusterIdx, 1);
      if (bestClusterIds && bestClusterIds.length) {
        changed = true;
        var selfCluster = clusters[node.clusterId];
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var randomIdx = Math.floor(Math.random() * bestClusterIds.length);
        var bestCluster = clusters[bestClusterIds[randomIdx]];
        bestCluster.nodes.push(node);
        node.clusterId = bestCluster.id;
      }
    });
    if (!changed)
      return "break";
    iter++;
  };
  while (iter < maxIteration) {
    var state_1 = _loop_1();
    if (state_1 === "break")
      break;
  }
  Object.keys(clusters).forEach(function(clusterId) {
    var cluster = clusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete clusters[clusterId];
    }
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(clusters).forEach(function(clusterId) {
    clustersArray.push(clusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var label_propagation_default = labelPropagation;

// node_modules/@antv/algorithm/es/louvain.js
init_esm();

// node_modules/@antv/algorithm/es/utils/vector.js
init_esm();
var Vector = function() {
  function Vector2(arr) {
    this.arr = arr;
  }
  Vector2.prototype.getArr = function() {
    return this.arr || [];
  };
  Vector2.prototype.add = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return new Vector2(otherArr);
    }
    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return new Vector2(this.arr);
    }
    if (this.arr.length === otherArr.length) {
      var res = [];
      for (var index in this.arr) {
        res[index] = this.arr[index] + otherArr[index];
      }
      return new Vector2(res);
    }
  };
  Vector2.prototype.subtract = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return new Vector2(otherArr);
    }
    if (!(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return new Vector2(this.arr);
    }
    if (this.arr.length === otherArr.length) {
      var res = [];
      for (var index in this.arr) {
        res[index] = this.arr[index] - otherArr[index];
      }
      return new Vector2(res);
    }
  };
  Vector2.prototype.avg = function(length5) {
    var res = [];
    if (length5 !== 0) {
      for (var index in this.arr) {
        res[index] = this.arr[index] / length5;
      }
    }
    return new Vector2(res);
  };
  Vector2.prototype.negate = function() {
    var res = [];
    for (var index in this.arr) {
      res[index] = -this.arr[index];
    }
    return new Vector2(res);
  };
  Vector2.prototype.squareEuclideanDistance = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return 0;
    }
    if (this.arr.length === otherArr.length) {
      var res = 0;
      for (var index in this.arr) {
        res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
      }
      return res;
    }
  };
  Vector2.prototype.euclideanDistance = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return 0;
    }
    if (this.arr.length === otherArr.length) {
      var res = 0;
      for (var index in this.arr) {
        res += Math.pow(this.arr[index] - otherVector.arr[index], 2);
      }
      return Math.sqrt(res);
    } else {
      console.error("The two vectors are unequal in length.");
    }
  };
  Vector2.prototype.normalize = function() {
    var res = [];
    var cloneArr = clone_default(this.arr);
    cloneArr.sort(function(a2, b10) {
      return a2 - b10;
    });
    var max7 = cloneArr[cloneArr.length - 1];
    var min6 = cloneArr[0];
    for (var index in this.arr) {
      res[index] = (this.arr[index] - min6) / (max7 - min6);
    }
    return new Vector2(res);
  };
  Vector2.prototype.norm2 = function() {
    var _a2;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length)) {
      return 0;
    }
    var res = 0;
    for (var index in this.arr) {
      res += Math.pow(this.arr[index], 2);
    }
    return Math.sqrt(res);
  };
  Vector2.prototype.dot = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (!((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) || !(otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return 0;
    }
    if (this.arr.length === otherArr.length) {
      var res = 0;
      for (var index in this.arr) {
        res += this.arr[index] * otherVector.arr[index];
      }
      return res;
    } else {
      console.error("The two vectors are unequal in length.");
    }
  };
  Vector2.prototype.equal = function(otherVector) {
    var _a2;
    var otherArr = otherVector.arr;
    if (((_a2 = this.arr) === null || _a2 === void 0 ? void 0 : _a2.length) !== (otherArr === null || otherArr === void 0 ? void 0 : otherArr.length)) {
      return false;
    }
    for (var index in this.arr) {
      if (this.arr[index] !== otherArr[index]) {
        return false;
      }
    }
    return true;
  };
  return Vector2;
}();
var vector_default = Vector;

// node_modules/@antv/algorithm/es/utils/node-properties.js
var getAllProperties = function getAllProperties2(nodes, key) {
  if (key === void 0) {
    key = void 0;
  }
  var allProperties = [];
  nodes.forEach(function(node) {
    if (key === void 0) {
      allProperties.push(node);
    }
    if (node[key] !== void 0) {
      allProperties.push(node[key]);
    }
  });
  return allProperties;
};

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
init_esm();

// node_modules/@antv/algorithm/es/types.js
var DistanceType;
(function(DistanceType2) {
  DistanceType2["EuclideanDistance"] = "euclideanDistance";
})(DistanceType || (DistanceType = {}));

// node_modules/@antv/algorithm/es/utils/data-preprocessing.js
var getAllKeyValueMap = function getAllKeyValueMap2(dataList, involvedKeys, uninvolvedKeys) {
  var keys2 = [];
  if (involvedKeys === null || involvedKeys === void 0 ? void 0 : involvedKeys.length) {
    keys2 = involvedKeys;
  } else {
    dataList.forEach(function(data) {
      keys2 = keys2.concat(Object.keys(data));
    });
    keys2 = uniq(keys2);
  }
  var allKeyValueMap = {};
  keys2.forEach(function(key) {
    var value = [];
    dataList.forEach(function(data) {
      if (data[key] !== void 0 && data[key] !== "") {
        value.push(data[key]);
      }
    });
    if (value.length && !(uninvolvedKeys === null || uninvolvedKeys === void 0 ? void 0 : uninvolvedKeys.includes(key))) {
      allKeyValueMap[key] = uniq(value);
    }
  });
  return allKeyValueMap;
};
var oneHot = function oneHot2(dataList, involvedKeys, uninvolvedKeys) {
  var allKeyValueMap = getAllKeyValueMap(dataList, involvedKeys, uninvolvedKeys);
  var oneHotCode = [];
  if (!Object.keys(allKeyValueMap).length) {
    return oneHotCode;
  }
  dataList.forEach(function(data, index) {
    var code = [];
    if (Object.keys(allKeyValueMap).length === 1) {
      var key = Object.keys(allKeyValueMap)[0];
      var keyValue = allKeyValueMap[key];
      if (keyValue.every(function(value) {
        return !isNaN(Number(value));
      })) {
        code = [data[key]];
      }
    } else {
      Object.keys(allKeyValueMap).forEach(function(key2) {
        var keyValue2 = data[key2];
        var allKeyValue = allKeyValueMap[key2];
        var valueIndex = allKeyValue.findIndex(function(value) {
          return keyValue2 === value;
        });
        var subCode = [];
        for (var i2 = 0; i2 < allKeyValue.length; i2++) {
          if (i2 === valueIndex) {
            subCode.push(1);
          } else {
            subCode.push(0);
          }
        }
        code = code.concat(subCode);
      });
    }
    oneHotCode[index] = code;
  });
  return oneHotCode;
};
var getDistance = function getDistance2(item, otherItem, distanceType, graphData) {
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var distance11 = 0;
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      distance11 = new vector_default(item).euclideanDistance(new vector_default(otherItem));
      break;
    default:
      break;
  }
  return distance11;
};

// node_modules/@antv/algorithm/es/louvain.js
var getModularity = function getModularity2(nodes, adjMatrix3, ks, m2) {
  var length5 = adjMatrix3.length;
  var param = 2 * m2;
  var modularity = 0;
  for (var i2 = 0; i2 < length5; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length5; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (clusteri !== clusterj)
        continue;
      var entry = adjMatrix3[i2][j2] || 0;
      var ki2 = ks[i2] || 0;
      var kj = ks[j2] || 0;
      modularity += entry - ki2 * kj / param;
    }
  }
  modularity *= 1 / param;
  return modularity;
};
var getInertialModularity = function getInertialModularity2(nodes, allPropertiesWeight) {
  if (nodes === void 0) {
    nodes = [];
  }
  var length5 = nodes.length;
  var totalProperties = new vector_default([]);
  for (var i2 = 0; i2 < length5; i2++) {
    totalProperties = totalProperties.add(new vector_default(allPropertiesWeight[i2]));
  }
  var avgProperties = totalProperties.avg(length5);
  avgProperties.normalize();
  var variance = 0;
  for (var i2 = 0; i2 < length5; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    var squareEuclideanDistance = propertiesi.squareEuclideanDistance(avgProperties);
    variance += squareEuclideanDistance;
  }
  var squareEuclideanDistanceInfo = [];
  nodes.forEach(function() {
    squareEuclideanDistanceInfo.push([]);
  });
  for (var i2 = 0; i2 < length5; i2++) {
    var propertiesi = new vector_default(allPropertiesWeight[i2]);
    nodes[i2]["clusterInertial"] = 0;
    for (var j2 = 0; j2 < length5; j2++) {
      if (i2 === j2) {
        squareEuclideanDistanceInfo[i2][j2] = 0;
        continue;
      }
      var propertiesj = new vector_default(allPropertiesWeight[j2]);
      squareEuclideanDistanceInfo[i2][j2] = propertiesi.squareEuclideanDistance(propertiesj);
      nodes[i2]["clusterInertial"] += squareEuclideanDistanceInfo[i2][j2];
    }
  }
  var inertialModularity = 0;
  var param = 2 * length5 * variance;
  for (var i2 = 0; i2 < length5; i2++) {
    var clusteri = nodes[i2].clusterId;
    for (var j2 = 0; j2 < length5; j2++) {
      var clusterj = nodes[j2].clusterId;
      if (i2 === j2 || clusteri !== clusterj)
        continue;
      var inertial = nodes[i2].clusterInertial * nodes[j2].clusterInertial / Math.pow(param, 2) - squareEuclideanDistanceInfo[i2][j2] / param;
      inertialModularity += inertial;
    }
  }
  return Number(inertialModularity.toFixed(4));
};
var louvain = function louvain2(graphData, directed, weightPropertyName, threshold, inertialModularity, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (inertialModularity === void 0) {
    inertialModularity = false;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var allPropertiesWeight = [];
  if (inertialModularity) {
    nodes.forEach(function(node, index) {
      node.properties = node.properties || {};
      node.originIndex = index;
    });
    var nodeTypeInfo_1 = [];
    if (nodes.every(function(node) {
      return node.hasOwnProperty("nodeType");
    })) {
      nodeTypeInfo_1 = Array.from(new Set(nodes.map(function(node) {
        return node.nodeType;
      })));
      nodes.forEach(function(node) {
        node.properties.nodeType = nodeTypeInfo_1.findIndex(function(nodeType) {
          return nodeType === node.nodeType;
        });
      });
    }
    var properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  var uniqueId5 = 1;
  var clusters = {};
  var nodeMap = {};
  nodes.forEach(function(node, i2) {
    var cid = String(uniqueId5++);
    node.clusterId = cid;
    clusters[cid] = {
      id: cid,
      nodes: [node]
    };
    nodeMap[node.id] = {
      node,
      idx: i2
    };
  });
  var adjMatrix3 = adjacent_matrix_default(graphData, directed);
  var ks = [];
  var neighbors = {};
  var m2 = 0;
  adjMatrix3.forEach(function(row, i2) {
    var k2 = 0;
    var iid = nodes[i2].id;
    neighbors[iid] = {};
    row.forEach(function(entry, j2) {
      if (!entry)
        return;
      k2 += entry;
      var jid = nodes[j2].id;
      neighbors[iid][jid] = entry;
      m2 += entry;
    });
    ks.push(k2);
  });
  m2 /= 2;
  var totalModularity = Infinity;
  var previousModularity = Infinity;
  var iter = 0;
  var finalNodes = [];
  var finalClusters = {};
  while (true) {
    if (inertialModularity && nodes.every(function(node) {
      return node.hasOwnProperty("properties");
    })) {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m2) + getInertialModularity(nodes, allPropertiesWeight) * inertialWeight;
    } else {
      totalModularity = getModularity(nodes, adjMatrix3, ks, m2);
    }
    if (iter === 0) {
      previousModularity = totalModularity;
      finalNodes = nodes;
      finalClusters = clusters;
    }
    var increaseWithinThreshold = totalModularity > 0 && totalModularity > previousModularity && totalModularity - previousModularity < threshold;
    if (totalModularity > previousModularity) {
      finalNodes = nodes.map(function(node) {
        return {
          node,
          clusterId: node.clusterId
        };
      });
      finalClusters = clone_default(clusters);
      previousModularity = totalModularity;
    }
    if (increaseWithinThreshold || iter > 100) {
      break;
    }
    ;
    iter++;
    Object.keys(clusters).forEach(function(clusterId) {
      var sumTot = 0;
      edges.forEach(function(edge) {
        var source = edge.source, target = edge.target;
        var sourceClusterId = nodeMap[source].node.clusterId;
        var targetClusterId = nodeMap[target].node.clusterId;
        if (sourceClusterId === clusterId && targetClusterId !== clusterId || targetClusterId === clusterId && sourceClusterId !== clusterId) {
          sumTot = sumTot + (edge[weightPropertyName] || 1);
        }
      });
      clusters[clusterId].sumTot = sumTot;
    });
    nodes.forEach(function(node, i2) {
      var selfCluster = clusters[node.clusterId];
      var bestIncrease = 0;
      var bestCluster;
      var commonParam = ks[i2] / (2 * m2);
      var kiin = 0;
      var selfClusterNodes = selfCluster.nodes;
      selfClusterNodes.forEach(function(scNode) {
        var scNodeIdx = nodeMap[scNode.id].idx;
        kiin += adjMatrix3[i2][scNodeIdx] || 0;
      });
      var removeModurarity = kiin - selfCluster.sumTot * commonParam;
      var selfClusterNodesAfterRemove = selfClusterNodes.filter(function(scNode) {
        return scNode.id !== node.id;
      });
      var propertiesWeightRemove = [];
      selfClusterNodesAfterRemove.forEach(function(nodeRemove, index) {
        propertiesWeightRemove[index] = allPropertiesWeight[nodeRemove.originIndex];
      });
      var removeInertialModularity = getInertialModularity(selfClusterNodesAfterRemove, allPropertiesWeight) * inertialWeight;
      var nodeNeighborIds = neighbors[node.id];
      Object.keys(nodeNeighborIds).forEach(function(neighborNodeId) {
        var neighborNode = nodeMap[neighborNodeId].node;
        var neighborClusterId = neighborNode.clusterId;
        if (neighborClusterId === node.clusterId)
          return;
        var neighborCluster = clusters[neighborClusterId];
        var clusterNodes = neighborCluster.nodes;
        if (!clusterNodes || !clusterNodes.length)
          return;
        var neighborClusterKiin = 0;
        clusterNodes.forEach(function(cNode) {
          var cNodeIdx = nodeMap[cNode.id].idx;
          neighborClusterKiin += adjMatrix3[i2][cNodeIdx] || 0;
        });
        var addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;
        var clusterNodesAfterAdd = clusterNodes.concat([node]);
        var propertiesWeightAdd = [];
        clusterNodesAfterAdd.forEach(function(nodeAdd, index) {
          propertiesWeightAdd[index] = allPropertiesWeight[nodeAdd.originIndex];
        });
        var addInertialModularity = getInertialModularity(clusterNodesAfterAdd, allPropertiesWeight) * inertialWeight;
        var increase = addModurarity - removeModurarity;
        if (inertialModularity) {
          increase = addModurarity + addInertialModularity - (removeModurarity + removeInertialModularity);
        }
        if (increase > bestIncrease) {
          bestIncrease = increase;
          bestCluster = neighborCluster;
        }
      });
      if (bestIncrease > 0) {
        bestCluster.nodes.push(node);
        var previousClusterId_1 = node.clusterId;
        node.clusterId = bestCluster.id;
        var nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);
        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);
        var neighborClusterSumTot_1 = 0;
        var selfClusterSumTot_1 = 0;
        edges.forEach(function(edge) {
          var source = edge.source, target = edge.target;
          var sourceClusterId = nodeMap[source].node.clusterId;
          var targetClusterId = nodeMap[target].node.clusterId;
          if (sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id || targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id) {
            neighborClusterSumTot_1 = neighborClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
          if (sourceClusterId === previousClusterId_1 && targetClusterId !== previousClusterId_1 || targetClusterId === previousClusterId_1 && sourceClusterId !== previousClusterId_1) {
            selfClusterSumTot_1 = selfClusterSumTot_1 + (edge[weightPropertyName] || 1);
          }
        });
        bestCluster.sumTot = neighborClusterSumTot_1;
        selfCluster.sumTot = selfClusterSumTot_1;
      }
    });
  }
  var newClusterIdMap = {};
  var clusterIdx = 0;
  Object.keys(finalClusters).forEach(function(clusterId) {
    var cluster = finalClusters[clusterId];
    if (!cluster.nodes || !cluster.nodes.length) {
      delete finalClusters[clusterId];
      return;
    }
    var newId = String(clusterIdx + 1);
    if (newId === clusterId) {
      return;
    }
    cluster.id = newId;
    cluster.nodes = cluster.nodes.map(function(item) {
      return {
        id: item.id,
        clusterId: newId
      };
    });
    finalClusters[newId] = cluster;
    newClusterIdMap[clusterId] = newId;
    delete finalClusters[clusterId];
    clusterIdx++;
  });
  finalNodes.forEach(function(nodeInfo) {
    var node = nodeInfo.node, clusterId = nodeInfo.clusterId;
    node.clusterId = clusterId;
    if (node.clusterId && newClusterIdMap[node.clusterId])
      node.clusterId = newClusterIdMap[node.clusterId];
  });
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var source = edge.source, target = edge.target;
    var weight = edge[weightPropertyName] || 1;
    var sourceClusterId = nodeMap[source].node.clusterId;
    var targetClusterId = nodeMap[target].node.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].weight += weight;
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        weight,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  var clustersArray = [];
  Object.keys(finalClusters).forEach(function(clusterId) {
    clustersArray.push(finalClusters[clusterId]);
  });
  return {
    clusters: clustersArray,
    clusterEdges
  };
};
var louvain_default = louvain;

// node_modules/@antv/algorithm/es/i-louvain.js
var iLouvain = function iLouvain2(graphData, directed, weightPropertyName, threshold, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight) {
  if (directed === void 0) {
    directed = false;
  }
  if (weightPropertyName === void 0) {
    weightPropertyName = "weight";
  }
  if (threshold === void 0) {
    threshold = 1e-4;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (inertialWeight === void 0) {
    inertialWeight = 1;
  }
  return louvain_default(graphData, directed, weightPropertyName, threshold, true, propertyKey, involvedKeys, uninvolvedKeys, inertialWeight);
};
var i_louvain_default = iLouvain;

// node_modules/@antv/algorithm/es/k-core.js
init_esm();
var kCore = function kCore2(graphData, k2) {
  var _a2;
  if (k2 === void 0) {
    k2 = 1;
  }
  var data = clone_default(graphData);
  var _b = data.nodes, nodes = _b === void 0 ? [] : _b;
  var _c = data.edges, edges = _c === void 0 ? [] : _c;
  var _loop_1 = function _loop_12() {
    var degrees2 = degree_default({
      nodes,
      edges
    });
    var nodeIds = Object.keys(degrees2);
    nodeIds.sort(function(a2, b10) {
      var _a3, _b2;
      return ((_a3 = degrees2[a2]) === null || _a3 === void 0 ? void 0 : _a3.degree) - ((_b2 = degrees2[b10]) === null || _b2 === void 0 ? void 0 : _b2.degree);
    });
    var minIndexId = nodeIds[0];
    if (!nodes.length || ((_a2 = degrees2[minIndexId]) === null || _a2 === void 0 ? void 0 : _a2.degree) >= k2) {
      return "break";
    }
    var originIndex = nodes.findIndex(function(node) {
      return node.id === minIndexId;
    });
    nodes.splice(originIndex, 1);
    edges = edges.filter(function(edge) {
      return !(edge.source === minIndexId || edge.target === minIndexId);
    });
  };
  while (true) {
    var state_1 = _loop_1();
    if (state_1 === "break")
      break;
  }
  return {
    nodes,
    edges
  };
};
var k_core_default = kCore;

// node_modules/@antv/algorithm/es/k-means.js
init_esm();
var getCentroid = function getCentroid2(distanceType, allPropertiesWeight, index) {
  var centroid = [];
  switch (distanceType) {
    case DistanceType.EuclideanDistance:
      centroid = allPropertiesWeight[index];
      break;
    default:
      centroid = [];
      break;
  }
  return centroid;
};
var kMeans = function kMeans2(data, k2, propertyKey, involvedKeys, uninvolvedKeys, distanceType) {
  if (k2 === void 0) {
    k2 = 3;
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = ["id"];
  }
  if (distanceType === void 0) {
    distanceType = DistanceType.EuclideanDistance;
  }
  var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b;
  var defaultClusterInfo = {
    clusters: [{
      id: "0",
      nodes
    }],
    clusterEdges: []
  };
  if (distanceType === DistanceType.EuclideanDistance && !nodes.every(function(node) {
    return node.hasOwnProperty(propertyKey);
  })) {
    return defaultClusterInfo;
  }
  var properties = [];
  var allPropertiesWeight = [];
  if (distanceType === DistanceType.EuclideanDistance) {
    properties = getAllProperties(nodes, propertyKey);
    allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  }
  if (!allPropertiesWeight.length) {
    return defaultClusterInfo;
  }
  var allPropertiesWeightUniq = uniq(allPropertiesWeight.map(function(item) {
    return item.join("");
  }));
  var finalK = Math.min(k2, nodes.length, allPropertiesWeightUniq.length);
  for (var i2 = 0; i2 < nodes.length; i2++) {
    nodes[i2].originIndex = i2;
  }
  var centroids = [];
  var centroidIndexList = [];
  var clusters = [];
  for (var i2 = 0; i2 < finalK; i2++) {
    if (i2 === 0) {
      var randomIndex = Math.floor(Math.random() * nodes.length);
      switch (distanceType) {
        case DistanceType.EuclideanDistance:
          centroids[i2] = allPropertiesWeight[randomIndex];
          break;
        default:
          centroids[i2] = [];
          break;
      }
      centroidIndexList.push(randomIndex);
      clusters[i2] = [nodes[randomIndex]];
      nodes[randomIndex].clusterId = String(i2);
    } else {
      var maxDistance = -Infinity;
      var maxDistanceNodeIndex = 0;
      var _loop_1 = function _loop_12(m3) {
        if (!centroidIndexList.includes(m3)) {
          var totalDistance = 0;
          for (var j3 = 0; j3 < centroids.length; j3++) {
            var distance12 = 0;
            switch (distanceType) {
              case DistanceType.EuclideanDistance:
                distance12 = getDistance(allPropertiesWeight[nodes[m3].originIndex], centroids[j3], distanceType);
                break;
              default:
                break;
            }
            totalDistance += distance12;
          }
          var avgDistance = totalDistance / centroids.length;
          if (avgDistance > maxDistance && !centroids.find(function(centroid) {
            return is_equal_default(centroid, getCentroid(distanceType, allPropertiesWeight, nodes[m3].originIndex));
          })) {
            maxDistance = avgDistance;
            maxDistanceNodeIndex = m3;
          }
        }
      };
      for (var m2 = 0; m2 < nodes.length; m2++) {
        _loop_1(m2);
      }
      centroids[i2] = getCentroid(distanceType, allPropertiesWeight, maxDistanceNodeIndex);
      centroidIndexList.push(maxDistanceNodeIndex);
      clusters[i2] = [nodes[maxDistanceNodeIndex]];
      nodes[maxDistanceNodeIndex].clusterId = String(i2);
    }
  }
  var iterations = 0;
  while (true) {
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var minDistanceIndex = 0;
      var minDistance = Infinity;
      if (!(iterations === 0 && centroidIndexList.includes(i2))) {
        for (var j2 = 0; j2 < centroids.length; j2++) {
          var distance11 = 0;
          switch (distanceType) {
            case DistanceType.EuclideanDistance:
              distance11 = getDistance(allPropertiesWeight[i2], centroids[j2], distanceType);
              break;
            default:
              break;
          }
          if (distance11 < minDistance) {
            minDistance = distance11;
            minDistanceIndex = j2;
          }
        }
        if (nodes[i2].clusterId !== void 0) {
          for (var n2 = clusters[Number(nodes[i2].clusterId)].length - 1; n2 >= 0; n2--) {
            if (clusters[Number(nodes[i2].clusterId)][n2].id === nodes[i2].id) {
              clusters[Number(nodes[i2].clusterId)].splice(n2, 1);
            }
          }
        }
        nodes[i2].clusterId = String(minDistanceIndex);
        clusters[minDistanceIndex].push(nodes[i2]);
      }
    }
    var centroidsEqualAvg = false;
    for (var i2 = 0; i2 < clusters.length; i2++) {
      var clusterNodes = clusters[i2];
      var totalVector = new vector_default([]);
      for (var j2 = 0; j2 < clusterNodes.length; j2++) {
        totalVector = totalVector.add(new vector_default(allPropertiesWeight[clusterNodes[j2].originIndex]));
      }
      var avgVector = totalVector.avg(clusterNodes.length);
      if (!avgVector.equal(new vector_default(centroids[i2]))) {
        centroidsEqualAvg = true;
        centroids[i2] = avgVector.getArr();
      }
    }
    iterations++;
    if (nodes.every(function(node) {
      return node.clusterId !== void 0;
    }) && centroidsEqualAvg || iterations >= 1e3) {
      break;
    }
  }
  var clusterEdges = [];
  var clusterEdgeMap = {};
  edges.forEach(function(edge) {
    var _a3, _b2;
    var source = edge.source, target = edge.target;
    var sourceClusterId = (_a3 = nodes.find(function(node) {
      return node.id === source;
    })) === null || _a3 === void 0 ? void 0 : _a3.clusterId;
    var targetClusterId = (_b2 = nodes.find(function(node) {
      return node.id === target;
    })) === null || _b2 === void 0 ? void 0 : _b2.clusterId;
    var newEdgeId = "".concat(sourceClusterId, "---").concat(targetClusterId);
    if (clusterEdgeMap[newEdgeId]) {
      clusterEdgeMap[newEdgeId].count++;
    } else {
      var newEdge = {
        source: sourceClusterId,
        target: targetClusterId,
        count: 1
      };
      clusterEdgeMap[newEdgeId] = newEdge;
      clusterEdges.push(newEdge);
    }
  });
  return {
    clusters,
    clusterEdges
  };
};
var k_means_default = kMeans;

// node_modules/@antv/algorithm/es/cosine-similarity.js
var cosineSimilarity = function cosineSimilarity2(item, targetItem) {
  var targetItemVector = new vector_default(targetItem);
  var targetNodeNorm2 = targetItemVector.norm2();
  var itemVector = new vector_default(item);
  var itemNorm2 = itemVector.norm2();
  var dot6 = targetItemVector.dot(itemVector);
  var norm2Product = targetNodeNorm2 * itemNorm2;
  var cosineSimilarity3 = norm2Product ? dot6 / norm2Product : 0;
  return cosineSimilarity3;
};
var cosine_similarity_default = cosineSimilarity;

// node_modules/@antv/algorithm/es/nodes-cosine-similarity.js
init_esm();
var nodesCosineSimilarity = function nodesCosineSimilarity2(nodes, seedNode, propertyKey, involvedKeys, uninvolvedKeys) {
  if (nodes === void 0) {
    nodes = [];
  }
  if (propertyKey === void 0) {
    propertyKey = void 0;
  }
  if (involvedKeys === void 0) {
    involvedKeys = [];
  }
  if (uninvolvedKeys === void 0) {
    uninvolvedKeys = [];
  }
  var similarNodes = clone_default(nodes.filter(function(node) {
    return node.id !== seedNode.id;
  }));
  var seedNodeIndex = nodes.findIndex(function(node) {
    return node.id === seedNode.id;
  });
  var properties = getAllProperties(nodes, propertyKey);
  var allPropertiesWeight = oneHot(properties, involvedKeys, uninvolvedKeys);
  var seedNodeProperties = allPropertiesWeight[seedNodeIndex];
  var allCosineSimilarity = [];
  similarNodes.forEach(function(node, index) {
    if (node.id !== seedNode.id) {
      var nodeProperties = allPropertiesWeight[index];
      var cosineSimilarityValue = cosine_similarity_default(nodeProperties, seedNodeProperties);
      allCosineSimilarity.push(cosineSimilarityValue);
      node.cosineSimilarity = cosineSimilarityValue;
    }
  });
  similarNodes.sort(function(a2, b10) {
    return b10.cosineSimilarity - a2.cosineSimilarity;
  });
  return {
    allCosineSimilarity,
    similarNodes
  };
};
var nodes_cosine_similarity_default = nodesCosineSimilarity;

// node_modules/@antv/algorithm/es/structs/union-find.js
var UnionFind = function() {
  function UnionFind2(items) {
    this.count = items.length;
    this.parent = {};
    for (var _i2 = 0, items_1 = items; _i2 < items_1.length; _i2++) {
      var i2 = items_1[_i2];
      this.parent[i2] = i2;
    }
  }
  UnionFind2.prototype.find = function(item) {
    while (this.parent[item] !== item) {
      item = this.parent[item];
    }
    return item;
  };
  UnionFind2.prototype.union = function(a2, b10) {
    var rootA = this.find(a2);
    var rootB = this.find(b10);
    if (rootA === rootB)
      return;
    if (rootA < rootB) {
      if (this.parent[b10] !== b10)
        this.union(this.parent[b10], a2);
      this.parent[b10] = this.parent[a2];
    } else {
      if (this.parent[a2] !== a2)
        this.union(this.parent[a2], b10);
      this.parent[a2] = this.parent[b10];
    }
  };
  UnionFind2.prototype.connected = function(a2, b10) {
    return this.find(a2) === this.find(b10);
  };
  return UnionFind2;
}();
var union_find_default = UnionFind;

// node_modules/@antv/algorithm/es/structs/binary-heap.js
var defaultCompare = function defaultCompare2(a2, b10) {
  return a2 - b10;
};
var MinBinaryHeap = function() {
  function MinBinaryHeap2(compareFn) {
    if (compareFn === void 0) {
      compareFn = defaultCompare;
    }
    this.compareFn = compareFn;
    this.list = [];
  }
  MinBinaryHeap2.prototype.getLeft = function(index) {
    return 2 * index + 1;
  };
  MinBinaryHeap2.prototype.getRight = function(index) {
    return 2 * index + 2;
  };
  MinBinaryHeap2.prototype.getParent = function(index) {
    if (index === 0) {
      return null;
    }
    return Math.floor((index - 1) / 2);
  };
  MinBinaryHeap2.prototype.isEmpty = function() {
    return this.list.length <= 0;
  };
  MinBinaryHeap2.prototype.top = function() {
    return this.isEmpty() ? void 0 : this.list[0];
  };
  MinBinaryHeap2.prototype.delMin = function() {
    var top = this.top();
    var bottom = this.list.pop();
    if (this.list.length > 0) {
      this.list[0] = bottom;
      this.moveDown(0);
    }
    return top;
  };
  MinBinaryHeap2.prototype.insert = function(value) {
    if (value !== null) {
      this.list.push(value);
      var index = this.list.length - 1;
      this.moveUp(index);
      return true;
    }
    return false;
  };
  MinBinaryHeap2.prototype.moveUp = function(index) {
    var parent = this.getParent(index);
    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {
      var tmp = this.list[parent];
      this.list[parent] = this.list[index];
      this.list[index] = tmp;
      index = parent;
      parent = this.getParent(index);
    }
  };
  MinBinaryHeap2.prototype.moveDown = function(index) {
    var _a2;
    var element = index;
    var left = this.getLeft(index);
    var right = this.getRight(index);
    var size2 = this.list.length;
    if (left !== null && left < size2 && this.compareFn(this.list[element], this.list[left]) > 0) {
      element = left;
    } else if (right !== null && right < size2 && this.compareFn(this.list[element], this.list[right]) > 0) {
      element = right;
    }
    if (index !== element) {
      _a2 = [this.list[element], this.list[index]], this.list[index] = _a2[0], this.list[element] = _a2[1];
      this.moveDown(element);
    }
  };
  return MinBinaryHeap2;
}();
var binary_heap_default = MinBinaryHeap;

// node_modules/@antv/algorithm/es/mts.js
var primMST = function primMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var currNode = nodes[0];
  var visited = /* @__PURE__ */ new Set();
  visited.add(currNode);
  var compareWeight = function compareWeight2(a2, b10) {
    if (weight) {
      return a2.weight - b10.weight;
    }
    return 0;
  };
  var edgeQueue = new binary_heap_default(compareWeight);
  getEdgesByNodeId(currNode.id, edges).forEach(function(edge) {
    edgeQueue.insert(edge);
  });
  while (!edgeQueue.isEmpty()) {
    var currEdge = edgeQueue.delMin();
    var source = currEdge.source;
    var target = currEdge.target;
    if (visited.has(source) && visited.has(target))
      continue;
    selectedEdges.push(currEdge);
    if (!visited.has(source)) {
      visited.add(source);
      getEdgesByNodeId(source, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
    if (!visited.has(target)) {
      visited.add(target);
      getEdgesByNodeId(target, edges).forEach(function(edge) {
        edgeQueue.insert(edge);
      });
    }
  }
  return selectedEdges;
};
var kruskalMST = function kruskalMST2(graphData, weight) {
  var selectedEdges = [];
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  if (nodes.length === 0) {
    return selectedEdges;
  }
  var weightEdges = edges.map(function(edge) {
    return edge;
  });
  if (weight) {
    weightEdges.sort(function(a2, b10) {
      return a2.weight - b10.weight;
    });
  }
  var disjointSet = new union_find_default(nodes.map(function(n2) {
    return n2.id;
  }));
  while (weightEdges.length > 0) {
    var curEdge = weightEdges.shift();
    var source = curEdge.source;
    var target = curEdge.target;
    if (!disjointSet.connected(source, target)) {
      selectedEdges.push(curEdge);
      disjointSet.union(source, target);
    }
  }
  return selectedEdges;
};
var minimumSpanningTree = function minimumSpanningTree2(graphData, weight, algo) {
  var algos = {
    prim: primMST,
    kruskal: kruskalMST
  };
  if (!algo)
    return kruskalMST(graphData, weight);
  return algos[algo](graphData, weight);
};
var mts_default = minimumSpanningTree;

// node_modules/@antv/algorithm/es/pageRank.js
var pageRank = function pageRank2(graphData, epsilon, linkProb) {
  if (typeof epsilon !== "number")
    epsilon = 1e-6;
  if (typeof linkProb !== "number")
    linkProb = 0.85;
  var distance11 = 1;
  var leakedRank = 0;
  var maxIterations = 1e3;
  var _a2 = graphData.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = graphData.edges, edges = _b === void 0 ? [] : _b;
  var nodesCount = nodes.length;
  var currentRank;
  var curRanks = {};
  var prevRanks = {};
  for (var j2 = 0; j2 < nodesCount; ++j2) {
    var node = nodes[j2];
    var nodeId = node.id;
    curRanks[nodeId] = 1 / nodesCount;
    prevRanks[nodeId] = 1 / nodesCount;
  }
  var nodeDegree = degree_default(graphData);
  while (maxIterations > 0 && distance11 > epsilon) {
    leakedRank = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = 0;
      if (nodeDegree[node.id].inDegree === 0) {
        curRanks[nodeId] = 0;
      } else {
        var neighbors = getNeighbors(nodeId, edges, "source");
        for (var i2 = 0; i2 < neighbors.length; ++i2) {
          var neighbor = neighbors[i2];
          var outDegree = nodeDegree[neighbor].outDegree;
          if (outDegree > 0)
            currentRank += prevRanks[neighbor] / outDegree;
        }
        curRanks[nodeId] = linkProb * currentRank;
        leakedRank += curRanks[nodeId];
      }
    }
    leakedRank = (1 - leakedRank) / nodesCount;
    distance11 = 0;
    for (var j2 = 0; j2 < nodesCount; ++j2) {
      var node = nodes[j2];
      var nodeId = node.id;
      currentRank = curRanks[nodeId] + leakedRank;
      distance11 += Math.abs(currentRank - prevRanks[nodeId]);
      prevRanks[nodeId] = currentRank;
    }
    maxIterations -= 1;
  }
  return prevRanks;
};
var pageRank_default = pageRank;

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
init_esm();

// node_modules/@antv/algorithm/es/gSpan/struct.js
var VACANT_EDGE_ID = -1;
var VACANT_NODE_ID = -1;
var VACANT_EDGE_LABEL = "-1";
var VACANT_NODE_LABEL = "-1";
var VACANT_GRAPH_ID = -1;
var Edge = function() {
  function Edge3(id2, from, to2, label) {
    if (id2 === void 0) {
      id2 = VACANT_EDGE_ID;
    }
    if (from === void 0) {
      from = VACANT_NODE_ID;
    }
    if (to2 === void 0) {
      to2 = VACANT_NODE_ID;
    }
    if (label === void 0) {
      label = VACANT_EDGE_LABEL;
    }
    this.id = id2;
    this.from = from;
    this.to = to2;
    this.label = label;
  }
  return Edge3;
}();
var Node = function() {
  function Node3(id2, label) {
    if (id2 === void 0) {
      id2 = VACANT_NODE_ID;
    }
    if (label === void 0) {
      label = VACANT_NODE_LABEL;
    }
    this.id = id2;
    this.label = label;
    this.edges = [];
    this.edgeMap = {};
  }
  Node3.prototype.addEdge = function(edge) {
    this.edges.push(edge);
    this.edgeMap[edge.id] = edge;
  };
  return Node3;
}();
var Graph = function() {
  function Graph5(id2, edgeIdAutoIncrease, directed) {
    if (id2 === void 0) {
      id2 = VACANT_NODE_ID;
    }
    if (edgeIdAutoIncrease === void 0) {
      edgeIdAutoIncrease = true;
    }
    if (directed === void 0) {
      directed = false;
    }
    this.id = id2;
    this.edgeIdAutoIncrease = edgeIdAutoIncrease;
    this.edges = [];
    this.nodes = [];
    this.nodeMap = {};
    this.edgeMap = {};
    this.nodeLabelMap = {};
    this.edgeLabelMap = {};
    this.counter = 0;
    this.directed = directed;
  }
  Graph5.prototype.getNodeNum = function() {
    return this.nodes.length;
  };
  Graph5.prototype.addNode = function(id2, label) {
    if (this.nodeMap[id2])
      return;
    var node = new Node(id2, label);
    this.nodes.push(node);
    this.nodeMap[id2] = node;
    if (!this.nodeLabelMap[label])
      this.nodeLabelMap[label] = [];
    this.nodeLabelMap[label].push(id2);
  };
  Graph5.prototype.addEdge = function(id2, from, to2, label) {
    if (this.edgeIdAutoIncrease || id2 === void 0)
      id2 = this.counter++;
    if (this.nodeMap[from] && this.nodeMap[to2] && this.nodeMap[to2].edgeMap[id2])
      return;
    var edge = new Edge(id2, from, to2, label);
    this.edges.push(edge);
    this.edgeMap[id2] = edge;
    this.nodeMap[from].addEdge(edge);
    if (!this.edgeLabelMap[label])
      this.edgeLabelMap[label] = [];
    this.edgeLabelMap[label].push(edge);
    if (!this.directed) {
      var rEdge = new Edge(id2, to2, from, label);
      this.nodeMap[to2].addEdge(rEdge);
      this.edgeLabelMap[label].push(rEdge);
    }
  };
  return Graph5;
}();

// node_modules/@antv/algorithm/es/gSpan/gSpan.js
var DFSedge = function() {
  function DFSedge2(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
    this.fromNode = fromNode;
    this.toNode = toNode;
    this.nodeEdgeNodeLabel = {
      nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,
      edgeLabel: edgeLabel || VACANT_EDGE_LABEL,
      nodeLabel2: toNodeLabel || VACANT_NODE_LABEL
    };
  }
  DFSedge2.prototype.equalTo = function(other) {
    return this.fromNode === other.formNode && this.toNode === other.toNode && this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel;
  };
  DFSedge2.prototype.notEqualTo = function(other) {
    return !this.equalTo(other);
  };
  return DFSedge2;
}();
var DFScode = function() {
  function DFScode2() {
    this.rmpath = [];
    this.dfsEdgeList = [];
  }
  DFScode2.prototype.equalTo = function(other) {
    var aLength = this.dfsEdgeList.length;
    var bLength = other.length;
    if (aLength !== bLength)
      return false;
    for (var i2 = 0; i2 < aLength; i2++) {
      if (this.dfsEdgeList[i2] !== other[i2])
        return false;
    }
    return true;
  };
  DFScode2.prototype.notEqualTo = function(other) {
    return !this.equalTo(other);
  };
  DFScode2.prototype.pushBack = function(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {
    this.dfsEdgeList.push(new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel));
    return this.dfsEdgeList;
  };
  DFScode2.prototype.toGraph = function(graphId, directed) {
    if (graphId === void 0) {
      graphId = VACANT_GRAPH_ID;
    }
    if (directed === void 0) {
      directed = false;
    }
    var graph = new Graph(graphId, true, directed);
    this.dfsEdgeList.forEach(function(dfsEdge) {
      var fromNodeId = dfsEdge.fromNode;
      var toNodeId = dfsEdge.toNode;
      var _a2 = dfsEdge.nodeEdgeNodeLabel, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
      if (nodeLabel1 !== VACANT_NODE_LABEL)
        graph.addNode(fromNodeId, nodeLabel1);
      if (nodeLabel2 !== VACANT_NODE_LABEL)
        graph.addNode(toNodeId, nodeLabel2);
      if (nodeLabel1 !== VACANT_NODE_LABEL && nodeLabel2 !== nodeLabel1)
        graph.addEdge(void 0, fromNodeId, toNodeId, edgeLabel);
    });
    return graph;
  };
  DFScode2.prototype.buildRmpath = function() {
    this.rmpath = [];
    var oldFrom = void 0;
    var selfLength = this.dfsEdgeList.length;
    for (var i2 = selfLength - 1; i2 >= 0; i2--) {
      var dfsEdge = this.dfsEdgeList[i2];
      var fromNodeIdx = dfsEdge.fromNode;
      var toNodeIdx = dfsEdge.toNode;
      if (fromNodeIdx < toNodeIdx && (oldFrom === void 0 || toNodeIdx === oldFrom)) {
        this.rmpath.push(i2);
        oldFrom = fromNodeIdx;
      }
    }
    return this.rmpath;
  };
  DFScode2.prototype.getNodeNum = function() {
    var nodeMap = {};
    this.dfsEdgeList.forEach(function(dfsEdge) {
      if (!nodeMap[dfsEdge.fromNode])
        nodeMap[dfsEdge.fromNode] = true;
      if (!nodeMap[dfsEdge.toNode])
        nodeMap[dfsEdge.toNode] = true;
    });
    return Object.keys(nodeMap).length;
  };
  return DFScode2;
}();
var History = function() {
  function History2(pdfs) {
    this.his = {};
    this.nodesUsed = {};
    this.edgesUsed = {};
    this.edges = [];
    if (!pdfs)
      return;
    while (pdfs) {
      var e8 = pdfs.edge;
      this.edges.push(e8);
      this.nodesUsed[e8.from] = 1;
      this.nodesUsed[e8.to] = 1;
      this.edgesUsed[e8.id] = 1;
      pdfs = pdfs.preNode;
    }
    this.edges = this.edges.reverse();
  }
  History2.prototype.hasNode = function(node) {
    return this.nodesUsed[node.id] === 1;
  };
  History2.prototype.hasEdge = function(edge) {
    return this.edgesUsed[edge.id] === 1;
  };
  return History2;
}();
var GSpan = function() {
  function GSpan2(_a2) {
    var graphs = _a2.graphs, _b = _a2.minSupport, minSupport = _b === void 0 ? 2 : _b, _c = _a2.minNodeNum, minNodeNum = _c === void 0 ? 1 : _c, _d = _a2.maxNodeNum, maxNodeNum = _d === void 0 ? 4 : _d, _e2 = _a2.top, top = _e2 === void 0 ? 10 : _e2, _f = _a2.directed, directed = _f === void 0 ? false : _f, _g = _a2.verbose, verbose = _g === void 0 ? false : _g;
    this.graphs = graphs;
    this.dfsCode = new DFScode();
    this.support = 0;
    this.frequentSize1Subgraphs = [];
    this.frequentSubgraphs = [];
    this.minSupport = minSupport;
    this.top = top;
    this.directed = directed;
    this.counter = 0;
    this.maxNodeNum = maxNodeNum;
    this.minNodeNum = minNodeNum;
    this.verbose = verbose;
    if (this.maxNodeNum < this.minNodeNum)
      this.maxNodeNum = this.minNodeNum;
    this.reportDF = [];
  }
  GSpan2.prototype.findForwardRootEdges = function(graph, fromNode) {
    var _this = this;
    var result = [];
    var nodeMap = graph.nodeMap;
    fromNode.edges.forEach(function(edge) {
      if (_this.directed || fromNode.label <= nodeMap[edge.to].label)
        result.push(edge);
    });
    return result;
  };
  GSpan2.prototype.findBackwardEdge = function(graph, edge1, edge2, history) {
    if (!this.directed && edge1 === edge2)
      return null;
    var nodeMap = graph.nodeMap;
    var edge2To = nodeMap[edge2.to];
    var edge2ToEdges = edge2To.edges;
    var edgeLength = edge2ToEdges.length;
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edge2ToEdges[i2];
      if (history.hasEdge(edge) || edge.to !== edge1.from)
        continue;
      if (!this.directed) {
        if (edge1.label < edge.label || edge1.label === edge.label && nodeMap[edge1.to].label <= nodeMap[edge2.to].label) {
          return edge;
        }
      } else {
        if (nodeMap[edge1.from].label < nodeMap[edge2.to].label || nodeMap[edge1.from].label === nodeMap[edge2.to].label && edge1.label <= edge.label) {
          return edge;
        }
      }
    }
    return null;
  };
  GSpan2.prototype.findForwardPureEdges = function(graph, rightmostEdge, minNodeLabel, history) {
    var result = [];
    var rightmostEdgeToId = rightmostEdge.to;
    var edges = graph.nodeMap[rightmostEdgeToId].edges;
    var edgeLength = edges.length;
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      var toNode = graph.nodeMap[edge.to];
      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {
        result.push(edge);
      }
    }
    return result;
  };
  GSpan2.prototype.findForwardRmpathEdges = function(graph, rightmostEdge, minNodeLabel, history) {
    var result = [];
    var nodeMap = graph.nodeMap;
    var toNodeLabel = nodeMap[rightmostEdge.to].label;
    var fromNode = nodeMap[rightmostEdge.from];
    var edges = fromNode.edges;
    var edgeLength = edges.length;
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      var newToNodeLabel = nodeMap[edge.to].label;
      if (rightmostEdge.to === edge.to || minNodeLabel > newToNodeLabel || history.hasNode(nodeMap[edge.to])) {
        continue;
      }
      if (rightmostEdge.label < edge.label || rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel) {
        result.push(edge);
      }
    }
    return result;
  };
  GSpan2.prototype.getSupport = function(projected) {
    var graphMap = {};
    projected.forEach(function(pro) {
      if (!graphMap[pro.graphId])
        graphMap[pro.graphId] = true;
    });
    return Object.keys(graphMap).length;
  };
  GSpan2.prototype.findMinLabel = function(obj) {
    var minLabel = void 0;
    Object.keys(obj).forEach(function(nodeEdgeNodeLabel) {
      var _a2 = obj[nodeEdgeNodeLabel], nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
      if (!minLabel) {
        minLabel = {
          nodeLabel1,
          edgeLabel,
          nodeLabel2
        };
        return;
      }
      if (nodeLabel1 < minLabel.nodeLabel1 || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel < minLabel.edgeLabel || nodeLabel1 === minLabel.nodeLabel1 && edgeLabel === minLabel.edgeLabel && nodeLabel2 < minLabel.nodeLabel2) {
        minLabel = {
          nodeLabel1,
          edgeLabel,
          nodeLabel2
        };
      }
    });
    return minLabel;
  };
  GSpan2.prototype.isMin = function() {
    var _this = this;
    var dfsCode = this.dfsCode;
    if (this.verbose)
      console.log("isMin checking", dfsCode);
    if (dfsCode.dfsEdgeList.length === 1)
      return true;
    var directed = this.directed;
    var graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);
    var nodeMap = graph.nodeMap;
    var dfsCodeMin = new DFScode();
    var root = {};
    graph.nodes.forEach(function(node) {
      var forwardEdges = _this.findForwardRootEdges(graph, node);
      forwardEdges.forEach(function(edge) {
        var otherNode = nodeMap[edge.to];
        var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(otherNode.label);
        if (!root[nodeEdgeNodeLabel])
          root[nodeEdgeNodeLabel] = {
            projected: [],
            nodeLabel1: node.label,
            edgeLabel: edge.label,
            nodeLabel2: otherNode.label
          };
        var pdfs = {
          graphId: graph.id,
          edge,
          preNode: null
        };
        root[nodeEdgeNodeLabel].projected.push(pdfs);
      });
    });
    var minLabel = this.findMinLabel(root);
    if (!minLabel)
      return;
    dfsCodeMin.dfsEdgeList.push(new DFSedge(0, 1, minLabel.nodeLabel1, minLabel.edgeLabel, minLabel.nodeLabel2));
    var projectIsMin = function projectIsMin2(projected) {
      var rmpath = dfsCodeMin.buildRmpath();
      var minNodeLabel = dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
      var maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode;
      var backwardRoot = {};
      var flag = false, newTo = 0;
      var end2 = directed ? -1 : 0;
      var _loop_1 = function _loop_12(i3) {
        if (flag)
          return "break";
        projected.forEach(function(p2) {
          var history = new History(p2);
          var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i3]], history.edges[rmpath[0]], history);
          if (backwardEdge) {
            if (!backwardRoot[backwardEdge.label]) {
              backwardRoot[backwardEdge.label] = {
                projected: [],
                edgeLabel: backwardEdge.label
              };
            }
            backwardRoot[backwardEdge.label].projected.push({
              graphId: graph.id,
              edge: backwardRoot,
              preNode: p2
            });
            newTo = dfsCodeMin.dfsEdgeList[rmpath[i3]].fromNode;
            flag = true;
          }
        });
      };
      for (var i2 = rmpath.length - 1; i2 > end2; i2--) {
        var state_1 = _loop_1(i2);
        if (state_1 === "break")
          break;
      }
      if (flag) {
        var minBackwardEdgeLabel = _this.findMinLabel(backwardRoot);
        dfsCodeMin.dfsEdgeList.push(new DFSedge(maxToC, newTo, VACANT_NODE_LABEL, minBackwardEdgeLabel.edgeLabel, VACANT_NODE_LABEL));
        var idx_1 = dfsCodeMin.dfsEdgeList.length - 1;
        if (_this.dfsCode.dfsEdgeList[idx_1] !== dfsCodeMin.dfsEdgeList[idx_1])
          return false;
        return projectIsMin2(backwardRoot[minBackwardEdgeLabel.edgeLabel].projected);
      }
      var forwardRoot = {};
      flag = false;
      var newFrom = 0;
      projected.forEach(function(p2) {
        var history = new History(p2);
        var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
        if (forwardPureEdges.length > 0) {
          flag = true;
          newFrom = maxToC;
          forwardPureEdges.forEach(function(edge) {
            var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
            if (!forwardRoot[key2])
              forwardRoot[key2] = {
                projected: [],
                edgeLabel: edge.label,
                nodeLabel2: nodeMap[edge.to].label
              };
            forwardRoot[key2].projected.push({
              graphId: graph.id,
              edge,
              preNode: p2
            });
          });
        }
      });
      var pathLength = rmpath.length;
      var _loop_2 = function _loop_22(i3) {
        if (flag)
          return "break";
        var value = rmpath[i3];
        projected.forEach(function(p2) {
          var history = new History(p2);
          var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[value], minNodeLabel, history);
          if (forwardRmpathEdges.length > 0) {
            flag = true;
            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;
            forwardRmpathEdges.forEach(function(edge) {
              var key2 = "".concat(edge.label, "-").concat(nodeMap[edge.to].label);
              if (!forwardRoot[key2])
                forwardRoot[key2] = {
                  projected: [],
                  edgeLabel: edge.label,
                  nodeLabel2: nodeMap[edge.to].label
                };
              forwardRoot[key2].projected.push({
                graphId: graph.id,
                edge,
                preNode: p2
              });
            });
          }
        });
      };
      for (var i2 = 0; i2 < pathLength; i2++) {
        var state_2 = _loop_2(i2);
        if (state_2 === "break")
          break;
      }
      if (!flag)
        return true;
      var forwardMinEdgeNodeLabel = _this.findMinLabel(forwardRoot);
      dfsCodeMin.dfsEdgeList.push(new DFSedge(newFrom, maxToC + 1, VACANT_NODE_LABEL, forwardMinEdgeNodeLabel.edgeLabel, forwardMinEdgeNodeLabel.nodeLabel2));
      var idx = dfsCodeMin.dfsEdgeList.length - 1;
      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])
        return false;
      return projectIsMin2(forwardRoot["".concat(forwardMinEdgeNodeLabel.edgeLabel, "-").concat(forwardMinEdgeNodeLabel.nodeLabel2)].projected);
    };
    var key = "".concat(minLabel.nodeLabel1, "-").concat(minLabel.edgeLabel, "-").concat(minLabel.nodeLabel2);
    return projectIsMin(root[key].projected);
  };
  GSpan2.prototype.report = function() {
    if (this.dfsCode.getNodeNum() < this.minNodeNum)
      return;
    this.counter++;
    var graph = this.dfsCode.toGraph(this.counter, this.directed);
    this.frequentSubgraphs.push(clone_default(graph));
  };
  GSpan2.prototype.subGraphMining = function(projected) {
    var _this = this;
    var support = this.getSupport(projected);
    if (support < this.minSupport)
      return;
    if (!this.isMin())
      return;
    this.report();
    var nodeNum = this.dfsCode.getNodeNum();
    var rmpath = this.dfsCode.buildRmpath();
    var maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;
    var minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;
    var forwardRoot = {};
    var backwardRoot = {};
    projected.forEach(function(p2) {
      var graph = _this.graphs[p2.graphId];
      var nodeMap = graph.nodeMap;
      var history = new History(p2);
      for (var i2 = rmpath.length - 1; i2 >= 0; i2--) {
        var backwardEdge = _this.findBackwardEdge(graph, history.edges[rmpath[i2]], history.edges[rmpath[0]], history);
        if (backwardEdge) {
          var key = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode, "-").concat(backwardEdge.label);
          if (!backwardRoot[key])
            backwardRoot[key] = {
              projected: [],
              toNodeId: _this.dfsCode.dfsEdgeList[rmpath[i2]].fromNode,
              edgeLabel: backwardEdge.label
            };
          backwardRoot[key].projected.push({
            graphId: p2.graphId,
            edge: backwardEdge,
            preNode: p2
          });
        }
      }
      if (nodeNum >= _this.maxNodeNum)
        return;
      var forwardPureEdges = _this.findForwardPureEdges(graph, history.edges[rmpath[0]], minNodeLabel, history);
      forwardPureEdges.forEach(function(edge) {
        var key2 = "".concat(maxToC, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
        if (!forwardRoot[key2])
          forwardRoot[key2] = {
            projected: [],
            fromNodeId: maxToC,
            edgeLabel: edge.label,
            nodeLabel2: nodeMap[edge.to].label
          };
        forwardRoot[key2].projected.push({
          graphId: p2.graphId,
          edge,
          preNode: p2
        });
      });
      var _loop_3 = function _loop_32(i3) {
        var forwardRmpathEdges = _this.findForwardRmpathEdges(graph, history.edges[rmpath[i3]], minNodeLabel, history);
        forwardRmpathEdges.forEach(function(edge) {
          var key2 = "".concat(_this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode, "-").concat(edge.label, "-").concat(nodeMap[edge.to].label);
          if (!forwardRoot[key2])
            forwardRoot[key2] = {
              projected: [],
              fromNodeId: _this.dfsCode.dfsEdgeList[rmpath[i3]].fromNode,
              edgeLabel: edge.label,
              nodeLabel2: nodeMap[edge.to].label
            };
          forwardRoot[key2].projected.push({
            graphId: p2.graphId,
            edge,
            preNode: p2
          });
        });
      };
      for (var i2 = 0; i2 < rmpath.length; i2++) {
        _loop_3(i2);
      }
    });
    Object.keys(backwardRoot).forEach(function(key) {
      var _a2 = backwardRoot[key], toNodeId = _a2.toNodeId, edgeLabel = _a2.edgeLabel;
      _this.dfsCode.dfsEdgeList.push(new DFSedge(maxToC, toNodeId, "-1", edgeLabel, "-1"));
      _this.subGraphMining(backwardRoot[key].projected);
      _this.dfsCode.dfsEdgeList.pop();
    });
    Object.keys(forwardRoot).forEach(function(key) {
      var _a2 = forwardRoot[key], fromNodeId = _a2.fromNodeId, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
      _this.dfsCode.dfsEdgeList.push(new DFSedge(fromNodeId, maxToC + 1, VACANT_NODE_LABEL, edgeLabel, nodeLabel2));
      _this.subGraphMining(forwardRoot[key].projected);
      _this.dfsCode.dfsEdgeList.pop();
    });
  };
  GSpan2.prototype.generate1EdgeFrequentSubGraphs = function() {
    var graphs = this.graphs;
    var directed = this.directed;
    var minSupport = this.minSupport;
    var frequentSize1Subgraphs = this.frequentSize1Subgraphs;
    var nodeLabelCounter = {}, nodeEdgeNodeCounter = {};
    var nodeLableCounted = {};
    var nodeEdgeNodeLabelCounted = {};
    Object.keys(graphs).forEach(function(key) {
      var graph = graphs[key];
      var nodeMap = graph.nodeMap;
      graph.nodes.forEach(function(node, i2) {
        var nodeLabel = node.label;
        var graphNodeKey = "".concat(key, "-").concat(nodeLabel);
        if (!nodeLableCounted[graphNodeKey]) {
          var counter = nodeLabelCounter[nodeLabel] || 0;
          counter++;
          nodeLabelCounter[nodeLabel] = counter;
        }
        nodeLableCounted[graphNodeKey] = {
          graphKey: key,
          label: nodeLabel
        };
        node.edges.forEach(function(edge) {
          var nodeLabel1 = nodeLabel;
          var nodeLabel2 = nodeMap[edge.to].label;
          if (!directed && nodeLabel1 > nodeLabel2) {
            var tmp = nodeLabel2;
            nodeLabel2 = nodeLabel1;
            nodeLabel1 = tmp;
          }
          var edgeLabel = edge.label;
          var graphNodeEdgeNodeKey = "".concat(key, "-").concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
          var nodeEdgeNodeKey = "".concat(nodeLabel1, "-").concat(edgeLabel, "-").concat(nodeLabel2);
          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {
            var counter2 = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;
            counter2++;
            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter2;
          }
          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {
            graphId: key,
            nodeLabel1,
            edgeLabel,
            nodeLabel2
          };
        });
      });
    });
    Object.keys(nodeLabelCounter).forEach(function(label) {
      var count = nodeLabelCounter[label];
      if (count < minSupport)
        return;
      var g2 = {
        nodes: [],
        edges: []
      };
      g2.nodes.push({
        id: "0",
        label
      });
      frequentSize1Subgraphs.push(g2);
    });
    return frequentSize1Subgraphs;
  };
  GSpan2.prototype.run = function() {
    var _this = this;
    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();
    if (this.maxNodeNum < 2)
      return;
    var graphs = this.graphs;
    var directed = this.directed;
    var root = {};
    Object.keys(graphs).forEach(function(graphId) {
      var graph = graphs[graphId];
      var nodeMap = graph.nodeMap;
      graph.nodes.forEach(function(node) {
        var forwardRootEdges = _this.findForwardRootEdges(graph, node);
        forwardRootEdges.forEach(function(edge) {
          var toNode = nodeMap[edge.to];
          var nodeEdgeNodeLabel = "".concat(node.label, "-").concat(edge.label, "-").concat(toNode.label);
          if (!root[nodeEdgeNodeLabel])
            root[nodeEdgeNodeLabel] = {
              projected: [],
              nodeLabel1: node.label,
              edgeLabel: edge.label,
              nodeLabel2: toNode.label
            };
          var pdfs = {
            graphId,
            edge,
            preNode: null
          };
          root[nodeEdgeNodeLabel].projected.push(pdfs);
        });
      });
    });
    Object.keys(root).forEach(function(nodeEdgeNodeLabel) {
      var _a2 = root[nodeEdgeNodeLabel], projected = _a2.projected, nodeLabel1 = _a2.nodeLabel1, edgeLabel = _a2.edgeLabel, nodeLabel2 = _a2.nodeLabel2;
      _this.dfsCode.dfsEdgeList.push(new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2));
      _this.subGraphMining(projected);
      _this.dfsCode.dfsEdgeList.pop();
    });
  };
  return GSpan2;
}();
var formatGraphs = function formatGraphs2(graphs, directed, nodeLabelProp, edgeLabelProp) {
  var result = {};
  Object.keys(graphs).forEach(function(key, i2) {
    var graph = graphs[key];
    var fGraph = new Graph(i2, true, directed);
    var nodeIdxMap = {};
    graph.nodes.forEach(function(node, j2) {
      fGraph.addNode(j2, node[nodeLabelProp]);
      nodeIdxMap[node.id] = j2;
    });
    graph.edges.forEach(function(edge, k2) {
      var sourceIdx = nodeIdxMap[edge.source];
      var targetIdx = nodeIdxMap[edge.target];
      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);
    });
    if (fGraph && fGraph.getNodeNum())
      result[fGraph.id] = fGraph;
  });
  return result;
};
var toGraphDatas = function toGraphDatas2(graphs, nodeLabelProp, edgeLabelProp) {
  var result = [];
  graphs.forEach(function(graph) {
    var graphData = {
      nodes: [],
      edges: []
    };
    graph.nodes.forEach(function(node) {
      var _a2;
      graphData.nodes.push((_a2 = {
        id: "".concat(node.id)
      }, _a2[nodeLabelProp] = node.label, _a2));
    });
    graph.edges.forEach(function(edge) {
      var _a2;
      graphData.edges.push((_a2 = {
        source: "".concat(edge.from),
        target: "".concat(edge.to)
      }, _a2[edgeLabelProp] = edge.label, _a2));
    });
    result.push(graphData);
  });
  return result;
};
var DEFAULT_LABEL_NAME = "cluster";
var gSpan = function gSpan2(params) {
  var graphs = params.graphs, _a2 = params.directed, directed = _a2 === void 0 ? false : _a2, _b = params.nodeLabelProp, nodeLabelProp = _b === void 0 ? DEFAULT_LABEL_NAME : _b, _c = params.edgeLabelProp, edgeLabelProp = _c === void 0 ? DEFAULT_LABEL_NAME : _c;
  var formattedGraphs = formatGraphs(graphs, directed, nodeLabelProp, edgeLabelProp);
  var minSupport = params.minSupport, maxNodeNum = params.maxNodeNum, minNodeNum = params.minNodeNum, verbose = params.verbose, top = params.top;
  var algoParams = {
    graphs: formattedGraphs,
    minSupport,
    maxNodeNum,
    minNodeNum,
    top,
    verbose,
    directed
  };
  var calculator = new GSpan(algoParams);
  calculator.run();
  var result = toGraphDatas(calculator.frequentSubgraphs, nodeLabelProp, edgeLabelProp);
  return result;
};
var gSpan_default = gSpan;

// node_modules/@antv/algorithm/es/gaddi.js
var findKNeighborUnits = function findKNeighborUnits2(graphData, spm, nodeLabelProp, k2) {
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (k2 === void 0) {
    k2 = 2;
  }
  var units = [];
  var nodes = graphData.nodes;
  spm.forEach(function(row, i2) {
    units.push(findKNeighborUnit(nodes, row, i2, nodeLabelProp, k2));
  });
  return units;
};
var findKNeighborUnit = function findKNeighborUnit2(nodes, row, i2, nodeLabelProp, k2) {
  var unitNodeIdxs = [i2];
  var neighbors = [];
  var labelCountMap = {};
  row.forEach(function(v2, j2) {
    if (v2 <= k2 && i2 !== j2) {
      unitNodeIdxs.push(j2);
      neighbors.push(nodes[j2]);
      var label = nodes[j2][nodeLabelProp];
      if (!labelCountMap[label])
        labelCountMap[label] = {
          count: 1,
          dists: [v2]
        };
      else {
        labelCountMap[label].count++;
        labelCountMap[label].dists.push(v2);
      }
    }
  });
  Object.keys(labelCountMap).forEach(function(label) {
    labelCountMap[label].dists = labelCountMap[label].dists.sort(function(a2, b10) {
      return a2 - b10;
    });
  });
  return {
    nodeIdx: i2,
    nodeId: nodes[i2].id,
    nodeIdxs: unitNodeIdxs,
    neighbors,
    neighborNum: unitNodeIdxs.length - 1,
    nodeLabelCountMap: labelCountMap
  };
};
var findNodePairsRandomly = function findNodePairsRandomly2(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm) {
  var nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);
  var nodePairMap = {};
  var foundNodePairCount = 0;
  kNeighborUnits.forEach(function(unit, i2) {
    var nodePairForICount = 0;
    var outerLoopCount = 0;
    var neighbors = unit.nodeIdxs;
    var neighborNum = unit.neighborNum - 1;
    while (nodePairForICount < nodePairNumEachNode) {
      var oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];
      var innerLoopCount = 0;
      while (nodePairMap["".concat(i2, "-").concat(oidx)] || nodePairMap["".concat(oidx, "-").concat(i2)]) {
        oidx = Math.floor(Math.random() * nodeNum);
        innerLoopCount++;
        if (innerLoopCount > 2 * nodeNum)
          break;
      }
      if (innerLoopCount < 2 * nodeNum) {
        nodePairMap["".concat(i2, "-").concat(oidx)] = {
          start: i2,
          end: oidx,
          distance: spm[i2][oidx]
        };
        nodePairForICount++;
        foundNodePairCount++;
        if (foundNodePairCount >= maxNodePairNum)
          return nodePairMap;
      }
      outerLoopCount++;
      if (outerLoopCount > 2 * nodeNum)
        break;
    }
    if (nodePairForICount < nodePairNumEachNode) {
      var gap = nodePairNumEachNode - nodePairForICount;
      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i2 - 1);
    }
  });
  return nodePairMap;
};
var getIntersectNeighborInducedGraph = function getIntersectNeighborInducedGraph2(nodePairMap, neighborUnits, graphData, cachedInducedGraphMap) {
  var nodes = graphData.nodes;
  if (!cachedInducedGraphMap)
    cachedInducedGraphMap = {};
  Object.keys(nodePairMap).forEach(function(key) {
    var _a2, _b;
    if (cachedInducedGraphMap && cachedInducedGraphMap[key])
      return;
    cachedInducedGraphMap[key] = {
      nodes: [],
      edges: []
    };
    var pair = nodePairMap[key];
    var startUnitNodeIds = (_a2 = neighborUnits[pair.start]) === null || _a2 === void 0 ? void 0 : _a2.nodeIdxs;
    var endUnitNodeIds = (_b = neighborUnits[pair.end]) === null || _b === void 0 ? void 0 : _b.nodeIdxs;
    if (!startUnitNodeIds || !endUnitNodeIds)
      return;
    var endSet = new Set(endUnitNodeIds);
    var intersect2 = startUnitNodeIds.filter(function(x2) {
      return endSet.has(x2);
    });
    if (!intersect2 || !intersect2.length)
      return;
    var intersectIdMap = {};
    var intersectLength = intersect2.length;
    for (var i2 = 0; i2 < intersectLength; i2++) {
      var node = nodes[intersect2[i2]];
      cachedInducedGraphMap[key].nodes.push(node);
      intersectIdMap[node.id] = true;
    }
    graphData.edges.forEach(function(edge) {
      if (intersectIdMap[edge.source] && intersectIdMap[edge.target])
        cachedInducedGraphMap[key].edges.push(edge);
    });
  });
  return cachedInducedGraphMap;
};
var getMatchedCount = function getMatchedCount2(graph, structure, nodeLabelProp, edgeLabelProp) {
  var _a2, _b;
  var nodeMap = {};
  graph.nodes.forEach(function(node) {
    nodeMap[node.id] = node;
  });
  var count = 0;
  if (!((_a2 = structure === null || structure === void 0 ? void 0 : structure.edges) === null || _a2 === void 0 ? void 0 : _a2.length) || ((_b = structure === null || structure === void 0 ? void 0 : structure.nodes) === null || _b === void 0 ? void 0 : _b.length) < 2)
    return 0;
  graph.edges.forEach(function(e8) {
    var sourceLabel = nodeMap[e8.source][nodeLabelProp];
    var targetLabel = nodeMap[e8.target][nodeLabelProp];
    var strNodeLabel1 = structure === null || structure === void 0 ? void 0 : structure.nodes[0][nodeLabelProp];
    var strNodeLabel2 = structure === null || structure === void 0 ? void 0 : structure.nodes[1][nodeLabelProp];
    var strEdgeLabel = structure === null || structure === void 0 ? void 0 : structure.edges[0][edgeLabelProp];
    if (e8[edgeLabelProp] !== strEdgeLabel)
      return;
    if (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2 || sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1) {
      count++;
    }
  });
  return count;
};
var findRepresentStructure = function findRepresentStructure2(matchedCountMap, structureNum, structures) {
  var maxOffset = Infinity, representClusterType = 0;
  var _loop_1 = function _loop_12(i3) {
    var countMapI = matchedCountMap[i3];
    var sortedGraphKeys = Object.keys(countMapI).sort(function(a2, b10) {
      return countMapI[a2] - countMapI[b10];
    });
    var groupNum = 10;
    var clusters = [];
    sortedGraphKeys.forEach(function(key, j2) {
      if (!clusters[j2 % groupNum])
        clusters[j2 % groupNum] = {
          graphs: [],
          totalCount: 0,
          aveCount: 0
        };
      clusters[j2 % groupNum].graphs.push(key);
      clusters[j2 % groupNum].totalCount += countMapI[key];
    });
    var aveIntraDist = 0;
    var aveCounts = [];
    clusters.forEach(function(graphsInCluster) {
      var aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;
      graphsInCluster.aveCount = aveCount;
      aveCounts.push(aveCount);
      var aveIntraPerCluster = 0;
      var graphsNum = graphsInCluster.length;
      graphsInCluster.graphs.forEach(function(graphKey1, j2) {
        var graph1Count = countMapI[graphKey1];
        graphsInCluster.graphs.forEach(function(graphKey2, k2) {
          if (j2 === k2)
            return;
          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);
        });
      });
      aveIntraPerCluster /= graphsNum * (graphsNum - 1) / 2;
      aveIntraDist += aveIntraPerCluster;
    });
    aveIntraDist /= clusters.length;
    var aveInterDist = 0;
    aveCounts.forEach(function(aveCount1, j2) {
      aveCounts.forEach(function(aveCount2, k2) {
        if (j2 === k2)
          return;
        aveInterDist += Math.abs(aveCount1 - aveCount2);
      });
      aveInterDist /= aveCounts.length * (aveCounts.length - 1) / 2;
    });
    var offset = aveInterDist - aveIntraDist;
    if (maxOffset < offset) {
      maxOffset = offset;
      representClusterType = i3;
    }
  };
  for (var i2 = 0; i2 < structureNum; i2++) {
    _loop_1(i2);
  }
  return {
    structure: structures[representClusterType],
    structureCountMap: matchedCountMap[representClusterType]
  };
};
var getNodeMaps = function getNodeMaps2(nodes, nodeLabelProp) {
  var nodeMap = {}, nodeLabelMap = {};
  nodes.forEach(function(node, i2) {
    nodeMap[node.id] = {
      idx: i2,
      node,
      degree: 0,
      inDegree: 0,
      outDegree: 0
    };
    var label = node[nodeLabelProp];
    if (!nodeLabelMap[label])
      nodeLabelMap[label] = [];
    nodeLabelMap[label].push(node);
  });
  return {
    nodeMap,
    nodeLabelMap
  };
};
var getEdgeMaps = function getEdgeMaps2(edges, edgeLabelProp, nodeMap) {
  var edgeMap = {}, edgeLabelMap = {};
  edges.forEach(function(edge, i2) {
    edgeMap["".concat(uniqueId)] = {
      idx: i2,
      edge
    };
    var label = edge[edgeLabelProp];
    if (!edgeLabelMap[label])
      edgeLabelMap[label] = [];
    edgeLabelMap[label].push(edge);
    var sourceNode = nodeMap[edge.source];
    if (sourceNode) {
      sourceNode.degree++;
      sourceNode.outDegree++;
    }
    var targetNode = nodeMap[edge.target];
    if (targetNode) {
      targetNode.degree++;
      targetNode.inDegree++;
    }
  });
  return {
    edgeMap,
    edgeLabelMap
  };
};
var getSpmMap = function getSpmMap2(nodes, spm, directed) {
  var length5 = spm.length;
  var map4 = {};
  spm.forEach(function(row, i2) {
    var start = directed ? 0 : i2 + 1;
    var iId = nodes[i2].id;
    for (var j2 = start; j2 < length5; j2++) {
      if (i2 === j2)
        continue;
      var jId = nodes[j2].id;
      var dist4 = row[j2];
      map4["".concat(iId, "-").concat(jId)] = dist4;
      if (!directed)
        map4["".concat(jId, "-").concat(iId)] = dist4;
    }
  });
  return map4;
};
var getNDSDist = function getNDSDist2(graph, node1, node2, nodeMap, spDist, kNeighborUnits, structure, nodeLabelProp, edgeLabelProp, cachedNDSMap, cachedInterInducedGraph) {
  var _a2;
  var key = "".concat(node1.id, "-").concat(node2.id);
  if (cachedNDSMap && cachedNDSMap[key])
    return cachedNDSMap[key];
  var interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : void 0;
  if (!interInducedGraph) {
    var pairMap = (_a2 = {}, _a2[key] = {
      start: nodeMap[node1.id].idx,
      end: nodeMap[node2.id].idx,
      distance: spDist
    }, _a2);
    cachedInterInducedGraph = getIntersectNeighborInducedGraph(pairMap, kNeighborUnits, graph, cachedInterInducedGraph);
    interInducedGraph = cachedInterInducedGraph[key];
  }
  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);
};
var stashPatternNodeLabelDegreeMap = function stashPatternNodeLabelDegreeMap2(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap) {
  var _a2, _b, _c;
  var minPatternNodeLabelDegree = (_a2 = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _a2 === void 0 ? void 0 : _a2.degree;
  var minPatternNodeLabelInDegree = (_b = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _b === void 0 ? void 0 : _b.inDegree;
  var minPatternNodeLabelOutDegree = (_c = minPatternNodeLabelDegreeMap[neighborLabel]) === null || _c === void 0 ? void 0 : _c.outDegree;
  if (minPatternNodeLabelDegreeMap[neighborLabel] === void 0) {
    minPatternNodeLabelDegree = Infinity;
    minPatternNodeLabelInDegree = Infinity;
    minPatternNodeLabelOutDegree = Infinity;
    patternNodeLabelMap[neighborLabel].forEach(function(patternNodeWithLabel) {
      var patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;
      if (minPatternNodeLabelDegree > patternNodeDegree)
        minPatternNodeLabelDegree = patternNodeDegree;
      var patternNodeInDegree = patternNodeMap[patternNodeWithLabel.id].inDegree;
      if (minPatternNodeLabelInDegree > patternNodeInDegree)
        minPatternNodeLabelInDegree = patternNodeInDegree;
      var patternNodeOutDegree = patternNodeMap[patternNodeWithLabel.id].outDegree;
      if (minPatternNodeLabelOutDegree > patternNodeOutDegree)
        minPatternNodeLabelOutDegree = patternNodeOutDegree;
    });
    minPatternNodeLabelDegreeMap[neighborLabel] = {
      degree: minPatternNodeLabelDegree,
      inDegree: minPatternNodeLabelInDegree,
      outDegree: minPatternNodeLabelOutDegree
    };
  }
  return {
    minPatternNodeLabelDegree,
    minPatternNodeLabelInDegree,
    minPatternNodeLabelOutDegree
  };
};
var GADDI = function GADDI2(graphData, pattern, directed, k2, length5, nodeLabelProp, edgeLabelProp) {
  var _a2;
  if (directed === void 0) {
    directed = false;
  }
  if (nodeLabelProp === void 0) {
    nodeLabelProp = "cluster";
  }
  if (edgeLabelProp === void 0) {
    edgeLabelProp = "cluster";
  }
  if (!graphData || !graphData.nodes)
    return;
  var nodeNum = graphData.nodes.length;
  if (!nodeNum)
    return;
  var spm = floydWarshall_default(graphData, directed);
  var patternSpm = floydWarshall_default(pattern, directed);
  var spmMap = getSpmMap(graphData.nodes, spm, directed);
  var patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);
  var _b = getNodeMaps(graphData.nodes, nodeLabelProp), nodeMap = _b.nodeMap, nodeLabelMap = _b.nodeLabelMap;
  var _c = getNodeMaps(pattern.nodes, nodeLabelProp), patternNodeMap = _c.nodeMap, patternNodeLabelMap = _c.nodeLabelMap;
  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);
  var patternEdgeLabelMap = getEdgeMaps(pattern.edges, edgeLabelProp, patternNodeMap).edgeLabelMap;
  var patternSpmSpread = [];
  patternSpm === null || patternSpm === void 0 ? void 0 : patternSpm.forEach(function(row) {
    patternSpmSpread = patternSpmSpread.concat(row);
  });
  if (!length5)
    length5 = Math.max.apply(Math, __spreadArray2(__spreadArray2([], patternSpmSpread, false), [2], false));
  if (!k2)
    k2 = length5;
  var kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k2);
  var patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k2);
  var maxNodePairNum = Math.min(100, nodeNum * (nodeNum - 1) / 2);
  var nodePairsMap = findNodePairsRandomly(k2, nodeNum, maxNodePairNum, kNeighborUnits, spm);
  var intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);
  var top = 10, minSupport = 1, minNodeNum = 1, maxNodeNum = 4;
  var params = {
    graphs: intGMap,
    nodeLabelProp,
    edgeLabelProp,
    minSupport,
    minNodeNum,
    maxNodeNum,
    directed
  };
  var freStructures = gSpan_default(params).slice(0, top);
  var structureNum = freStructures.length;
  var matchedCountMap = [];
  freStructures.forEach(function(structure, i3) {
    matchedCountMap[i3] = {};
    Object.keys(intGMap).forEach(function(key) {
      var graph = intGMap[key];
      var subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);
      matchedCountMap[i3][key] = subStructureCount;
    });
  });
  var _d = findRepresentStructure(matchedCountMap, structureNum, freStructures), dsG = _d.structure, ndsDist = _d.structureCountMap;
  var beginPNode = pattern.nodes[0], candidates = [], label = (_a2 = pattern.nodes[0]) === null || _a2 === void 0 ? void 0 : _a2[nodeLabelProp], maxNodeNumWithSameLabel = -Infinity;
  pattern.nodes.forEach(function(node) {
    var pLabel = node[nodeLabelProp];
    var nodesWithSameLabel = nodeLabelMap[pLabel];
    if ((nodesWithSameLabel === null || nodesWithSameLabel === void 0 ? void 0 : nodesWithSameLabel.length) > maxNodeNumWithSameLabel) {
      maxNodeNumWithSameLabel = nodesWithSameLabel.length;
      candidates = nodesWithSameLabel;
      label = pLabel;
      beginPNode = node;
    }
  });
  var minPatternNodeLabelDegreeMap = {};
  var patternIntGraphMap = {}, patternNDSDist = {}, patternNDSDistMap = {};
  var patternSpDist = {};
  var patternSpDistBack = {};
  Object.keys(patternNodeLabelMap).forEach(function(label2, j2) {
    patternSpDist[label2] = [];
    if (directed) {
      patternSpDistBack[label2] = [];
    }
    var maxDist = -Infinity;
    var patternNodesWithLabel2 = patternNodeLabelMap[label2];
    var patternNodePairMap = {};
    patternNodesWithLabel2.forEach(function(nodeWithLabel2) {
      var dist4 = patternSpmMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)];
      dist4 && patternSpDist[label2].push(dist4);
      if (maxDist < dist4)
        maxDist = dist4;
      patternNodePairMap["".concat(beginPNode.id, "-").concat(nodeWithLabel2.id)] = {
        start: 0,
        end: patternNodeMap[nodeWithLabel2.id].idx,
        distance: dist4
      };
      if (directed) {
        var distBack = patternSpmMap["".concat(nodeWithLabel2.id, "-").concat(beginPNode.id)];
        distBack && patternSpDistBack[label2].push(distBack);
      }
    });
    patternSpDist[label2] = patternSpDist[label2].sort(function(a2, b10) {
      return a2 - b10;
    });
    if (directed)
      patternSpDistBack[label2] = patternSpDistBack[label2].sort(function(a2, b10) {
        return a2 - b10;
      });
    patternIntGraphMap = getIntersectNeighborInducedGraph(patternNodePairMap, patternKNeighborUnits, pattern, patternIntGraphMap);
    var currentPatternNDSDistArray = [];
    Object.keys(patternNodePairMap).forEach(function(key) {
      if (patternNDSDist[key]) {
        currentPatternNDSDistArray.push(patternNDSDist[key]);
        return;
      }
      var patternIntGraph = patternIntGraphMap[key];
      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);
      currentPatternNDSDistArray.push(patternNDSDist[key]);
    });
    currentPatternNDSDistArray = currentPatternNDSDistArray.sort(function(a2, b10) {
      return b10 - a2;
    });
    patternNDSDistMap["".concat(beginPNode.id, "-").concat(label2)] = currentPatternNDSDistArray;
    if (label2 === label)
      return;
    var candidatesNum = (candidates === null || candidates === void 0 ? void 0 : candidates.length) || 0;
    var _loop_4 = function _loop_42(m3) {
      var cNode = candidates[m3];
      var graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];
      var graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];
      var patternLabel2Num = patternNodeLabelMap[label2].length;
      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {
        candidates.splice(m3, 1);
        return "continue";
      }
      var prune2Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (graphNeighborUnitCountMap.dists[n2] > patternSpDist[label2][n2]) {
          prune2Invalid = true;
          break;
        }
      }
      if (prune2Invalid) {
        candidates.splice(m3, 1);
        return "continue";
      }
      var cNodePairMap = {};
      graphNeighborUnit.neighbors.forEach(function(neighborNode) {
        var dist4 = spmMap["".concat(cNode.id, "-").concat(neighborNode.id)];
        cNodePairMap["".concat(cNode.id, "-").concat(neighborNode.id)] = {
          start: nodeMap[cNode.id].idx,
          end: nodeMap[neighborNode.id].idx,
          distance: dist4
        };
      });
      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);
      var currentNDSDistArray = [];
      Object.keys(cNodePairMap).forEach(function(key) {
        if (ndsDist[key]) {
          currentNDSDistArray.push(ndsDist[key]);
          return;
        }
        var intGraph = intGMap[key];
        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);
        currentNDSDistArray.push(ndsDist[key]);
      });
      currentNDSDistArray = currentNDSDistArray.sort(function(a2, b10) {
        return b10 - a2;
      });
      var prune3Invalid = false;
      for (var n2 = 0; n2 < patternLabel2Num; n2++) {
        if (currentNDSDistArray[n2] < currentPatternNDSDistArray[n2]) {
          prune3Invalid = true;
          break;
        }
      }
      if (prune3Invalid) {
        candidates.splice(m3, 1);
        return "continue";
      }
    };
    for (var m2 = candidatesNum - 1; m2 >= 0; m2--) {
      _loop_4(m2);
    }
  });
  var candidateGraphs = [];
  candidates === null || candidates === void 0 ? void 0 : candidates.forEach(function(candidate) {
    var nodeIdx = nodeMap[candidate.id].idx;
    var lengthNeighborUnit = findKNeighborUnit(graphData.nodes, spm[nodeIdx], nodeIdx, nodeLabelProp, length5);
    var neighborNodes = lengthNeighborUnit.neighbors;
    var neighborNum = neighborNodes.length;
    var unmatched = false;
    for (var i3 = neighborNum - 1; i3 >= 0; i3--) {
      if (neighborNodes.length + 1 < pattern.nodes.length) {
        unmatched = true;
        return;
      }
      var neighborNode = neighborNodes[i3];
      var neighborLabel = neighborNode[nodeLabelProp];
      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var key = "".concat(candidate.id, "-").concat(neighborNode.id);
      var distToCandidate = spmMap[key];
      var idx = patternSpDist[neighborLabel].length - 1;
      var maxDistWithLabelInPattern = patternSpDist[neighborLabel][idx];
      if (distToCandidate > maxDistWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      if (directed) {
        var keyBack = "".concat(neighborNode.id, "-").concat(candidate.id);
        var distFromCandidate = spmMap[keyBack];
        idx = patternSpDistBack[neighborLabel].length - 1;
        var maxBackDistWithLabelInPattern = patternSpDistBack[neighborLabel][idx];
        if (distFromCandidate > maxBackDistWithLabelInPattern) {
          neighborNodes.splice(i3, 1);
          continue;
        }
      }
      var ndsToCandidate = ndsDist[key] ? ndsDist[key] : getNDSDist(graphData, candidate, neighborNode, nodeMap, distToCandidate, kNeighborUnits, dsG, nodeLabelProp, edgeLabelProp, ndsDist, intGMap);
      var patternKey = "".concat(beginPNode.id, "-").concat(neighborLabel);
      var minNdsWithLabelInPattern = patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1];
      if (ndsToCandidate < minNdsWithLabelInPattern) {
        neighborNodes.splice(i3, 1);
        continue;
      }
      var _a3 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, neighborLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _a3.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _a3.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _a3.minPatternNodeLabelOutDegree;
      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {
        neighborNodes.splice(i3, 1);
        continue;
      }
    }
    if (!unmatched) {
      candidateGraphs.push({
        nodes: [candidate].concat(neighborNodes)
      });
    }
  });
  var undirectedLengthsToBeginPNode = dijkstra_default(pattern, beginPNode.id, false).length;
  var undirectedLengthsToBeginPNodeLabelMap = {};
  if (directed) {
    Object.keys(undirectedLengthsToBeginPNode).forEach(function(nodeId) {
      var nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])
        undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];
      else
        undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(undirectedLengthsToBeginPNode[nodeId]);
    });
    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(function(pLabel) {
      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort(function(a2, b10) {
        return a2 - b10;
      });
    });
  } else {
    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;
  }
  var candidateGraphNum = candidateGraphs.length;
  var _loop_2 = function _loop_22(i3) {
    var candidateGraph = candidateGraphs[i3];
    var candidate = candidateGraph.nodes[0];
    var candidateNodeLabelCountMap = {};
    var candidateNodeMap = {};
    candidateGraph.nodes.forEach(function(node, q2) {
      candidateNodeMap[node.id] = {
        idx: q2,
        node,
        degree: 0,
        inDegree: 0,
        outDegree: 0
      };
      var cNodeLabel2 = node[nodeLabelProp];
      if (!candidateNodeLabelCountMap[cNodeLabel2])
        candidateNodeLabelCountMap[cNodeLabel2] = 1;
      else
        candidateNodeLabelCountMap[cNodeLabel2]++;
    });
    var candidateEdges = [];
    var edgeLabelCountMap = {};
    graphData.edges.forEach(function(edge) {
      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {
        candidateEdges.push(edge);
        if (!edgeLabelCountMap[edge[edgeLabelProp]])
          edgeLabelCountMap[edge[edgeLabelProp]] = 1;
        else
          edgeLabelCountMap[edge[edgeLabelProp]]++;
        candidateNodeMap[edge.source].degree++;
        candidateNodeMap[edge.target].degree++;
        candidateNodeMap[edge.source].outDegree++;
        candidateNodeMap[edge.target].inDegree++;
      }
    });
    var pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;
    var prunedByEdgeLabel = false;
    for (var e8 = 0; e8 < pattenrEdgeLabelNum; e8++) {
      var label_1 = Object.keys(patternEdgeLabelMap)[e8];
      if (!edgeLabelCountMap[label_1] || edgeLabelCountMap[label_1] < patternEdgeLabelMap[label_1].length) {
        prunedByEdgeLabel = true;
        break;
      }
    }
    if (prunedByEdgeLabel) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var candidateEdgeNum = candidateEdges.length;
    if (candidateEdgeNum < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "break";
    }
    var candidateGraphInvalid = false;
    var _loop_5 = function _loop_52(e9) {
      var edge = candidateEdges[e9];
      var edgeLabel2 = edge[edgeLabelProp];
      var patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel2];
      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
      var sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];
      var targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];
      var edgeMatched = false;
      patternEdgesWithLabel.forEach(function(patternEdge) {
        var patternSource = patternNodeMap[patternEdge.source].node;
        var patternTarget = patternNodeMap[patternEdge.target].node;
        if (patternSource[nodeLabelProp] === sourceLabel && patternTarget[nodeLabelProp] === targetLabel)
          edgeMatched = true;
        if (!directed && patternSource[nodeLabelProp] === targetLabel && patternTarget[nodeLabelProp] === sourceLabel)
          edgeMatched = true;
      });
      if (!edgeMatched) {
        edgeLabelCountMap[edgeLabel2]--;
        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel2] < patternEdgesWithLabel.length) {
          candidateGraphInvalid = true;
          return "break";
        }
        candidateEdges.splice(e9, 1);
        candidateNodeMap[edge.source].degree--;
        candidateNodeMap[edge.target].degree--;
        candidateNodeMap[edge.source].outDegree--;
        candidateNodeMap[edge.target].inDegree--;
        return "continue";
      }
    };
    for (var e8 = candidateEdgeNum - 1; e8 >= 0; e8--) {
      var state_2 = _loop_5(e8);
      if (state_2 === "break")
        break;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    candidateGraph.edges = candidateEdges;
    var lengthsToCandidate = dijkstra_default(candidateGraph, candidateGraph.nodes[0].id, false).length;
    Object.keys(lengthsToCandidate).reverse().forEach(function(targetId) {
      if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid)
        return;
      if (lengthsToCandidate[targetId] === Infinity) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
        return;
      }
      var nLabel = nodeMap[targetId].node[nodeLabelProp];
      if (!undirectedLengthsToBeginPNodeLabelMap[nLabel] || !undirectedLengthsToBeginPNodeLabelMap[nLabel].length || lengthsToCandidate[targetId] > undirectedLengthsToBeginPNodeLabelMap[nLabel][undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1]) {
        var targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];
        candidateNodeLabelCountMap[targetNodeLabel]--;
        if (candidateNodeLabelCountMap[targetNodeLabel] < patternNodeLabelMap[targetNodeLabel].length) {
          candidateGraphInvalid = true;
          return;
        }
        var idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);
        candidateGraph.nodes.splice(idx, 1);
        candidateNodeMap[targetId] = void 0;
      }
    });
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    var degreeChanged = true;
    var loopCount = 0;
    while (degreeChanged && !candidateGraphInvalid) {
      degreeChanged = false;
      var condition = directed ? candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree || candidateNodeMap[candidate.id].inDegree < patternNodeMap[beginPNode.id].inDegree || candidateNodeMap[candidate.id].outDegree < patternNodeMap[beginPNode.id].outDegree : candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree;
      if (condition) {
        candidateGraphInvalid = true;
        break;
      }
      if (candidateNodeLabelCountMap[candidate[nodeLabelProp]] < patternNodeLabelMap[candidate[nodeLabelProp]].length) {
        candidateGraphInvalid = true;
        break;
      }
      var currentCandidateNodeNum = candidateGraph.nodes.length;
      for (var o2 = currentCandidateNodeNum - 1; o2 >= 0; o2--) {
        var cgNode = candidateGraph.nodes[o2];
        var nodeDegree = candidateNodeMap[cgNode.id].degree;
        var nodeInDegree = candidateNodeMap[cgNode.id].inDegree;
        var nodeOutDegree = candidateNodeMap[cgNode.id].outDegree;
        var cNodeLabel = cgNode[nodeLabelProp];
        var _e2 = stashPatternNodeLabelDegreeMap(minPatternNodeLabelDegreeMap, cNodeLabel, patternNodeMap, patternNodeLabelMap), minPatternNodeLabelDegree = _e2.minPatternNodeLabelDegree, minPatternNodeLabelInDegree = _e2.minPatternNodeLabelInDegree, minPatternNodeLabelOutDegree = _e2.minPatternNodeLabelOutDegree;
        var deleteCondition = directed ? nodeDegree < minPatternNodeLabelDegree || nodeInDegree < minPatternNodeLabelInDegree || nodeOutDegree < minPatternNodeLabelOutDegree : nodeDegree < minPatternNodeLabelDegree;
        if (deleteCondition) {
          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;
          if (candidateNodeLabelCountMap[cgNode[nodeLabelProp]] < patternNodeLabelMap[cgNode[nodeLabelProp]].length) {
            candidateGraphInvalid = true;
            break;
          }
          candidateGraph.nodes.splice(o2, 1);
          candidateNodeMap[cgNode.id] = void 0;
          degreeChanged = true;
        }
      }
      if (candidateGraphInvalid || !degreeChanged && loopCount !== 0)
        break;
      candidateEdgeNum = candidateEdges.length;
      for (var y2 = candidateEdgeNum - 1; y2 >= 0; y2--) {
        var cedge = candidateEdges[y2];
        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {
          candidateEdges.splice(y2, 1);
          var edgeLabel = cedge[edgeLabelProp];
          edgeLabelCountMap[edgeLabel]--;
          if (candidateNodeMap[cedge.source]) {
            candidateNodeMap[cedge.source].degree--;
            candidateNodeMap[cedge.source].outDegree--;
          }
          if (candidateNodeMap[cedge.target]) {
            candidateNodeMap[cedge.target].degree--;
            candidateNodeMap[cedge.target].inDegree--;
          }
          if (patternEdgeLabelMap[edgeLabel] && edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length) {
            candidateGraphInvalid = true;
            break;
          }
          degreeChanged = true;
        }
      }
      loopCount++;
    }
    if (candidateGraphInvalid) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
    if (candidateGraphInvalid || candidateGraph.nodes.length < pattern.nodes.length || candidateEdges.length < pattern.edges.length) {
      candidateGraphs.splice(i3, 1);
      return "continue";
    }
  };
  for (var i2 = candidateGraphNum - 1; i2 >= 0; i2--) {
    var state_1 = _loop_2(i2);
    if (state_1 === "break")
      break;
  }
  var currentLength = candidateGraphs.length;
  var _loop_3 = function _loop_32(i3) {
    var cg1 = candidateGraphs[i3];
    var cg1EdgeMap = {};
    cg1.edges.forEach(function(edge) {
      var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
      if (!cg1EdgeMap[key])
        cg1EdgeMap[key] = 1;
      else
        cg1EdgeMap[key]++;
    });
    var _loop_6 = function _loop_62(j3) {
      var cg2 = candidateGraphs[j3];
      var cg2EdgeMap = {};
      cg2.edges.forEach(function(edge) {
        var key = "".concat(edge.source, "-").concat(edge.target, "-").concat(edge.label);
        if (!cg2EdgeMap[key])
          cg2EdgeMap[key] = 1;
        else
          cg2EdgeMap[key]++;
      });
      var same = true;
      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {
        same = false;
      } else {
        Object.keys(cg1EdgeMap).forEach(function(key) {
          if (cg2EdgeMap[key] !== cg1EdgeMap[key])
            same = false;
        });
      }
      if (same) {
        candidateGraphs.splice(j3, 1);
      }
    };
    for (var j2 = currentLength - 1; j2 > i3; j2--) {
      _loop_6(j2);
    }
    currentLength = candidateGraphs.length;
  };
  for (var i2 = 0; i2 <= currentLength - 1; i2++) {
    _loop_3(i2);
  }
  return candidateGraphs;
};
var gaddi_default = GADDI;

// node_modules/@antv/algorithm/es/structs/stack.js
var Stack = function() {
  function Stack2(maxStep) {
    if (maxStep === void 0) {
      maxStep = 10;
    }
    this.linkedList = new linked_list_default();
    this.maxStep = maxStep;
  }
  Object.defineProperty(Stack2.prototype, "length", {
    get: function get2() {
      return this.linkedList.toArray().length;
    },
    enumerable: false,
    configurable: true
  });
  Stack2.prototype.isEmpty = function() {
    return !this.linkedList.head;
  };
  Stack2.prototype.isMaxStack = function() {
    return this.toArray().length >= this.maxStep;
  };
  Stack2.prototype.peek = function() {
    if (this.isEmpty()) {
      return null;
    }
    return this.linkedList.head.value;
  };
  Stack2.prototype.push = function(value) {
    this.linkedList.prepend(value);
    if (this.length > this.maxStep) {
      this.linkedList.deleteTail();
    }
  };
  Stack2.prototype.pop = function() {
    var removeHead = this.linkedList.deleteHead();
    return removeHead ? removeHead.value : null;
  };
  Stack2.prototype.toArray = function() {
    return this.linkedList.toArray().map(function(node) {
      return node.value;
    });
  };
  Stack2.prototype.clear = function() {
    while (!this.isEmpty()) {
      this.pop();
    }
  };
  return Stack2;
}();
var stack_default = Stack;

// node_modules/@antv/algorithm/es/index.js
var detectDirectedCycle3 = detect_cycle_default;
var es_default = {
  getAdjMatrix: adjacent_matrix_default,
  breadthFirstSearch: bfs_default,
  connectedComponent: getConnectedComponents,
  getDegree: degree_default,
  getInDegree,
  getOutDegree,
  detectCycle: detect_cycle_default,
  detectDirectedCycle: detectDirectedCycle3,
  detectAllCycles,
  detectAllDirectedCycle,
  detectAllUndirectedCycle,
  depthFirstSearch,
  dijkstra: dijkstra_default,
  findAllPath,
  findShortestPath,
  floydWarshall: floydWarshall_default,
  labelPropagation: label_propagation_default,
  louvain: louvain_default,
  iLouvain: i_louvain_default,
  kCore: k_core_default,
  kMeans: k_means_default,
  cosineSimilarity: cosine_similarity_default,
  nodesCosineSimilarity: nodes_cosine_similarity_default,
  minimumSpanningTree: mts_default,
  pageRank: pageRank_default,
  getNeighbors,
  Stack: stack_default,
  GADDI: gaddi_default
};

// node_modules/@antv/g6-core/es/util/math.js
var math_exports = {};
__export(math_exports, {
  Line: () => Line,
  applyMatrix: () => applyMatrix,
  compare: () => compare,
  distance: () => distance4,
  floydWarshall: () => floydWarshall3,
  fractionToLine: () => fractionToLine,
  getAdjMatrix: () => getAdjMatrix,
  getBBoxBoundLine: () => getBBoxBoundLine,
  getCircleCenterByPoints: () => getCircleCenterByPoints,
  getCircleIntersectByPoint: () => getCircleIntersectByPoint,
  getDegree: () => getDegree,
  getEllipseIntersectByPoint: () => getEllipseIntersectByPoint,
  getLineIntersect: () => getLineIntersect,
  getPointsCenter: () => getPointsCenter,
  getRectIntersectByPoint: () => getRectIntersectByPoint,
  intersectBBox: () => intersectBBox,
  invertMatrix: () => invertMatrix,
  isPointInPolygon: () => isPointInPolygon,
  isPointsOverlap: () => isPointsOverlap,
  isPolygonsIntersect: () => isPolygonsIntersect,
  itemIntersectByLine: () => itemIntersectByLine,
  lerp: () => lerp5,
  move: () => move,
  pointLineDistance: () => pointLineDistance,
  pointLineSquareDist: () => pointLineSquareDist,
  pointRectSquareDist: () => pointRectSquareDist,
  rotate: () => rotate4,
  scale: () => scale7,
  scaleMatrix: () => scaleMatrix,
  squareDist: () => squareDist,
  translate: () => translate3
});
init_esm();
var transform2 = ext_exports.transform;
var compare = function compare2(attributeName) {
  return function(m2, n2) {
    return m2[attributeName] - n2[attributeName];
  };
};
var isBetween = function isBetween2(value, min6, max7) {
  return value >= min6 && value <= max7;
};
var getLineIntersect = function getLineIntersect2(p0, p1, p2, p3) {
  var tolerance2 = 1e-4;
  var E3 = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var invertKross = 1 / kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s2 = (E3.x * D1.y - E3.y * D1.x) * invertKross;
    var t4 = (E3.x * D0.y - E3.y * D0.x) * invertKross;
    if (!isBetween(s2, 0, 1) || !isBetween(t4, 0, 1))
      return null;
    return {
      x: p0.x + s2 * D0.x,
      y: p0.y + s2 * D0.y
    };
  }
  return null;
};
var getRectIntersectByPoint = function getRectIntersectByPoint2(rect2, point) {
  var x2 = rect2.x, y2 = rect2.y, width = rect2.width, height = rect2.height;
  var cx = x2 + width / 2;
  var cy = y2 + height / 2;
  var points = [];
  var center = {
    x: cx,
    y: cy
  };
  points.push({
    x: x2,
    y: y2
  });
  points.push({
    x: x2 + width,
    y: y2
  });
  points.push({
    x: x2 + width,
    y: y2 + height
  });
  points.push({
    x: x2,
    y: y2 + height
  });
  points.push({
    x: x2,
    y: y2
  });
  var rst = null;
  for (var i2 = 1; i2 < points.length; i2++) {
    rst = getLineIntersect(points[i2 - 1], points[i2], center, point);
    if (rst) {
      break;
    }
  }
  return rst;
};
var getCircleIntersectByPoint = function getCircleIntersectByPoint2(circle2, point) {
  var cx = circle2.x, cy = circle2.y, r2 = circle2.r;
  var x2 = point.x, y2 = point.y;
  var dx = x2 - cx;
  var dy = y2 - cy;
  if (dx * dx + dy * dy < r2 * r2) {
    return null;
  }
  var angle3 = Math.atan(dy / dx);
  return {
    x: cx + Math.abs(r2 * Math.cos(angle3)) * Math.sign(dx),
    y: cy + Math.abs(r2 * Math.sin(angle3)) * Math.sign(dy)
  };
};
var getEllipseIntersectByPoint = function getEllipseIntersectByPoint2(ellipse, point) {
  var a2 = ellipse.rx;
  var b10 = ellipse.ry;
  var cx = ellipse.x;
  var cy = ellipse.y;
  var dx = point.x - cx;
  var dy = point.y - cy;
  var angle3 = Math.atan2(dy / b10, dx / a2);
  if (angle3 < 0) {
    angle3 += 2 * Math.PI;
  }
  return {
    x: cx + a2 * Math.cos(angle3),
    y: cy + b10 * Math.sin(angle3)
  };
};
var applyMatrix = function applyMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  var vector = [point.x, point.y, tag];
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  vec3_exports.transformMat3(vector, vector, matrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var invertMatrix = function invertMatrix2(point, matrix, tag) {
  if (tag === void 0) {
    tag = 1;
  }
  if (!matrix || isNaN(matrix[0])) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var inversedMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);
  if (!inversedMatrix) {
    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var vector = [point.x, point.y, tag];
  vec3_exports.transformMat3(vector, vector, inversedMatrix);
  return {
    x: vector[0],
    y: vector[1]
  };
};
var getCircleCenterByPoints = function getCircleCenterByPoints2(p1, p2, p3) {
  var a2 = p1.x - p2.x;
  var b10 = p1.y - p2.y;
  var c2 = p1.x - p3.x;
  var d2 = p1.y - p3.y;
  var e8 = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;
  var f2 = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;
  var denominator = b10 * c2 - a2 * d2;
  return {
    x: -(d2 * e8 - b10 * f2) / denominator,
    y: -(a2 * f2 - c2 * e8) / denominator
  };
};
var distance4 = function distance5(p1, p2) {
  var vx = p1.x - p2.x;
  var vy = p1.y - p2.y;
  return Math.sqrt(vx * vx + vy * vy);
};
var scaleMatrix = function scaleMatrix2(matrix, ratio) {
  var result = [];
  matrix.forEach(function(row) {
    var newRow = [];
    row.forEach(function(v2) {
      newRow.push(v2 * ratio);
    });
    result.push(newRow);
  });
  return result;
};
var floydWarshall3 = function floydWarshall4(adjMatrix3) {
  var dist4 = [];
  var size2 = adjMatrix3.length;
  for (var i2 = 0; i2 < size2; i2 += 1) {
    dist4[i2] = [];
    for (var j2 = 0; j2 < size2; j2 += 1) {
      if (i2 === j2) {
        dist4[i2][j2] = 0;
      } else if (adjMatrix3[i2][j2] === 0 || !adjMatrix3[i2][j2]) {
        dist4[i2][j2] = Infinity;
      } else {
        dist4[i2][j2] = adjMatrix3[i2][j2];
      }
    }
  }
  for (var k2 = 0; k2 < size2; k2 += 1) {
    for (var i2 = 0; i2 < size2; i2 += 1) {
      for (var j2 = 0; j2 < size2; j2 += 1) {
        if (dist4[i2][j2] > dist4[i2][k2] + dist4[k2][j2]) {
          dist4[i2][j2] = dist4[i2][k2] + dist4[k2][j2];
        }
      }
    }
  }
  return dist4;
};
var getAdjMatrix = function getAdjMatrix2(data, directed) {
  var nodes = data.nodes, edges = data.edges;
  var matrix = [];
  var nodeMap = {};
  if (!nodes) {
    throw new Error("invalid nodes data!");
  }
  if (nodes) {
    nodes.forEach(function(node, i2) {
      nodeMap[node.id] = i2;
      var row = [];
      matrix.push(row);
    });
  }
  if (edges) {
    edges.forEach(function(e8) {
      var source = e8.source, target = e8.target;
      var sIndex = nodeMap[source];
      var tIndex = nodeMap[target];
      matrix[sIndex][tIndex] = 1;
      if (!directed) {
        matrix[tIndex][sIndex] = 1;
      }
    });
  }
  return matrix;
};
var translate3 = function translate4(group, vec) {
  group.translate(vec.x, vec.y);
};
var move = function move2(group, point, animate, animateCfg) {
  if (animateCfg === void 0) {
    animateCfg = {
      duration: 500
    };
  }
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var bbox = group.getCanvasBBox();
  var vx = point.x - bbox.minX;
  var vy = point.y - bbox.minY;
  if (animate) {
    var dx_1 = vx * matrix[0];
    var dy_1 = vy * matrix[4];
    var lastX_1 = 0;
    var lastY_1 = 0;
    var newX_1 = 0;
    var newY_1 = 0;
    group.animate(function(ratio) {
      newX_1 = dx_1 * ratio;
      newY_1 = dy_1 * ratio;
      matrix = transform2(matrix, [["t", newX_1 - lastX_1, newY_1 - lastY_1]]);
      lastX_1 = newX_1;
      lastY_1 = newY_1;
      return {
        matrix
      };
    }, animateCfg);
  } else {
    var movedMatrix = transform2(matrix, [["t", vx, vy]]);
    group.setMatrix(movedMatrix);
  }
};
var scale7 = function scale8(group, ratio) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  var scaleXY = ratio;
  if (!is_array_default(ratio)) {
    scaleXY = [ratio, ratio];
  }
  if (is_array_default(ratio) && ratio.length === 1) {
    scaleXY = [ratio[0], ratio[0]];
  }
  matrix = transform2(matrix, [["s", scaleXY[0], scaleXY[1]]]);
  group.setMatrix(matrix);
};
var rotate4 = function rotate5(group, angle3) {
  var matrix = group.getMatrix();
  if (!matrix) {
    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  }
  matrix = transform2(matrix, [["r", angle3]]);
  group.setMatrix(matrix);
};
var getDegree = function getDegree2(n2, nodeIdxMap, edges) {
  var degrees2 = [];
  for (var i2 = 0; i2 < n2; i2++) {
    degrees2[i2] = 0;
  }
  edges.forEach(function(e8) {
    if (e8.source) {
      degrees2[nodeIdxMap[e8.source]] += 1;
    }
    if (e8.target) {
      degrees2[nodeIdxMap[e8.target]] += 1;
    }
  });
  return degrees2;
};
function onSegment(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
var isPointInPolygon = function isPointInPolygon2(points, x2, y2) {
  var isHit = false;
  var n2 = points.length;
  var tolerance2 = 1e-6;
  function dcmp2(xValue) {
    if (Math.abs(xValue) < tolerance2) {
      return 0;
    }
    return xValue < 0 ? -1 : 1;
  }
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment(p1, p2, [x2, y2])) {
      return true;
    }
    if (dcmp2(p1[1] - y2) > 0 !== dcmp2(p2[1] - y2) > 0 && dcmp2(x2 - (y2 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
};
var intersectBBox = function intersectBBox2(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
};
var lineIntersectPolygon = function lineIntersectPolygon2(lines, line) {
  var isIntersect = false;
  each_default(lines, function(l2) {
    if (getLineIntersect(l2.from, l2.to, line.from, line.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var isPolygonsIntersect = function isPolygonsIntersect2(points1, points2) {
  var getBBox4 = function getBBox5(points) {
    var xArr = points.map(function(p2) {
      return p2[0];
    });
    var yArr = points.map(function(p2) {
      return p2[1];
    });
    return {
      minX: Math.min.apply(null, xArr),
      maxX: Math.max.apply(null, xArr),
      minY: Math.min.apply(null, yArr),
      maxY: Math.max.apply(null, yArr)
    };
  };
  var parseToLines = function parseToLines2(points) {
    var lines = [];
    var count = points.length;
    for (var i2 = 0; i2 < count - 1; i2++) {
      var point = points[i2];
      var next = points[i2 + 1];
      lines.push({
        from: {
          x: point[0],
          y: point[1]
        },
        to: {
          x: next[0],
          y: next[1]
        }
      });
    }
    if (lines.length > 1) {
      var first = points[0];
      var last2 = points[count - 1];
      lines.push({
        from: {
          x: last2[0],
          y: last2[1]
        },
        to: {
          x: first[0],
          y: first[1]
        }
      });
    }
    return lines;
  };
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox4(points1);
  var bbox2 = getBBox4(points2);
  if (!intersectBBox(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each_default(points2, function(point) {
    if (isPointInPolygon(points1, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each_default(points1, function(point) {
    if (isPointInPolygon(points2, point[0], point[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each_default(lines2, function(line) {
    if (lineIntersectPolygon(lines1, line)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
};
var Line = function() {
  function Line5(x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  }
  Line5.prototype.getBBox = function() {
    var minX = Math.min(this.x1, this.x2);
    var minY = Math.min(this.y1, this.y2);
    var maxX = Math.max(this.x1, this.x2);
    var maxY = Math.max(this.y1, this.y2);
    var res = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return res;
  };
  return Line5;
}();
var getBBoxBoundLine = function getBBoxBoundLine2(bbox, direction3) {
  var bounds = {
    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],
    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],
    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],
    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]
  };
  return bounds[direction3];
};
var fractionAlongLineA = function fractionAlongLineA2(la2, lb) {
  var uaT = (lb.x2 - lb.x1) * (la2.y1 - lb.y1) - (lb.y2 - lb.y1) * (la2.x1 - lb.x1);
  var ubT = (la2.x2 - la2.x1) * (la2.y1 - lb.y1) - (la2.y2 - la2.y1) * (la2.x1 - lb.x1);
  var uB = (lb.y2 - lb.y1) * (la2.x2 - la2.x1) - (lb.x2 - lb.x1) * (la2.y2 - la2.y1);
  if (uB) {
    var ua2 = uaT / uB;
    var ub = ubT / uB;
    if (ua2 >= 0 && ua2 <= 1 && ub >= 0 && ub <= 1) {
      return ua2;
    }
  }
  return Number.POSITIVE_INFINITY;
};
var itemIntersectByLine = function itemIntersectByLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var countIntersections = 0;
  var intersections = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x2 = _a2[2], y2 = _a2[3];
    intersections[i2] = getLineIntersect({
      x: line.x1,
      y: line.y1
    }, {
      x: line.x2,
      y: line.y2
    }, {
      x: x1,
      y: y1
    }, {
      x: x2,
      y: y2
    });
    if (intersections[i2]) {
      countIntersections += 1;
    }
  }
  return [intersections, countIntersections];
};
var fractionToLine = function fractionToLine2(item, line) {
  var directions = ["top", "left", "bottom", "right"];
  var bbox = item.getBBox();
  var minDistance = Number.POSITIVE_INFINITY;
  var countIntersections = 0;
  for (var i2 = 0; i2 < 4; i2++) {
    var _a2 = getBBoxBoundLine(bbox, directions[i2]), x1 = _a2[0], y1 = _a2[1], x2 = _a2[2], y2 = _a2[3];
    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));
    testDistance = Math.abs(testDistance - 0.5);
    if (testDistance >= 0 && testDistance <= 1) {
      countIntersections += 1;
      minDistance = testDistance < minDistance ? testDistance : minDistance;
    }
  }
  if (countIntersections === 0)
    return -1;
  return minDistance;
};
var getPointsCenter = function getPointsCenter2(points) {
  var centerX = 0;
  var centerY = 0;
  if (points.length > 0) {
    for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
      var point = points_1[_i2];
      centerX += point.x;
      centerY += point.y;
    }
    centerX /= points.length;
    centerY /= points.length;
  }
  return {
    x: centerX,
    y: centerY
  };
};
var squareDist = function squareDist2(a2, b10) {
  return Math.pow(a2.x - b10.x, 2) + Math.pow(a2.y - b10.y, 2);
};
var pointLineSquareDist = function pointLineSquareDist2(point, line) {
  var x1 = line.x1;
  var y1 = line.y1;
  var x2 = line.x2 - x1;
  var y2 = line.y2 - y1;
  var px = point.x - x1;
  var py = point.y - y1;
  var dotprod = px * x2 + py * y2;
  var projlenSq;
  if (dotprod <= 0) {
    projlenSq = 0;
  } else {
    px = x2 - px;
    py = y2 - py;
    dotprod = px * x2 + py * y2;
    if (dotprod <= 0) {
      projlenSq = 0;
    } else {
      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);
    }
  }
  var lenSq = px * px + py * py - projlenSq;
  if (lenSq < 0) {
    lenSq = 0;
  }
  return lenSq;
};
var isPointsOverlap = function isPointsOverlap2(p1, p2, e8) {
  if (e8 === void 0) {
    e8 = 1e-3;
  }
  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e8, 2);
};
var pointRectSquareDist = function pointRectSquareDist2(point, rect2) {
  var isLeft = point.x < rect2.x;
  var isRight = point.x > rect2.x + rect2.width;
  var isTop = point.y > rect2.y + rect2.height;
  var isBottom = point.y < rect2.y;
  var isPointOutside = isLeft || isRight || isTop || isBottom;
  if (!isPointOutside) {
    return 0;
  }
  if (isTop && !isLeft && !isRight) {
    return Math.pow(rect2.y + rect2.height - point.y, 2);
  }
  if (isBottom && !isLeft && !isRight) {
    return Math.pow(point.y - rect2.y, 2);
  }
  if (isLeft && !isTop && !isBottom) {
    return Math.pow(rect2.x - point.x, 2);
  }
  if (isRight && !isTop && !isBottom) {
    return Math.pow(rect2.x + rect2.width - point.x, 2);
  }
  var dx = Math.min(Math.abs(rect2.x - point.x), Math.abs(rect2.x + rect2.width - point.x));
  var dy = Math.min(Math.abs(rect2.y - point.y), Math.abs(rect2.y + rect2.height - point.y));
  return dx * dx + dy * dy;
};
var pointLineDistance = function pointLineDistance2(line, point) {
  var x1 = line[0], y1 = line[1], x2 = line[2], y2 = line[3];
  var x3 = point.x, y3 = point.y;
  var d2 = [x2 - x1, y2 - y1];
  if (vec2_exports.exactEquals(d2, [0, 0])) {
    return NaN;
  }
  var u2 = [-d2[1], d2[0]];
  vec2_exports.normalize(u2, u2);
  var a2 = [x3 - x1, y3 - y1];
  return Math.abs(vec2_exports.dot(a2, u2));
};
var lerp5 = function lerp6(start, end2, alpha) {
  return start + (end2 - start) * alpha;
};

// node_modules/@antv/g6-core/es/util/validation.js
init_esm();

// node_modules/@antv/g6-core/es/util/graphic.js
var graphic_exports = {};
__export(graphic_exports, {
  cloneBesidesImg: () => cloneBesidesImg,
  getBBox: () => getBBox,
  getComboBBox: () => getComboBBox,
  getLabelPosition: () => getLabelPosition,
  getLetterWidth: () => getLetterWidth,
  getLoopCfgs: () => getLoopCfgs,
  getTextSize: () => getTextSize,
  plainCombosToTrees: () => plainCombosToTrees,
  reconstructTree: () => reconstructTree,
  shouldRefreshEdge: () => shouldRefreshEdge,
  traverseTree: () => traverseTree,
  traverseTreeUp: () => traverseTreeUp
});

// node_modules/@antv/g6-core/es/global.js
var subjectColor = "rgb(95, 149, 255)";
var backColor = "rgb(255, 255, 255)";
var textColor = "rgb(0, 0, 0)";
var activeFill = "rgb(247, 250, 255)";
var nodeMainFill = "rgb(239, 244, 255)";
var comboFill = "rgb(253, 253, 253)";
var disabledFill = "rgb(250, 250, 250)";
var edgeMainStroke = "rgb(224, 224, 224)";
var edgeInactiveStroke = "rgb(234, 234, 234)";
var edgeDisablesStroke = "rgb(245, 245, 245)";
var inactiveStroke = "rgb(191, 213, 255)";
var highlightStroke = "#4572d9";
var highlightFill = "rgb(223, 234, 255)";
var colorSet = {
  mainStroke: subjectColor,
  mainFill: nodeMainFill,
  activeStroke: subjectColor,
  activeFill,
  inactiveStroke,
  inactiveFill: activeFill,
  selectedStroke: subjectColor,
  selectedFill: backColor,
  highlightStroke,
  highlightFill,
  disableStroke: edgeMainStroke,
  disableFill: disabledFill,
  edgeMainStroke,
  edgeActiveStroke: subjectColor,
  edgeInactiveStroke,
  edgeSelectedStroke: subjectColor,
  edgeHighlightStroke: subjectColor,
  edgeDisableStroke: edgeDisablesStroke,
  comboMainStroke: edgeMainStroke,
  comboMainFill: comboFill,
  comboActiveStroke: subjectColor,
  comboActiveFill: activeFill,
  comboInactiveStroke: edgeMainStroke,
  comboInactiveFill: comboFill,
  comboSelectedStroke: subjectColor,
  comboSelectedFill: comboFill,
  comboHighlightStroke: highlightStroke,
  comboHighlightFill: comboFill,
  comboDisableStroke: edgeInactiveStroke,
  comboDisableFill: disabledFill
};
var global_default = {
  version: "0.6.4",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet.mainStroke,
      fill: nodeMainFill
    },
    size: 20,
    color: colorSet.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke
    }
  },
  nodeStateStyles: {
    active: {
      fill: colorSet.activeFill,
      stroke: colorSet.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet.selectedFill,
      stroke: colorSet.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet.highlightFill,
      stroke: colorSet.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet.inactiveFill,
      stroke: colorSet.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet.disableFill,
      stroke: colorSet.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet.edgeMainStroke
  },
  edgeStateStyles: {
    active: {
      stroke: colorSet.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor,
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet.comboMainFill,
      lineWidth: 1,
      stroke: colorSet.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  comboStateStyles: {
    active: {
      stroke: colorSet.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet.comboActiveFill
    },
    selected: {
      stroke: colorSet.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet.comboSelectedFill,
      shadowColor: colorSet.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet.comboInactiveStroke,
      fill: colorSet.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet.comboDisableStroke,
      fill: colorSet.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  windowFontFamily: typeof window !== "undefined" && window.getComputedStyle && document.body ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
};

// node_modules/@antv/g6-core/es/util/letterAspectRatio.js
var letterAspectRatio_default = {
  " ": 0.3329986572265625,
  a: 0.5589996337890625,
  A: 0.6569992065429687,
  b: 0.58599853515625,
  B: 0.6769989013671875,
  c: 0.5469985961914062,
  C: 0.7279998779296875,
  d: 0.58599853515625,
  D: 0.705999755859375,
  e: 0.554998779296875,
  E: 0.63699951171875,
  f: 0.37299957275390627,
  F: 0.5769989013671875,
  g: 0.5909988403320312,
  G: 0.7479995727539063,
  h: 0.555999755859375,
  H: 0.7199996948242188,
  i: 0.255999755859375,
  I: 0.23699951171875,
  j: 0.26699981689453123,
  J: 0.5169998168945312,
  k: 0.5289993286132812,
  K: 0.6899993896484375,
  l: 0.23499908447265624,
  L: 0.5879989624023437,
  m: 0.854998779296875,
  M: 0.8819992065429687,
  n: 0.5589996337890625,
  N: 0.7189987182617188,
  o: 0.58599853515625,
  O: 0.7669998168945312,
  p: 0.58599853515625,
  P: 0.6419998168945312,
  q: 0.58599853515625,
  Q: 0.7669998168945312,
  r: 0.3649993896484375,
  R: 0.6759994506835938,
  s: 0.504998779296875,
  S: 0.6319992065429687,
  t: 0.354998779296875,
  T: 0.6189987182617187,
  u: 0.5599990844726562,
  U: 0.7139999389648437,
  v: 0.48199920654296874,
  V: 0.6389999389648438,
  w: 0.754998779296875,
  W: 0.929998779296875,
  x: 0.5089996337890625,
  X: 0.63699951171875,
  y: 0.4959991455078125,
  Y: 0.66199951171875,
  z: 0.48699951171875,
  Z: 0.6239990234375,
  "0": 0.6,
  "1": 0.40099945068359377,
  "2": 0.6,
  "3": 0.6,
  "4": 0.6,
  "5": 0.6,
  "6": 0.6,
  "7": 0.5469985961914062,
  "8": 0.6,
  "9": 0.6,
  "[": 0.3329986572265625,
  "]": 0.3329986572265625,
  ",": 0.26399993896484375,
  ".": 0.26399993896484375,
  ";": 0.26399993896484375,
  ":": 0.26399993896484375,
  "{": 0.3329986572265625,
  "}": 0.3329986572265625,
  "\\": 0.5,
  "|": 0.19499969482421875,
  "=": 0.604998779296875,
  "+": 0.604998779296875,
  "-": 0.604998779296875,
  _: 0.5,
  "`": 0.3329986572265625,
  " ~": 0.8329986572265625,
  "!": 0.3329986572265625,
  "@": 0.8579986572265625,
  "#": 0.6,
  $: 0.6,
  "%": 0.9699996948242188,
  "^": 0.517999267578125,
  "&": 0.7259994506835937,
  "*": 0.505999755859375,
  "(": 0.3329986572265625,
  ")": 0.3329986572265625,
  "<": 0.604998779296875,
  ">": 0.604998779296875,
  "/": 0.5,
  "?": 0.53699951171875
};

// node_modules/@antv/g6-core/es/util/graphic.js
init_esm();
var PI = Math.PI;
var sin = Math.sin;
var cos = Math.cos;
var SELF_LINK_SIN = sin(PI / 8);
var SELF_LINK_COS = cos(PI / 8);
var getBBox = function getBBox2(element, group) {
  var bbox = element.getBBox();
  var leftTop = {
    x: bbox.minX,
    y: bbox.minY
  };
  var rightBottom = {
    x: bbox.maxX,
    y: bbox.maxY
  };
  if (group) {
    var matrix = group.getMatrix();
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    leftTop = applyMatrix(leftTop, matrix);
    rightBottom = applyMatrix(rightBottom, matrix);
  }
  var lx = leftTop.x, ly = leftTop.y;
  var rx = rightBottom.x, ry = rightBottom.y;
  return {
    x: lx,
    y: ly,
    minX: lx,
    minY: ly,
    maxX: rx,
    maxY: ry,
    width: rx - lx,
    height: ry - ly
  };
};
var getLoopCfgs = function getLoopCfgs2(cfg) {
  var item = cfg.sourceNode || cfg.targetNode;
  var container2 = item.get("group");
  var containerMatrix = container2.getMatrix();
  if (!containerMatrix)
    containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  var keyShape = item.getKeyShape();
  var bbox = keyShape.getBBox();
  var loopCfg = cfg.loopCfg || {};
  var dist4 = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2;
  var position = loopCfg.position || global_default.defaultLoopPosition;
  var center = [containerMatrix[6], containerMatrix[7]];
  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];
  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];
  var rstart = bbox.height / 2;
  var rend = bbox.height / 2;
  var sinDeltaStart = rstart * SELF_LINK_SIN;
  var cosDeltaStart = rstart * SELF_LINK_COS;
  var sinDeltaEnd = rend * SELF_LINK_SIN;
  var cosDeltaEnd = rend * SELF_LINK_COS;
  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {
    switch (position) {
      case "top":
        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
        break;
      case "top-right":
        rstart = bbox.height / 2;
        rend = bbox.width / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];
        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];
        break;
      case "right":
        rstart = bbox.width / 2;
        rend = bbox.width / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];
        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];
        break;
      case "bottom-right":
        rstart = bbox.width / 2;
        rend = bbox.height / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];
        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];
        break;
      case "bottom":
        rstart = bbox.height / 2;
        rend = bbox.height / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];
        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];
        break;
      case "bottom-left":
        rstart = bbox.height / 2;
        rend = bbox.width / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];
        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];
        break;
      case "left":
        rstart = bbox.width / 2;
        rend = bbox.width / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];
        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];
        break;
      case "top-left":
        rstart = bbox.width / 2;
        rend = bbox.height / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];
        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];
        break;
      default:
        rstart = bbox.width / 2;
        rend = bbox.width / 2;
        sinDeltaStart = rstart * SELF_LINK_SIN;
        cosDeltaStart = rstart * SELF_LINK_COS;
        sinDeltaEnd = rend * SELF_LINK_SIN;
        cosDeltaEnd = rend * SELF_LINK_COS;
        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];
        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];
    }
    if (loopCfg.clockwise === false) {
      var swap = [startPoint[0], startPoint[1]];
      startPoint = [endPoint[0], endPoint[1]];
      endPoint = [swap[0], swap[1]];
    }
  }
  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];
  var scaleRateStart = (rstart + dist4) / rstart;
  var scaleRateEnd = (rend + dist4) / rend;
  if (loopCfg.clockwise === false) {
    scaleRateStart = (rend + dist4) / rend;
    scaleRateEnd = (rstart + dist4) / rstart;
  }
  var startExtendVec = vec2_exports.scale([0, 0], startVec, scaleRateStart);
  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];
  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];
  var endExtendVec = vec2_exports.scale([0, 0], endVec, scaleRateEnd);
  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];
  cfg.startPoint = {
    x: startPoint[0],
    y: startPoint[1]
  };
  cfg.endPoint = {
    x: endPoint[0],
    y: endPoint[1]
  };
  cfg.controlPoints = [{
    x: controlPoint1[0],
    y: controlPoint1[1]
  }, {
    x: controlPoint2[0],
    y: controlPoint2[1]
  }];
  return cfg;
};
var getLabelPosition = function getLabelPosition2(pathShape, percent, refX, refY, rotate7) {
  var TAN_OFFSET = 1e-4;
  var vector = [];
  var point = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent);
  if (!point) {
    return {
      x: 0,
      y: 0,
      angle: 0
    };
  }
  if (percent < TAN_OFFSET) {
    vector = pathShape.getStartTangent().reverse();
  } else if (percent > 1 - TAN_OFFSET) {
    vector = pathShape.getEndTangent();
  } else {
    var offsetPoint = pathShape === null || pathShape === void 0 ? void 0 : pathShape.getPoint(percent + TAN_OFFSET);
    vector.push([point.x, point.y]);
    vector.push([offsetPoint.x, offsetPoint.y]);
  }
  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);
  if (rad < 0) {
    rad += PI * 2;
  }
  if (refX) {
    point.x += cos(rad) * refX;
    point.y += sin(rad) * refX;
  }
  if (refY) {
    var normal2 = rad - PI / 2;
    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {
      normal2 -= PI;
    }
    point.x += cos(normal2) * refY;
    point.y += sin(normal2) * refY;
  }
  var result = {
    x: point.x,
    y: point.y,
    angle: rad
  };
  if (rotate7) {
    if (rad > 0.5 * PI && rad < 1.5 * PI) {
      rad -= PI;
    }
    return __assign2({
      rotate: rad
    }, result);
  }
  return result;
};
var traverse = function traverse2(data, fn2) {
  if (fn2(data) === false) {
    return false;
  }
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverse2(data.children[i2], fn2))
        return false;
    }
  }
  return true;
};
var traverseUp = function traverseUp2(data, fn2) {
  if (data && data.children) {
    for (var i2 = data.children.length - 1; i2 >= 0; i2--) {
      if (!traverseUp2(data.children[i2], fn2))
        return;
    }
  }
  if (fn2(data) === false) {
    return false;
  }
  return true;
};
var traverseTree = function traverseTree2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverse(data, fn2);
};
var traverseTreeUp = function traverseTreeUp2(data, fn2) {
  if (typeof fn2 !== "function") {
    return;
  }
  traverseUp(data, fn2);
};
var getLetterWidth = function getLetterWidth2(letter, fontSize) {
  return fontSize * (letterAspectRatio_default[letter] || 1);
};
var getTextSize = function getTextSize2(text, fontSize) {
  var width = 0;
  var pattern = new RegExp("[\u4E00-\u9FA5]+");
  text.split("").forEach(function(letter) {
    if (pattern.test(letter)) {
      width += fontSize;
    } else {
      width += getLetterWidth(letter, fontSize);
    }
  });
  return [width, fontSize];
};
var plainCombosToTrees = function plainCombosToTrees2(array, nodes) {
  var result = [];
  var addedMap = {};
  var modelMap = {};
  array.forEach(function(d2) {
    modelMap[d2.id] = d2;
  });
  array.forEach(function(d2, i2) {
    var cd = clone_default(d2);
    cd.itemType = "combo";
    cd.children = void 0;
    if (cd.parentId === cd.id) {
      console.warn("The parentId for combo ".concat(cd.id, " can not be the same as the combo's id"));
      delete cd.parentId;
    } else if (cd.parentId && !modelMap[cd.parentId]) {
      console.warn("The parent combo for combo ".concat(cd.id, " does not exist!"));
      delete cd.parentId;
    }
    var mappedObj = addedMap[cd.id];
    if (mappedObj) {
      cd.children = mappedObj.children;
      addedMap[cd.id] = cd;
      mappedObj = cd;
      if (!mappedObj.parentId) {
        result.push(mappedObj);
        return;
      }
      var mappedParent = addedMap[mappedObj.parentId];
      if (mappedParent) {
        if (mappedParent.children)
          mappedParent.children.push(cd);
        else
          mappedParent.children = [cd];
      } else {
        var parent_1 = {
          id: mappedObj.parentId,
          children: [mappedObj]
        };
        addedMap[mappedObj.parentId] = parent_1;
        addedMap[cd.id] = cd;
      }
      return;
    }
    if (is_string_default(d2.parentId)) {
      var parent_2 = addedMap[d2.parentId];
      if (parent_2) {
        if (parent_2.children)
          parent_2.children.push(cd);
        else
          parent_2.children = [cd];
        addedMap[cd.id] = cd;
      } else {
        var pa2 = {
          id: d2.parentId,
          children: [cd]
        };
        addedMap[pa2.id] = pa2;
        addedMap[cd.id] = cd;
      }
    } else {
      result.push(cd);
      addedMap[cd.id] = cd;
    }
  });
  var nodeMap = {};
  (nodes || []).forEach(function(node) {
    nodeMap[node.id] = node;
    var combo = addedMap[node.comboId];
    if (combo) {
      var cnode = {
        id: node.id,
        comboId: node.comboId
      };
      if (combo.children)
        combo.children.push(cnode);
      else
        combo.children = [cnode];
      cnode.itemType = "node";
      addedMap[node.id] = cnode;
    }
  });
  var maxDepth = 0;
  result.forEach(function(tree) {
    tree.depth = maxDepth + 10;
    traverse(tree, function(child) {
      var parent;
      var itemType = addedMap[child.id].itemType;
      if (itemType === "node") {
        parent = addedMap[child.comboId];
      } else {
        parent = addedMap[child.parentId];
      }
      if (parent) {
        if (itemType === "node")
          child.depth = maxDepth + 1;
        else
          child.depth = maxDepth + 10;
      } else {
        child.depth = maxDepth + 10;
      }
      if (maxDepth < child.depth)
        maxDepth = child.depth;
      var oriNodeModel = nodeMap[child.id];
      if (oriNodeModel) {
        oriNodeModel.depth = child.depth;
      }
      return true;
    });
  });
  return result;
};
var reconstructTree = function reconstructTree2(trees, subtreeId, newParentId) {
  var _a2;
  var brothers = trees;
  var subtree;
  var comboChildsMap = {
    root: {
      children: trees
    }
  };
  var foundSubTree = false;
  var oldParentId = "root";
  (trees || []).forEach(function(tree) {
    if (foundSubTree)
      return;
    if (tree.id === subtreeId) {
      subtree = tree;
      if (tree.itemType === "combo") {
        subtree.parentId = newParentId;
      } else {
        subtree.comboId = newParentId;
      }
      foundSubTree = true;
      return;
    }
    traverseTree(tree, function(child) {
      var _a3;
      comboChildsMap[child.id] = {
        children: (child === null || child === void 0 ? void 0 : child.children) || []
      };
      brothers = (_a3 = comboChildsMap[child.parentId || child.comboId || "root"]) === null || _a3 === void 0 ? void 0 : _a3.children;
      if (child && (child.removed || subtreeId === child.id) && brothers) {
        oldParentId = child.parentId || child.comboId || "root";
        subtree = child;
        if (child.itemType === "combo") {
          subtree.parentId = newParentId;
        } else {
          subtree.comboId = newParentId;
        }
        foundSubTree = true;
        return false;
      }
      return true;
    });
  });
  brothers = (_a2 = comboChildsMap[oldParentId]) === null || _a2 === void 0 ? void 0 : _a2.children;
  var index = brothers ? brothers.indexOf(subtree) : -1;
  if (index > -1)
    brothers.splice(index, 1);
  if (!foundSubTree) {
    subtree = {
      id: subtreeId,
      itemType: "node",
      comboId: newParentId
    };
    comboChildsMap[subtreeId] = {
      children: void 0
    };
  }
  if (subtreeId) {
    var found_1 = false;
    if (newParentId) {
      var newParentDepth_1 = 0;
      (trees || []).forEach(function(tree) {
        if (found_1)
          return;
        traverseTree(tree, function(child) {
          if (newParentId === child.id) {
            found_1 = true;
            if (child.children)
              child.children.push(subtree);
            else
              child.children = [subtree];
            newParentDepth_1 = child.depth;
            if (subtree.itemType === "node")
              subtree.depth = newParentDepth_1 + 2;
            else
              subtree.depth = newParentDepth_1 + 1;
            return false;
          }
          return true;
        });
      });
    } else if ((!newParentId || !found_1) && subtree.itemType !== "node") {
      trees.push(subtree);
    }
    var currentDepth_1 = subtree.depth;
    traverseTree(subtree, function(child) {
      if (child.itemType === "node")
        currentDepth_1 += 2;
      else
        currentDepth_1 += 1;
      child.depth = currentDepth_1;
      return true;
    });
  }
  return trees;
};
var getComboBBox = function getComboBBox2(children, graph, combo) {
  var comboBBox = {
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity,
    x: void 0,
    y: void 0,
    width: void 0,
    height: void 0,
    centerX: void 0,
    centerY: void 0
  };
  if (!children || children.length === 0) {
    var comboModel = combo === null || combo === void 0 ? void 0 : combo.getModel();
    var _a2 = comboModel || {}, x2 = _a2.x, y2 = _a2.y;
    return {
      minX: x2,
      minY: y2,
      maxX: x2,
      maxY: y2,
      x: x2,
      y: y2,
      width: void 0,
      height: void 0
    };
  }
  children.forEach(function(child) {
    var childItem = graph.findById(child.id);
    if (!childItem || !childItem.isVisible())
      return;
    childItem.set("bboxCanvasCache", void 0);
    var childBBox = childItem.getCanvasBBox();
    if (childBBox.x && comboBBox.minX > childBBox.minX)
      comboBBox.minX = childBBox.minX;
    if (childBBox.y && comboBBox.minY > childBBox.minY)
      comboBBox.minY = childBBox.minY;
    if (childBBox.x && comboBBox.maxX < childBBox.maxX)
      comboBBox.maxX = childBBox.maxX;
    if (childBBox.y && comboBBox.maxY < childBBox.maxY)
      comboBBox.maxY = childBBox.maxY;
  });
  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;
  comboBBox.width = comboBBox.maxX - comboBBox.minX;
  comboBBox.height = comboBBox.maxY - comboBBox.minY;
  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;
  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;
  Object.keys(comboBBox).forEach(function(key) {
    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {
      comboBBox[key] = void 0;
    }
  });
  return comboBBox;
};
var shouldRefreshEdge = function shouldRefreshEdge2(cfg) {
  var refreshEdge = is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size;
  if (cfg.style)
    refreshEdge = refreshEdge || is_number_default(cfg.style.r) || is_number_default(cfg.style.width) || is_number_default(cfg.style.height) || is_number_default(cfg.style.rx) || is_number_default(cfg.style.ry);
  return refreshEdge;
};
var cloneBesidesImg = function cloneBesidesImg2(obj) {
  var clonedObj = {};
  Object.keys(obj).forEach(function(key1) {
    var obj2 = obj[key1];
    if (is_object_default(obj2) && !is_array_default(obj2)) {
      var clonedObj2_1 = {};
      Object.keys(obj2).forEach(function(key2) {
        var v2 = obj2[key2];
        if (key2 === "img" && !is_string_default(v2))
          return;
        clonedObj2_1[key2] = clone_default(v2);
      });
      clonedObj[key1] = clonedObj2_1;
    } else {
      clonedObj[key1] = clone_default(obj2);
    }
  });
  return clonedObj;
};

// node_modules/@antv/g6-core/es/util/validation.js
var dataValidation = function dataValidation2(data) {
  if (!data) {
    console.error("G6 Error Tips: the data must be defined");
    return false;
  }
  var nodes = data.nodes, edges = data.edges, _a2 = data.combos, combos = _a2 === void 0 ? [] : _a2;
  if (!nodes && !edges) {
    var validated_1 = true;
    traverseTree(data, function(param) {
      if (!is_string_default(param.id)) {
        validated_1 = false;
        return false;
      }
      return true;
    });
    return validated_1;
  }
  var nonNode = (nodes || []).find(function(node) {
    return !is_string_default(node.id);
  });
  if (nonNode) {
    console.warn("G6 Warning Tips: missing 'id' property, or %c".concat(nonNode.id, "%c is not a string."), "font-size: 20px; color: red;", "");
    return false;
  }
  var nodeIds = (nodes || []).map(function(node) {
    return node.id;
  });
  var comboIds = combos === null || combos === void 0 ? void 0 : combos.map(function(combo) {
    return combo.id;
  });
  var ids = __spreadArray(__spreadArray([], nodeIds, true), comboIds, true);
  var nonEdges = (edges || []).find(function(edge) {
    return !ids.includes(edge.source) || !ids.includes(edge.target);
  });
  if (nonEdges) {
    console.warn("G6 Warning Tips: The source %c".concat(nonEdges.source, "%c or the target %c").concat(nonEdges.target, "%c of the edge do not exist in the nodes or combos."), "font-size: 20px; color: red;", "", "font-size: 20px; color: red;", "");
    return false;
  }
  return true;
};
var singleDataValidation = function singleDataValidation2(type, data) {
  if (type === "node" || type === "combo") {
    if (data.id && !is_string_default(data.id)) {
      console.warn("G6 Warning Tips: missing 'id' property, or the 'id' %c".concat(data.id, "%c is not a string."), "font-size: 20px; color: red;", "");
      return false;
    }
  } else if (type === "edge") {
    if (!data.source || !data.target) {
      console.warn("G6 Warning Tips: missing 'source' or 'target' for the edge.");
      return false;
    }
  }
  return true;
};

// node_modules/@antv/g6-core/es/graph/controller/mode.js
init_esm();
var ModeController = function() {
  function ModeController2(graph) {
    this.graph = graph;
    this.destroyed = false;
    this.modes = graph.get("modes") || {
      default: []
    };
    this.formatModes();
    this.mode = graph.get("defaultMode") || "default";
    this.currentBehaves = [];
    this.setMode(this.mode);
  }
  ModeController2.prototype.formatModes = function() {
    var modes = this.modes;
    each_default(modes, function(mode) {
      each_default(mode, function(behavior, i2) {
        if (is_string_default(behavior)) {
          mode[i2] = {
            type: behavior
          };
        }
      });
    });
  };
  ModeController2.prototype.setBehaviors = function(mode) {
    var graph = this.graph;
    var behaviors2 = this.modes[mode];
    var behaves = [];
    var behave;
    each_default(behaviors2 || [], function(behavior) {
      var BehaviorInstance = behavior_default.getBehavior(behavior.type || behavior);
      if (!BehaviorInstance) {
        return;
      }
      behave = new BehaviorInstance(behavior);
      if (behave) {
        behave.bind(graph);
        behaves.push(behave);
      }
    });
    this.currentBehaves = behaves;
  };
  ModeController2.mergeBehaviors = function(modeBehaviors, behaviors2) {
    each_default(behaviors2, function(behavior) {
      if (modeBehaviors.indexOf(behavior) < 0) {
        if (is_string_default(behavior)) {
          behavior = {
            type: behavior
          };
        }
        modeBehaviors.push(behavior);
      }
    });
    return modeBehaviors;
  };
  ModeController2.filterBehaviors = function(modeBehaviors, behaviors2) {
    var result = [];
    modeBehaviors.forEach(function(behavior) {
      var type = "";
      if (is_string_default(behavior)) {
        type = behavior;
      } else {
        type = behavior.type;
      }
      if (behaviors2.indexOf(type) < 0) {
        result.push(behavior);
      }
    });
    return result;
  };
  ModeController2.prototype.setMode = function(mode) {
    var _a2 = this, modes = _a2.modes, graph = _a2.graph;
    var current = mode;
    var behaviors2 = modes[current];
    if (!behaviors2) {
      return;
    }
    graph.emit("beforemodechange", {
      mode
    });
    each_default(this.currentBehaves, function(behave) {
      if (behave.delegate)
        behave.delegate.remove();
      behave.unbind(graph);
    });
    this.setBehaviors(current);
    graph.emit("aftermodechange", {
      mode
    });
    this.mode = mode;
  };
  ModeController2.prototype.getMode = function() {
    return this.mode;
  };
  ModeController2.prototype.manipulateBehaviors = function(behaviors2, modes, isAdd) {
    var _this = this;
    var behaves;
    if (!is_array_default(behaviors2)) {
      behaves = [behaviors2];
    } else {
      behaves = behaviors2;
    }
    if (is_array_default(modes)) {
      each_default(modes, function(mode) {
        if (!_this.modes[mode]) {
          if (isAdd) {
            _this.modes[mode] = behaves;
          }
        } else if (isAdd) {
          _this.modes[mode] = ModeController2.mergeBehaviors(_this.modes[mode] || [], behaves);
        } else {
          _this.modes[mode] = ModeController2.filterBehaviors(_this.modes[mode] || [], behaves);
        }
      });
      return this;
    }
    var currentMode = modes;
    if (!modes) {
      currentMode = this.mode;
    }
    if (!this.modes[currentMode]) {
      if (isAdd) {
        this.modes[currentMode] = behaves;
      }
    }
    if (isAdd) {
      this.modes[currentMode] = ModeController2.mergeBehaviors(this.modes[currentMode] || [], behaves);
    } else {
      this.modes[currentMode] = ModeController2.filterBehaviors(this.modes[currentMode] || [], behaves);
    }
    this.formatModes();
    this.setMode(this.mode);
    return this;
  };
  ModeController2.prototype.updateBehavior = function(behavior, newCfg, mode) {
    if (is_string_default(behavior)) {
      behavior = {
        type: behavior
      };
    }
    var behaviorSet = [];
    if (!mode || mode === this.mode || mode === "default") {
      behaviorSet = this.currentBehaves;
      if (!behaviorSet || !behaviorSet.length) {
        console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
        return this;
      }
      var length_1 = behaviorSet.length;
      for (var i2 = 0; i2 < length_1; i2++) {
        var behave = behaviorSet[i2];
        if (behave.type === behavior.type) {
          behave.updateCfg(newCfg);
          return this;
        }
        if (i2 === length_1 - 1)
          console.warn("Update behavior failed! There is no such behavior in the mode");
      }
    } else {
      behaviorSet = this.modes[mode];
      if (!behaviorSet || !behaviorSet.length) {
        console.warn("Update behavior failed! There is no behaviors in this mode on the graph.");
        return this;
      }
      var length_2 = behaviorSet.length;
      for (var i2 = 0; i2 < length_2; i2++) {
        var behave = behaviorSet[i2];
        if (behave.type === behavior.type || behave === behavior.type) {
          if (behave === behavior.type)
            behave = {
              type: behave
            };
          Object.assign(behave, newCfg);
          behaviorSet[i2] = behave;
          return this;
        }
        if (i2 === length_2 - 1)
          console.warn("Update behavior failed! There is no such behavior in the mode");
      }
    }
    return this;
  };
  ModeController2.prototype.destroy = function() {
    this.graph = null;
    this.modes = null;
    this.currentBehaves = null;
    this.destroyed = true;
  };
  return ModeController2;
}();
var mode_default = ModeController;

// node_modules/@antv/g6-core/es/graph/controller/view.js
init_esm();

// node_modules/@antv/g6-core/es/util/base.js
var base_exports = {};
__export(base_exports, {
  calculationItemsBBox: () => calculationItemsBBox,
  cloneEvent: () => cloneEvent,
  formatPadding: () => formatPadding,
  isNaN: () => isNaN2,
  isViewportChanged: () => isViewportChanged,
  processParallelEdges: () => processParallelEdges,
  uniqueId: () => uniqueId3
});
init_esm();

// node_modules/@antv/g-base/esm/util/path.js
var path_exports = {};
__export(path_exports, {
  catmullRomToBezier: () => catmullRomToBezier,
  fillPath: () => fillPath,
  fillPathByDiff: () => fillPathByDiff,
  formatPath: () => formatPath,
  intersection: () => intersection,
  parsePathArray: () => parsePathArray,
  parsePathString: () => parsePathString,
  pathToAbsolute: () => pathToAbsolute,
  pathToCurve: () => pathToCurve,
  rectPath: () => rectPath
});
init_esm();
var SPACES = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
var parsePathString = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND, function(a2, b10, c2) {
    var params = [];
    var name = b10.toLowerCase();
    c2.replace(PATH_VALUES, function(a3, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b10, params[0]]);
    }
    if (name === "r") {
      data.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data;
};
var catmullRomToBezier = function(crp, z2) {
  var d2 = [];
  for (var i2 = 0, iLen = crp.length; iLen - 2 * !z2 > i2; i2 += 2) {
    var p2 = [
      {
        x: +crp[i2 - 2],
        y: +crp[i2 - 1]
      },
      {
        x: +crp[i2],
        y: +crp[i2 + 1]
      },
      {
        x: +crp[i2 + 2],
        y: +crp[i2 + 3]
      },
      {
        x: +crp[i2 + 4],
        y: +crp[i2 + 5]
      }
    ];
    if (z2) {
      if (!i2) {
        p2[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i2) {
        p2[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i2) {
        p2[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p2[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i2) {
        p2[3] = p2[2];
      } else if (!i2) {
        p2[0] = {
          x: +crp[i2],
          y: +crp[i2 + 1]
        };
      }
    }
    d2.push([
      "C",
      (-p2[0].x + 6 * p2[1].x + p2[2].x) / 6,
      (-p2[0].y + 6 * p2[1].y + p2[2].y) / 6,
      (p2[1].x + 6 * p2[2].x - p2[3].x) / 6,
      (p2[1].y + 6 * p2[2].y - p2[3].y) / 6,
      p2[2].x,
      p2[2].y
    ]);
  }
  return d2;
};
var ellipsePath = function(x2, y2, rx, ry, a2) {
  var res = [];
  if (a2 === null && ry === null) {
    ry = rx;
  }
  x2 = +x2;
  y2 = +y2;
  rx = +rx;
  ry = +ry;
  if (a2 !== null) {
    var rad = Math.PI / 180;
    var x1 = x2 + rx * Math.cos(-ry * rad);
    var x22 = x2 + rx * Math.cos(-a2 * rad);
    var y1 = y2 + rx * Math.sin(-ry * rad);
    var y22 = y2 + rx * Math.sin(-a2 * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a2 - ry > 180), 0, x22, y22]
    ];
  } else {
    res = [["M", x2, y2], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute = function(pathArray) {
  pathArray = parsePathString(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x2 = +pathArray[0][1];
    y2 = +pathArray[0][2];
    mx = x2;
    my = y2;
    start++;
    res[0] = ["M", x2, y2];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r2 = void 0, pa2 = void 0, i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    res.push(r2 = []);
    pa2 = pathArray[i2];
    pa0 = pa2[0];
    if (pa0 !== pa0.toUpperCase()) {
      r2[0] = pa0.toUpperCase();
      switch (r2[0]) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x2;
          r2[7] = +pa2[7] + y2;
          break;
        case "V":
          r2[1] = +pa2[1] + y2;
          break;
        case "H":
          r2[1] = +pa2[1] + x2;
          break;
        case "R":
          dots = [x2, y2].concat(pa2.slice(1));
          for (var j2 = 2, jj = dots.length; j2 < jj; j2++) {
            dots[j2] = +dots[j2] + x2;
            dots[++j2] = +dots[j2] + y2;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x2, y2, pa2[1], pa2[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x2, y2, pa2[1], pa2[2], pa2[3]));
          r2 = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa2[1] + x2;
          my = +pa2[2] + y2;
          break;
        default:
          for (var j2 = 1, jj = pa2.length; j2 < jj; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x2 : y2);
          }
      }
    } else if (pa0 === "R") {
      dots = [x2, y2].concat(pa2.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r2 = ["R"].concat(pa2.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x2, y2, pa2[1], pa2[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x2, y2, pa2[1], pa2[2], pa2[3]));
      r2 = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k2 = 0, kk = pa2.length; k2 < kk; k2++) {
        r2[k2] = pa2[k2];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r2[0]) {
        case "Z":
          x2 = +mx;
          y2 = +my;
          break;
        case "H":
          x2 = r2[1];
          break;
        case "V":
          y2 = r2[1];
          break;
        case "M":
          mx = r2[r2.length - 2];
          my = r2[r2.length - 1];
          break;
        default:
          x2 = r2[r2.length - 2];
          y2 = r2[r2.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle3, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle3 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate7 = function(x4, y4, rad2) {
    var X2 = x4 * Math.cos(rad2) - y4 * Math.sin(rad2);
    var Y2 = x4 * Math.sin(rad2) + y4 * Math.cos(rad2);
    return {
      x: X2,
      y: Y2
    };
  };
  if (!recursive) {
    xy = rotate7(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate7(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x3 = (x1 - x2) / 2;
    var y3 = (y1 - y2) / 2;
    var h2 = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h2 > 1) {
      h2 = Math.sqrt(h2);
      rx = h2 * rx;
      ry = h2 * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k2 = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
    cx = k2 * rx * y3 / ry + (x1 + x2) / 2;
    cy = k2 * -ry * x3 / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle3, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t4 = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t4;
  var hy = 4 / 3 * ry * t4;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i2 = 0, ii2 = res.length; i2 < ii2; i2++) {
    newres[i2] = i2 % 2 ? rotate7(res[i2 - 1], res[i2], rad).y : rotate7(res[i2], res[i2 + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path, path2) {
  var p2 = pathToAbsolute(path);
  var p22 = path2 && pathToAbsolute(path2);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii2;
  var processPath = function(path3, d2, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d2.x, d2.y, d2.x, d2.y, d2.x, d2.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d2.qx = d2.qy = null);
    switch (path3[0]) {
      case "M":
        d2.X = path3[1];
        d2.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d2.x, d2.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d2.x * 2 - d2.bx;
          ny = d2.y * 2 - d2.by;
        } else {
          nx = d2.x;
          ny = d2.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d2.qx = d2.x * 2 - d2.qx;
          d2.qy = d2.y * 2 - d2.qy;
        } else {
          d2.qx = d2.x;
          d2.qy = d2.y;
        }
        path3 = ["C"].concat(q2c(d2.x, d2.y, d2.qx, d2.qy, path3[1], path3[2]));
        break;
      case "Q":
        d2.qx = path3[1];
        d2.qy = path3[2];
        path3 = ["C"].concat(q2c(d2.x, d2.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d2.x, d2.y, path3[1], d2.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d2.x, d2.y, d2.X, d2.Y));
        break;
      default:
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i3) {
    if (pp[i3].length > 7) {
      pp[i3].shift();
      var pi3 = pp[i3];
      while (pi3.length) {
        pcoms1[i3] = "A";
        p22 && (pcoms2[i3] = "A");
        pp.splice(i3++, 0, ["C"].concat(pi3.splice(0, 6)));
      }
      pp.splice(i3, 1);
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  var fixM = function(path1, path22, a1, a2, i3) {
    if (path1 && path22 && path1[i3][0] === "M" && path22[i3][0] !== "M") {
      path22.splice(i3, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i3][1];
      a1.y = path1[i3][2];
      ii2 = Math.max(p2.length, p22 && p22.length || 0);
    }
  };
  ii2 = Math.max(p2.length, p22 && p22.length || 0);
  for (var i2 = 0; i2 < ii2; i2++) {
    p2[i2] && (pfirst = p2[i2][0]);
    if (pfirst !== "C") {
      pcoms1[i2] = pfirst;
      i2 && (pcom = pcoms1[i2 - 1]);
    }
    p2[i2] = processPath(p2[i2], attrs, pcom);
    if (pcoms1[i2] !== "A" && pfirst === "C")
      pcoms1[i2] = "C";
    fixArc(p2, i2);
    if (p22) {
      p22[i2] && (pfirst = p22[i2][0]);
      if (pfirst !== "C") {
        pcoms2[i2] = pfirst;
        i2 && (pcom = pcoms2[i2 - 1]);
      }
      p22[i2] = processPath(p22[i2], attrs2, pcom);
      if (pcoms2[i2] !== "A" && pfirst === "C") {
        pcoms2[i2] = "C";
      }
      fixArc(p22, i2);
    }
    fixM(p2, p22, attrs, attrs2, i2);
    fixM(p22, p2, attrs2, attrs, i2);
    var seg = p2[i2];
    var seg2 = p22 && p22[i2];
    var seglen = seg.length;
    var seg2len = p22 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p22 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p22 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p22 && seg2[seg2len - 2];
    attrs2.y = p22 && seg2[seg2len - 1];
  }
  return p22 ? [p2, p22] : p2;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path) {
  return path.join(",").replace(p2s, "$1");
};
var base3 = function(t4, p1, p2, p3, p4) {
  var t12 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t22 = t4 * t12 + 6 * p1 - 12 * p2 + 6 * p3;
  return t4 * t22 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z2) {
  if (z2 === null) {
    z2 = 1;
  }
  z2 = z2 > 1 ? 1 : z2 < 0 ? 0 : z2;
  var z22 = z2 / 2;
  var n2 = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    var ct2 = z22 * Tvalues[i2] + z22;
    var xbase = base3(ct2, x1, x2, x3, x4);
    var ybase = base3(ct2, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i2] * Math.sqrt(comb);
  }
  return z22 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a2;
  var b10;
  var c2;
  var t4;
  for (var i2 = 0; i2 < 2; ++i2) {
    if (i2 === 0) {
      b10 = 6 * x0 - 12 * x1 + 6 * x2;
      a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c2 = 3 * x1 - 3 * x0;
    } else {
      b10 = 6 * y0 - 12 * y1 + 6 * y2;
      a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c2 = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a2) < 1e-12) {
      if (Math.abs(b10) < 1e-12) {
        continue;
      }
      t4 = -c2 / b10;
      if (t4 > 0 && t4 < 1) {
        tvalues.push(t4);
      }
      continue;
    }
    var b2ac = b10 * b10 - 4 * c2 * a2;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t12 = (-b10 + sqrtb2ac) / (2 * a2);
    if (t12 > 0 && t12 < 1) {
      tvalues.push(t12);
    }
    var t22 = (-b10 - sqrtb2ac) / (2 * a2);
    if (t22 > 0 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j2 = tvalues.length;
  var jlen = j2;
  var mt2;
  while (j2--) {
    t4 = tvalues[j2];
    mt2 = 1 - t4;
    bounds[0][j2] = mt2 * mt2 * mt2 * x0 + 3 * mt2 * mt2 * t4 * x1 + 3 * mt2 * t4 * t4 * x2 + t4 * t4 * t4 * x3;
    bounds[1][j2] = mt2 * mt2 * mt2 * y0 + 3 * mt2 * mt2 * t4 * y1 + 3 * mt2 * t4 * t4 * y2 + t4 * t4 * t4 * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x2, y2) {
  return x2 >= bbox.x && x2 <= bbox.x + bbox.width && y2 >= bbox.y && y2 <= bbox.y + bbox.height;
};
var rectPath = function(x2, y2, w2, h2, r2) {
  if (r2) {
    return [
      ["M", +x2 + +r2, y2],
      ["l", w2 - r2 * 2, 0],
      ["a", r2, r2, 0, 0, 1, r2, r2],
      ["l", 0, h2 - r2 * 2],
      ["a", r2, r2, 0, 0, 1, -r2, r2],
      ["l", r2 * 2 - w2, 0],
      ["a", r2, r2, 0, 0, 1, -r2, -r2],
      ["l", 0, r2 * 2 - h2],
      ["a", r2, r2, 0, 0, 1, r2, -r2],
      ["z"]
    ];
  }
  var res = [["M", x2, y2], ["l", w2, 0], ["l", 0, h2], ["l", -w2, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x2, y2, width, height) {
  if (x2 === null) {
    x2 = y2 = width = height = 0;
  }
  if (y2 === null) {
    y2 = x2.y;
    width = x2.width;
    height = x2.height;
    x2 = x2.x;
  }
  return {
    x: x2,
    y: y2,
    width,
    w: width,
    height,
    h: height,
    x2: x2 + width,
    y2: y2 + height,
    cx: x2 + width / 2,
    cy: y2 + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x2, y2, width, height),
    vb: [x2, y2, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!is_array_default(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t4) {
  var t12 = 1 - t4;
  var t13 = Math.pow(t12, 3);
  var t122 = Math.pow(t12, 2);
  var t22 = t4 * t4;
  var t32 = t22 * t4;
  var x2 = t13 * p1x + t122 * 3 * t4 * c1x + t12 * 3 * t4 * t4 * c2x + t32 * p2x;
  var y2 = t13 * p1y + t122 * 3 * t4 * c1y + t12 * 3 * t4 * t4 * c2y + t32 * p2y;
  var mx = p1x + 2 * t4 * (c1x - p1x) + t22 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t4 * (c1y - p1y) + t22 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t4 * (c2x - c1x) + t22 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t4 * (c2y - c1y) + t22 * (p2y - 2 * c2y + c1y);
  var ax = t12 * p1x + t4 * c1x;
  var ay = t12 * p1y + t4 * c1y;
  var cx = t12 * c2x + t4 * p2x;
  var cy = t12 * c2y + t4 * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x: x2,
    y: y2,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i2 = 0; i2 < n1 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez1.concat(i2 / n1));
    dots1.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n1
    });
  }
  for (var i2 = 0; i2 < n2 + 1; i2++) {
    var d2 = findDotsAtSegment.apply(0, bez2.concat(i2 / n2));
    dots2.push({
      x: d2.x,
      y: d2.y,
      t: i2 / n2
    });
  }
  for (var i2 = 0; i2 < n1; i2++) {
    for (var j2 = 0; j2 < n2; j2++) {
      var di2 = dots1[i2];
      var di1 = dots1[i2 + 1];
      var dj = dots2[j2];
      var dj1 = dots2[j2 + 1];
      var ci2 = Math.abs(di1.x - di2.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect(di2.x, di2.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t12 = di2.t + Math.abs((is[ci2] - di2[ci2]) / (di1[ci2] - di2[ci2])) * (di1.t - di2.t);
        var t22 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t12 >= 0 && t12 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1: t12,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i2 = 0, ii2 = path1.length; i2 < ii2; i2++) {
    var pi3 = path1[i2];
    if (pi3[0] === "M") {
      x1 = x1m = pi3[1];
      y1 = y1m = pi3[2];
    } else {
      if (pi3[0] === "C") {
        bez1 = [x1, y1].concat(pi3.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j2 = 0, jj = path2.length; j2 < jj; j2++) {
        var pj = path2[j2];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k2 = 0, kk = intr.length; k2 < kk; k2++) {
              intr[k2].segment1 = i2;
              intr[k2].segment2 = j2;
              intr[k2].bez1 = bez1;
              intr[k2].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points, t4) {
  var left = [];
  var right = [];
  function recurse(points2, t5) {
    if (points2.length === 1) {
      left.push(points2[0]);
      right.push(points2[0]);
    } else {
      var middlePoints = [];
      for (var i2 = 0; i2 < points2.length - 1; i2++) {
        if (i2 === 0) {
          left.push(points2[0]);
        }
        if (i2 === points2.length - 2) {
          right.push(points2[i2 + 1]);
        }
        middlePoints[i2] = [
          (1 - t5) * points2[i2][0] + t5 * points2[i2 + 1][0],
          (1 - t5) * points2[i2][1] + t5 * points2[i2 + 1][1]
        ];
      }
      recurse(middlePoints, t5);
    }
  }
  if (points.length) {
    recurse(points, t4);
  }
  return { left, right: right.reverse() };
}
function splitCurve(start, end2, count) {
  var points = [[start[1], start[2]]];
  count = count || 2;
  var segments = [];
  if (end2[0] === "A") {
    points.push(end2[6]);
    points.push(end2[7]);
  } else if (end2[0] === "C") {
    points.push([end2[1], end2[2]]);
    points.push([end2[3], end2[4]]);
    points.push([end2[5], end2[6]]);
  } else if (end2[0] === "S" || end2[0] === "Q") {
    points.push([end2[1], end2[2]]);
    points.push([end2[3], end2[4]]);
  } else {
    points.push([end2[1], end2[2]]);
  }
  var leftSegments = points;
  var t4 = 1 / count;
  for (var i2 = 0; i2 < count - 1; i2++) {
    var rt2 = t4 / (1 - t4 * i2);
    var split = decasteljau(leftSegments, rt2);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end2, count) {
  if (count === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end2[0] === "L" || end2[0] === "C" || end2[0] === "Q") {
    segments = segments.concat(splitCurve(start, end2, count));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i2 = 0; i2 <= count - 1; i2++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i2 = 0; i2 < targetLen - sourceLen; i2++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i2 = 0; i2 < targetLen; i2++) {
    var index = Math.floor(ratio * i2);
    segmentsToFill[index] = (segmentsToFill[index] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count, i3) {
    if (i3 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i3], source[i3 + 1], count));
  }, []);
  filled.unshift(source[0]);
  if (target[targetLen] === "Z" || target[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual2 = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each_default(obj1, function(item, i2) {
    if (item !== obj2[i2]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add7, modify) {
  var type = null;
  var min6 = modify;
  if (add7 < min6) {
    min6 = add7;
    type = "add";
  }
  if (del < min6) {
    min6 = del;
    type = "del";
  }
  return {
    type,
    min: min6
  };
}
var levenshteinDistance = function(source, target) {
  var sourceLen = source.length;
  var targetLen = target.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist4 = [];
  for (var i2 = 0; i2 <= sourceLen; i2++) {
    dist4[i2] = [];
    dist4[i2][0] = { min: i2 };
  }
  for (var j2 = 0; j2 <= targetLen; j2++) {
    dist4[0][j2] = { min: j2 };
  }
  for (var i2 = 1; i2 <= sourceLen; i2++) {
    sourceSegment = source[i2 - 1];
    for (var j2 = 1; j2 <= targetLen; j2++) {
      targetSegment = target[j2 - 1];
      if (isEqual2(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist4[i2 - 1][j2].min + 1;
      var add7 = dist4[i2][j2 - 1].min + 1;
      var modify = dist4[i2 - 1][j2 - 1].min + temp;
      dist4[i2][j2] = getMinDiff(del, add7, modify);
    }
  }
  return dist4;
};
var fillPathByDiff = function(source, target) {
  var diffMatrix = levenshteinDistance(source, target);
  var sourceLen = source.length;
  var targetLen = target.length;
  var changes = [];
  var index = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i2 = 1; i2 <= sourceLen; i2++) {
      var min6 = diffMatrix[i2][i2].min;
      minPos = i2;
      for (var j2 = index; j2 <= targetLen; j2++) {
        if (diffMatrix[i2][j2].min < min6) {
          min6 = diffMatrix[i2][j2].min;
          minPos = j2;
        }
      }
      index = minPos;
      if (diffMatrix[i2][index].type) {
        changes.push({ index: i2 - 1, type: diffMatrix[i2][index].type });
      }
    }
    for (var i2 = changes.length - 1; i2 >= 0; i2--) {
      index = changes[i2].index;
      if (changes[i2].type === "add") {
        source.splice(index, 0, [].concat(source[index]));
      } else {
        source.splice(index, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i2 = 0; i2 < diff; i2++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points, former, count) {
  var result = [].concat(points);
  var index;
  var t4 = 1 / (count + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i2 = 1; i2 <= count; i2++) {
    t4 *= i2;
    index = Math.floor(points.length * t4);
    if (index === 0) {
      result.unshift([formerEnd[0] * t4 + points[index][0] * (1 - t4), formerEnd[1] * t4 + points[index][1] * (1 - t4)]);
    } else {
      result.splice(index, 0, [
        formerEnd[0] * t4 + points[index][0] * (1 - t4),
        formerEnd[1] * t4 + points[index][1] * (1 - t4)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points = [];
  switch (segment[0]) {
    case "M":
      points.push([segment[1], segment[2]]);
      break;
    case "L":
      points.push([segment[1], segment[2]]);
      break;
    case "A":
      points.push([segment[6], segment[7]]);
      break;
    case "Q":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "T":
      points.push([segment[1], segment[2]]);
      break;
    case "C":
      points.push([segment[5], segment[6]]);
      points.push([segment[1], segment[2]]);
      points.push([segment[3], segment[4]]);
      break;
    case "S":
      points.push([segment[3], segment[4]]);
      points.push([segment[1], segment[2]]);
      break;
    case "H":
      points.push([segment[1], segment[1]]);
      break;
    case "V":
      points.push([segment[1], segment[1]]);
      break;
    default:
  }
  return points;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points;
  for (var i2 = 0; i2 < toPath.length; i2++) {
    if (fromPath[i2][0] !== toPath[i2][0]) {
      points = _getSegmentPoints(fromPath[i2]);
      switch (toPath[i2][0]) {
        case "M":
          fromPath[i2] = ["M"].concat(points[0]);
          break;
        case "L":
          fromPath[i2] = ["L"].concat(points[0]);
          break;
        case "A":
          fromPath[i2] = [].concat(toPath[i2]);
          fromPath[i2][6] = points[0][0];
          fromPath[i2][7] = points[0][1];
          break;
        case "Q":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["Q"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "T":
          fromPath[i2] = ["T"].concat(points[0]);
          break;
        case "C":
          if (points.length < 3) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 2);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["C"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        case "S":
          if (points.length < 2) {
            if (i2 > 0) {
              points = _splitPoints(points, fromPath[i2 - 1], 1);
            } else {
              fromPath[i2] = toPath[i2];
              break;
            }
          }
          fromPath[i2] = ["S"].concat(points.reduce(function(arr, i3) {
            return arr.concat(i3);
          }, []));
          break;
        default:
          fromPath[i2] = toPath[i2];
      }
    }
  }
  return fromPath;
};

// node_modules/@antv/g-base/esm/event/graph-event.js
var GraphEvent = function() {
  function GraphEvent2(type, event) {
    this.bubbles = true;
    this.target = null;
    this.currentTarget = null;
    this.delegateTarget = null;
    this.delegateObject = null;
    this.defaultPrevented = false;
    this.propagationStopped = false;
    this.shape = null;
    this.fromShape = null;
    this.toShape = null;
    this.propagationPath = [];
    this.type = type;
    this.name = type;
    this.originalEvent = event;
    this.timeStamp = event.timeStamp;
  }
  GraphEvent2.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    if (this.originalEvent.preventDefault) {
      this.originalEvent.preventDefault();
    }
  };
  GraphEvent2.prototype.stopPropagation = function() {
    this.propagationStopped = true;
  };
  GraphEvent2.prototype.toString = function() {
    var type = this.type;
    return "[Event (type=" + type + ")]";
  };
  GraphEvent2.prototype.save = function() {
  };
  GraphEvent2.prototype.restore = function() {
  };
  return GraphEvent2;
}();
var graph_event_default = GraphEvent;

// node_modules/@antv/g-base/node_modules/tslib/tslib.es6.js
var extendStatics3 = function(d2, b10) {
  extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics3(d2, b10);
};
function __extends3(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics3(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}

// node_modules/@antv/g-base/esm/util/util.js
init_esm();
function removeFromArray(arr, obj) {
  var index = arr.indexOf(obj);
  if (index !== -1) {
    arr.splice(index, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container2, shape) {
  if (container2.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container2) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}

// node_modules/@antv/g-base/esm/abstract/base.js
var Base = function(_super) {
  __extends3(Base2, _super);
  function Base2(cfg) {
    var _this = _super.call(this) || this;
    _this.destroyed = false;
    var defaultCfg2 = _this.getDefaultCfg();
    _this.cfg = mix(defaultCfg2, cfg);
    return _this;
  }
  Base2.prototype.getDefaultCfg = function() {
    return {};
  };
  Base2.prototype.get = function(name) {
    return this.cfg[name];
  };
  Base2.prototype.set = function(name, value) {
    this.cfg[name] = value;
  };
  Base2.prototype.destroy = function() {
    this.cfg = {
      destroyed: true
    };
    this.off();
    this.destroyed = true;
  };
  return Base2;
}(esm_default);
var base_default = Base;

// node_modules/detect-browser/es/index.js
var __spreadArray3 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
  function BrowserInfo2(name, version2, os) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.type = "browser";
  }
  return BrowserInfo2;
}();
var NodeInfo = function() {
  function NodeInfo2(version2) {
    this.version = version2;
    this.type = "node";
    this.name = "node";
    this.os = process.platform;
  }
  return NodeInfo2;
}();
var SearchBotDeviceInfo = function() {
  function SearchBotDeviceInfo2(name, version2, os, bot) {
    this.name = name;
    this.version = version2;
    this.os = os;
    this.bot = bot;
    this.type = "bot-device";
  }
  return SearchBotDeviceInfo2;
}();
var BotInfo = function() {
  function BotInfo2() {
    this.type = "bot";
    this.bot = true;
    this.name = "bot";
    this.version = null;
    this.os = null;
  }
  return BotInfo2;
}();
var ReactNativeInfo = function() {
  function ReactNativeInfo2() {
    this.type = "react-native";
    this.name = "react-native";
    this.version = null;
    this.os = null;
  }
  return ReactNativeInfo2;
}();
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray3(__spreadArray3([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a2 = operatingSystemRules[ii2], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua2);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output.push("0");
  }
  return output;
}

// node_modules/@antv/g-base/esm/abstract/container.js
init_esm();

// node_modules/@antv/g-base/esm/abstract/element.js
init_esm();

// node_modules/@antv/g-base/esm/util/matrix.js
function multiplyMatrix(a2, b10) {
  var out = [];
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a10 = a2[3];
  var a11 = a2[4];
  var a12 = a2[5];
  var a20 = a2[6];
  var a21 = a2[7];
  var a22 = a2[8];
  var b00 = b10[0];
  var b01 = b10[1];
  var b02 = b10[2];
  var b102 = b10[3];
  var b11 = b10[4];
  var b12 = b10[5];
  var b20 = b10[6];
  var b21 = b10[7];
  var b22 = b10[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b102 * a00 + b11 * a10 + b12 * a20;
  out[4] = b102 * a01 + b11 * a11 + b12 * a21;
  out[5] = b102 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2(m2, v2) {
  var out = [];
  var x2 = v2[0];
  var y2 = v2[1];
  out[0] = m2[0] * x2 + m2[3] * y2 + m2[6];
  out[1] = m2[1] * x2 + m2[4] * y2 + m2[7];
  return out;
}
function invert4(a2) {
  var out = [];
  var a00 = a2[0];
  var a01 = a2[1];
  var a02 = a2[2];
  var a10 = a2[3];
  var a11 = a2[4];
  var a12 = a2[5];
  var a20 = a2[6];
  var a21 = a2[7];
  var a22 = a2[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

// node_modules/@antv/g-base/esm/abstract/element.js
var transform3 = ext_exports.transform;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD2 = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i2 = 0; i2 < arr.length; i2++) {
    if (is_array_default(arr[i2])) {
      result.push([].concat(arr[i2]));
    } else {
      result.push(arr[i2]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k2 in toAttrs) {
    fromAttrs[k2] = attrs[k2];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each_default(props, function(v2, k2) {
    if (RESERVED_PORPS.indexOf(k2) === -1 && !is_equal_default(attrs[k2], v2)) {
      toAttrs[k2] = v2;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation) {
  if (animation.onFrame) {
    return animations;
  }
  var startTime = animation.startTime, delay = animation.delay, duration = animation.duration;
  var hasOwnProperty4 = Object.prototype.hasOwnProperty;
  each_default(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each_default(animation.toAttrs, function(v2, k2) {
        if (hasOwnProperty4.call(item.toAttrs, k2)) {
          delete item.toAttrs[k2];
          delete item.fromAttrs[k2];
        }
      });
    }
  });
  return animations;
}
var Element2 = function(_super) {
  __extends3(Element3, _super);
  function Element3(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.attrs = {};
    var attrs = _this.getDefaultAttrs();
    mix(attrs, cfg.attrs);
    _this.attrs = attrs;
    _this.initAttrs(attrs);
    _this.initAnimate();
    return _this;
  }
  Element3.prototype.getDefaultCfg = function() {
    return {
      visible: true,
      capture: true,
      zIndex: 0
    };
  };
  Element3.prototype.getDefaultAttrs = function() {
    return {
      matrix: this.getDefaultMatrix(),
      opacity: 1
    };
  };
  Element3.prototype.onCanvasChange = function(changeType) {
  };
  Element3.prototype.initAttrs = function(attrs) {
  };
  Element3.prototype.initAnimate = function() {
    this.set("animable", true);
    this.set("animating", false);
  };
  Element3.prototype.isGroup = function() {
    return false;
  };
  Element3.prototype.getParent = function() {
    return this.get("parent");
  };
  Element3.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  Element3.prototype.attr = function() {
    var _a2;
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var name = args[0], value = args[1];
    if (!name)
      return this.attrs;
    if (is_object_default(name)) {
      for (var k2 in name) {
        this.setAttr(k2, name[k2]);
      }
      this.afterAttrsChange(name);
      return this;
    }
    if (args.length === 2) {
      this.setAttr(name, value);
      this.afterAttrsChange((_a2 = {}, _a2[name] = value, _a2));
      return this;
    }
    return this.attrs[name];
  };
  Element3.prototype.isClipped = function(refX, refY) {
    var clip = this.getClip();
    return clip && !clip.isHit(refX, refY);
  };
  Element3.prototype.setAttr = function(name, value) {
    var originValue = this.attrs[name];
    if (originValue !== value) {
      this.attrs[name] = value;
      this.onAttrChange(name, value, originValue);
    }
  };
  Element3.prototype.onAttrChange = function(name, value, originValue) {
    if (name === "matrix") {
      this.set("totalMatrix", null);
    }
  };
  Element3.prototype.afterAttrsChange = function(targetAttrs) {
    if (this.cfg.isClipShape) {
      var applyTo = this.cfg.applyTo;
      if (applyTo) {
        applyTo.onCanvasChange("clip");
      }
    } else {
      this.onCanvasChange("attr");
    }
  };
  Element3.prototype.show = function() {
    this.set("visible", true);
    this.onCanvasChange("show");
    return this;
  };
  Element3.prototype.hide = function() {
    this.set("visible", false);
    this.onCanvasChange("hide");
    return this;
  };
  Element3.prototype.setZIndex = function(zIndex) {
    this.set("zIndex", zIndex);
    var parent = this.getParent();
    if (parent) {
      parent.sort();
    }
    return this;
  };
  Element3.prototype.toFront = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get("el");
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.push(this);
    this.onCanvasChange("zIndex");
  };
  Element3.prototype.toBack = function() {
    var parent = this.getParent();
    if (!parent) {
      return;
    }
    var children = parent.getChildren();
    var el = this.get("el");
    var index = children.indexOf(this);
    children.splice(index, 1);
    children.unshift(this);
    this.onCanvasChange("zIndex");
  };
  Element3.prototype.remove = function(destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    var parent = this.getParent();
    if (parent) {
      removeFromArray(parent.getChildren(), this);
      if (!parent.get("clearing")) {
        this.onCanvasChange("remove");
      }
    } else {
      this.onCanvasChange("remove");
    }
    if (destroy) {
      this.destroy();
    }
  };
  Element3.prototype.resetMatrix = function() {
    this.attr(MATRIX, this.getDefaultMatrix());
    this.onCanvasChange("matrix");
  };
  Element3.prototype.getMatrix = function() {
    return this.attr(MATRIX);
  };
  Element3.prototype.setMatrix = function(m2) {
    this.attr(MATRIX, m2);
    this.onCanvasChange("matrix");
  };
  Element3.prototype.getTotalMatrix = function() {
    var totalMatrix = this.cfg.totalMatrix;
    if (!totalMatrix) {
      var currentMatrix = this.attr("matrix");
      var parentMatrix = this.cfg.parentMatrix;
      if (parentMatrix && currentMatrix) {
        totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || parentMatrix;
      }
      this.set("totalMatrix", totalMatrix);
    }
    return totalMatrix;
  };
  Element3.prototype.applyMatrix = function(matrix) {
    var currentMatrix = this.attr("matrix");
    var totalMatrix = null;
    if (matrix && currentMatrix) {
      totalMatrix = multiplyMatrix(matrix, currentMatrix);
    } else {
      totalMatrix = currentMatrix || matrix;
    }
    this.set("totalMatrix", totalMatrix);
    this.set("parentMatrix", matrix);
  };
  Element3.prototype.getDefaultMatrix = function() {
    return null;
  };
  Element3.prototype.applyToMatrix = function(v2) {
    var matrix = this.attr("matrix");
    if (matrix) {
      return multiplyVec2(matrix, v2);
    }
    return v2;
  };
  Element3.prototype.invertFromMatrix = function(v2) {
    var matrix = this.attr("matrix");
    if (matrix) {
      var invertMatrix3 = invert4(matrix);
      if (invertMatrix3) {
        return multiplyVec2(invertMatrix3, v2);
      }
    }
    return v2;
  };
  Element3.prototype.setClip = function(clipCfg) {
    var canvas = this.getCanvas();
    var clipShape = null;
    if (clipCfg) {
      var ShapeBase3 = this.getShapeBase();
      var shapeType = upper_first_default(clipCfg.type);
      var Cons = ShapeBase3[shapeType];
      if (Cons) {
        clipShape = new Cons({
          type: clipCfg.type,
          isClipShape: true,
          applyTo: this,
          attrs: clipCfg.attrs,
          canvas
        });
      }
    }
    this.set("clipShape", clipShape);
    this.onCanvasChange("clip");
    return clipShape;
  };
  Element3.prototype.getClip = function() {
    var clipShape = this.cfg.clipShape;
    if (!clipShape) {
      return null;
    }
    return clipShape;
  };
  Element3.prototype.clone = function() {
    var _this = this;
    var originAttrs = this.attrs;
    var attrs = {};
    each_default(originAttrs, function(i2, k2) {
      if (is_array_default(originAttrs[k2])) {
        attrs[k2] = _cloneArrayAttr(originAttrs[k2]);
      } else {
        attrs[k2] = originAttrs[k2];
      }
    });
    var cons = this.constructor;
    var clone8 = new cons({ attrs });
    each_default(CLONE_CFGS, function(cfgName) {
      clone8.set(cfgName, _this.get(cfgName));
    });
    return clone8;
  };
  Element3.prototype.destroy = function() {
    var destroyed = this.destroyed;
    if (destroyed) {
      return;
    }
    this.attrs = {};
    _super.prototype.destroy.call(this);
  };
  Element3.prototype.isAnimatePaused = function() {
    return this.get("_pause").isPaused;
  };
  Element3.prototype.animate = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    if (!this.get("timeline") && !this.get("canvas")) {
      return;
    }
    this.set("animating", true);
    var timeline = this.get("timeline");
    if (!timeline) {
      timeline = this.get("canvas").get("timeline");
      this.set("timeline", timeline);
    }
    var animations = this.get("animations") || [];
    if (!timeline.timer) {
      timeline.initTimer();
    }
    var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop_default : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
    var onFrame;
    var repeat;
    var pauseCallback;
    var resumeCallback;
    var animateCfg;
    if (is_function_default(toAttrs)) {
      onFrame = toAttrs;
      toAttrs = {};
    } else if (is_object_default(toAttrs) && toAttrs.onFrame) {
      onFrame = toAttrs.onFrame;
      repeat = toAttrs.repeat;
    }
    if (is_object_default(duration)) {
      animateCfg = duration;
      duration = animateCfg.duration;
      easing = animateCfg.easing || "easeLinear";
      delay = animateCfg.delay || 0;
      repeat = animateCfg.repeat || repeat || false;
      callback = animateCfg.callback || noop_default;
      pauseCallback = animateCfg.pauseCallback || noop_default;
      resumeCallback = animateCfg.resumeCallback || noop_default;
    } else {
      if (is_number_default(callback)) {
        delay = callback;
        callback = null;
      }
      if (is_function_default(easing)) {
        callback = easing;
        easing = "easeLinear";
      } else {
        easing = easing || "easeLinear";
      }
    }
    var formatToAttrs = getFormatToAttrs(toAttrs, this);
    var animation = {
      fromAttrs: getFormatFromAttrs(formatToAttrs, this),
      toAttrs: formatToAttrs,
      duration,
      easing,
      repeat,
      callback,
      pauseCallback,
      resumeCallback,
      delay,
      startTime: timeline.getTime(),
      id: unique_id_default(),
      onFrame,
      pathFormatted: false
    };
    if (animations.length > 0) {
      animations = checkExistedAttrs(animations, animation);
    } else {
      timeline.addAnimator(this);
    }
    animations.push(animation);
    this.set("animations", animations);
    this.set("_pause", { isPaused: false });
  };
  Element3.prototype.stopAnimate = function(toEnd) {
    var _this = this;
    if (toEnd === void 0) {
      toEnd = true;
    }
    var animations = this.get("animations");
    each_default(animations, function(animation) {
      if (toEnd) {
        if (animation.onFrame) {
          _this.attr(animation.onFrame(1));
        } else {
          _this.attr(animation.toAttrs);
        }
      }
      if (animation.callback) {
        animation.callback();
      }
    });
    this.set("animating", false);
    this.set("animations", []);
  };
  Element3.prototype.pauseAnimate = function() {
    var timeline = this.get("timeline");
    var animations = this.get("animations");
    var pauseTime = timeline.getTime();
    each_default(animations, function(animation) {
      animation._paused = true;
      animation._pauseTime = pauseTime;
      if (animation.pauseCallback) {
        animation.pauseCallback();
      }
    });
    this.set("_pause", {
      isPaused: true,
      pauseTime
    });
    return this;
  };
  Element3.prototype.resumeAnimate = function() {
    var timeline = this.get("timeline");
    var current = timeline.getTime();
    var animations = this.get("animations");
    var pauseTime = this.get("_pause").pauseTime;
    each_default(animations, function(animation) {
      animation.startTime = animation.startTime + (current - pauseTime);
      animation._paused = false;
      animation._pauseTime = null;
      if (animation.resumeCallback) {
        animation.resumeCallback();
      }
    });
    this.set("_pause", {
      isPaused: false
    });
    this.set("animations", animations);
    return this;
  };
  Element3.prototype.emitDelegation = function(type, eventObj) {
    var _this = this;
    var paths = eventObj.propagationPath;
    var events = this.getEvents();
    var relativeShape;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
    } else if (type === "mouseleave") {
      relativeShape = eventObj.toShape;
    }
    var _loop_1 = function(i3) {
      var element = paths[i3];
      var name_1 = element.get("name");
      if (name_1) {
        if ((element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)) {
          return "break";
        }
        if (is_array_default(name_1)) {
          each_default(name_1, function(subName) {
            _this.emitDelegateEvent(element, subName, eventObj);
          });
        } else {
          this_1.emitDelegateEvent(element, name_1, eventObj);
        }
      }
    };
    var this_1 = this;
    for (var i2 = 0; i2 < paths.length; i2++) {
      var state_1 = _loop_1(i2);
      if (state_1 === "break")
        break;
    }
  };
  Element3.prototype.emitDelegateEvent = function(element, name, eventObj) {
    var events = this.getEvents();
    var eventName = name + DELEGATION_SPLIT + eventObj.type;
    if (events[eventName] || events[WILDCARD2]) {
      eventObj.name = eventName;
      eventObj.currentTarget = element;
      eventObj.delegateTarget = this;
      eventObj.delegateObject = element.get("delegateObject");
      this.emit(eventName, eventObj);
    }
  };
  Element3.prototype.translate = function(translateX, translateY) {
    if (translateX === void 0) {
      translateX = 0;
    }
    if (translateY === void 0) {
      translateY = 0;
    }
    var matrix = this.getMatrix();
    var newMatrix = transform3(matrix, [["t", translateX, translateY]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element3.prototype.move = function(targetX, targetY) {
    var x2 = this.attr("x") || 0;
    var y2 = this.attr("y") || 0;
    this.translate(targetX - x2, targetY - y2);
    return this;
  };
  Element3.prototype.moveTo = function(targetX, targetY) {
    return this.move(targetX, targetY);
  };
  Element3.prototype.scale = function(ratioX, ratioY) {
    var matrix = this.getMatrix();
    var newMatrix = transform3(matrix, [["s", ratioX, ratioY || ratioX]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element3.prototype.rotate = function(radian) {
    var matrix = this.getMatrix();
    var newMatrix = transform3(matrix, [["r", radian]]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element3.prototype.rotateAtStart = function(rotate7) {
    var _a2 = this.attr(), x2 = _a2.x, y2 = _a2.y;
    var matrix = this.getMatrix();
    var newMatrix = transform3(matrix, [
      ["t", -x2, -y2],
      ["r", rotate7],
      ["t", x2, y2]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  Element3.prototype.rotateAtPoint = function(x2, y2, rotate7) {
    var matrix = this.getMatrix();
    var newMatrix = transform3(matrix, [
      ["t", -x2, -y2],
      ["r", rotate7],
      ["t", x2, y2]
    ]);
    this.setMatrix(newMatrix);
    return this;
  };
  return Element3;
}(base_default);
var element_default = Element2;

// node_modules/@antv/g-base/esm/abstract/container.js
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container2, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container2.getChildren(), element);
}
function getComparer(compare3) {
  return function(left, right) {
    var result = compare3(left, right);
    return result === 0 ? left[INDEX] - right[INDEX] : result;
  };
}
var Container = function(_super) {
  __extends3(Container3, _super);
  function Container3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Container3.prototype.isCanvas = function() {
    return false;
  };
  Container3.prototype.getBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each_default(children, function(child) {
        var box3 = child.getBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min_default(xArr);
      maxX = max_default(xArr);
      minY = min_default(yArr);
      maxY = max_default(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container3.prototype.getCanvasBBox = function() {
    var minX = Infinity;
    var maxX = -Infinity;
    var minY = Infinity;
    var maxY = -Infinity;
    var xArr = [];
    var yArr = [];
    var children = this.getChildren().filter(function(child) {
      return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
    });
    if (children.length > 0) {
      each_default(children, function(child) {
        var box3 = child.getCanvasBBox();
        xArr.push(box3.minX, box3.maxX);
        yArr.push(box3.minY, box3.maxY);
      });
      minX = min_default(xArr);
      maxX = max_default(xArr);
      minY = min_default(yArr);
      maxY = max_default(yArr);
    } else {
      minX = 0;
      maxX = 0;
      minY = 0;
      maxY = 0;
    }
    var box2 = {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
    return box2;
  };
  Container3.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["children"] = [];
    return cfg;
  };
  Container3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "matrix") {
      var totalMatrix = this.getTotalMatrix();
      this._applyChildrenMarix(totalMatrix);
    }
  };
  Container3.prototype.applyMatrix = function(matrix) {
    var preTotalMatrix = this.getTotalMatrix();
    _super.prototype.applyMatrix.call(this, matrix);
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix === preTotalMatrix) {
      return;
    }
    this._applyChildrenMarix(totalMatrix);
  };
  Container3.prototype._applyChildrenMarix = function(totalMatrix) {
    var children = this.getChildren();
    each_default(children, function(child) {
      child.applyMatrix(totalMatrix);
    });
  };
  Container3.prototype.addShape = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var type = args[0];
    var cfg = args[1];
    if (is_object_default(type)) {
      cfg = type;
    } else {
      cfg["type"] = type;
    }
    var shapeType = SHAPE_MAP[cfg.type];
    if (!shapeType) {
      shapeType = upper_first_default(cfg.type);
      SHAPE_MAP[cfg.type] = shapeType;
    }
    var ShapeBase3 = this.getShapeBase();
    var shape = new ShapeBase3[shapeType](cfg);
    this.add(shape);
    return shape;
  };
  Container3.prototype.addGroup = function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    var groupClass = args[0], cfg = args[1];
    var group;
    if (is_function_default(groupClass)) {
      if (cfg) {
        group = new groupClass(cfg);
      } else {
        group = new groupClass({
          parent: this
        });
      }
    } else {
      var tmpCfg = groupClass || {};
      var TmpGroupClass = this.getGroupBase();
      group = new TmpGroupClass(tmpCfg);
    }
    this.add(group);
    return group;
  };
  Container3.prototype.getCanvas = function() {
    var canvas;
    if (this.isCanvas()) {
      canvas = this;
    } else {
      canvas = this.get("canvas");
    }
    return canvas;
  };
  Container3.prototype.getShape = function(x2, y2, ev) {
    if (!isAllowCapture(this)) {
      return null;
    }
    var children = this.getChildren();
    var shape;
    if (!this.isCanvas()) {
      var v2 = [x2, y2, 1];
      v2 = this.invertFromMatrix(v2);
      if (!this.isClipped(v2[0], v2[1])) {
        shape = this._findShape(children, v2[0], v2[1], ev);
      }
    } else {
      shape = this._findShape(children, x2, y2, ev);
    }
    return shape;
  };
  Container3.prototype._findShape = function(children, x2, y2, ev) {
    var shape = null;
    for (var i2 = children.length - 1; i2 >= 0; i2--) {
      var child = children[i2];
      if (isAllowCapture(child)) {
        if (child.isGroup()) {
          shape = child.getShape(x2, y2, ev);
        } else if (child.isHit(x2, y2)) {
          shape = child;
        }
      }
      if (shape) {
        break;
      }
    }
    return shape;
  };
  Container3.prototype.add = function(element) {
    var canvas = this.getCanvas();
    var children = this.getChildren();
    var timeline = this.get("timeline");
    var preParent = element.getParent();
    if (preParent) {
      removeChild(preParent, element, false);
    }
    element.set("parent", this);
    if (canvas) {
      setCanvas(element, canvas);
    }
    if (timeline) {
      setTimeline(element, timeline);
    }
    children.push(element);
    element.onCanvasChange("add");
    this._applyElementMatrix(element);
  };
  Container3.prototype._applyElementMatrix = function(element) {
    var totalMatrix = this.getTotalMatrix();
    if (totalMatrix) {
      element.applyMatrix(totalMatrix);
    }
  };
  Container3.prototype.getChildren = function() {
    return this.get("children");
  };
  Container3.prototype.sort = function() {
    var children = this.getChildren();
    each_default(children, function(child, index) {
      child[INDEX] = index;
      return child;
    });
    children.sort(getComparer(function(obj1, obj2) {
      return obj1.get("zIndex") - obj2.get("zIndex");
    }));
    this.onCanvasChange("sort");
  };
  Container3.prototype.clear = function() {
    this.set("clearing", true);
    if (this.destroyed) {
      return;
    }
    var children = this.getChildren();
    for (var i2 = children.length - 1; i2 >= 0; i2--) {
      children[i2].destroy();
    }
    this.set("children", []);
    this.onCanvasChange("clear");
    this.set("clearing", false);
  };
  Container3.prototype.destroy = function() {
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    _super.prototype.destroy.call(this);
  };
  Container3.prototype.getFirst = function() {
    return this.getChildByIndex(0);
  };
  Container3.prototype.getLast = function() {
    var children = this.getChildren();
    return this.getChildByIndex(children.length - 1);
  };
  Container3.prototype.getChildByIndex = function(index) {
    var children = this.getChildren();
    return children[index];
  };
  Container3.prototype.getCount = function() {
    var children = this.getChildren();
    return children.length;
  };
  Container3.prototype.contain = function(element) {
    var children = this.getChildren();
    return children.indexOf(element) > -1;
  };
  Container3.prototype.removeChild = function(element, destroy) {
    if (destroy === void 0) {
      destroy = true;
    }
    if (this.contain(element)) {
      element.remove(destroy);
    }
  };
  Container3.prototype.findAll = function(fn2) {
    var rst = [];
    var children = this.getChildren();
    each_default(children, function(element) {
      if (fn2(element)) {
        rst.push(element);
      }
      if (element.isGroup()) {
        rst = rst.concat(element.findAll(fn2));
      }
    });
    return rst;
  };
  Container3.prototype.find = function(fn2) {
    var rst = null;
    var children = this.getChildren();
    each_default(children, function(element) {
      if (fn2(element)) {
        rst = element;
      } else if (element.isGroup()) {
        rst = element.find(fn2);
      }
      if (rst) {
        return false;
      }
    });
    return rst;
  };
  Container3.prototype.findById = function(id2) {
    return this.find(function(element) {
      return element.get("id") === id2;
    });
  };
  Container3.prototype.findByClassName = function(className) {
    return this.find(function(element) {
      return element.get("className") === className;
    });
  };
  Container3.prototype.findAllByName = function(name) {
    return this.findAll(function(element) {
      return element.get("name") === name;
    });
  };
  return Container3;
}(element_default);
var container_default = Container;

// node_modules/@antv/g-base/esm/animate/timeline.js
init_esm();

// node_modules/@antv/g-base/node_modules/d3-timer/src/timer.js
var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1e3;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f2) {
  setTimeout(f2, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t4 = new Timer();
  t4.restart(callback, delay, time);
  return t4;
}
function timerFlush() {
  now();
  ++frame;
  var t4 = taskHead, e8;
  while (t4) {
    if ((e8 = clockNow - t4._time) >= 0)
      t4._call.call(null, e8);
    t4 = t4._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time = Infinity;
  while (t12) {
    if (t12._call) {
      if (time > t12._time)
        time = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

// node_modules/@antv/g-base/node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/@antv/g-base/node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b10, a2) {
  if (a2 <= 0)
    r2 = g2 = b10 = NaN;
  return new Rgb(r2, g2, b10, a2);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color))
    o2 = color(o2);
  if (!o2)
    return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r2, g2, b10, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b10, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b10, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b10;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend2(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl)
    return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color))
    o2 = color(o2);
  if (!o2)
    return new Hsl();
  if (o2 instanceof Hsl)
    return o2;
  o2 = o2.rgb();
  var r2 = o2.r / 255, g2 = o2.g / 255, b10 = o2.b / 255, min6 = Math.min(r2, g2, b10), max7 = Math.max(r2, g2, b10), h2 = NaN, s2 = max7 - min6, l2 = (max7 + min6) / 2;
  if (s2) {
    if (r2 === max7)
      h2 = (g2 - b10) / s2 + (g2 < b10) * 6;
    else if (g2 === max7)
      h2 = (b10 - r2) / s2 + 2;
    else
      h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max7 + min6 : 2 - max7 - min6;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o2.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend2(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}

// node_modules/@antv/g-base/node_modules/d3-color/src/math.js
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// node_modules/@antv/g-base/node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o2) {
  if (o2 instanceof Lab)
    return new Lab(o2.l, o2.a, o2.b, o2.opacity);
  if (o2 instanceof Hcl)
    return hcl2lab(o2);
  if (!(o2 instanceof Rgb))
    o2 = rgbConvert(o2);
  var r2 = rgb2lrgb(o2.r), g2 = rgb2lrgb(o2.g), b10 = rgb2lrgb(o2.b), y2 = xyz2lab((0.2225045 * r2 + 0.7168786 * g2 + 0.0606169 * b10) / Yn), x2, z2;
  if (r2 === g2 && g2 === b10)
    x2 = z2 = y2;
  else {
    x2 = xyz2lab((0.4360747 * r2 + 0.3850649 * g2 + 0.1430804 * b10) / Xn);
    z2 = xyz2lab((0.0139322 * r2 + 0.0971045 * g2 + 0.7141733 * b10) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z2), o2.opacity);
}
function lab(l2, a2, b10, opacity) {
  return arguments.length === 1 ? labConvert(l2) : new Lab(l2, a2, b10, opacity == null ? 1 : opacity);
}
function Lab(l2, a2, b10, opacity) {
  this.l = +l2;
  this.a = +a2;
  this.b = +b10;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend2(Color, {
  brighter: function(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker: function(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z2 = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z2 = Zn * lab2xyz(z2);
    return new Rgb(lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z2), lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z2), lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z2), this.opacity);
  }
}));
function xyz2lab(t4) {
  return t4 > t3 ? Math.pow(t4, 1 / 3) : t4 / t2 + t0;
}
function lab2xyz(t4) {
  return t4 > t1 ? t4 * t4 * t4 : t2 * (t4 - t0);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o2) {
  if (o2 instanceof Hcl)
    return new Hcl(o2.h, o2.c, o2.l, o2.opacity);
  if (!(o2 instanceof Lab))
    o2 = labConvert(o2);
  if (o2.a === 0 && o2.b === 0)
    return new Hcl(NaN, 0 < o2.l && o2.l < 100 ? 0 : NaN, o2.l, o2.opacity);
  var h2 = Math.atan2(o2.b, o2.a) * rad2deg;
  return new Hcl(h2 < 0 ? h2 + 360 : h2, Math.sqrt(o2.a * o2.a + o2.b * o2.b), o2.l, o2.opacity);
}
function hcl(h2, c2, l2, opacity) {
  return arguments.length === 1 ? hclConvert(h2) : new Hcl(h2, c2, l2, opacity == null ? 1 : opacity);
}
function Hcl(h2, c2, l2, opacity) {
  this.h = +h2;
  this.c = +c2;
  this.l = +l2;
  this.opacity = +opacity;
}
function hcl2lab(o2) {
  if (isNaN(o2.h))
    return new Lab(o2.l, 0, 0, o2.opacity);
  var h2 = o2.h * deg2rad;
  return new Lab(o2.l, Math.cos(h2) * o2.c, Math.sin(h2) * o2.c, o2.opacity);
}
define_default(Hcl, hcl, extend2(Color, {
  brighter: function(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker: function(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/@antv/g-base/node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o2) {
  if (o2 instanceof Cubehelix)
    return new Cubehelix(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Rgb))
    o2 = rgbConvert(o2);
  var r2 = o2.r / 255, g2 = o2.g / 255, b10 = o2.b / 255, l2 = (BC_DA * b10 + ED * r2 - EB * g2) / (BC_DA + ED - EB), bl = b10 - l2, k2 = (E * (g2 - l2) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l2 * (1 - l2)), h2 = s2 ? Math.atan2(k2, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h2 < 0 ? h2 + 360 : h2, s2, l2, o2.opacity);
}
function cubehelix(h2, s2, l2, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h2) : new Cubehelix(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Cubehelix(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend2(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h2 = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l2 = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh = Math.cos(h2), sinh = Math.sin(h2);
    return new Rgb(255 * (l2 + a2 * (A * cosh + B * sinh)), 255 * (l2 + a2 * (C * cosh + D * sinh)), 255 * (l2 + a2 * (E * cosh)), this.opacity);
  }
}));

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/basis.js
function basis(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values2) {
  var n2 = values2.length - 1;
  return function(t4) {
    var i2 = t4 <= 0 ? t4 = 0 : t4 >= 1 ? (t4 = 1, n2 - 1) : Math.floor(t4 * n2), v1 = values2[i2], v2 = values2[i2 + 1], v0 = i2 > 0 ? values2[i2 - 1] : 2 * v1 - v2, v3 = i2 < n2 - 1 ? values2[i2 + 2] : 2 * v2 - v1;
    return basis((t4 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values2) {
  var n2 = values2.length;
  return function(t4) {
    var i2 = Math.floor(((t4 %= 1) < 0 ? ++t4 : t4) * n2), v0 = values2[(i2 + n2 - 1) % n2], v1 = values2[i2 % n2], v2 = values2[(i2 + 1) % n2], v3 = values2[(i2 + 2) % n2];
    return basis((t4 - i2 / n2) * n2, v0, v1, v2, v3);
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/constant.js
function constant_default(x2) {
  return function() {
    return x2;
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/color.js
function linear(a2, d2) {
  return function(t4) {
    return a2 + t4 * d2;
  };
}
function exponential(a2, b10, y2) {
  return a2 = Math.pow(a2, y2), b10 = Math.pow(b10, y2) - a2, y2 = 1 / y2, function(t4) {
    return Math.pow(a2 + t4 * b10, y2);
  };
}
function hue(a2, b10) {
  var d2 = b10 - a2;
  return d2 ? linear(a2, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant_default(isNaN(a2) ? b10 : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b10) {
    return b10 - a2 ? exponential(a2, b10, y2) : constant_default(isNaN(a2) ? b10 : a2);
  };
}
function nogamma(a2, b10) {
  var d2 = b10 - a2;
  return d2 ? linear(a2, d2) : constant_default(isNaN(a2) ? b10 : a2);
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y2) {
  var color3 = gamma(y2);
  function rgb2(start, end2) {
    var r2 = color3((start = rgb(start)).r, (end2 = rgb(end2)).r), g2 = color3(start.g, end2.g), b10 = color3(start.b, end2.b), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.r = r2(t4);
      start.g = g2(t4);
      start.b = b10(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n2 = colors.length, r2 = new Array(n2), g2 = new Array(n2), b10 = new Array(n2), i2, color3;
    for (i2 = 0; i2 < n2; ++i2) {
      color3 = rgb(colors[i2]);
      r2[i2] = color3.r || 0;
      g2[i2] = color3.g || 0;
      b10[i2] = color3.b || 0;
    }
    r2 = spline(r2);
    g2 = spline(g2);
    b10 = spline(b10);
    color3.opacity = 1;
    return function(t4) {
      color3.r = r2(t4);
      color3.g = g2(t4);
      color3.b = b10(t4);
      return color3 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a2, b10) {
  if (!b10)
    b10 = [];
  var n2 = a2 ? Math.min(b10.length, a2.length) : 0, c2 = b10.slice(), i2;
  return function(t4) {
    for (i2 = 0; i2 < n2; ++i2)
      c2[i2] = a2[i2] * (1 - t4) + b10[i2] * t4;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/array.js
function array_default(a2, b10) {
  return (isNumberArray(b10) ? numberArray_default : genericArray)(a2, b10);
}
function genericArray(a2, b10) {
  var nb = b10 ? b10.length : 0, na2 = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na2), c2 = new Array(nb), i2;
  for (i2 = 0; i2 < na2; ++i2)
    x2[i2] = value_default(a2[i2], b10[i2]);
  for (; i2 < nb; ++i2)
    c2[i2] = b10[i2];
  return function(t4) {
    for (i2 = 0; i2 < na2; ++i2)
      c2[i2] = x2[i2](t4);
    return c2;
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/date.js
function date_default(a2, b10) {
  var d2 = new Date();
  return a2 = +a2, b10 = +b10, function(t4) {
    return d2.setTime(a2 * (1 - t4) + b10 * t4), d2;
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/number.js
function number_default(a2, b10) {
  return a2 = +a2, b10 = +b10, function(t4) {
    return a2 * (1 - t4) + b10 * t4;
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/object.js
function object_default(a2, b10) {
  var i2 = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b10 === null || typeof b10 !== "object")
    b10 = {};
  for (k2 in b10) {
    if (k2 in a2) {
      i2[k2] = value_default(a2[k2], b10[k2]);
    } else {
      c2[k2] = b10[k2];
    }
  }
  return function(t4) {
    for (k2 in i2)
      c2[k2] = i2[k2](t4);
    return c2;
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero4(b10) {
  return function() {
    return b10;
  };
}
function one(b10) {
  return function(t4) {
    return b10(t4) + "";
  };
}
function string_default(a2, b10) {
  var bi2 = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s2 = [], q2 = [];
  a2 = a2 + "", b10 = b10 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b10))) {
    if ((bs = bm.index) > bi2) {
      bs = b10.slice(bi2, bs);
      if (s2[i2])
        s2[i2] += bs;
      else
        s2[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i2])
        s2[i2] += bm;
      else
        s2[++i2] = bm;
    } else {
      s2[++i2] = null;
      q2.push({ i: i2, x: number_default(am, bm) });
    }
    bi2 = reB.lastIndex;
  }
  if (bi2 < b10.length) {
    bs = b10.slice(bi2);
    if (s2[i2])
      s2[i2] += bs;
    else
      s2[++i2] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero4(b10) : (b10 = q2.length, function(t4) {
    for (var i3 = 0, o2; i3 < b10; ++i3)
      s2[(o2 = q2[i3]).i] = o2.x(t4);
    return s2.join("");
  });
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/value.js
function value_default(a2, b10) {
  var t4 = typeof b10, c2;
  return b10 == null || t4 === "boolean" ? constant_default(b10) : (t4 === "number" ? number_default : t4 === "string" ? (c2 = color(b10)) ? (b10 = c2, rgb_default) : string_default : b10 instanceof color ? rgb_default : b10 instanceof Date ? date_default : isNumberArray(b10) ? numberArray_default : Array.isArray(b10) ? genericArray : typeof b10.valueOf !== "function" && typeof b10.toString !== "function" || isNaN(b10) ? object_default : number_default)(a2, b10);
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/transform/decompose.js
var degrees = 180 / Math.PI;
var identity5 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a2, b10, c2, d2, e8, f2) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b10 * b10))
    a2 /= scaleX, b10 /= scaleX;
  if (skewX = a2 * c2 + b10 * d2)
    c2 -= a2 * skewX, d2 -= b10 * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d2 * d2))
    c2 /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a2 * d2 < b10 * c2)
    a2 = -a2, b10 = -b10, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e8,
    translateY: f2,
    rotate: Math.atan2(b10, a2) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/transform/parse.js
var cssNode;
var cssRoot;
var cssView;
var svgNode;
function parseCss(value) {
  if (value === "none")
    return identity5;
  if (!cssNode)
    cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose_default(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null)
    return identity5;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity5;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate5(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push("translate(", null, pxComma, null, pxParen);
      q2.push({ i: i2 - 4, x: number_default(xa2, xb) }, { i: i2 - 2, x: number_default(ya2, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate7(a2, b10, s2, q2) {
    if (a2 !== b10) {
      if (a2 - b10 > 180)
        b10 += 360;
      else if (b10 - a2 > 180)
        a2 += 360;
      q2.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: number_default(a2, b10) });
    } else if (b10) {
      s2.push(pop(s2) + "rotate(" + b10 + degParen);
    }
  }
  function skewX(a2, b10, s2, q2) {
    if (a2 !== b10) {
      q2.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: number_default(a2, b10) });
    } else if (b10) {
      s2.push(pop(s2) + "skewX(" + b10 + degParen);
    }
  }
  function scale9(xa2, ya2, xb, yb, s2, q2) {
    if (xa2 !== xb || ya2 !== yb) {
      var i2 = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q2.push({ i: i2 - 4, x: number_default(xa2, xb) }, { i: i2 - 2, x: number_default(ya2, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b10) {
    var s2 = [], q2 = [];
    a2 = parse2(a2), b10 = parse2(b10);
    translate5(a2.translateX, a2.translateY, b10.translateX, b10.translateY, s2, q2);
    rotate7(a2.rotate, b10.rotate, s2, q2);
    skewX(a2.skewX, b10.skewX, s2, q2);
    scale9(a2.scaleX, a2.scaleY, b10.scaleX, b10.scaleY, s2, q2);
    a2 = b10 = null;
    return function(t4) {
      var i2 = -1, n2 = q2.length, o2;
      while (++i2 < n2)
        s2[(o2 = q2[i2]).i] = o2.x(t4);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end2) {
    var h2 = hue2((start = hsl(start)).h, (end2 = hsl(end2)).h), s2 = nogamma(start.s, end2.s), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.s = s2(t4);
      start.l = l2(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end2) {
    var h2 = hue2((start = hcl(start)).h, (end2 = hcl(end2)).h), c2 = nogamma(start.c, end2.c), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
    return function(t4) {
      start.h = h2(t4);
      start.c = c2(t4);
      start.l = l2(t4);
      start.opacity = opacity(t4);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/@antv/g-base/node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix3(start, end2) {
      var h2 = hue2((start = cubehelix(start)).h, (end2 = cubehelix(end2)).h), s2 = nogamma(start.s, end2.s), l2 = nogamma(start.l, end2.l), opacity = nogamma(start.opacity, end2.opacity);
      return function(t4) {
        start.h = h2(t4);
        start.s = s2(t4);
        start.l = l2(Math.pow(t4, y2));
        start.opacity = opacity(t4);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/@antv/g-base/node_modules/d3-ease/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  easeBack: () => backInOut,
  easeBackIn: () => backIn,
  easeBackInOut: () => backInOut,
  easeBackOut: () => backOut,
  easeBounce: () => bounceOut,
  easeBounceIn: () => bounceIn,
  easeBounceInOut: () => bounceInOut,
  easeBounceOut: () => bounceOut,
  easeCircle: () => circleInOut,
  easeCircleIn: () => circleIn,
  easeCircleInOut: () => circleInOut,
  easeCircleOut: () => circleOut,
  easeCubic: () => cubicInOut,
  easeCubicIn: () => cubicIn,
  easeCubicInOut: () => cubicInOut,
  easeCubicOut: () => cubicOut,
  easeElastic: () => elasticOut,
  easeElasticIn: () => elasticIn,
  easeElasticInOut: () => elasticInOut,
  easeElasticOut: () => elasticOut,
  easeExp: () => expInOut,
  easeExpIn: () => expIn,
  easeExpInOut: () => expInOut,
  easeExpOut: () => expOut,
  easeLinear: () => linear2,
  easePoly: () => polyInOut,
  easePolyIn: () => polyIn,
  easePolyInOut: () => polyInOut,
  easePolyOut: () => polyOut,
  easeQuad: () => quadInOut,
  easeQuadIn: () => quadIn,
  easeQuadInOut: () => quadInOut,
  easeQuadOut: () => quadOut,
  easeSin: () => sinInOut,
  easeSinIn: () => sinIn,
  easeSinInOut: () => sinInOut,
  easeSinOut: () => sinOut
});

// node_modules/@antv/g-base/node_modules/d3-ease/src/linear.js
function linear2(t4) {
  return +t4;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/quad.js
function quadIn(t4) {
  return t4 * t4;
}
function quadOut(t4) {
  return t4 * (2 - t4);
}
function quadInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 : --t4 * (2 - t4) + 1) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/cubic.js
function cubicIn(t4) {
  return t4 * t4 * t4;
}
function cubicOut(t4) {
  return --t4 * t4 * t4 + 1;
}
function cubicInOut(t4) {
  return ((t4 *= 2) <= 1 ? t4 * t4 * t4 : (t4 -= 2) * t4 * t4 + 2) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/poly.js
var exponent = 3;
var polyIn = function custom(e8) {
  e8 = +e8;
  function polyIn2(t4) {
    return Math.pow(t4, e8);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e8) {
  e8 = +e8;
  function polyOut2(t4) {
    return 1 - Math.pow(1 - t4, e8);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e8) {
  e8 = +e8;
  function polyInOut2(t4) {
    return ((t4 *= 2) <= 1 ? Math.pow(t4, e8) : 2 - Math.pow(2 - t4, e8)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);

// node_modules/@antv/g-base/node_modules/d3-ease/src/sin.js
var pi = Math.PI;
var halfPi = pi / 2;
function sinIn(t4) {
  return +t4 === 1 ? 1 : 1 - Math.cos(t4 * halfPi);
}
function sinOut(t4) {
  return Math.sin(t4 * halfPi);
}
function sinInOut(t4) {
  return (1 - Math.cos(pi * t4)) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/math.js
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/exp.js
function expIn(t4) {
  return tpmt(1 - +t4);
}
function expOut(t4) {
  return 1 - tpmt(t4);
}
function expInOut(t4) {
  return ((t4 *= 2) <= 1 ? tpmt(1 - t4) : 2 - tpmt(t4 - 1)) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/circle.js
function circleIn(t4) {
  return 1 - Math.sqrt(1 - t4 * t4);
}
function circleOut(t4) {
  return Math.sqrt(1 - --t4 * t4);
}
function circleInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - Math.sqrt(1 - t4 * t4) : Math.sqrt(1 - (t4 -= 2) * t4) + 1) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/bounce.js
var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;
function bounceIn(t4) {
  return 1 - bounceOut(1 - t4);
}
function bounceOut(t4) {
  return (t4 = +t4) < b1 ? b0 * t4 * t4 : t4 < b3 ? b0 * (t4 -= b2) * t4 + b4 : t4 < b6 ? b0 * (t4 -= b5) * t4 + b7 : b0 * (t4 -= b8) * t4 + b9;
}
function bounceInOut(t4) {
  return ((t4 *= 2) <= 1 ? 1 - bounceOut(1 - t4) : bounceOut(t4 - 1) + 1) / 2;
}

// node_modules/@antv/g-base/node_modules/d3-ease/src/back.js
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t4) {
    return (t4 = +t4) * t4 * (s2 * (t4 - 1) + t4);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t4) {
    return --t4 * t4 * ((t4 + 1) * s2 + t4) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t4) {
    return ((t4 *= 2) < 1 ? t4 * t4 * ((s2 + 1) * t4 - s2) : (t4 -= 2) * t4 * ((s2 + 1) * t4 + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);

// node_modules/@antv/g-base/node_modules/d3-ease/src/elastic.js
var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;
var elasticIn = function custom7(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticIn2(t4) {
    return a2 * tpmt(- --t4) * Math.sin((s2 - t4) / p2);
  }
  elasticIn2.amplitude = function(a3) {
    return custom7(a3, p2 * tau);
  };
  elasticIn2.period = function(p3) {
    return custom7(a2, p3);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticOut2(t4) {
    return 1 - a2 * tpmt(t4 = +t4) * Math.sin((t4 + s2) / p2);
  }
  elasticOut2.amplitude = function(a3) {
    return custom8(a3, p2 * tau);
  };
  elasticOut2.period = function(p3) {
    return custom8(a2, p3);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a2, p2) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p2 /= tau);
  function elasticInOut2(t4) {
    return ((t4 = t4 * 2 - 1) < 0 ? a2 * tpmt(-t4) * Math.sin((s2 - t4) / p2) : 2 - a2 * tpmt(t4) * Math.sin((s2 + t4) / p2)) / 2;
  }
  elasticInOut2.amplitude = function(a3) {
    return custom9(a3, p2 * tau);
  };
  elasticInOut2.period = function(p3) {
    return custom9(a2, p3);
  };
  return elasticInOut2;
}(amplitude, period);

// node_modules/@antv/g-base/esm/animate/register.js
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || src_exports2[type];
}

// node_modules/@antv/g-base/esm/util/color.js
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};

// node_modules/@antv/g-base/esm/animate/timeline.js
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation, ratio) {
  var cProps = {};
  var fromAttrs = animation.fromAttrs, toAttrs = animation.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k2 in toAttrs) {
    if (!is_equal_default(fromAttrs[k2], toAttrs[k2])) {
      if (k2 === "path") {
        var toPath = toAttrs[k2];
        var fromPath = fromAttrs[k2];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString(toAttrs[k2]);
          fromPath = parsePathString(fromAttrs[k2]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
        } else if (!animation.pathFormatted) {
          toPath = parsePathString(toAttrs[k2]);
          fromPath = parsePathString(fromAttrs[k2]);
          fromPath = formatPath(fromPath, toPath);
          animation.fromAttrs.path = fromPath;
          animation.toAttrs.path = toPath;
          animation.pathFormatted = true;
        }
        cProps[k2] = [];
        for (var i2 = 0; i2 < toPath.length; i2++) {
          var toPathPoint = toPath[i2];
          var fromPathPoint = fromPath[i2];
          var cPathPoint = [];
          for (var j2 = 0; j2 < toPathPoint.length; j2++) {
            if (is_number_default(toPathPoint[j2]) && fromPathPoint && is_number_default(fromPathPoint[j2])) {
              interf = value_default(fromPathPoint[j2], toPathPoint[j2]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j2]);
            }
          }
          cProps[k2].push(cPathPoint);
        }
      } else if (k2 === "matrix") {
        var matrixFn = array_default(fromAttrs[k2] || IDENTITY_MATRIX, toAttrs[k2] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k2] = currentMatrix;
      } else if (isColorProp(k2) && isGradientColor(toAttrs[k2])) {
        cProps[k2] = toAttrs[k2];
      } else if (!is_function_default(toAttrs[k2])) {
        interf = value_default(fromAttrs[k2], toAttrs[k2]);
        cProps[k2] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation, elapsed) {
  var startTime = animation.startTime, delay = animation.delay;
  if (elapsed < startTime + delay || animation._paused) {
    return false;
  }
  var ratio;
  var duration = animation.duration;
  var easing = animation.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation.delay;
  if (animation.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation.onFrame) {
        shape.attr(animation.onFrame(1));
      } else {
        shape.attr(animation.toAttrs);
      }
      return true;
    }
  }
  if (animation.onFrame) {
    var attrs = animation.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation, ratio);
  }
  return false;
}
var Timeline = function() {
  function Timeline2(canvas) {
    this.animators = [];
    this.current = 0;
    this.timer = null;
    this.canvas = canvas;
  }
  Timeline2.prototype.initTimer = function() {
    var _this = this;
    var isFinished = false;
    var shape;
    var animations;
    var animation;
    this.timer = timer(function(elapsed) {
      _this.current = elapsed;
      if (_this.animators.length > 0) {
        for (var i2 = _this.animators.length - 1; i2 >= 0; i2--) {
          shape = _this.animators[i2];
          if (shape.destroyed) {
            _this.removeAnimator(i2);
            continue;
          }
          if (!shape.isAnimatePaused()) {
            animations = shape.get("animations");
            for (var j2 = animations.length - 1; j2 >= 0; j2--) {
              animation = animations[j2];
              isFinished = update(shape, animation, elapsed);
              if (isFinished) {
                animations.splice(j2, 1);
                isFinished = false;
                if (animation.callback) {
                  animation.callback();
                }
              }
            }
          }
          if (animations.length === 0) {
            _this.removeAnimator(i2);
          }
        }
        var autoDraw = _this.canvas.get("autoDraw");
        if (!autoDraw) {
          _this.canvas.draw();
        }
      }
    });
  };
  Timeline2.prototype.addAnimator = function(shape) {
    this.animators.push(shape);
  };
  Timeline2.prototype.removeAnimator = function(index) {
    this.animators.splice(index, 1);
  };
  Timeline2.prototype.isAnimating = function() {
    return !!this.animators.length;
  };
  Timeline2.prototype.stop = function() {
    if (this.timer) {
      this.timer.stop();
    }
  };
  Timeline2.prototype.stopAllAnimations = function(toEnd) {
    if (toEnd === void 0) {
      toEnd = true;
    }
    this.animators.forEach(function(animator) {
      animator.stopAnimate(toEnd);
    });
    this.animators = [];
    this.canvas.draw();
  };
  Timeline2.prototype.getTime = function() {
    return this.current;
  };
  return Timeline2;
}();
var timeline_default = Timeline;

// node_modules/@antv/g-base/esm/event/event-contoller.js
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target;
  eventObj.currentTarget = target;
  eventObj.delegateTarget = target;
  target.emit(type, eventObj);
}
function bubbleEvent(container2, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container2.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container2, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container2;
    eventObj.delegateTarget = container2;
    container2.emit(type, eventObj);
  }
}
var EventController = function() {
  function EventController4(cfg) {
    var _this = this;
    this.draggingShape = null;
    this.dragging = false;
    this.currentShape = null;
    this.mousedownShape = null;
    this.mousedownPoint = null;
    this._eventCallback = function(ev) {
      var type = ev.type;
      _this._triggerEvent(type, ev);
    };
    this._onDocumentMove = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging || _this.currentShape) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.dragging) {
            _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
          }
        }
      }
    };
    this._onDocumentMouseUp = function(ev) {
      var canvas = _this.canvas;
      var el = canvas.get("el");
      if (el !== ev.target) {
        if (_this.dragging) {
          var pointInfo = _this._getPointInfo(ev);
          if (_this.draggingShape) {
            _this._emitEvent("drop", ev, pointInfo, null);
          }
          _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
          _this._afterDrag(_this.draggingShape, pointInfo, ev);
        }
      }
    };
    this.canvas = cfg.canvas;
  }
  EventController4.prototype.init = function() {
    this._bindEvents();
  };
  EventController4.prototype._bindEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each_default(EVENTS, function(eventName) {
      el.addEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.addEventListener("mousemove", this._onDocumentMove);
      document.addEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController4.prototype._clearEvents = function() {
    var _this = this;
    var el = this.canvas.get("el");
    each_default(EVENTS, function(eventName) {
      el.removeEventListener(eventName, _this._eventCallback);
    });
    if (document) {
      document.removeEventListener("mousemove", this._onDocumentMove);
      document.removeEventListener("mouseup", this._onDocumentMouseUp);
    }
  };
  EventController4.prototype._getEventObj = function(type, event, point, target, fromShape, toShape) {
    var eventObj = new graph_event_default(type, event);
    eventObj.fromShape = fromShape;
    eventObj.toShape = toShape;
    eventObj.x = point.x;
    eventObj.y = point.y;
    eventObj.clientX = point.clientX;
    eventObj.clientY = point.clientY;
    eventObj.propagationPath.push(target);
    return eventObj;
  };
  EventController4.prototype._getShape = function(point, ev) {
    return this.canvas.getShape(point.x, point.y, ev);
  };
  EventController4.prototype._getPointInfo = function(ev) {
    var canvas = this.canvas;
    var clientPoint = canvas.getClientByEvent(ev);
    var point = canvas.getPointByEvent(ev);
    return {
      x: point.x,
      y: point.y,
      clientX: clientPoint.x,
      clientY: clientPoint.y
    };
  };
  EventController4.prototype._triggerEvent = function(type, ev) {
    var pointInfo = this._getPointInfo(ev);
    var shape = this._getShape(pointInfo, ev);
    var method = this["_on" + type];
    var leaveCanvas = false;
    if (method) {
      method.call(this, pointInfo, shape, ev);
    } else {
      var preShape = this.currentShape;
      if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
        this._emitEvent(type, ev, pointInfo, null, null, shape);
        if (shape) {
          this._emitEvent(type, ev, pointInfo, shape, null, shape);
        }
        if (type === "mouseenter" && this.draggingShape) {
          this._emitEvent("dragenter", ev, pointInfo, null);
        }
      } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
        leaveCanvas = true;
        if (preShape) {
          this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
        }
        this._emitEvent(type, ev, pointInfo, null, preShape, null);
        if (type === "mouseleave" && this.draggingShape) {
          this._emitEvent("dragleave", ev, pointInfo, null);
        }
      } else {
        this._emitEvent(type, ev, pointInfo, shape, null, null);
      }
    }
    if (!leaveCanvas) {
      this.currentShape = shape;
    }
    if (shape && !shape.get("destroyed")) {
      var canvas = this.canvas;
      var el = canvas.get("el");
      el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
    }
  };
  EventController4.prototype._onmousedown = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      this.mousedownShape = shape;
      this.mousedownPoint = pointInfo;
      this.mousedownTimeStamp = event.timeStamp;
    }
    this._emitEvent("mousedown", event, pointInfo, shape, null, null);
  };
  EventController4.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
    var el = this.canvas.get("el");
    if (fromShape !== toShape) {
      if (fromShape) {
        this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
        this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
        if (!toShape || toShape.get("destroyed")) {
          el.style.cursor = this.canvas.get("cursor");
        }
      }
      if (toShape) {
        this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
        this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
      }
    }
  };
  EventController4.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
    if (toShape) {
      if (toShape !== fromShape) {
        if (fromShape) {
          this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
        }
        this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
      }
      if (!isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    } else if (fromShape) {
      this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
    }
    if (isCanvasEmit) {
      this._emitEvent("dragover", event, pointInfo, toShape);
    }
  };
  EventController4.prototype._afterDrag = function(draggingShape, pointInfo, event) {
    if (draggingShape) {
      draggingShape.set("capture", true);
      this.draggingShape = null;
    }
    this.dragging = false;
    var shape = this._getShape(pointInfo, event);
    if (shape !== draggingShape) {
      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
    }
    this.currentShape = shape;
  };
  EventController4.prototype._onmouseup = function(pointInfo, shape, event) {
    if (event.button === LEFT_BTN_CODE) {
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitEvent("drop", event, pointInfo, shape);
        }
        this._emitEvent("dragend", event, pointInfo, draggingShape);
        this._afterDrag(draggingShape, pointInfo, event);
      } else {
        this._emitEvent("mouseup", event, pointInfo, shape);
        if (shape === this.mousedownShape) {
          this._emitEvent("click", event, pointInfo, shape);
        }
        this.mousedownShape = null;
        this.mousedownPoint = null;
      }
    }
  };
  EventController4.prototype._ondragover = function(pointInfo, shape, event) {
    event.preventDefault();
    var preShape = this.currentShape;
    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
  };
  EventController4.prototype._onmousemove = function(pointInfo, shape, event) {
    var canvas = this.canvas;
    var preShape = this.currentShape;
    var draggingShape = this.draggingShape;
    if (this.dragging) {
      if (draggingShape) {
        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
      }
      this._emitEvent("drag", event, pointInfo, draggingShape);
    } else {
      var mousedownPoint = this.mousedownPoint;
      if (mousedownPoint) {
        var mousedownShape = this.mousedownShape;
        var now2 = event.timeStamp;
        var timeWindow = now2 - this.mousedownTimeStamp;
        var dx = mousedownPoint.clientX - pointInfo.clientX;
        var dy = mousedownPoint.clientY - pointInfo.clientY;
        var dist4 = dx * dx + dy * dy;
        if (timeWindow > 120 || dist4 > CLICK_OFFSET) {
          if (mousedownShape && mousedownShape.get("draggable")) {
            draggingShape = this.mousedownShape;
            draggingShape.set("capture", false);
            this.draggingShape = draggingShape;
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, draggingShape);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else if (!mousedownShape && canvas.get("draggable")) {
            this.dragging = true;
            this._emitEvent("dragstart", event, pointInfo, null);
            this.mousedownShape = null;
            this.mousedownPoint = null;
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      } else {
        this._emitMouseoverEvents(event, pointInfo, preShape, shape);
        this._emitEvent("mousemove", event, pointInfo, shape);
      }
    }
  };
  EventController4.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
    var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
    if (shape) {
      eventObj.shape = shape;
      emitTargetEvent(shape, type, eventObj);
      var parent_1 = shape.getParent();
      while (parent_1) {
        parent_1.emitDelegation(type, eventObj);
        if (!eventObj.propagationStopped) {
          bubbleEvent(parent_1, type, eventObj);
        }
        eventObj.propagationPath.push(parent_1);
        parent_1 = parent_1.getParent();
      }
    } else {
      var canvas = this.canvas;
      emitTargetEvent(canvas, type, eventObj);
    }
  };
  EventController4.prototype.destroy = function() {
    this._clearEvents();
    this.canvas = null;
    this.currentShape = null;
    this.draggingShape = null;
    this.mousedownPoint = null;
    this.mousedownShape = null;
    this.mousedownTimeStamp = null;
  };
  return EventController4;
}();
var event_contoller_default = EventController;

// node_modules/@antv/g-base/esm/abstract/canvas.js
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas = function(_super) {
  __extends3(Canvas4, _super);
  function Canvas4(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.initContainer();
    _this.initDom();
    _this.initEvents();
    _this.initTimeline();
    return _this;
  }
  Canvas4.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["cursor"] = "default";
    cfg["supportCSSTransform"] = false;
    return cfg;
  };
  Canvas4.prototype.initContainer = function() {
    var container2 = this.get("container");
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
      this.set("container", container2);
    }
  };
  Canvas4.prototype.initDom = function() {
    var el = this.createDom();
    this.set("el", el);
    var container2 = this.get("container");
    container2.appendChild(el);
    this.setDOMSize(this.get("width"), this.get("height"));
  };
  Canvas4.prototype.initEvents = function() {
    var eventController = new event_contoller_default({
      canvas: this
    });
    eventController.init();
    this.set("eventController", eventController);
  };
  Canvas4.prototype.initTimeline = function() {
    var timeline = new timeline_default(this);
    this.set("timeline", timeline);
  };
  Canvas4.prototype.setDOMSize = function(width, height) {
    var el = this.get("el");
    if (isBrowser) {
      el.style.width = width + PX_SUFFIX;
      el.style.height = height + PX_SUFFIX;
    }
  };
  Canvas4.prototype.changeSize = function(width, height) {
    this.setDOMSize(width, height);
    this.set("width", width);
    this.set("height", height);
    this.onCanvasChange("changeSize");
  };
  Canvas4.prototype.getRenderer = function() {
    return this.get("renderer");
  };
  Canvas4.prototype.getCursor = function() {
    return this.get("cursor");
  };
  Canvas4.prototype.setCursor = function(cursor) {
    this.set("cursor", cursor);
    var el = this.get("el");
    if (isBrowser && el) {
      el.style.cursor = cursor;
    }
  };
  Canvas4.prototype.getPointByEvent = function(ev) {
    var supportCSSTransform = this.get("supportCSSTransform");
    if (supportCSSTransform) {
      if (isFirefox && !is_nil_default(ev.layerX) && ev.layerX !== ev.offsetX) {
        return {
          x: ev.layerX,
          y: ev.layerY
        };
      }
      if (!is_nil_default(ev.offsetX)) {
        return {
          x: ev.offsetX,
          y: ev.offsetY
        };
      }
    }
    var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
    return this.getPointByClient(clientX, clientY);
  };
  Canvas4.prototype.getClientByEvent = function(ev) {
    var clientInfo = ev;
    if (ev.touches) {
      if (ev.type === "touchend") {
        clientInfo = ev.changedTouches[0];
      } else {
        clientInfo = ev.touches[0];
      }
    }
    return {
      x: clientInfo.clientX,
      y: clientInfo.clientY
    };
  };
  Canvas4.prototype.getPointByClient = function(clientX, clientY) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: clientX - bbox.left,
      y: clientY - bbox.top
    };
  };
  Canvas4.prototype.getClientByPoint = function(x2, y2) {
    var el = this.get("el");
    var bbox = el.getBoundingClientRect();
    return {
      x: x2 + bbox.left,
      y: y2 + bbox.top
    };
  };
  Canvas4.prototype.draw = function() {
  };
  Canvas4.prototype.removeDom = function() {
    var el = this.get("el");
    el.parentNode.removeChild(el);
  };
  Canvas4.prototype.clearEvents = function() {
    var eventController = this.get("eventController");
    eventController.destroy();
  };
  Canvas4.prototype.isCanvas = function() {
    return true;
  };
  Canvas4.prototype.getParent = function() {
    return null;
  };
  Canvas4.prototype.destroy = function() {
    var timeline = this.get("timeline");
    if (this.get("destroyed")) {
      return;
    }
    this.clear();
    if (timeline) {
      timeline.stop();
    }
    this.clearEvents();
    this.removeDom();
    _super.prototype.destroy.call(this);
  };
  return Canvas4;
}(container_default);
var canvas_default = Canvas;

// node_modules/@antv/g-base/esm/abstract/group.js
var AbstractGroup = function(_super) {
  __extends3(AbstractGroup2, _super);
  function AbstractGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AbstractGroup2.prototype.isGroup = function() {
    return true;
  };
  AbstractGroup2.prototype.isEntityGroup = function() {
    return false;
  };
  AbstractGroup2.prototype.clone = function() {
    var clone8 = _super.prototype.clone.call(this);
    var children = this.getChildren();
    for (var i2 = 0; i2 < children.length; i2++) {
      var child = children[i2];
      clone8.add(child.clone());
    }
    return clone8;
  };
  return AbstractGroup2;
}(container_default);
var group_default2 = AbstractGroup;

// node_modules/@antv/g-base/esm/abstract/shape.js
var AbstractShape = function(_super) {
  __extends3(AbstractShape2, _super);
  function AbstractShape2(cfg) {
    return _super.call(this, cfg) || this;
  }
  AbstractShape2.prototype._isInBBox = function(refX, refY) {
    var bbox = this.getBBox();
    return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
  };
  AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    this.clearCacheBBox();
  };
  AbstractShape2.prototype.getBBox = function() {
    var bbox = this.cfg.bbox;
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set("bbox", bbox);
    }
    return bbox;
  };
  AbstractShape2.prototype.getCanvasBBox = function() {
    var canvasBBox = this.cfg.canvasBBox;
    if (!canvasBBox) {
      canvasBBox = this.calculateCanvasBBox();
      this.set("canvasBBox", canvasBBox);
    }
    return canvasBBox;
  };
  AbstractShape2.prototype.applyMatrix = function(matrix) {
    _super.prototype.applyMatrix.call(this, matrix);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.calculateCanvasBBox = function() {
    var bbox = this.getBBox();
    var totalMatrix = this.getTotalMatrix();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (totalMatrix) {
      var topLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.minY]);
      var topRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.minY]);
      var bottomLeft = multiplyVec2(totalMatrix, [bbox.minX, bbox.maxY]);
      var bottomRight = multiplyVec2(totalMatrix, [bbox.maxX, bbox.maxY]);
      minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
      minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      maxY = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
    }
    var attrs = this.attrs;
    if (attrs.shadowColor) {
      var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
      var shadowLeft = minX - shadowBlur + shadowOffsetX;
      var shadowRight = maxX + shadowBlur + shadowOffsetX;
      var shadowTop = minY - shadowBlur + shadowOffsetY;
      var shadowBottom = maxY + shadowBlur + shadowOffsetY;
      minX = Math.min(minX, shadowLeft);
      maxX = Math.max(maxX, shadowRight);
      minY = Math.min(minY, shadowTop);
      maxY = Math.max(maxY, shadowBottom);
    }
    return {
      x: minX,
      y: minY,
      minX,
      minY,
      maxX,
      maxY,
      width: maxX - minX,
      height: maxY - minY
    };
  };
  AbstractShape2.prototype.clearCacheBBox = function() {
    this.set("bbox", null);
    this.set("canvasBBox", null);
  };
  AbstractShape2.prototype.isClipShape = function() {
    return this.get("isClipShape");
  };
  AbstractShape2.prototype.isInShape = function(refX, refY) {
    return false;
  };
  AbstractShape2.prototype.isOnlyHitBox = function() {
    return false;
  };
  AbstractShape2.prototype.isHit = function(x2, y2) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    var vec = [x2, y2, 1];
    vec = this.invertFromMatrix(vec);
    var refX = vec[0], refY = vec[1];
    var inBBox = this._isInBBox(refX, refY);
    if (this.isOnlyHitBox()) {
      return inBBox;
    }
    if (inBBox && !this.isClipped(refX, refY)) {
      if (this.isInShape(refX, refY)) {
        return true;
      }
      if (startArrowShape && startArrowShape.isHit(refX, refY)) {
        return true;
      }
      if (endArrowShape && endArrowShape.isHit(refX, refY)) {
        return true;
      }
    }
    return false;
  };
  return AbstractShape2;
}(element_default);
var shape_default = AbstractShape;

// node_modules/@antv/g-base/esm/bbox/register.js
var cache = /* @__PURE__ */ new Map();
function register(type, method) {
  cache.set(type, method);
}
function getMethod(type) {
  return cache.get(type);
}

// node_modules/@antv/g-base/esm/bbox/rect.js
function rect_default(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x: x2,
    y: y2,
    width,
    height
  };
}

// node_modules/@antv/g-base/esm/bbox/circle.js
function circle_default(shape) {
  var _a2 = shape.attr(), x2 = _a2.x, y2 = _a2.y, r2 = _a2.r;
  return {
    x: x2 - r2,
    y: y2 - r2,
    width: r2 * 2,
    height: r2 * 2
  };
}

// node_modules/@antv/g-math/esm/util.js
var util_exports = {};
__export(util_exports, {
  distance: () => distance6,
  getBBoxByArray: () => getBBoxByArray,
  getBBoxRange: () => getBBoxRange,
  isNumberEqual: () => isNumberEqual2,
  piMod: () => piMod
});
function minNum(array) {
  return Math.min.apply(null, array);
}
function maxNum(array) {
  return Math.max.apply(null, array);
}
function distance6(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual2(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = minNum(xArr);
  var minY = minNum(yArr);
  var maxX = maxNum(xArr);
  var maxY = maxNum(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getBBoxRange(x1, y1, x2, y2) {
  return {
    minX: minNum([x1, x2]),
    maxX: maxNum([x1, x2]),
    minY: minNum([y1, y2]),
    maxY: maxNum([y1, y2])
  };
}
function piMod(angle3) {
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}

// node_modules/@antv/g-math/esm/line.js
init_vec2();
var line_default = {
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  length: function(x1, y1, x2, y2) {
    return distance6(x1, y1, x2, y2);
  },
  pointAt: function(x1, y1, x2, y2, t4) {
    return {
      x: (1 - t4) * x1 + t4 * x2,
      y: (1 - t4) * y1 + t4 * y2
    };
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3) {
    var cross6 = (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1);
    if (cross6 < 0) {
      return distance6(x1, y1, x3, y3);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross6 > lengthSquare) {
      return distance6(x2, y2, x3, y3);
    }
    return this.pointToLine(x1, y1, x2, y2, x3, y3);
  },
  pointToLine: function(x1, y1, x2, y2, x3, y3) {
    var d2 = [x2 - x1, y2 - y1];
    if (exactEquals6(d2, [0, 0])) {
      return Math.sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));
    }
    var u2 = [-d2[1], d2[0]];
    normalize4(u2, u2);
    var a2 = [x3 - x1, y3 - y1];
    return Math.abs(dot4(a2, u2));
  },
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};

// node_modules/@antv/g-math/esm/bezier.js
var EPSILON2 = 1e-4;
function nearestPoint(xArr, yArr, x2, y2, tCallback, length5) {
  var t4;
  var d2 = Infinity;
  var v0 = [x2, y2];
  var segNum = 20;
  if (length5 && length5 > 200) {
    segNum = length5 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i2 = 0; i2 <= segNum; i2++) {
    var _t2 = i2 * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t2])), tCallback.apply(null, yArr.concat([_t2]))];
    var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d2) {
      t4 = _t2;
      d2 = d1;
    }
  }
  if (t4 === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t4 === 1) {
    var count = xArr.length;
    return {
      x: xArr[count - 1],
      y: yArr[count - 1]
    };
  }
  d2 = Infinity;
  for (var i2 = 0; i2 < 32; i2++) {
    if (interval2 < EPSILON2) {
      break;
    }
    var prev = t4 - interval2;
    var next = t4 + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d2) {
      t4 = prev;
      d2 = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d22 = distance6(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d22 < d2) {
        t4 = next;
        d2 = d22;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t4])),
    y: tCallback.apply(null, yArr.concat([t4]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count = xArr.length;
  for (var i2 = 0; i2 < count; i2++) {
    var x2 = xArr[i2];
    var y2 = yArr[i2];
    var nextX = xArr[(i2 + 1) % count];
    var nextY = yArr[(i2 + 1) % count];
    totalLength += distance6(x2, y2, nextX, nextY);
  }
  return totalLength / 2;
}

// node_modules/@antv/g-math/esm/quadratic.js
function quadraticAt(p0, p1, p2, t4) {
  var onet = 1 - t4;
  return onet * onet * p0 + 2 * t4 * onet * p1 + t4 * t4 * p2;
}
function extrema(p0, p1, p2) {
  var a2 = p0 + p2 - 2 * p1;
  if (isNumberEqual2(a2, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a2;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt(p0, p1, p2, t4) {
  return 2 * (1 - t4) * (p1 - p0) + 2 * t4 * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t4) {
  var xt2 = quadraticAt(x1, x2, x3, t4);
  var yt2 = quadraticAt(y1, y2, y3, t4);
  var controlPoint1 = line_default.pointAt(x1, y1, x2, y2, t4);
  var controlPoint2 = line_default.pointAt(x2, y2, x3, y3, t4);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt2, yt2],
    [xt2, yt2, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance6(x1, y1, x2, y2) + distance6(x2, y2, x3, y3) + distance6(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left = quadratics[0];
  var right = quadratics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return quadraticLength.apply(null, left) + quadraticLength.apply(null, right);
}
var quadratic_default = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema(x1, x2, x3)[0];
    var yExtrema2 = extrema(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance6(point.x, point.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t4) {
    return {
      x: quadraticAt(x1, x2, x3, t4),
      y: quadraticAt(y1, y2, y3, t4)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t4) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t4);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t4) {
    var dx = derivativeAt(x1, x2, x3, t4);
    var dy = derivativeAt(y1, y2, y3, t4);
    var angle3 = Math.atan2(dy, dx);
    return piMod(angle3);
  }
};

// node_modules/@antv/g-math/esm/cubic.js
function cubicAt(p0, p1, p2, p3, t4) {
  var onet = 1 - t4;
  return onet * onet * onet * p0 + 3 * p1 * t4 * onet * onet + 3 * p2 * t4 * t4 * onet + p3 * t4 * t4 * t4;
}
function derivativeAt2(p0, p1, p2, p3, t4) {
  var onet = 1 - t4;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t4 * (p2 - p1) + t4 * t4 * (p3 - p2));
}
function extrema2(p0, p1, p2, p3) {
  var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b10 = 6 * p0 - 12 * p1 + 6 * p2;
  var c2 = 3 * p1 - 3 * p0;
  var extremas = [];
  var t12;
  var t22;
  var discSqrt;
  if (isNumberEqual2(a2, 0)) {
    if (!isNumberEqual2(b10, 0)) {
      t12 = -c2 / b10;
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
    }
  } else {
    var disc = b10 * b10 - 4 * a2 * c2;
    if (isNumberEqual2(disc, 0)) {
      extremas.push(-b10 / (2 * a2));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t12 = (-b10 + discSqrt) / (2 * a2);
      t22 = (-b10 - discSqrt) / (2 * a2);
      if (t12 >= 0 && t12 <= 1) {
        extremas.push(t12);
      }
      if (t22 >= 0 && t22 <= 1) {
        extremas.push(t22);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t4) {
  var xt2 = cubicAt(x1, x2, x3, x4, t4);
  var yt2 = cubicAt(y1, y2, y3, y4, t4);
  var c1 = line_default.pointAt(x1, y1, x2, y2, t4);
  var c2 = line_default.pointAt(x2, y2, x3, y3, t4);
  var c3 = line_default.pointAt(x3, y3, x4, y4, t4);
  var c12 = line_default.pointAt(c1.x, c1.y, c2.x, c2.y, t4);
  var c23 = line_default.pointAt(c2.x, c2.y, c3.x, c3.y, t4);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt2, yt2],
    [xt2, yt2, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left = cubics[0];
  var right = cubics[1];
  left.push(iterationCount - 1);
  right.push(iterationCount - 1);
  return cubicLength.apply(null, left) + cubicLength.apply(null, right);
}
var cubic_default = {
  extrema: extrema2,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema2(x1, x2, x3, x4);
    var yExtrema2 = extrema2(y1, y2, y3, y4);
    for (var i2 = 0; i2 < xExtrema2.length; i2++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i2]));
    }
    for (var i2 = 0; i2 < yExtrema2.length; i2++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i2]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length5);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5) {
    var point = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length5);
    return distance6(point.x, point.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t4) {
    return {
      x: cubicAt(x1, x2, x3, x4, t4),
      y: cubicAt(y1, y2, y3, y4, t4)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t4) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t4);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t4) {
    var dx = derivativeAt2(x1, x2, x3, x4, t4);
    var dy = derivativeAt2(y1, y2, y3, y4, t4);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/ellipse.js
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
var ellipse_default = {
  box: function(x2, y2, rx, ry) {
    return {
      x: x2 - rx,
      y: y2 - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  length: function(x2, y2, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  nearestPoint: function(x2, y2, rx, ry, x0, y0) {
    var a2 = rx;
    var b10 = ry;
    if (a2 === 0 || b10 === 0) {
      return {
        x: x2,
        y: y2
      };
    }
    var relativeX = x0 - x2;
    var relativeY = y0 - y2;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a2 * a2;
    var squareB = b10 * b10;
    var t4 = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i2 = 0; i2 < 4; i2++) {
      nearestX = a2 * Math.cos(t4);
      nearestY = b10 * Math.sin(t4);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t4), 3) / a2;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t4), 3) / b10;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r2 = Math.hypot(ry1, rx1);
      var q2 = Math.hypot(qy, qx);
      var delta_c = r2 * Math.asin((rx1 * qy - ry1 * qx) / (r2 * q2));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t4 += delta_t;
      t4 = Math.min(Math.PI / 2, Math.max(0, t4));
    }
    return {
      x: x2 + copysign(nearestX, relativeX),
      y: y2 + copysign(nearestY, relativeY)
    };
  },
  pointDistance: function(x2, y2, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x2, y2, rx, ry, x0, y0);
    return distance6(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(x2, y2, rx, ry, t4) {
    var angle3 = 2 * Math.PI * t4;
    return {
      x: x2 + rx * Math.cos(angle3),
      y: y2 + ry * Math.sin(angle3)
    };
  },
  tangentAngle: function(x2, y2, rx, ry, t4) {
    var angle3 = 2 * Math.PI * t4;
    var tangentAngle = Math.atan2(ry * Math.cos(angle3), -rx * Math.sin(angle3));
    return piMod(tangentAngle);
  }
};

// node_modules/@antv/g-math/esm/arc.js
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle3) - ry * Math.sin(xRotation) * Math.cos(angle3);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle3) + ry * Math.cos(xRotation) * Math.cos(angle3);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.cos(xRotation) * Math.cos(angle3) - ry * Math.sin(xRotation) * Math.sin(angle3) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle3) {
  return rx * Math.sin(xRotation) * Math.cos(angle3) + ry * Math.cos(xRotation) * Math.sin(angle3) + cy;
}
function getAngle2(rx, ry, x0, y0) {
  var angle3 = Math.atan2(y0 * rx, x0 * ry);
  return (angle3 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle3) {
  return {
    x: rx * Math.cos(angle3),
    y: ry * Math.sin(angle3)
  };
}
function rotate6(x2, y2, angle3) {
  var cos3 = Math.cos(angle3);
  var sin3 = Math.sin(angle3);
  return [x2 * cos3 - y2 * sin3, x2 * sin3 + y2 * cos3];
}
var arc_default = {
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var xAngle = xDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i2 = 0; i2 < xs.length; i2++) {
      var x2 = xAt(cx, cy, rx, ry, xRotation, xs[i2]);
      if (x2 < minX) {
        minX = x2;
      }
      if (x2 > maxX) {
        maxX = x2;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i2 = -Math.PI * 2; i2 <= Math.PI * 2; i2 += Math.PI) {
      var yAngle = yDim + i2;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i2 = 0; i2 < ys.length; i2++) {
      var y2 = yAt(cx, cy, rx, ry, xRotation, ys[i2]);
      if (y2 < minY) {
        minY = y2;
      }
      if (y2 > maxY) {
        maxY = y2;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  },
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate6(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse_default.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle3 = getAngle2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle3 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle3 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate6(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance6(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t4) {
    var angle3 = (endAngle - startAngle) * t4 + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle3),
      y: yAt(cx, cy, rx, ry, xRotation, angle3)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t4) {
    var angle3 = (endAngle - startAngle) * t4 + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle3);
    return piMod(Math.atan2(dy, dx));
  }
};

// node_modules/@antv/g-math/esm/segments.js
function analyzePoints(points) {
  var totalLength = 0;
  var segments = [];
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to2 = points[i2 + 1];
    var length_1 = distance6(from[0], from[1], to2[0], to2[1]);
    var seg = {
      from,
      to: to2,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points) {
  if (points.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var from = points[i2];
    var to2 = points[i2 + 1];
    totalLength += distance6(from[0], from[1], to2[0], to2[1]);
  }
  return totalLength;
}
function pointAtSegments(points, t4) {
  if (t4 > 1 || t4 < 0 || points.length < 2) {
    return null;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  if (totalLength === 0) {
    return {
      x: points[0][0],
      y: points[0][1]
    };
  }
  var startRatio = 0;
  var point = null;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to2 = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t4 >= startRatio && t4 <= startRatio + currentRatio) {
      var localRatio = (t4 - startRatio) / currentRatio;
      point = line_default.pointAt(from[0], from[1], to2[0], to2[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point;
}
function angleAtSegments(points, t4) {
  if (t4 > 1 || t4 < 0 || points.length < 2) {
    return 0;
  }
  var _a2 = analyzePoints(points), segments = _a2.segments, totalLength = _a2.totalLength;
  var startRatio = 0;
  var angle3 = 0;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var seg = segments[i2];
    var from = seg.from, to2 = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t4 >= startRatio && t4 <= startRatio + currentRatio) {
      angle3 = Math.atan2(to2[1] - from[1], to2[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle3;
}
function distanceAtSegment(points, x2, y2) {
  var minDistance = Infinity;
  for (var i2 = 0; i2 < points.length - 1; i2++) {
    var point = points[i2];
    var nextPoint = points[i2 + 1];
    var distance_1 = line_default.pointDistance(point[0], point[1], nextPoint[0], nextPoint[1], x2, y2);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}

// node_modules/@antv/g-math/esm/polyline.js
var polyline_default = {
  box: function(points) {
    var xArr = [];
    var yArr = [];
    for (var i2 = 0; i2 < points.length; i2++) {
      var point = points[i2];
      xArr.push(point[0]);
      yArr.push(point[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(points) {
    return lengthOfSegment(points);
  },
  pointAt: function(points, t4) {
    return pointAtSegments(points, t4);
  },
  pointDistance: function(points, x2, y2) {
    return distanceAtSegment(points, x2, y2);
  },
  tangentAngle: function(points, t4) {
    return angleAtSegments(points, t4);
  }
};

// node_modules/@antv/g-base/esm/bbox/util.js
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}

// node_modules/@antv/g-base/esm/bbox/polyline.js
function polyline_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  var _a2 = util_exports.getBBoxByArray(xArr, yArr), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/polygon.js
function polygon_default2(shape) {
  var attrs = shape.attr();
  var points = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    xArr.push(point[0]);
    yArr.push(point[1]);
  }
  return util_exports.getBBoxByArray(xArr, yArr);
}

// node_modules/@antv/g-base/esm/util/offscreen.js
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}

// node_modules/@antv/g-base/esm/util/text.js
function getTextHeight(text, fontSize, lineHeight) {
  var lineCount = 1;
  if (is_string_default(text)) {
    lineCount = text.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (is_nil_default(text) || text === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (is_string_default(text) && text.includes("\n")) {
    var textArr = text.split("\n");
    each_default(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}

// node_modules/@antv/g-base/esm/bbox/text.js
function text_default(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, text = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text, font);
  var bbox;
  if (!width) {
    bbox = {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text, fontSize, lineHeight);
    var point = {
      x: x2,
      y: y2 - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point.x -= width;
      } else if (textAlign === "center") {
        point.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point.y += height;
      } else if (textBaseline === "middle") {
        point.y += height / 2;
      }
    }
    bbox = {
      x: point.x,
      y: point.y,
      width,
      height
    };
  }
  return bbox;
}

// node_modules/@antv/path-util/esm/parse-path.js
init_esm();
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p2) {
  var path = p2 || [];
  if (is_array_default(path)) {
    return path;
  }
  if (is_string_default(path)) {
    path = path.match(regexTags);
    each_default(path, function(item, index) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each_default(item, function(sub6, i2) {
        if (!isNaN(sub6)) {
          item[i2] = +sub6;
        }
      });
      path[index] = item;
    });
    return path;
  }
}
var parse_path_default = parsePath;

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/index.js
init_esm2();

// node_modules/@antv/path-util/node_modules/@antv/matrix-util/esm/ext.js
init_esm2();

// node_modules/@antv/path-util/esm/catmull-rom-2-bezier.js
function smoothBezier(points, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min6;
  var max7;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min6 = constraint[0], max7 = constraint[1];
    for (var i2 = 0, l2 = points.length; i2 < l2; i2 += 1) {
      var point = points[i2];
      min6 = vec2_exports.min([0, 0], min6, point);
      max7 = vec2_exports.max([0, 0], max7, point);
    }
  }
  for (var i2 = 0, len5 = points.length; i2 < len5; i2 += 1) {
    var point = points[i2];
    if (i2 === 0 && !isLoop) {
      cp0 = point;
    } else if (i2 === len5 - 1 && !isLoop) {
      cp1 = point;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i2 ? i2 - 1 : len5 - 1, i2 - 1][isLoop ? 0 : 1];
      prevPoint = points[prevIdx];
      nextPoint = points[isLoop ? (i2 + 1) % len5 : i2 + 1];
      var v2 = [0, 0];
      v2 = vec2_exports.sub(v2, nextPoint, prevPoint);
      v2 = vec2_exports.scale(v2, v2, smooth);
      var d0 = vec2_exports.distance(point, prevPoint);
      var d1 = vec2_exports.distance(point, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = vec2_exports.scale([0, 0], v2, -d0);
      var v22 = vec2_exports.scale([0, 0], v2, d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      nextCp0 = vec2_exports.add([0, 0], point, v22);
      nextCp0 = vec2_exports.min([0, 0], nextCp0, vec2_exports.max([0, 0], nextPoint, point));
      nextCp0 = vec2_exports.max([0, 0], nextCp0, vec2_exports.min([0, 0], nextPoint, point));
      v1 = vec2_exports.sub([0, 0], nextCp0, point);
      v1 = vec2_exports.scale([0, 0], v1, -d0 / d1);
      cp1 = vec2_exports.add([0, 0], point, v1);
      cp1 = vec2_exports.min([0, 0], cp1, vec2_exports.max([0, 0], prevPoint, point));
      cp1 = vec2_exports.max([0, 0], cp1, vec2_exports.min([0, 0], prevPoint, point));
      v22 = vec2_exports.sub([0, 0], point, cp1);
      v22 = vec2_exports.scale([0, 0], v22, d1 / d0);
      nextCp0 = vec2_exports.add([0, 0], point, v22);
      if (hasConstraint) {
        cp1 = vec2_exports.max([0, 0], cp1, min6);
        cp1 = vec2_exports.min([0, 0], cp1, max7);
        nextCp0 = vec2_exports.max([0, 0], nextCp0, min6);
        nextCp0 = vec2_exports.min([0, 0], nextCp0, max7);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z2, constraint) {
  if (z2 === void 0) {
    z2 = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z2;
  var pointList = [];
  for (var i2 = 0, l2 = crp.length; i2 < l2; i2 += 2) {
    pointList.push([crp[i2], crp[i2 + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len5 = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p2;
  for (var i2 = 0; i2 < len5 - 1; i2 += 1) {
    cp1 = controlPointList[i2 * 2];
    cp2 = controlPointList[i2 * 2 + 1];
    p2 = pointList[i2 + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len5];
    cp2 = controlPointList[len5 + 1];
    p2 = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
  }
  return d1;
}
var catmull_rom_2_bezier_default = catmullRom2Bezier;

// node_modules/@antv/path-util/esm/fill-path-by-diff.js
init_esm();

// node_modules/@antv/path-util/esm/path-intersection.js
init_esm();

// node_modules/@antv/path-util/esm/parse-path-string.js
init_esm();
var SPACES2 = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029";
var PATH_COMMAND2 = new RegExp("([a-z])[" + SPACES2 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES2 + "]*,?[" + SPACES2 + "]*)+)", "ig");
var PATH_VALUES2 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES2 + "]*,?[" + SPACES2 + "]*", "ig");
function parsePathString2(pathString) {
  if (!pathString) {
    return null;
  }
  if (is_array_default(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data = [];
  String(pathString).replace(PATH_COMMAND2, function(a2, b10, c2) {
    var params = [];
    var name = b10.toLowerCase();
    c2.replace(PATH_VALUES2, function(a3, b11) {
      b11 && params.push(+b11);
    });
    if (name === "m" && params.length > 2) {
      data.push([b10].concat(params.splice(0, 2)));
      name = "l";
      b10 = b10 === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data.push([b10, params[0]]);
    }
    if (name === "r") {
      data.push([b10].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data.push([b10].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data;
}

// node_modules/@antv/path-util/esm/path-2-absolute.js
var REGEX_MD = /[a-z]/;
function toSymmetry(p2, c2) {
  return [
    c2[0] + (c2[0] - p2[0]),
    c2[1] + (c2[1] - p2[1])
  ];
}
function pathToAbsolute2(pathString) {
  var pathArray = parsePathString2(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i2 = 0; i2 < pathArray.length; i2++) {
    var cmd = pathArray[i2][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x2 = 0;
  var y2 = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x2 = +first[1];
    y2 = +first[2];
    mx = x2;
    my = y2;
    start++;
    res[0] = ["M", x2, y2];
  }
  for (var i2 = start, ii2 = pathArray.length; i2 < ii2; i2++) {
    var pa2 = pathArray[i2];
    var preParams = res[i2 - 1];
    var r2 = [];
    var cmd = pa2[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r2[0] = upCmd;
      switch (upCmd) {
        case "A":
          r2[1] = pa2[1];
          r2[2] = pa2[2];
          r2[3] = pa2[3];
          r2[4] = pa2[4];
          r2[5] = pa2[5];
          r2[6] = +pa2[6] + x2;
          r2[7] = +pa2[7] + y2;
          break;
        case "V":
          r2[1] = +pa2[1] + y2;
          break;
        case "H":
          r2[1] = +pa2[1] + x2;
          break;
        case "M":
          mx = +pa2[1] + x2;
          my = +pa2[2] + y2;
          r2[1] = mx;
          r2[2] = my;
          break;
        default:
          for (var j2 = 1, jj = pa2.length; j2 < jj; j2++) {
            r2[j2] = +pa2[j2] + (j2 % 2 ? x2 : y2);
          }
      }
    } else {
      r2 = pathArray[i2];
    }
    switch (upCmd) {
      case "Z":
        x2 = +mx;
        y2 = +my;
        break;
      case "H":
        x2 = r2[1];
        r2 = ["L", x2, y2];
        break;
      case "V":
        y2 = r2[1];
        r2 = ["L", x2, y2];
        break;
      case "T":
        x2 = r2[1];
        y2 = r2[2];
        var symetricT = toSymmetry([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r2 = ["Q", symetricT[0], symetricT[1], x2, y2];
        break;
      case "S":
        x2 = r2[r2.length - 2];
        y2 = r2[r2.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r2 = ["C", symetricS[0], symetricS[1], r2[1], r2[2], x2, y2];
        break;
      case "M":
        mx = r2[r2.length - 2];
        my = r2[r2.length - 1];
        break;
      default:
        x2 = r2[r2.length - 2];
        y2 = r2[r2.length - 1];
    }
    res.push(r2);
  }
  return res;
}

// node_modules/@antv/path-util/esm/process/arc-2-cubic.js
var TAU = Math.PI * 2;

// node_modules/@antv/path-util/esm/get-arc-params.js
init_esm();
function vMag(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio(u2, v2) {
  return vMag(u2) * vMag(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag(u2) * vMag(v2)) : 1;
}
function vAngle(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio(u2, v2));
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u2);
  var dTheta = vAngle(u2, v2);
  if (vRatio(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/path-util/esm/path-2-segments.js
function toSymmetry2(point, center) {
  return [center[0] + (center[0] - point[0]), center[1] + (center[1] - point[1])];
}
function getSegments(path) {
  path = parse_path_default(path);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    nextParams = path[i2 + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i2;
        break;
      case "A":
        var arcParams = getArcParams(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path[lastStartMovePointIndex + 1];
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i2 - 1];
      var cp = toSymmetry2(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i2 - 1];
      var cp1 = toSymmetry2(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d2 = 1e-3;
      var _a2 = segment["arcParams"] || {}, _b = _a2.cx, cx = _b === void 0 ? 0 : _b, _c = _a2.cy, cy = _c === void 0 ? 0 : _c, _d = _a2.rx, rx = _d === void 0 ? 0 : _d, _e2 = _a2.ry, ry = _e2 === void 0 ? 0 : _e2, _f = _a2.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a2.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a2.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d2 *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d2) + cx;
      var dy1 = ry * Math.sin(startAngle - d2) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d2) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d2) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}

// node_modules/@antv/path-util/esm/is-polygons-intersect.js
init_esm();

// node_modules/@antv/g-base/esm/bbox/path.js
init_esm();
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = quadratic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = cubic_default.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = arc_default.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min_default(xArr);
  var minY = min_default(yArr);
  var maxX = max_default(xArr);
  var maxY = max_default(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }
  for (var i2 = 0; i2 < segmentsWithAngle.length; i2++) {
    var segment = segmentsWithAngle[i2];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY = maxY + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path_default(shape) {
  var attrs = shape.attr();
  var path = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path);
  var _a2 = getPathBox(segments, lineWidth), x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x2,
    minY: y2,
    maxX: x2 + width,
    maxY: y2 + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/line.js
function line_default2(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}

// node_modules/@antv/g-base/esm/bbox/ellipse.js
function ellipse_default2(shape) {
  var attrs = shape.attr();
  var x2 = attrs.x, y2 = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x2 - rx,
    y: y2 - ry,
    width: rx * 2,
    height: ry * 2
  };
}

// node_modules/@antv/g-base/esm/bbox/index.js
register("rect", rect_default);
register("image", rect_default);
register("circle", circle_default);
register("marker", circle_default);
register("polyline", polyline_default2);
register("polygon", polygon_default2);
register("text", text_default);
register("path", path_default);
register("line", line_default2);
register("ellipse", ellipse_default2);

// node_modules/@antv/g6-core/es/interface/behavior.js
var G6GraphEvent = function(_super) {
  __extends2(G6GraphEvent2, _super);
  function G6GraphEvent2(type, event) {
    var _this = _super.call(this, type, event) || this;
    _this.item = event.item;
    _this.canvasX = event.canvasX;
    _this.canvasY = event.canvasY;
    _this.wheelDelta = event.wheelDelta;
    _this.detail = event.detail;
    return _this;
  }
  return G6GraphEvent2;
}(graph_event_default);

// node_modules/@antv/g6-core/es/util/base.js
var uniqueId3 = function uniqueId4(type) {
  return "".concat(type, "-").concat(Math.random()).concat(Date.now());
};
var formatPadding = function formatPadding2(padding) {
  if (is_array_default(padding)) {
    switch (padding.length) {
      case 4:
        return padding;
      case 3:
        padding.push(padding[1]);
        return padding;
      case 2:
        return padding.concat(padding);
      case 1:
        return [padding[0], padding[0], padding[0], padding[0]];
      default:
        return [0, 0, 0, 0];
    }
  }
  if (is_number_default(padding)) {
    return [padding, padding, padding, padding];
  } else if (is_string_default(padding)) {
    var intPadding = parseInt(padding, 10);
    return [intPadding, intPadding, intPadding, intPadding];
  }
  return [0, 0, 0, 0];
};
var cloneEvent = function cloneEvent2(e8) {
  var event = new G6GraphEvent(e8.type, e8);
  event.clientX = e8.clientX;
  event.clientY = e8.clientY;
  event.x = e8.x;
  event.y = e8.y;
  event.target = e8.target;
  event.currentTarget = e8.currentTarget;
  event.bubbles = true;
  event.item = e8.item;
  return event;
};
var isViewportChanged = function isViewportChanged2(matrix) {
  if (!matrix) {
    return false;
  }
  var MATRIX_LEN = 9;
  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i2 = 0; i2 < MATRIX_LEN; i2++) {
    if (matrix[i2] !== ORIGIN_MATRIX[i2]) {
      return true;
    }
  }
  return false;
};
var isNaN2 = function isNaN3(input) {
  return Number.isNaN(Number(input));
};
var calculationItemsBBox = function calculationItemsBBox2(items) {
  var minx = Infinity;
  var maxx = -Infinity;
  var miny = Infinity;
  var maxy = -Infinity;
  for (var i2 = 0; i2 < items.length; i2++) {
    var element = items[i2];
    var bbox = element.getBBox();
    var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
    if (minX < minx) {
      minx = minX;
    }
    if (minY < miny) {
      miny = minY;
    }
    if (maxX > maxx) {
      maxx = maxX;
    }
    if (maxY > maxy) {
      maxy = maxY;
    }
  }
  var x2 = Math.floor(minx);
  var y2 = Math.floor(miny);
  var width = Math.ceil(maxx) - Math.floor(minx);
  var height = Math.ceil(maxy) - Math.floor(miny);
  return {
    x: x2,
    y: y2,
    width,
    height,
    minX: minx,
    minY: miny,
    maxX: maxx,
    maxY: maxy
  };
};
var processParallelEdges = function processParallelEdges2(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {
  if (offsetDiff === void 0) {
    offsetDiff = 15;
  }
  if (multiEdgeType === void 0) {
    multiEdgeType = "quadratic";
  }
  if (singleEdgeType === void 0) {
    singleEdgeType = void 0;
  }
  if (loopEdgeType === void 0) {
    loopEdgeType = void 0;
  }
  var len5 = edges.length;
  var cod = offsetDiff * 2;
  var loopPosition = ["top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left"];
  var edgeMap = {};
  var tags = [];
  var reverses = {};
  for (var i2 = 0; i2 < len5; i2++) {
    var edge = edges[i2];
    var source = edge.source, target = edge.target;
    var sourceTarget = "".concat(source, "-").concat(target);
    if (tags[i2])
      continue;
    if (!edgeMap[sourceTarget]) {
      edgeMap[sourceTarget] = [];
    }
    tags[i2] = true;
    edgeMap[sourceTarget].push(edge);
    for (var j2 = 0; j2 < len5; j2++) {
      if (i2 === j2)
        continue;
      var sedge = edges[j2];
      var src = sedge.source;
      var dst = sedge.target;
      if (!tags[j2]) {
        if (source === dst && target === src) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
          reverses["".concat(src, "|").concat(dst, "|").concat(edgeMap[sourceTarget].length - 1)] = true;
        } else if (source === src && target === dst) {
          edgeMap[sourceTarget].push(sedge);
          tags[j2] = true;
        }
      }
    }
  }
  for (var key in edgeMap) {
    var arcEdges = edgeMap[key];
    var length_1 = arcEdges.length;
    for (var k2 = 0; k2 < length_1; k2++) {
      var current = arcEdges[k2];
      if (current.source === current.target) {
        if (loopEdgeType)
          current.type = loopEdgeType;
        current.loopCfg = {
          position: loopPosition[k2 % 8],
          dist: Math.floor(k2 / 8) * 20 + 50
        };
        continue;
      }
      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {
        current.type = singleEdgeType;
        continue;
      }
      current.type = multiEdgeType;
      var sign = (k2 % 2 === 0 ? 1 : -1) * (reverses["".concat(current.source, "|").concat(current.target, "|").concat(k2)] ? -1 : 1);
      if (length_1 % 2 === 1) {
        current.curveOffset = sign * Math.ceil(k2 / 2) * cod;
      } else {
        current.curveOffset = sign * (Math.floor(k2 / 2) * cod + offsetDiff);
      }
    }
  }
  return edges;
};

// node_modules/@antv/g6-core/es/graph/controller/view.js
var ViewController = function() {
  function ViewController2(graph) {
    this.destroyed = false;
    this.graph = graph;
    this.destroyed = false;
  }
  ViewController2.prototype.getViewCenter = function() {
    var padding = this.getFormatPadding();
    var graph = this.graph;
    var width = this.graph.get("width");
    var height = graph.get("height");
    return {
      x: (width - padding[1] - padding[3]) / 2 + padding[3],
      y: (height - padding[0] - padding[2]) / 2 + padding[0]
    };
  };
  ViewController2.prototype.fitCenter = function() {
    var graph = this.graph;
    var group = graph.get("group");
    group.resetMatrix();
    var bbox = group.getCanvasBBox();
    if (bbox.width === 0 || bbox.height === 0)
      return;
    var viewCenter = this.getViewCenter();
    var groupCenter = {
      x: bbox.x + bbox.width / 2,
      y: bbox.y + bbox.height / 2
    };
    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
  };
  ViewController2.prototype.fitView = function() {
    var graph = this.graph;
    var padding = this.getFormatPadding();
    var width = graph.get("width");
    var height = graph.get("height");
    var group = graph.get("group");
    group.resetMatrix();
    var bbox = group.getCanvasBBox();
    if (bbox.width === 0 || bbox.height === 0)
      return;
    var viewCenter = this.getViewCenter();
    var groupCenter = {
      x: bbox.x + bbox.width / 2,
      y: bbox.y + bbox.height / 2
    };
    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
    var w2 = (width - padding[1] - padding[3]) / bbox.width;
    var h2 = (height - padding[0] - padding[2]) / bbox.height;
    var ratio = w2;
    if (w2 > h2) {
      ratio = h2;
    }
    if (!graph.zoom(ratio, viewCenter)) {
      console.warn("zoom failed, ratio out of range, ratio: %f", ratio);
    }
  };
  ViewController2.prototype.fitViewByRules = function(rules) {
    var _a2 = rules.onlyOutOfViewPort, onlyOutOfViewPort = _a2 === void 0 ? false : _a2, _b = rules.direction, direction3 = _b === void 0 ? "both" : _b, _c = rules.ratioRule, ratioRule = _c === void 0 ? "min" : _c;
    var graph = this.graph;
    var padding = this.getFormatPadding();
    var width = graph.get("width");
    var height = graph.get("height");
    var group = graph.get("group");
    group.resetMatrix();
    var bbox = group.getCanvasBBox();
    if (bbox.width === 0 || bbox.height === 0)
      return;
    var viewCenter = this.getViewCenter();
    var groupCenter = {
      x: bbox.x + bbox.width / 2,
      y: bbox.y + bbox.height / 2
    };
    graph.translate(viewCenter.x - groupCenter.x, viewCenter.y - groupCenter.y);
    var wRatio = (width - padding[1] - padding[3]) / bbox.width;
    var hRatio = (height - padding[0] - padding[2]) / bbox.height;
    var ratio;
    if (direction3 === "x") {
      ratio = wRatio;
    } else if (direction3 === "y") {
      ratio = hRatio;
    } else {
      ratio = ratioRule === "max" ? Math.max(wRatio, hRatio) : Math.min(wRatio, hRatio);
    }
    if (onlyOutOfViewPort) {
      ratio = ratio < 1 ? ratio : 1;
    }
    var initZoomRatio = graph.getZoom();
    var endZoom = initZoomRatio * ratio;
    var minZoom = graph.get("minZoom");
    if (endZoom < minZoom) {
      endZoom = minZoom;
      console.warn("fitview failed, ratio out of range, ratio: %f", ratio, "graph minzoom has been used instead");
    }
    graph.zoomTo(endZoom, viewCenter);
  };
  ViewController2.prototype.getFormatPadding = function() {
    var padding = this.graph.get("fitViewPadding");
    return formatPadding(padding);
  };
  ViewController2.prototype.focusPoint = function(point, animate, animateCfg) {
    var _this = this;
    var viewCenter = this.getViewCenter();
    var modelCenter = this.getPointByCanvas(viewCenter.x, viewCenter.y);
    var viewportMatrix = this.graph.get("group").getMatrix();
    if (!viewportMatrix)
      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (animate) {
      var dx_1 = (modelCenter.x - point.x) * viewportMatrix[0];
      var dy_1 = (modelCenter.y - point.y) * viewportMatrix[4];
      var lastX_1 = 0;
      var lastY_1 = 0;
      var newX_1 = 0;
      var newY_1 = 0;
      this.graph.get("canvas").animate(function(ratio) {
        newX_1 = dx_1 * ratio;
        newY_1 = dy_1 * ratio;
        _this.graph.translate(newX_1 - lastX_1, newY_1 - lastY_1);
        lastX_1 = newX_1;
        lastY_1 = newY_1;
      }, __assign2({}, animateCfg));
    } else {
      this.graph.translate((modelCenter.x - point.x) * viewportMatrix[0], (modelCenter.y - point.y) * viewportMatrix[4]);
    }
  };
  ViewController2.prototype.getPointByCanvas = function(canvasX, canvasY) {
    var viewportMatrix = this.graph.get("group").getMatrix();
    if (!viewportMatrix) {
      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    var point = invertMatrix({
      x: canvasX,
      y: canvasY
    }, viewportMatrix);
    return point;
  };
  ViewController2.prototype.getPointByClient = function(clientX, clientY) {
    var canvas = this.graph.get("canvas");
    var canvasPoint = canvas.getPointByClient(clientX, clientY);
    return this.getPointByCanvas(canvasPoint.x, canvasPoint.y);
  };
  ViewController2.prototype.getClientByPoint = function(x2, y2) {
    var canvas = this.graph.get("canvas");
    var canvasPoint = this.getCanvasByPoint(x2, y2);
    var point = canvas.getClientByPoint(canvasPoint.x, canvasPoint.y);
    return {
      x: point.x,
      y: point.y
    };
  };
  ViewController2.prototype.getCanvasByPoint = function(x2, y2) {
    var viewportMatrix = this.graph.get("group").getMatrix();
    if (!viewportMatrix) {
      viewportMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    return applyMatrix({
      x: x2,
      y: y2
    }, viewportMatrix);
  };
  ViewController2.prototype.focus = function(item, animate, animateCfg) {
    if (is_string_default(item)) {
      item = this.graph.findById(item);
    }
    if (item) {
      var x2 = 0, y2 = 0;
      if (item.getType && item.getType() === "edge") {
        var sourceMatrix = item.getSource().get("group").getMatrix();
        var targetMatrix = item.getTarget().get("group").getMatrix();
        if (sourceMatrix && targetMatrix) {
          x2 = (sourceMatrix[6] + targetMatrix[6]) / 2;
          y2 = (sourceMatrix[7] + targetMatrix[7]) / 2;
        } else if (sourceMatrix || targetMatrix) {
          x2 = sourceMatrix ? sourceMatrix[6] : targetMatrix[6];
          y2 = sourceMatrix ? sourceMatrix[7] : targetMatrix[7];
        }
      } else {
        var group = item.get("group");
        var matrix = group.getMatrix();
        if (!matrix)
          matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        x2 = matrix[6];
        y2 = matrix[7];
      }
      this.focusPoint({
        x: x2,
        y: y2
      }, animate, animateCfg);
    }
  };
  ViewController2.prototype.changeSize = function(width, height) {
    var graph = this.graph;
    if (!is_number_default(width) || !is_number_default(height)) {
      throw Error("invalid canvas width & height, please make sure width & height type is number");
    }
    graph.set({
      width,
      height
    });
    var canvas = graph.get("canvas");
    canvas.changeSize(width, height);
    var plugins = graph.get("plugins");
    plugins.forEach(function(plugin) {
      if (plugin.get("gridContainer")) {
        plugin.positionInit();
      }
    });
  };
  ViewController2.prototype.destroy = function() {
    this.graph = null;
    this.destroyed = false;
  };
  return ViewController2;
}();
var view_default = ViewController;

// node_modules/@antv/g6-core/es/graph/controller/item.js
init_esm();

// node_modules/@antv/g6-core/es/item/edge.js
init_esm();

// node_modules/@antv/g6-core/es/item/item.js
init_esm();

// node_modules/@antv/g6-core/es/element/shape.js
init_esm();

// node_modules/@antv/g6-core/es/element/xml.js
init_esm();
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
function looseJSONParse(text) {
  if (typeof text !== "string") {
    return text;
  }
  var safeParse = function safeParse2(str8) {
    if (typeof str8 !== "string") {
      return str8;
    }
    try {
      return JSON.parse(str8.trim());
    } catch (e8) {
      return str8.trim();
    }
  };
  var firstAttempt = safeParse(text);
  if (typeof firstAttempt !== "string") {
    return firstAttempt;
  }
  var tail = function tail2(arr) {
    return arr[arr.length - 1];
  };
  var str7 = text.trim();
  var objectStack = [];
  var syntaxStack = [];
  var isLastPair = function isLastPair2() {
    var syntaxes = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      syntaxes[_i2] = arguments[_i2];
    }
    return syntaxes.some(function(syntax) {
      return tail(syntaxStack) === syntax;
    });
  };
  var getValueStore = function getValueStore2() {
    return tail(objectStack);
  };
  var rst = null;
  var i2 = 0;
  var temp = "";
  while (i2 < str7.length) {
    var nowChar = str7[i2];
    var isInString = isLastPair('"', "'");
    if (!isInString && !nowChar.trim()) {
      i2 += 1;
      continue;
    }
    var isLastTranslate = str7[i2 - 1] === "\\";
    var isInObject = isLastPair("}");
    var isInArray = isLastPair("]");
    var isWaitingValue = isLastPair(",");
    var tempArr = getValueStore();
    if (isInString) {
      if (tail(syntaxStack) === nowChar && !isLastTranslate) {
        syntaxStack.pop();
        var value = safeParse(temp);
        tempArr.push(value);
        rst = value;
        temp = "";
      } else {
        temp += nowChar;
      }
    } else if (isInArray && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
    } else if (isInObject && nowChar === ":") {
      syntaxStack.push(",");
      if (temp) {
        tempArr.push(temp);
        temp = "";
      }
    } else if (isWaitingValue && nowChar === ",") {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      syntaxStack.pop();
    } else if (nowChar === "}" && (isInObject || isWaitingValue)) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      if (isWaitingValue) {
        syntaxStack.pop();
      }
      var obj = {};
      for (var c2 = 1; c2 < tempArr.length; c2 += 2) {
        obj[tempArr[c2 - 1]] = tempArr[c2];
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(obj);
      }
      syntaxStack.pop();
      rst = obj;
    } else if (nowChar === "]" && isInArray) {
      if (temp) {
        tempArr.push(safeParse(temp));
        temp = "";
      }
      objectStack.pop();
      if (objectStack.length) {
        tail(objectStack).push(tempArr);
      }
      syntaxStack.pop();
      rst = tempArr;
    } else if (nowChar === "{") {
      objectStack.push([]);
      syntaxStack.push("}");
    } else if (nowChar === "[") {
      objectStack.push([]);
      syntaxStack.push("]");
    } else if (nowChar === '"') {
      syntaxStack.push('"');
    } else if (nowChar === "'") {
      syntaxStack.push("'");
    } else {
      temp += nowChar;
    }
    i2 += 1;
  }
  return rst || temp;
}
var keyConvert = function keyConvert2(str7) {
  return str7.split("-").reduce(function(a2, b10) {
    return a2 + b10.charAt(0).toUpperCase() + b10.slice(1);
  });
};
var xmlDataRenderer = function xmlDataRenderer2(xml) {
  return function(data) {
    var len5 = xml.length;
    var arr = [];
    var i2 = 0;
    var tmp = "";
    while (i2 < len5) {
      if (xml[i2] === "{" && xml[i2 + 1] === "{") {
        arr.push(tmp);
        tmp = "";
        i2 += 2;
      } else if (xml[i2] === "}" && xml[i2 + 1] === "}") {
        if (arr.length) {
          var last2 = arr.pop();
          tmp = get_default(data, tmp, last2.endsWith("=") ? '"{'.concat(tmp, '}"') : tmp);
          arr.push(last2 + tmp);
        }
        i2 += 2;
        tmp = "";
      } else {
        tmp += xml[i2];
        i2 += 1;
      }
    }
    arr.push(tmp);
    return arr.map(function(e8, index) {
      return arr[index - 1] && arr[index - 1].endsWith("=") ? '"{'.concat(e8, '}"') : e8;
    }).join("");
  };
};
function parseXML(xml, cfg) {
  var attrs = {};
  var keys2 = xml.getAttributeNames && xml.getAttributeNames() || [];
  var children = xml.children && Array.from(xml.children).map(function(e8) {
    return parseXML(e8, cfg);
  });
  var rst = {};
  var tagName = xml.tagName ? xml.tagName.toLowerCase() : "group";
  if (tagName === "text") {
    attrs.text = xml.innerText;
  }
  rst.type = tagName;
  if (tagName === "img") {
    rst.type = "image";
  }
  Array.from(keys2).forEach(function(k2) {
    var key = keyConvert(k2);
    var val = xml.getAttribute(k2);
    try {
      if (key === "style" || key === "attrs") {
        var style = looseJSONParse(val);
        attrs = __assign2(__assign2({}, attrs), style);
      } else {
        rst[key] = looseJSONParse(val);
      }
    } catch (e8) {
      if (key === "style") {
        throw e8;
      }
      rst[key] = val;
    }
  });
  rst.attrs = attrs;
  if (cfg && cfg.style && rst.name && _typeof2(cfg.style[rst.name]) === "object") {
    rst.attrs = __assign2(__assign2({}, rst.attrs), cfg.style[rst.name]);
  }
  if (cfg && cfg.style && rst.keyshape) {
    rst.attrs = __assign2(__assign2({}, rst.attrs), cfg.style);
  }
  if (children.length) {
    rst.children = children;
  }
  return rst;
}
function getBBox3(node, offset, chilrenBBox) {
  var _a2 = node.attrs, attrs = _a2 === void 0 ? {} : _a2;
  var bbox = {
    x: offset.x || 0,
    y: offset.y || 0,
    width: chilrenBBox.width || 0,
    height: chilrenBBox.height || 0
  };
  var shapeHeight, shapeWidth;
  switch (node.type) {
    case "maker":
    case "circle":
      if (attrs.r) {
        shapeWidth = 2 * attrs.r;
        shapeHeight = 2 * attrs.r;
      }
      break;
    case "text":
      if (attrs.text) {
        shapeWidth = getTextSize(attrs.text, attrs.fontSize || 12)[0];
        shapeHeight = 16;
        bbox.y += shapeHeight;
        bbox.height = shapeHeight;
        bbox.width = shapeWidth;
        node.attrs = __assign2({
          fontSize: 12,
          fill: "#000"
        }, attrs);
      }
      break;
    default:
      if (attrs.width) {
        shapeWidth = attrs.width;
      }
      if (attrs.height) {
        shapeHeight = attrs.height;
      }
  }
  if (shapeHeight >= 0) {
    bbox.height = shapeHeight;
  }
  if (shapeWidth >= 0) {
    bbox.width = shapeWidth;
  }
  if (attrs.marginTop) {
    bbox.y += attrs.marginTop;
  }
  if (attrs.marginLeft) {
    bbox.x += attrs.marginLeft;
  }
  return bbox;
}
function generateTarget(target, lastOffset) {
  var _a2;
  if (lastOffset === void 0) {
    lastOffset = {
      x: 0,
      y: 0
    };
  }
  var defaultBbox = __assign2({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  }, lastOffset);
  if ((_a2 = target.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
    var _b = target.attrs, attrs = _b === void 0 ? {} : _b;
    var marginTop = attrs.marginTop;
    var offset = __assign2({}, lastOffset);
    if (marginTop) {
      offset.y += marginTop;
    }
    for (var index = 0; index < target.children.length; index++) {
      target.children[index].attrs.key = "".concat(attrs.key || "root", " -").concat(index, " ");
      var node = generateTarget(target.children[index], offset);
      if (node.bbox) {
        var bbox = node.bbox;
        if (node.attrs.next === "inline") {
          offset.x += node.bbox.width;
        } else {
          offset.y += node.bbox.height;
        }
        if (bbox.width + bbox.x > defaultBbox.width) {
          defaultBbox.width = bbox.width + bbox.x;
        }
        if (bbox.height + bbox.y > defaultBbox.height) {
          defaultBbox.height = bbox.height + bbox.y;
        }
      }
    }
  }
  target.bbox = getBBox3(target, lastOffset, defaultBbox);
  target.attrs = __assign2(__assign2({}, target.attrs), target.bbox);
  return target;
}
function compareTwoTarget(nowTarget, formerTarget) {
  var _a2, _b, _c, _d;
  var type = (nowTarget || {}).type;
  var key = ((formerTarget === null || formerTarget === void 0 ? void 0 : formerTarget.attrs) || {}).key;
  if (key && nowTarget) {
    nowTarget.attrs.key = key;
  }
  if (!nowTarget && formerTarget) {
    return {
      action: "delete",
      val: formerTarget,
      type,
      key
    };
  }
  if (nowTarget && !formerTarget) {
    return {
      action: "add",
      val: nowTarget,
      type
    };
  }
  if (!nowTarget && !formerTarget) {
    return {
      action: "same",
      type
    };
  }
  var children = [];
  if (((_a2 = nowTarget.children) === null || _a2 === void 0 ? void 0 : _a2.length) > 0 || ((_b = formerTarget.children) === null || _b === void 0 ? void 0 : _b.length) > 0) {
    var length_1 = Math.max((_c = nowTarget.children) === null || _c === void 0 ? void 0 : _c.length, (_d = formerTarget.children) === null || _d === void 0 ? void 0 : _d.length);
    var formerChilren = formerTarget.children || [];
    var nowChilren = nowTarget.children || [];
    for (var index = 0; index < length_1; index += 1) {
      children.push(compareTwoTarget(nowChilren[index], formerChilren[index]));
    }
  }
  var formerKeys = Object.keys(formerTarget.attrs);
  var nowKeys = Object.keys(nowTarget.attrs);
  if (formerTarget.type !== nowTarget.type) {
    return {
      action: "restructure",
      nowTarget,
      formerTarget,
      key,
      children
    };
  }
  if (formerKeys.filter(function(e8) {
    return e8 !== "children";
  }).some(function(e8) {
    return nowTarget.attrs[e8] !== formerTarget.attrs[e8] || !nowKeys.includes(e8);
  })) {
    return {
      action: "change",
      val: nowTarget,
      children,
      type,
      key
    };
  }
  return {
    action: "same",
    children,
    type,
    key
  };
}
function createNodeFromXML(gen) {
  var structures = {};
  var compileXML = function compileXML2(cfg) {
    var rawStr = typeof gen === "function" ? gen(cfg) : gen;
    var target = xmlDataRenderer(rawStr)(cfg);
    var xmlParser = document.createElement("div");
    xmlParser.innerHTML = target;
    var xml = xmlParser.children[0];
    var result = generateTarget(parseXML(xml, cfg));
    xmlParser.remove();
    return result;
  };
  return {
    draw: function draw4(cfg, group) {
      var resultTarget = compileXML(cfg);
      var keyshape = group;
      var renderTarget = function renderTarget2(target) {
        var _a2 = target.attrs, attrs = _a2 === void 0 ? {} : _a2, bbox = target.bbox, type = target.type, children = target.children, rest = __rest2(target, ["attrs", "bbox", "type", "children"]);
        if (target.type !== "group") {
          var shape = group.addShape(target.type, __assign2({
            attrs,
            origin: {
              bbox,
              type,
              children
            }
          }, rest));
          if (target.keyshape) {
            keyshape = shape;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return renderTarget2(n2);
          });
        }
      };
      renderTarget(resultTarget);
      structures[cfg.id] = [resultTarget];
      return keyshape;
    },
    update: function update15(cfg, node) {
      if (!structures[cfg.id]) {
        structures[cfg.id] = [];
      }
      var container2 = node.getContainer();
      var children = container2.get("children");
      var newTarget = compileXML(cfg);
      var lastTarget = structures[cfg.id].pop();
      var diffResult = compareTwoTarget(newTarget, lastTarget);
      var addShape = function addShape2(shape) {
        var _a2;
        if (shape.type !== "group") {
          container2.addShape(shape.type, {
            attrs: shape.attrs
          });
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return addShape2(e8);
          });
        }
      };
      var delShape = function delShape2(shape) {
        var _a2;
        var targetShape = children.find(function(e8) {
          return e8.attrs.key === shape.attrs.key;
        });
        if (targetShape) {
          container2.removeChild(targetShape);
        }
        if ((_a2 = shape.children) === null || _a2 === void 0 ? void 0 : _a2.length) {
          shape.children.map(function(e8) {
            return delShape2(e8);
          });
        }
      };
      var updateTarget = function updateTarget2(target) {
        var key = target.key;
        if (target.type !== "group") {
          var targetShape = children.find(function(e8) {
            return e8.attrs.key === key;
          });
          switch (target.action) {
            case "change":
              if (targetShape) {
                var originAttr = target.val.keyshape ? node.getOriginStyle() : {};
                targetShape.attr(__assign2(__assign2({}, originAttr), target.val.attrs));
              }
              break;
            case "add":
              addShape(target.val);
              break;
            case "delete":
              delShape(target.val);
              break;
            case "restructure":
              delShape(target.formerTarget);
              addShape(target.nowTarget);
              break;
            default:
              break;
          }
        }
        if (target.children) {
          target.children.forEach(function(n2) {
            return updateTarget2(n2);
          });
        }
      };
      updateTarget(diffResult);
      structures[cfg.id].push(newTarget);
    },
    getAnchorPoints: function getAnchorPoints4() {
      return [[0, 0.5], [1, 0.5], [0.5, 1], [0.5, 0]];
    }
  };
}

// node_modules/@antv/g6-core/es/element/shape.js
var cache2 = {};
function ucfirst(str7) {
  if (!cache2[str7]) {
    cache2[str7] = upper_first_default(str7);
  }
  return cache2[str7];
}
var ShapeFactoryBase = {
  defaultShapeType: "defaultType",
  className: null,
  getShape: function getShape(type) {
    var self2 = this;
    var shape = self2[type] || self2[self2.defaultShapeType] || self2["simple-circle"];
    return shape;
  },
  draw: function draw(type, cfg, group) {
    var shape = this.getShape(type);
    group["shapeMap"] = {};
    var rst = shape.draw(cfg, group);
    if (shape.afterDraw) {
      shape.afterDraw(cfg, group, rst);
    }
    return rst;
  },
  baseUpdate: function baseUpdate(type, cfg, item, updateType) {
    var _a2, _b;
    var shape = this.getShape(type);
    if (shape.update) {
      shape.mergeStyle = (_a2 = shape.getOptions) === null || _a2 === void 0 ? void 0 : _a2.call(shape, cfg, updateType);
      (_b = shape.update) === null || _b === void 0 ? void 0 : _b.call(shape, cfg, item, updateType);
    }
    if (shape.afterUpdate) {
      shape.afterUpdate(cfg, item);
    }
  },
  setState: function setState(type, name, value, item) {
    var shape = this.getShape(type);
    shape.setState(name, value, item);
  },
  shouldUpdate: function shouldUpdate2(type) {
    var shape = this.getShape(type);
    return !!shape.update;
  },
  getControlPoints: function getControlPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getControlPoints(cfg);
  },
  getAnchorPoints: function getAnchorPoints(type, cfg) {
    var shape = this.getShape(type);
    return shape.getAnchorPoints(cfg);
  }
};
var ShapeFramework = {
  options: {},
  draw: function draw2(cfg, group) {
    return this.drawShape(cfg, group);
  },
  drawShape: function drawShape() {
  },
  afterDraw: function afterDraw() {
  },
  afterUpdate: function afterUpdate() {
  },
  setState: function setState2() {
  },
  getControlPoints: function getControlPoints2(cfg) {
    return cfg.controlPoints;
  },
  getAnchorPoints: function getAnchorPoints2(cfg) {
    var defaultAnchorPoints = this.options.anchorPoints;
    var anchorPoints = cfg.anchorPoints || defaultAnchorPoints;
    return anchorPoints;
  }
};
var Shape = function() {
  function Shape2() {
  }
  Shape2.registerFactory = function(factoryType, cfg) {
    var className = ucfirst(factoryType);
    var factoryBase = ShapeFactoryBase;
    var shapeFactory = __assign2(__assign2({}, factoryBase), cfg);
    Shape2[className] = shapeFactory;
    shapeFactory.className = className;
    return shapeFactory;
  };
  Shape2.getFactory = function(factoryType) {
    var className = ucfirst(factoryType);
    return Shape2[className];
  };
  Shape2.registerNode = function(shapeType, nodeDefinition, extendShapeType) {
    var shapeFactory = Shape2.Node;
    var shapeObj;
    if (typeof nodeDefinition === "string" || typeof nodeDefinition === "function") {
      var autoNodeDefinition = createNodeFromXML(nodeDefinition);
      shapeObj = __assign2(__assign2({}, shapeFactory.getShape("single-node")), autoNodeDefinition);
    } else if (nodeDefinition.jsx) {
      var jsx = nodeDefinition.jsx;
      var autoNodeDefinition = createNodeFromXML(jsx);
      shapeObj = __assign2(__assign2(__assign2({}, shapeFactory.getShape("single-node")), autoNodeDefinition), nodeDefinition);
    } else {
      shapeFactory.getShape(extendShapeType);
      var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
      shapeObj = __assign2(__assign2({}, extendShape), nodeDefinition);
    }
    shapeObj.type = shapeType;
    shapeObj.itemType = "node";
    shapeFactory[shapeType] = shapeObj;
    return shapeObj;
  };
  Shape2.registerEdge = function(shapeType, edgeDefinition, extendShapeType) {
    var shapeFactory = Shape2.Edge;
    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
    var shapeObj = __assign2(__assign2({}, extendShape), edgeDefinition);
    shapeObj.type = shapeType;
    shapeObj.itemType = "edge";
    shapeFactory[shapeType] = shapeObj;
    return shapeObj;
  };
  Shape2.registerCombo = function(shapeType, comboDefinition, extendShapeType) {
    var shapeFactory = Shape2.Combo;
    var extendShape = extendShapeType ? shapeFactory.getShape(extendShapeType) : ShapeFramework;
    var shapeObj = __assign2(__assign2({}, extendShape), comboDefinition);
    shapeObj.type = shapeType;
    shapeObj.itemType = "combo";
    shapeFactory[shapeType] = shapeObj;
    return shapeObj;
  };
  return Shape2;
}();
var shape_default2 = Shape;
Shape.registerFactory("node", {
  defaultShapeType: "circle"
});
Shape.registerFactory("edge", {
  defaultShapeType: "line"
});
Shape.registerFactory("combo", {
  defaultShapeType: "circle"
});

// node_modules/@antv/g6-core/es/item/item.js
var CACHE_BBOX = "bboxCache";
var CACHE_CANVAS_BBOX = "bboxCanvasCache";
var ItemBase = function() {
  function ItemBase2(cfg) {
    this._cfg = {};
    this.destroyed = false;
    var defaultCfg2 = {
      id: void 0,
      type: "item",
      model: {},
      group: void 0,
      animate: false,
      visible: true,
      locked: false,
      event: true,
      keyShape: void 0,
      states: []
    };
    this._cfg = Object.assign(defaultCfg2, this.getDefaultCfg(), cfg);
    var model = this.get("model");
    var id2 = model.id;
    var itemType = this.get("type");
    if (!id2) {
      id2 = uniqueId3(itemType);
      this.get("model").id = id2;
    }
    this.set("id", id2);
    var group = cfg.group;
    if (group) {
      group.set("item", this);
      group.set("id", id2);
    }
    this.init();
    this.draw();
    var shapeType = model.shape || model.type || (itemType === "edge" ? "line" : "circle");
    var shapeFactory = this.get("shapeFactory");
    if (shapeFactory && shapeFactory[shapeType]) {
      var options = shapeFactory[shapeType].options;
      if (options && options.stateStyles) {
        var styles = this.get("styles") || model.stateStyles;
        styles = deep_mix_default({}, options.stateStyles, styles);
        this.set("styles", styles);
      }
    }
  }
  ItemBase2.prototype.calculateBBox = function() {
    var keyShape = this.get("keyShape");
    var group = this.get("group");
    var bbox = getBBox(keyShape, group);
    bbox.x = bbox.minX;
    bbox.y = bbox.minY;
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    bbox.centerX = (bbox.minX + bbox.maxX) / 2;
    bbox.centerY = (bbox.minY + bbox.maxY) / 2;
    return bbox;
  };
  ItemBase2.prototype.calculateCanvasBBox = function() {
    var keyShape = this.get("keyShape");
    var group = this.get("group");
    var bbox = getBBox(keyShape, group);
    bbox.x = bbox.minX;
    bbox.y = bbox.minY;
    bbox.width = bbox.maxX - bbox.minX;
    bbox.height = bbox.maxY - bbox.minY;
    bbox.centerX = (bbox.minX + bbox.maxX) / 2;
    bbox.centerY = (bbox.minY + bbox.maxY) / 2;
    return bbox;
  };
  ItemBase2.prototype.drawInner = function() {
    var self2 = this;
    var shapeFactory = self2.get("shapeFactory");
    var group = self2.get("group");
    var model = self2.get("model");
    group.clear();
    var visible = model.visible;
    if (visible !== void 0 && !visible)
      self2.changeVisibility(visible);
    if (!shapeFactory) {
      return;
    }
    self2.updatePosition(model);
    var cfg = self2.getShapeCfg(model);
    var shapeType = cfg.type;
    var keyShape = shapeFactory.draw(shapeType, cfg, group);
    if (keyShape) {
      self2.set("keyShape", keyShape);
      keyShape.set("isKeyShape", true);
      keyShape.set("draggable", true);
    }
    this.setOriginStyle();
    this.set("currentShape", shapeType);
    this.restoreStates(shapeFactory, shapeType);
  };
  ItemBase2.prototype.setOriginStyle = function() {
    var group = this.get("group");
    var children = group.get("children");
    var keyShape = this.getKeyShape();
    var self2 = this;
    var keyShapeName = keyShape.get("name");
    if (!this.get("originStyle")) {
      var originStyles = {};
      for (var i2 = 0; i2 < children.length; i2++) {
        var child = children[i2];
        var shapeType = child.get("type");
        var name_1 = child.get("name");
        if (name_1 && name_1 !== keyShapeName) {
          originStyles[name_1] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
          if (shapeType === "text" && originStyles[name_1]) {
            delete originStyles[name_1].x;
            delete originStyles[name_1].y;
            delete originStyles[name_1].matrix;
          }
        } else {
          var keyShapeStyle = self2.getShapeStyleByName();
          delete keyShapeStyle.path;
          delete keyShapeStyle.matrix;
          if (!keyShapeName) {
            Object.assign(originStyles, keyShapeStyle);
          } else {
            if (!name_1) {
              var shapeName = uniqueId3("shape");
              child.set("name", shapeName);
              group["shapeMap"][shapeName] = child;
              originStyles[shapeName] = shapeType !== "image" ? clone_default(child.attr()) : self2.getShapeStyleByName(name_1);
            } else {
              originStyles[keyShapeName] = keyShapeStyle;
            }
          }
        }
      }
      self2.set("originStyle", originStyles);
    } else {
      var styles_1 = this.get("originStyle");
      if (keyShapeName && !styles_1[keyShapeName])
        styles_1[keyShapeName] = {};
      var currentStatesStyle_1 = this.getCurrentStatesStyle();
      var _loop_1 = function _loop_12(i3) {
        var child2 = children[i3];
        var name_2 = child2.get("name");
        var shapeAttrs = child2.attr();
        if (name_2 && name_2 !== keyShapeName) {
          var shapeStateStyle_1 = currentStatesStyle_1[name_2];
          if (!styles_1[name_2])
            styles_1[name_2] = {};
          if (shapeStateStyle_1) {
            Object.keys(shapeAttrs).forEach(function(key) {
              var value = shapeAttrs[key];
              if (value !== shapeStateStyle_1[key])
                styles_1[name_2][key] = value;
            });
          } else {
            styles_1[name_2] = child2.get("type") !== "image" ? clone_default(shapeAttrs) : self2.getShapeStyleByName(name_2);
          }
        } else {
          var shapeAttrs_1 = child2.attr();
          var keyShapeStateStyles_1 = {};
          Object.keys(currentStatesStyle_1).forEach(function(styleKey) {
            var subStyle = currentStatesStyle_1[styleKey];
            if (styleKey === keyShapeName || !is_plain_object_default(subStyle)) {
              keyShapeStateStyles_1[styleKey] = subStyle;
            }
          });
          Object.keys(shapeAttrs_1).forEach(function(key) {
            var value = shapeAttrs_1[key];
            if (keyShapeStateStyles_1[key] !== value) {
              if (keyShapeName)
                styles_1[keyShapeName][key] = value;
              else
                styles_1[key] = value;
            }
          });
        }
      };
      for (var i2 = 0; i2 < children.length; i2++) {
        _loop_1(i2);
      }
      delete styles_1.path;
      delete styles_1.matrix;
      delete styles_1.x;
      delete styles_1.y;
      if (styles_1[keyShapeName]) {
        delete styles_1[keyShapeName].x;
        delete styles_1[keyShapeName].y;
        delete styles_1[keyShapeName].matrix;
        delete styles_1[keyShapeName].path;
      }
      self2.set("originStyle", styles_1);
    }
  };
  ItemBase2.prototype.restoreStates = function(shapeFactory, shapeType) {
    var self2 = this;
    var states = self2.get("states");
    each_default(states, function(state) {
      shapeFactory.setState(shapeType, state, true, self2);
    });
  };
  ItemBase2.prototype.init = function() {
    var shapeFactory = shape_default2.getFactory(this.get("type"));
    this.set("shapeFactory", shapeFactory);
  };
  ItemBase2.prototype.get = function(key) {
    return this._cfg[key];
  };
  ItemBase2.prototype.set = function(key, val) {
    if (is_plain_object_default(key)) {
      this._cfg = __assign2(__assign2({}, this._cfg), key);
    } else {
      this._cfg[key] = val;
    }
  };
  ItemBase2.prototype.getDefaultCfg = function() {
    return {};
  };
  ItemBase2.prototype.clearCache = function() {
    this.set(CACHE_BBOX, null);
    this.set(CACHE_CANVAS_BBOX, null);
  };
  ItemBase2.prototype.beforeDraw = function() {
  };
  ItemBase2.prototype.afterDraw = function() {
  };
  ItemBase2.prototype.afterUpdate = function() {
  };
  ItemBase2.prototype.draw = function() {
    this.beforeDraw();
    this.drawInner();
    this.afterDraw();
  };
  ItemBase2.prototype.getShapeStyleByName = function(name) {
    var group = this.get("group");
    var currentShape;
    if (name) {
      currentShape = group["shapeMap"][name];
    } else {
      currentShape = this.getKeyShape();
    }
    if (currentShape) {
      var styles_2 = {};
      each_default(currentShape.attr(), function(val, key) {
        if (key !== "img" || is_string_default(val)) {
          styles_2[key] = val;
        }
      });
      return styles_2;
    }
    return {};
  };
  ItemBase2.prototype.getShapeCfg = function(model, updateType) {
    var styles = this.get("styles");
    if (styles) {
      var newModel = model;
      newModel.style = __assign2(__assign2({}, styles), model.style);
      return newModel;
    }
    return model;
  };
  ItemBase2.prototype.getStateStyle = function(state) {
    var styles = this.get("styles");
    var stateStyle = styles && styles[state];
    return stateStyle;
  };
  ItemBase2.prototype.getOriginStyle = function() {
    return this.get("originStyle");
  };
  ItemBase2.prototype.getCurrentStatesStyle = function() {
    var self2 = this;
    var styles = {};
    var states = self2.getStates();
    if (!states || !states.length) {
      return this.get("originStyle");
    }
    each_default(self2.getStates(), function(state) {
      styles = Object.assign(styles, self2.getStateStyle(state));
    });
    return styles;
  };
  ItemBase2.prototype.setState = function(state, value) {
    var states = this.get("states");
    var shapeFactory = this.get("shapeFactory");
    var stateName = state;
    var filterStateName = state;
    if (is_string_default(value)) {
      stateName = "".concat(state, ":").concat(value);
      filterStateName = "".concat(state, ":");
    }
    var newStates = states;
    if (is_boolean_default(value)) {
      var index = states.indexOf(filterStateName);
      if (value) {
        if (index > -1) {
          return;
        }
        states.push(stateName);
      } else if (index > -1) {
        states.splice(index, 1);
      }
    } else if (is_string_default(value)) {
      var filterStates = states.filter(function(name) {
        return name.includes(filterStateName);
      });
      if (filterStates.length > 0) {
        this.clearStates(filterStates);
      }
      newStates = newStates.filter(function(name) {
        return !name.includes(filterStateName);
      });
      newStates.push(stateName);
      this.set("states", newStates);
    }
    if (shapeFactory) {
      var model = this.get("model");
      var type = model.type;
      shapeFactory.setState(type, state, value, this);
    }
  };
  ItemBase2.prototype.clearStates = function(states) {
    var self2 = this;
    var originStates = self2.getStates();
    var shapeFactory = self2.get("shapeFactory");
    var model = self2.get("model");
    var shape = model.type;
    if (!states) {
      states = originStates;
    }
    if (is_string_default(states)) {
      states = [states];
    }
    var newStates = originStates.filter(function(state) {
      return states.indexOf(state) === -1;
    });
    self2.set("states", newStates);
    states.forEach(function(state) {
      shapeFactory.setState(shape, state, false, self2);
    });
  };
  ItemBase2.prototype.getContainer = function() {
    return this.get("group");
  };
  ItemBase2.prototype.getKeyShape = function() {
    return this.get("keyShape");
  };
  ItemBase2.prototype.getModel = function() {
    return this.get("model");
  };
  ItemBase2.prototype.getType = function() {
    return this.get("type");
  };
  ItemBase2.prototype.getID = function() {
    return this.get("id");
  };
  ItemBase2.prototype.isItem = function() {
    return true;
  };
  ItemBase2.prototype.getStates = function() {
    return this.get("states");
  };
  ItemBase2.prototype.hasState = function(state) {
    var states = this.getStates();
    return states.indexOf(state) >= 0;
  };
  ItemBase2.prototype.refresh = function(updateType) {
    var model = this.get("model");
    this.updatePosition(model);
    this.updateShape(updateType);
    this.afterUpdate();
    this.clearCache();
  };
  ItemBase2.prototype.getUpdateType = function(cfg) {
    return void 0;
  };
  ItemBase2.prototype.update = function(cfg, updateType) {
    if (updateType === void 0) {
      updateType = void 0;
    }
    var model = this.get("model");
    if (updateType === "move") {
      this.updatePosition(cfg);
    } else {
      var oriVisible = model.visible;
      var cfgVisible = cfg.visible;
      if (oriVisible !== cfgVisible && cfgVisible !== void 0)
        this.changeVisibility(cfgVisible);
      var originPosition = {
        x: model.x,
        y: model.y
      };
      cfg.x = isNaN(+cfg.x) ? model.x : +cfg.x;
      cfg.y = isNaN(+cfg.y) ? model.y : +cfg.y;
      var styles = this.get("styles");
      if (cfg.stateStyles) {
        var stateStyles = cfg.stateStyles;
        mix(styles, stateStyles);
        delete cfg.stateStyles;
      }
      Object.assign(model, cfg);
      if (originPosition.x !== cfg.x || originPosition.y !== cfg.y) {
        this.updatePosition(cfg);
      }
      this.updateShape(updateType);
    }
    this.afterUpdate();
    this.clearCache();
  };
  ItemBase2.prototype.updateShape = function(updateType) {
    var shapeFactory = this.get("shapeFactory");
    var model = this.get("model");
    var shape = model.type;
    if (shapeFactory.shouldUpdate(shape) && shape === this.get("currentShape")) {
      var updateCfg2 = this.getShapeCfg(model, updateType);
      shapeFactory.baseUpdate(shape, updateCfg2, this, updateType);
      if (updateType !== "move")
        this.setOriginStyle();
    } else {
      this.draw();
    }
    this.restoreStates(shapeFactory, shape);
  };
  ItemBase2.prototype.updatePosition = function(cfg) {
    var model = this.get("model");
    var x2 = isNaN(+cfg.x) ? +model.x : +cfg.x;
    var y2 = isNaN(+cfg.y) ? +model.y : +cfg.y;
    var group = this.get("group");
    if (isNaN(x2) || isNaN(y2)) {
      return false;
    }
    model.x = x2;
    model.y = y2;
    var matrix = group.getMatrix();
    if (matrix && matrix[6] === x2 && matrix[7] === y2)
      return false;
    group.resetMatrix();
    translate3(group, {
      x: x2,
      y: y2
    });
    this.clearCache();
    return true;
  };
  ItemBase2.prototype.getBBox = function() {
    var bbox = this.get(CACHE_BBOX);
    if (!bbox) {
      bbox = this.calculateBBox();
      this.set(CACHE_BBOX, bbox);
    }
    return bbox;
  };
  ItemBase2.prototype.getCanvasBBox = function() {
    var bbox = this.get(CACHE_CANVAS_BBOX);
    if (!bbox) {
      bbox = this.calculateCanvasBBox();
      this.set(CACHE_CANVAS_BBOX, bbox);
    }
    return bbox;
  };
  ItemBase2.prototype.toFront = function() {
    var group = this.get("group");
    group.toFront();
  };
  ItemBase2.prototype.toBack = function() {
    var group = this.get("group");
    group.toBack();
  };
  ItemBase2.prototype.show = function() {
    this.changeVisibility(true);
  };
  ItemBase2.prototype.hide = function() {
    this.changeVisibility(false);
  };
  ItemBase2.prototype.changeVisibility = function(visible) {
    var group = this.get("group");
    if (visible) {
      group.show();
    } else {
      group.hide();
    }
    this.set("visible", visible);
  };
  ItemBase2.prototype.isVisible = function() {
    return this.get("visible");
  };
  ItemBase2.prototype.enableCapture = function(enable) {
    var group = this.get("group");
    if (group) {
      group.set("capture", enable);
    }
  };
  ItemBase2.prototype.destroy = function() {
    if (!this.destroyed) {
      var animate = this.get("animate");
      var group = this.get("group");
      if (animate) {
        group.stopAnimate();
      }
      group["shapeMap"] = {};
      this.clearCache();
      group.remove();
      this._cfg = null;
      this.destroyed = true;
    }
  };
  return ItemBase2;
}();
var item_default = ItemBase;

// node_modules/@antv/g6-core/es/item/edge.js
var END_MAP = {
  source: "start",
  target: "end"
};
var ITEM_NAME_SUFFIX = "Node";
var POINT_NAME_SUFFIX = "Point";
var ANCHOR_NAME_SUFFIX = "Anchor";
var Edge2 = function(_super) {
  __extends2(Edge3, _super);
  function Edge3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Edge3.prototype.getDefaultCfg = function() {
    return {
      type: "edge",
      sourceNode: null,
      targetNode: null,
      startPoint: null,
      endPoint: null,
      linkCenter: false
    };
  };
  Edge3.prototype.setEnd = function(name, value) {
    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
    var itemName = name + ITEM_NAME_SUFFIX;
    var preItem = this.get(itemName);
    if (preItem && !preItem.destroyed) {
      preItem.removeEdge(this);
    }
    if (is_plain_object_default(value)) {
      this.set(pointName, value);
      this.set(itemName, null);
    } else if (value) {
      value.addEdge(this);
      this.set(itemName, value);
      this.set(pointName, null);
    }
  };
  Edge3.prototype.getLinkPoint = function(name, model, controlPoints) {
    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
    var itemName = name + ITEM_NAME_SUFFIX;
    var point = this.get(pointName);
    if (!point) {
      var item = this.get(itemName);
      var anchorName = name + ANCHOR_NAME_SUFFIX;
      var prePoint = this.getPrePoint(name, controlPoints);
      var anchorIndex = model[anchorName];
      if (!is_nil_default(anchorIndex)) {
        point = item.getLinkPointByAnchor(anchorIndex);
      }
      point = point || item.getLinkPoint(prePoint);
      if (!is_nil_default(point.index)) {
        this.set("".concat(name, "AnchorIndex"), point.index);
      }
    }
    return point;
  };
  Edge3.prototype.getPrePoint = function(name, controlPoints) {
    if (controlPoints && controlPoints.length) {
      var index = name === "source" ? 0 : controlPoints.length - 1;
      return controlPoints[index];
    }
    var oppositeName = name === "source" ? "target" : "source";
    return this.getEndPoint(oppositeName);
  };
  Edge3.prototype.getEndPoint = function(name) {
    var itemName = name + ITEM_NAME_SUFFIX;
    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
    var item = this.get(itemName);
    if (item) {
      return item.get("model");
    }
    return this.get(pointName);
  };
  Edge3.prototype.getControlPointsByCenter = function(model) {
    var sourcePoint = this.getEndPoint("source");
    var targetPoint = this.getEndPoint("target");
    var shapeFactory = this.get("shapeFactory");
    var type = model.type;
    return shapeFactory.getControlPoints(type, {
      startPoint: sourcePoint,
      endPoint: targetPoint
    });
  };
  Edge3.prototype.getEndCenter = function(name) {
    var itemName = name + ITEM_NAME_SUFFIX;
    var pointName = END_MAP[name] + POINT_NAME_SUFFIX;
    var item = this.get(itemName);
    if (item) {
      var bbox = item.getBBox();
      return {
        x: bbox.centerX,
        y: bbox.centerY
      };
    }
    return this.get(pointName);
  };
  Edge3.prototype.init = function() {
    _super.prototype.init.call(this);
    this.setSource(this.get("source"));
    this.setTarget(this.get("target"));
  };
  Edge3.prototype.getShapeCfg = function(model, updateType) {
    var self2 = this;
    var linkCenter = self2.get("linkCenter");
    var cfg = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("move")) ? model : _super.prototype.getShapeCfg.call(this, model);
    if (linkCenter) {
      cfg.startPoint = self2.getEndCenter("source");
      cfg.endPoint = self2.getEndCenter("target");
    } else {
      var controlPoints = cfg.controlPoints || self2.getControlPointsByCenter(cfg);
      cfg.startPoint = self2.getLinkPoint("source", model, controlPoints);
      cfg.endPoint = self2.getLinkPoint("target", model, controlPoints);
    }
    cfg.sourceNode = self2.get("sourceNode");
    cfg.targetNode = self2.get("targetNode");
    return cfg;
  };
  Edge3.prototype.getModel = function() {
    var out = this.get("model");
    var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
    var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
    if (sourceItem) {
      delete out["source".concat(ITEM_NAME_SUFFIX)];
    } else {
      out.source = this.get("start".concat(POINT_NAME_SUFFIX));
    }
    if (targetItem) {
      delete out["target".concat(ITEM_NAME_SUFFIX)];
    } else {
      out.target = this.get("end".concat(POINT_NAME_SUFFIX));
    }
    if (!is_string_default(out.source) && !is_plain_object_default(out.source)) {
      out.source = out.source.getID();
    }
    if (!is_string_default(out.target) && !is_plain_object_default(out.target)) {
      out.target = out.target.getID();
    }
    return out;
  };
  Edge3.prototype.setSource = function(source) {
    this.setEnd("source", source);
    this.set("source", source);
  };
  Edge3.prototype.setTarget = function(target) {
    this.setEnd("target", target);
    this.set("target", target);
  };
  Edge3.prototype.getSource = function() {
    return this.get("source");
  };
  Edge3.prototype.getTarget = function() {
    return this.get("target");
  };
  Edge3.prototype.updatePosition = function() {
    return false;
  };
  Edge3.prototype.update = function(cfg, updateType) {
    if (updateType === void 0) {
      updateType = void 0;
    }
    var model = this.get("model");
    var oriVisible = model.visible;
    var cfgVisible = cfg.visible;
    if (oriVisible !== cfgVisible && cfgVisible !== void 0)
      this.changeVisibility(cfgVisible);
    var styles = this.get("styles");
    if (cfg.stateStyles) {
      var stateStyles = cfg.stateStyles;
      mix(styles, stateStyles);
      delete cfg.stateStyles;
    }
    Object.assign(model, cfg);
    this.updateShape(updateType);
    this.afterUpdate();
    this.clearCache();
  };
  Edge3.prototype.destroy = function() {
    var sourceItem = this.get("source".concat(ITEM_NAME_SUFFIX));
    var targetItem = this.get("target".concat(ITEM_NAME_SUFFIX));
    if (sourceItem && !sourceItem.destroyed) {
      sourceItem.removeEdge(this);
    }
    if (targetItem && !targetItem.destroyed) {
      targetItem.removeEdge(this);
    }
    _super.prototype.destroy.call(this);
  };
  return Edge3;
}(item_default);
var edge_default = Edge2;

// node_modules/@antv/g6-core/es/item/node.js
init_esm();
var CACHE_ANCHOR_POINTS = "anchorPointsCache";
var CACHE_BBOX2 = "bboxCache";
var Node2 = function(_super) {
  __extends2(Node3, _super);
  function Node3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Node3.prototype.getNearestPoint = function(points, curPoint) {
    var index = 0;
    var nearestPoint2 = points[0];
    var minDistance = distance4(points[0], curPoint);
    for (var i2 = 0; i2 < points.length; i2++) {
      var point = points[i2];
      var dis = distance4(point, curPoint);
      if (dis < minDistance) {
        nearestPoint2 = point;
        minDistance = dis;
        index = i2;
      }
    }
    nearestPoint2.anchorIndex = index;
    return nearestPoint2;
  };
  Node3.prototype.getDefaultCfg = function() {
    return {
      type: "node",
      edges: []
    };
  };
  Node3.prototype.getEdges = function() {
    return this.get("edges");
  };
  Node3.prototype.getInEdges = function() {
    var self2 = this;
    return this.get("edges").filter(function(edge) {
      return edge.get("target") === self2;
    });
  };
  Node3.prototype.getOutEdges = function() {
    var self2 = this;
    return this.get("edges").filter(function(edge) {
      return edge.get("source") === self2;
    });
  };
  Node3.prototype.getNeighbors = function(type) {
    var _this = this;
    var edges = this.get("edges");
    if (type === "target") {
      var neighhborsConverter_1 = function neighhborsConverter_12(edge) {
        return edge.getSource() === _this;
      };
      return edges.filter(neighhborsConverter_1).map(function(edge) {
        return edge.getTarget();
      });
    }
    if (type === "source") {
      var neighhborsConverter_2 = function neighhborsConverter_22(edge) {
        return edge.getTarget() === _this;
      };
      return edges.filter(neighhborsConverter_2).map(function(edge) {
        return edge.getSource();
      });
    }
    var neighhborsConverter = function neighhborsConverter2(edge) {
      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();
    };
    return edges.map(neighhborsConverter);
  };
  Node3.prototype.getLinkPointByAnchor = function(index) {
    var anchorPoints = this.getAnchorPoints();
    return anchorPoints[index];
  };
  Node3.prototype.getLinkPoint = function(point) {
    var keyShape = this.get("keyShape");
    var type = keyShape.get("type");
    var itemType = this.get("type");
    var centerX;
    var centerY;
    var bbox = this.getBBox();
    if (itemType === "combo") {
      centerX = bbox.centerX || (bbox.maxX + bbox.minX) / 2;
      centerY = bbox.centerY || (bbox.maxY + bbox.minY) / 2;
    } else {
      centerX = bbox.centerX;
      centerY = bbox.centerY;
    }
    var anchorPoints = this.getAnchorPoints();
    var intersectPoint;
    switch (type) {
      case "circle":
        intersectPoint = getCircleIntersectByPoint({
          x: centerX,
          y: centerY,
          r: bbox.width / 2
        }, point);
        break;
      case "ellipse":
        intersectPoint = getEllipseIntersectByPoint({
          x: centerX,
          y: centerY,
          rx: bbox.width / 2,
          ry: bbox.height / 2
        }, point);
        break;
      default:
        intersectPoint = getRectIntersectByPoint(bbox, point);
    }
    var linkPoint = intersectPoint;
    if (anchorPoints.length) {
      if (!linkPoint) {
        linkPoint = point;
      }
      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);
    }
    if (!linkPoint) {
      linkPoint = {
        x: centerX,
        y: centerY
      };
    }
    return linkPoint;
  };
  Node3.prototype.getAnchorPoints = function() {
    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);
    if (!anchorPoints) {
      anchorPoints = [];
      var shapeFactory = this.get("shapeFactory");
      var bbox_1 = this.getBBox();
      var model = this.get("model");
      var shapeCfg = this.getShapeCfg(model);
      var type = model.type;
      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];
      each_default(points, function(pointArr, index) {
        var point = {
          x: bbox_1.minX + pointArr[0] * bbox_1.width,
          y: bbox_1.minY + pointArr[1] * bbox_1.height,
          anchorIndex: index
        };
        anchorPoints.push(point);
      });
      this.set(CACHE_ANCHOR_POINTS, anchorPoints);
    }
    return anchorPoints;
  };
  Node3.prototype.addEdge = function(edge) {
    this.get("edges").push(edge);
  };
  Node3.prototype.lock = function() {
    this.set("locked", true);
  };
  Node3.prototype.unlock = function() {
    this.set("locked", false);
  };
  Node3.prototype.hasLocked = function() {
    return this.get("locked");
  };
  Node3.prototype.removeEdge = function(edge) {
    var edges = this.getEdges();
    var index = edges.indexOf(edge);
    if (index > -1)
      edges.splice(index, 1);
  };
  Node3.prototype.clearCache = function() {
    this.set(CACHE_BBOX2, null);
    this.set(CACHE_ANCHOR_POINTS, null);
  };
  Node3.prototype.getUpdateType = function(cfg) {
    var _a2, _b, _c, _d, _e2;
    if (!cfg)
      return void 0;
    var existX = !is_nil_default(cfg.x);
    var existY = !is_nil_default(cfg.y);
    var keys2 = Object.keys(cfg);
    if (keys2.length === 1 && (existX || existY) || keys2.length === 2 && existX && existY)
      return "move";
    if (is_number_default(cfg.x) || is_number_default(cfg.y) || cfg.type || cfg.anchorPoints || cfg.size || (cfg === null || cfg === void 0 ? void 0 : cfg.style) && (((_a2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _a2 === void 0 ? void 0 : _a2.r) || ((_b = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _b === void 0 ? void 0 : _b.width) || ((_c = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _d === void 0 ? void 0 : _d.rx) || ((_e2 = cfg === null || cfg === void 0 ? void 0 : cfg.style) === null || _e2 === void 0 ? void 0 : _e2.ry)))
      return "bbox|label";
    var updateLabel2 = keys2.includes("label") || keys2.includes("labelCfg");
    return updateLabel2 ? "style|label" : "style";
  };
  return Node3;
}(item_default);
var node_default = Node2;

// node_modules/@antv/g6-core/es/item/combo.js
init_esm();
var CACHE_BBOX3 = "bboxCache";
var CACHE_CANVAS_BBOX2 = "bboxCanvasCache";
var CACHE_SIZE = "sizeCache";
var CACHE_ANCHOR_POINTS2 = "anchorPointsCache";
var Combo = function(_super) {
  __extends2(Combo2, _super);
  function Combo2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Combo2.prototype.getDefaultCfg = function() {
    return {
      type: "combo",
      nodes: [],
      edges: [],
      combos: []
    };
  };
  Combo2.prototype.getShapeCfg = function(model) {
    var styles = this.get("styles");
    var bbox = this.get("bbox");
    if (styles && bbox) {
      var newModel = model;
      var size2 = {
        r: Math.hypot(bbox.height, bbox.width) / 2 || global_default.defaultCombo.size[0] / 2,
        width: bbox.width || global_default.defaultCombo.size[0],
        height: bbox.height || global_default.defaultCombo.size[1]
      };
      newModel.style = __assign2(__assign2(__assign2({}, styles), model.style), size2);
      var padding = model.padding || global_default.defaultCombo.padding;
      if (is_number_default(padding)) {
        size2.r += padding;
        size2.width += padding * 2;
        size2.height += padding * 2;
      } else {
        size2.r += padding[0];
        size2.width += padding[1] + padding[3] || padding[1] * 2;
        size2.height += padding[0] + padding[2] || padding[0] * 2;
      }
      this.set(CACHE_SIZE, size2);
      return newModel;
    }
    return model;
  };
  Combo2.prototype.calculateCanvasBBox = function() {
    if (this.destroyed)
      return;
    var keyShape = this.get("keyShape");
    var group = this.get("group");
    var bbox = getBBox(keyShape, group);
    bbox.centerX = (bbox.minX + bbox.maxX) / 2;
    bbox.centerY = (bbox.minY + bbox.maxY) / 2;
    var cacheSize = this.get(CACHE_SIZE);
    var cacheBBox = this.get(CACHE_BBOX3) || {};
    var oriX = cacheBBox.x;
    var oriY = cacheBBox.x;
    if (cacheSize) {
      cacheSize.width = Math.max(cacheSize.width, bbox.width);
      cacheSize.height = Math.max(cacheSize.height, bbox.height);
      var type = keyShape.get("type");
      if (type === "circle") {
        bbox.width = cacheSize.r * 2;
        bbox.height = cacheSize.r * 2;
      } else {
        bbox.width = cacheSize.width;
        bbox.height = cacheSize.height;
      }
      bbox.minX = bbox.centerX - bbox.width / 2;
      bbox.minY = bbox.centerY - bbox.height / 2;
      bbox.maxX = bbox.centerX + bbox.width / 2;
      bbox.maxY = bbox.centerY + bbox.height / 2;
    } else {
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      bbox.centerX = (bbox.minX + bbox.maxX) / 2;
      bbox.centerY = (bbox.minY + bbox.maxY) / 2;
    }
    bbox.x = bbox.minX;
    bbox.y = bbox.minY;
    if (bbox.x !== oriX || bbox.y !== oriY)
      this.set(CACHE_ANCHOR_POINTS2, null);
    return bbox;
  };
  Combo2.prototype.getChildren = function() {
    var self2 = this;
    return {
      nodes: self2.getNodes(),
      combos: self2.getCombos()
    };
  };
  Combo2.prototype.getNodes = function() {
    var self2 = this;
    return self2.get("nodes");
  };
  Combo2.prototype.getCombos = function() {
    var self2 = this;
    return self2.get("combos");
  };
  Combo2.prototype.addChild = function(item) {
    var self2 = this;
    var itemType = item.getType();
    switch (itemType) {
      case "node":
        self2.addNode(item);
        break;
      case "combo":
        self2.addCombo(item);
        break;
      default:
        console.warn("Only node or combo items are allowed to be added into a combo");
        return false;
    }
    return true;
  };
  Combo2.prototype.addCombo = function(combo) {
    var self2 = this;
    self2.get("combos").push(combo);
    return true;
  };
  Combo2.prototype.addNode = function(node) {
    var self2 = this;
    self2.get("nodes").push(node);
    return true;
  };
  Combo2.prototype.removeChild = function(item) {
    var self2 = this;
    var itemType = item.getType();
    switch (itemType) {
      case "node":
        self2.removeNode(item);
        break;
      case "combo":
        self2.removeCombo(item);
        break;
      default:
        console.warn("Only node or combo items are allowed to be added into a combo");
        return false;
    }
    return true;
  };
  Combo2.prototype.removeCombo = function(combo) {
    if (!combo)
      return;
    var combos = this.getCombos();
    var index = combos.indexOf(combo);
    if (index > -1) {
      combos.splice(index, 1);
      return true;
    }
    return false;
  };
  Combo2.prototype.removeNode = function(node) {
    if (!node)
      return;
    var nodes = this.getNodes();
    var index = nodes.indexOf(node);
    if (index > -1) {
      nodes.splice(index, 1);
      return true;
    }
    return false;
  };
  Combo2.prototype.getUpdateType = function(cfg) {
    return void 0;
  };
  Combo2.prototype.getBBox = function() {
    this.set(CACHE_CANVAS_BBOX2, null);
    var bbox = this.calculateCanvasBBox();
    return bbox;
  };
  Combo2.prototype.clearCache = function() {
    this.set(CACHE_BBOX3, null);
    this.set(CACHE_CANVAS_BBOX2, null);
    this.set(CACHE_ANCHOR_POINTS2, null);
  };
  Combo2.prototype.destroy = function() {
    if (!this.destroyed) {
      var animate = this.get("animate");
      var group = this.get("group");
      if (animate) {
        group.stopAnimate();
      }
      group["shapeMap"] = {};
      this.clearCache();
      this.set(CACHE_SIZE, null);
      this.set("bbox", null);
      group.remove();
      this._cfg = null;
      this.destroyed = true;
    }
  };
  return Combo2;
}(node_default);
var combo_default = Combo;

// node_modules/@antv/g6-core/es/graph/controller/item.js
var NODE = "node";
var EDGE = "edge";
var VEDGE = "vedge";
var COMBO = "combo";
var CFG_PREFIX = "default";
var MAPPER_SUFFIX = "Mapper";
var STATE_SUFFIX = "stateStyles";
var ItemController = function() {
  function ItemController2(graph) {
    var _this = this;
    this.edgeToBeUpdateMap = {};
    this.throttleRefresh = throttle_default(function(_2) {
      var _a2;
      var graph2 = _this.graph;
      if (!graph2 || graph2.get("destroyed"))
        return;
      var edgeToBeUpdateMap = _this.edgeToBeUpdateMap;
      if (!edgeToBeUpdateMap || !((_a2 = Object.keys(edgeToBeUpdateMap)) === null || _a2 === void 0 ? void 0 : _a2.length))
        return;
      Object.keys(edgeToBeUpdateMap).forEach(function(eid) {
        var edge = edgeToBeUpdateMap[eid].edge;
        if (!edge || edge.destroyed)
          return;
        var source = edge.getSource();
        var target = edge.getTarget();
        if (!source || source.destroyed || !target || target.destroyed)
          return;
        edge.refresh(edgeToBeUpdateMap[eid].updateType);
      });
      _this.edgeToBeUpdateMap = {};
    }, 16, {
      trailing: true,
      leading: true
    });
    this.graph = graph;
    this.destroyed = false;
  }
  ItemController2.prototype.addItem = function(type, model) {
    var graph = this.graph;
    var vType = type === VEDGE ? EDGE : type;
    var parent = graph.get("".concat(vType, "Group")) || graph.get("group");
    var upperType = upper_first_default(vType);
    var item = null;
    var styles = graph.get(vType + upper_first_default(STATE_SUFFIX)) || {};
    var defaultModel = graph.get(CFG_PREFIX + upperType);
    if (model[STATE_SUFFIX]) {
      styles = model[STATE_SUFFIX];
    }
    if (defaultModel) {
      each_default(defaultModel, function(val, cfg) {
        if (is_object_default(val) && !is_array_default(val)) {
          model[cfg] = deep_mix_default({}, val, model[cfg]);
        } else if (is_array_default(val)) {
          model[cfg] = model[cfg] || clone_default(defaultModel[cfg]);
        } else {
          model[cfg] = model[cfg] || defaultModel[cfg];
        }
      });
    }
    var mapper = graph.get(vType + MAPPER_SUFFIX);
    if (mapper) {
      var mappedModel_1 = mapper(model);
      if (mappedModel_1[STATE_SUFFIX]) {
        styles = mappedModel_1[STATE_SUFFIX];
        delete mappedModel_1[STATE_SUFFIX];
      }
      each_default(mappedModel_1, function(val, cfg) {
        if (is_object_default(val) && !is_array_default(val)) {
          model[cfg] = deep_mix_default({}, model[cfg], val);
        } else {
          model[cfg] = mappedModel_1[cfg] || model[cfg];
        }
      });
    }
    graph.emit("beforeadditem", {
      type,
      model
    });
    if (type === EDGE || type === VEDGE) {
      var source = void 0;
      var target = void 0;
      source = model.source;
      target = model.target;
      if (source && is_string_default(source)) {
        source = graph.findById(source);
      }
      if (target && is_string_default(target)) {
        target = graph.findById(target);
      }
      if (!source || !target) {
        console.warn("The source or target node of edge ".concat(model.id, " does not exist!"));
        return;
      }
      if (source.getType && source.getType() === "combo") {
        model.isComboEdge = true;
      }
      if (target.getType && target.getType() === "combo") {
        model.isComboEdge = true;
      }
      item = new edge_default({
        model,
        source,
        target,
        styles,
        linkCenter: graph.get("linkCenter"),
        group: parent.addGroup()
      });
    } else if (type === NODE) {
      item = new node_default({
        model,
        styles,
        group: parent.addGroup()
      });
    } else if (type === COMBO) {
      var children = model.children;
      var comboBBox = getComboBBox(children, graph);
      var bboxX = void 0, bboxY = void 0;
      if (!isNaN(comboBBox.x))
        bboxX = comboBBox.x;
      else if (isNaN(model.x))
        bboxX = Math.random() * 100;
      if (!isNaN(comboBBox.y))
        bboxY = comboBBox.y;
      else if (isNaN(model.y))
        bboxY = Math.random() * 100;
      if (isNaN(model.x) || isNaN(model.y)) {
        model.x = bboxX;
        model.y = bboxY;
      } else {
        var dx = model.x - bboxX;
        var dy = model.y - bboxY;
        this.updateComboSucceeds(model.id, dx, dy, children);
      }
      var comboGroup = parent.addGroup();
      comboGroup.setZIndex(model.depth);
      item = new combo_default({
        model,
        styles,
        bbox: model.collapsed ? getComboBBox([], graph) : comboBBox,
        group: comboGroup
      });
      var comboModel_1 = item.getModel();
      (children || []).forEach(function(child) {
        var childItem = graph.findById(child.id);
        item.addChild(childItem);
        child.depth = comboModel_1.depth + 2;
      });
      if (model.collapsed) {
        setTimeout(function() {
          if (!item.destroyed) {
            graph.collapseCombo(item);
            graph.updateCombo(item);
          }
        }, 0);
      }
    }
    if (item) {
      graph.get("".concat(type, "s")).push(item);
      graph.get("itemMap")[item.get("id")] = item;
      graph.emit("afteradditem", {
        item,
        model
      });
      return item;
    }
  };
  ItemController2.prototype.updateItem = function(item, cfg) {
    var _this = this;
    var _a2, _b;
    var graph = this.graph;
    if (is_string_default(item)) {
      item = graph.findById(item);
    }
    if (!item || item.destroyed) {
      return;
    }
    var type = "";
    if (item.getType)
      type = item.getType();
    var mapper = graph.get(type + MAPPER_SUFFIX);
    var model = item.getModel();
    var oriX = model.x, oriY = model.y;
    var updateType = item.getUpdateType(cfg);
    if (mapper) {
      var result = deep_mix_default({}, model, cfg);
      var mappedModel = mapper(result);
      var newModel = deep_mix_default({}, model, mappedModel, cfg);
      if (mappedModel[STATE_SUFFIX]) {
        item.set("styles", newModel[STATE_SUFFIX]);
        delete newModel[STATE_SUFFIX];
      }
      each_default(newModel, function(val, key) {
        cfg[key] = val;
      });
    } else {
      each_default(cfg, function(val, key) {
        if (model[key]) {
          if (is_object_default(val) && !is_array_default(val)) {
            cfg[key] = __assign2(__assign2({}, model[key]), cfg[key]);
          }
        }
      });
    }
    graph.emit("beforeupdateitem", {
      item,
      cfg
    });
    if (type === EDGE) {
      if (cfg.source) {
        var source = cfg.source;
        if (is_string_default(source)) {
          source = graph.findById(source);
        }
        item.setSource(source);
      }
      if (cfg.target) {
        var target = cfg.target;
        if (is_string_default(target)) {
          target = graph.findById(target);
        }
        item.setTarget(target);
      }
      item.update(cfg);
    } else if (type === NODE) {
      item.update(cfg, updateType);
      var edges = item.getEdges();
      var refreshEdge = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) || updateType === "move";
      if (updateType === "move") {
        each_default(edges, function(edge) {
          _this.edgeToBeUpdateMap[edge.getID()] = {
            edge,
            updateType
          };
          _this.throttleRefresh();
        });
      } else if (refreshEdge) {
        each_default(edges, function(edge) {
          edge.refresh(updateType);
        });
      }
    } else if (type === COMBO) {
      item.update(cfg, updateType);
      if (!isNaN(cfg.x) || !isNaN(cfg.y)) {
        var dx = cfg.x - oriX || 0;
        var dy = cfg.y - oriY || 0;
        this.updateComboSucceeds(model.id, dx, dy);
      }
      var edges_1 = item.getEdges();
      var refreshEdge = (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox")) || updateType === "move";
      if (refreshEdge && type === COMBO) {
        var shapeFactory = item.get("shapeFactory");
        var shapeType = model.type || "circle";
        var comboAnimate = model.animate === void 0 || cfg.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate || cfg.animate;
        if (comboAnimate) {
          setTimeout(function() {
            if (!item || item.destroyed)
              return;
            var keyShape = item.getKeyShape();
            if (!keyShape || keyShape.destroyed)
              return;
            each_default(edges_1, function(edge) {
              if (edge && !edge.destroyed)
                edge.refresh();
            });
          }, 201);
        } else {
          each_default(edges_1, function(edge) {
            edge.refresh();
          });
        }
      }
    }
    graph.emit("afterupdateitem", {
      item,
      cfg
    });
  };
  ItemController2.prototype.updateCombo = function(combo, children, followCombo) {
    var _this = this;
    var _a2, _b;
    var graph = this.graph;
    if (is_string_default(combo)) {
      combo = graph.findById(combo);
    }
    if (!combo || combo.destroyed) {
      return;
    }
    var model = combo.getModel();
    var comboBBox = getComboBBox(children, graph, combo);
    var comboX = comboBBox.x, comboY = comboBBox.y;
    combo.set("bbox", comboBBox);
    var x2 = comboX, y2 = comboY;
    if (followCombo) {
      x2 = isNaN(model.x) ? comboX : model.x;
      y2 = isNaN(model.y) ? comboY : model.y;
    } else {
      x2 = isNaN(comboX) ? model.x : comboX;
      y2 = isNaN(comboY) ? model.y : comboY;
    }
    combo.update({
      x: x2,
      y: y2
    });
    var shapeFactory = combo.get("shapeFactory");
    var shapeType = model.type || "circle";
    var comboAnimate = model.animate === void 0 ? (_b = (_a2 = shapeFactory[shapeType]) === null || _a2 === void 0 ? void 0 : _a2.options) === null || _b === void 0 ? void 0 : _b.animate : model.animate;
    if (comboAnimate) {
      setTimeout(function() {
        if (!combo || combo.destroyed)
          return;
        var keyShape = combo.getKeyShape();
        if (!keyShape || keyShape.destroyed)
          return;
        combo.getShapeCfg(model);
        _this.updateComboEdges(combo);
      }, 201);
    } else {
      this.updateComboEdges(combo);
    }
  };
  ItemController2.prototype.updateComboEdges = function(combo) {
    var combEdges = combo.getEdges() || [];
    for (var i2 = 0; i2 < combEdges.length; i2++) {
      var edge = combEdges[i2];
      if (edge && !edge.destroyed) {
        var edgeSF = edge.get("shapeFactory");
        var edgeCfg = edge.getShapeCfg(edge.getModel());
        var edgeGroup = edge.getContainer();
        edgeGroup.clear();
        var keyShape = edgeSF.draw(edgeCfg.type, edgeCfg, edgeGroup);
        edge.set("keyShape", keyShape);
        keyShape.set("isKeyShape", true);
        keyShape.set("draggable", true);
        edge.setOriginStyle();
      }
    }
  };
  ItemController2.prototype.collapseCombo = function(combo) {
    var graph = this.graph;
    if (is_string_default(combo)) {
      combo = graph.findById(combo);
    }
    var children = combo.getChildren();
    children.nodes.forEach(function(node) {
      graph.hideItem(node);
    });
    children.combos.forEach(function(c2) {
      graph.hideItem(c2);
    });
  };
  ItemController2.prototype.updateComboSucceeds = function(comboId, dx, dy, children) {
    var _this = this;
    if (children === void 0) {
      children = [];
    }
    var graph = this.graph;
    if (!dx && !dy)
      return;
    var kids = children;
    if (!(kids === null || kids === void 0 ? void 0 : kids.length)) {
      var comboTrees = graph.get("comboTrees");
      comboTrees === null || comboTrees === void 0 ? void 0 : comboTrees.forEach(function(child) {
        traverseTree(child, function(subTree) {
          if (subTree.id === comboId) {
            kids = subTree.children;
            return false;
          }
          return true;
        });
      });
    }
    kids === null || kids === void 0 ? void 0 : kids.forEach(function(child) {
      var childItem = graph.findById(child.id);
      if (childItem) {
        var childModel = childItem.getModel();
        _this.updateItem(child.id, {
          x: (childModel.x || 0) + dx,
          y: (childModel.y || 0) + dy
        });
      }
    });
  };
  ItemController2.prototype.expandCombo = function(combo) {
    var graph = this.graph;
    if (is_string_default(combo)) {
      combo = graph.findById(combo);
    }
    var children = combo.getChildren();
    children.nodes.forEach(function(node) {
      graph.showItem(node);
    });
    children.combos.forEach(function(c2) {
      if (c2.getModel().collapsed) {
        c2.show();
      } else {
        graph.showItem(c2);
      }
    });
  };
  ItemController2.prototype.removeItem = function(item) {
    var _this = this;
    var graph = this.graph;
    if (is_string_default(item)) {
      item = graph.findById(item);
    }
    if (!item || item.destroyed) {
      return;
    }
    var itemModel = clone_default(item.getModel());
    graph.emit("beforeremoveitem", {
      item: itemModel
    });
    var type = "";
    if (item.getType)
      type = item.getType();
    var items = graph.get("".concat(type, "s"));
    var index = items.indexOf(item);
    if (index > -1)
      items.splice(index, 1);
    if (type === EDGE) {
      var vitems = graph.get("v".concat(type, "s"));
      var vindex = vitems.indexOf(item);
      if (vindex > -1)
        vitems.splice(vindex, 1);
    }
    var itemId = item.get("id");
    var itemMap = graph.get("itemMap");
    delete itemMap[itemId];
    var comboTrees = graph.get("comboTrees");
    var id2 = item.get("id");
    if (type === NODE) {
      var comboId = item.getModel().comboId;
      if (comboTrees && comboId) {
        var brothers_1 = comboTrees;
        var found_1 = false;
        comboTrees.forEach(function(ctree) {
          if (found_1)
            return;
          traverseTree(ctree, function(combo) {
            if (combo.id === id2 && brothers_1) {
              var bidx = brothers_1.indexOf(combo);
              brothers_1.splice(bidx, 1);
              found_1 = true;
              return false;
            }
            brothers_1 = combo.children;
            return true;
          });
        });
      }
      var edges = item.getEdges();
      for (var i2 = edges.length - 1; i2 >= 0; i2--) {
        graph.removeItem(edges[i2], false);
      }
      if (comboId)
        graph.updateCombo(comboId);
    } else if (type === COMBO) {
      var parentId = item.getModel().parentId;
      var comboInTree_1;
      var found_2 = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found_2)
          return;
        traverseTree(ctree, function(combo) {
          if (combo.id === id2) {
            comboInTree_1 = combo;
            found_2 = true;
            return false;
          }
          return true;
        });
      });
      comboInTree_1.removed = true;
      if (comboInTree_1 && comboInTree_1.children) {
        comboInTree_1.children.forEach(function(child) {
          _this.removeItem(child.id);
        });
      }
      var edges = item.getEdges();
      for (var i2 = edges.length; i2 >= 0; i2--) {
        graph.removeItem(edges[i2], false);
      }
      if (parentId)
        graph.updateCombo(parentId);
    }
    item.destroy();
    graph.emit("afterremoveitem", {
      item: itemModel,
      type
    });
  };
  ItemController2.prototype.setItemState = function(item, state, value) {
    var graph = this.graph;
    var stateName = state;
    if (is_string_default(value)) {
      stateName = "".concat(state, ":").concat(value);
    }
    if (item.hasState(stateName) === value && value || is_string_default(value) && item.hasState(stateName)) {
      return;
    }
    graph.emit("beforeitemstatechange", {
      item,
      state: stateName,
      enabled: value
    });
    item.setState(state, value);
    graph.autoPaint();
    graph.emit("afteritemstatechange", {
      item,
      state: stateName,
      enabled: value
    });
  };
  ItemController2.prototype.priorityState = function(item, state) {
    var graph = this.graph;
    var currentItem = item;
    if (is_string_default(item)) {
      currentItem = graph.findById(item);
    }
    this.setItemState(currentItem, state, false);
    this.setItemState(currentItem, state, true);
  };
  ItemController2.prototype.clearItemStates = function(item, states) {
    var graph = this.graph;
    if (is_string_default(item)) {
      item = graph.findById(item);
    }
    graph.emit("beforeitemstatesclear", {
      item,
      states
    });
    item.clearStates(states);
    graph.emit("afteritemstatesclear", {
      item,
      states
    });
  };
  ItemController2.prototype.refreshItem = function(item) {
    var graph = this.graph;
    if (is_string_default(item)) {
      item = graph.findById(item);
    }
    graph.emit("beforeitemrefresh", {
      item
    });
    item.refresh();
    graph.emit("afteritemrefresh", {
      item
    });
  };
  ItemController2.prototype.addCombos = function(comboTrees, comboModels) {
    var _this = this;
    var graph = this.graph;
    (comboTrees || []).forEach(function(ctree) {
      traverseTreeUp(ctree, function(child) {
        var comboModel;
        comboModels.forEach(function(model) {
          if (model.id === child.id) {
            model.children = child.children;
            model.depth = child.depth;
            comboModel = model;
          }
        });
        if (comboModel) {
          _this.addItem("combo", comboModel);
        }
        return true;
      });
    });
    var comboGroup = graph.get("comboGroup");
    if (comboGroup)
      comboGroup.sort();
  };
  ItemController2.prototype.changeItemVisibility = function(item, visible) {
    var _this = this;
    var graph = this.graph;
    if (is_string_default(item)) {
      item = graph.findById(item);
    }
    if (!item) {
      console.warn("The item to be shown or hidden does not exist!");
      return;
    }
    graph.emit("beforeitemvisibilitychange", {
      item,
      visible
    });
    item.changeVisibility(visible);
    if (item.getType && item.getType() === NODE) {
      var edges = item.getEdges();
      each_default(edges, function(edge) {
        if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
          return;
        }
        _this.changeItemVisibility(edge, visible);
      });
    } else if (item.getType && item.getType() === COMBO) {
      var comboTrees = graph.get("comboTrees");
      var id_1 = item.get("id");
      var children_1 = [];
      var found_3 = false;
      (comboTrees || []).forEach(function(ctree) {
        if (found_3)
          return;
        if (!ctree.children || ctree.children.length === 0)
          return;
        traverseTree(ctree, function(combo) {
          if (combo.id === id_1) {
            children_1 = combo.children;
            found_3 = true;
            return false;
          }
          return true;
        });
      });
      if (children_1 && (!visible || visible && !item.getModel().collapsed)) {
        children_1.forEach(function(child) {
          var childItem = graph.findById(child.id);
          _this.changeItemVisibility(childItem, visible);
        });
      }
      var edges = item.getEdges();
      each_default(edges, function(edge) {
        if (visible && !(edge.get("source").isVisible() && edge.get("target").isVisible())) {
          return;
        }
        _this.changeItemVisibility(edge, visible);
      });
    }
    graph.emit("afteritemvisibilitychange", {
      item,
      visible
    });
    return item;
  };
  ItemController2.prototype.destroy = function() {
    this.graph = null;
    this.destroyed = true;
  };
  return ItemController2;
}();
var item_default2 = ItemController;

// node_modules/@antv/g6-core/es/graph/controller/state.js
init_esm();
var timer2 = null;
var StateController = function() {
  function StateController2(graph) {
    this.graph = graph;
    this.cachedStates = {
      enabled: {},
      disabled: {}
    };
    this.destroyed = false;
  }
  StateController2.checkCache = function(item, state, cache3) {
    if (!cache3[state]) {
      return;
    }
    var index = cache3[state].indexOf(item);
    if (index >= 0) {
      cache3[state].splice(index, 1);
    }
  };
  StateController2.cacheState = function(item, state, states) {
    if (!states[state]) {
      states[state] = [];
    }
    states[state].push(item);
  };
  StateController2.prototype.updateState = function(item, state, enabled) {
    var _this = this;
    var checkCache = StateController2.checkCache, cacheState = StateController2.cacheState;
    if (item.destroyed) {
      return;
    }
    var cachedStates = this.cachedStates;
    var enabledStates = cachedStates.enabled;
    var disabledStates = cachedStates.disabled;
    if (enabled) {
      checkCache(item, state, disabledStates);
      cacheState(item, state, enabledStates);
    } else {
      checkCache(item, state, enabledStates);
      cacheState(item, state, disabledStates);
    }
    if (timer2) {
      clearTimeout(timer2);
    }
    timer2 = setTimeout(function() {
      timer2 = null;
      _this.updateGraphStates();
    }, 16);
  };
  StateController2.prototype.updateStates = function(item, states, enabled) {
    var _this = this;
    if (is_string_default(states)) {
      this.updateState(item, states, enabled);
    } else {
      states.forEach(function(state) {
        _this.updateState(item, state, enabled);
      });
    }
  };
  StateController2.prototype.updateGraphStates = function() {
    var states = this.graph.get("states");
    var cachedStates = this.cachedStates;
    each_default(cachedStates.disabled, function(val, key) {
      if (states[key]) {
        states[key] = states[key].filter(function(item) {
          return val.indexOf(item) < 0 && !val.destroyed;
        });
      }
    });
    each_default(cachedStates.enabled, function(val, key) {
      if (!states[key]) {
        states[key] = val;
      } else {
        var map_1 = {};
        states[key].forEach(function(item) {
          if (!item.destroyed) {
            map_1[item.get("id")] = true;
          }
        });
        val.forEach(function(item) {
          if (!item.destroyed) {
            var id2 = item.get("id");
            if (!map_1[id2]) {
              map_1[id2] = true;
              states[key].push(item);
            }
          }
        });
      }
    });
    this.graph.emit("graphstatechange", {
      states
    });
    this.cachedStates = {
      enabled: {},
      disabled: {}
    };
  };
  StateController2.prototype.destroy = function() {
    this.graph = null;
    this.cachedStates = null;
    if (timer2) {
      clearTimeout(timer2);
    }
    timer2 = null;
    this.destroyed = true;
  };
  return StateController2;
}();
var state_default = StateController;

// node_modules/@antv/g6-core/es/item/hull.js
init_esm();

// node_modules/@antv/g6-core/es/util/path.js
var path_exports2 = {};
__export(path_exports2, {
  getClosedSpline: () => getClosedSpline,
  getControlPoint: () => getControlPoint,
  getSpline: () => getSpline,
  paddedHull: () => paddedHull,
  pathToPoints: () => pathToPoints,
  pointsToPolygon: () => pointsToPolygon,
  roundedHull: () => roundedHull
});
var substitute2 = function substitute3(str7, o2) {
  if (!str7 || !o2) {
    return str7;
  }
  return str7.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    var res = o2[name];
    if (res === 0)
      res = "0";
    return res || "";
  });
};
var getSpline = function getSpline2(points) {
  var data = [];
  if (points.length < 2) {
    throw new Error("point length must largn than 2, now it's ".concat(points.length));
  }
  for (var _i2 = 0, points_1 = points; _i2 < points_1.length; _i2++) {
    var point = points_1[_i2];
    var x2 = point.x, y2 = point.y;
    data.push(x2);
    data.push(y2);
  }
  var spliePath = catmull_rom_2_bezier_default(data);
  spliePath.unshift(["M", points[0].x, points[0].y]);
  return spliePath;
};
var getControlPoint = function getControlPoint2(startPoint, endPoint, percent, offset) {
  if (percent === void 0) {
    percent = 0;
  }
  if (offset === void 0) {
    offset = 0;
  }
  var point = {
    x: (1 - percent) * startPoint.x + percent * endPoint.x,
    y: (1 - percent) * startPoint.y + percent * endPoint.y
  };
  var tangent = [0, 0];
  vec2_exports.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);
  if (!tangent || !tangent[0] && !tangent[1]) {
    tangent = [0, 0];
  }
  var perpendicular = [-tangent[1] * offset, tangent[0] * offset];
  point.x += perpendicular[0];
  point.y += perpendicular[1];
  return point;
};
var pointsToPolygon = function pointsToPolygon2(points, z2) {
  var length5 = points.length;
  if (!length5) {
    return "";
  }
  var path = "";
  var str7 = "";
  for (var i2 = 0; i2 < length5; i2++) {
    var item = points[i2];
    if (i2 === 0) {
      str7 = "M{x} {y}";
    } else {
      str7 = "L{x} {y}";
    }
    path += substitute2(str7, item);
  }
  if (z2) {
    path += "Z";
  }
  return path;
};
var pathToPoints = function pathToPoints2(path) {
  var points = [];
  path.forEach(function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i2 = 1; i2 < seg.length; i2 = i2 + 2) {
        points.push([seg[i2], seg[i2 + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points;
};
var getClosedSpline = function getClosedSpline2(points) {
  if (points.length < 2) {
    throw new Error("point length must largn than 2, now it's ".concat(points.length));
  }
  var first = points[0];
  var second = points[1];
  var last2 = points[points.length - 1];
  var lastSecond = points[points.length - 2];
  points.unshift(last2);
  points.unshift(lastSecond);
  points.push(first);
  points.push(second);
  var closedPath = [];
  for (var i2 = 1; i2 < points.length - 2; i2 += 1) {
    var x0 = points[i2 - 1].x;
    var y0 = points[i2 - 1].y;
    var x1 = points[i2].x;
    var y1 = points[i2].y;
    var x2 = points[i2 + 1].x;
    var y2 = points[i2 + 1].y;
    var x3 = i2 !== points.length - 2 ? points[i2 + 2].x : x2;
    var y3 = i2 !== points.length - 2 ? points[i2 + 2].y : y2;
    var cp1x = x1 + (x2 - x0) / 6;
    var cp1y = y1 + (y2 - y0) / 6;
    var cp2x = x2 - (x3 - x1) / 6;
    var cp2y = y2 - (y3 - y1) / 6;
    closedPath.push(["C", cp1x, cp1y, cp2x, cp2y, x2, y2]);
  }
  closedPath.unshift(["M", last2.x, last2.y]);
  return closedPath;
};
var vecScaleTo = function vecScaleTo2(v2, length5) {
  return vec2_exports.scale([0, 0], vec2_exports.normalize([0, 0], v2), length5);
};
var unitNormal = function unitNormal2(p0, p1) {
  var n2 = [p0[1] - p1[1], p1[0] - p0[0]];
  var nLength = Math.sqrt(n2[0] * n2[0] + n2[1] * n2[1]);
  if (nLength === 0) {
    throw new Error("p0 should not be equal to p1");
  }
  return [n2[0] / nLength, n2[1] / nLength];
};
var vecFrom = function vecFrom2(p0, p1) {
  return [p1[0] - p0[0], p1[1] - p0[1]];
};
function roundedHull(polyPoints, padding) {
  var roundedHull1 = function roundedHull12(points) {
    var p12 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p12, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p2, " A ").concat(padding, ",").concat(padding, ",0,0,0,").concat(p12);
  };
  var roundedHull2 = function roundedHull22(points) {
    var offsetVector = vec2_exports.scale([0, 0], unitNormal(points[0], points[1]), padding);
    var invOffsetVector = vec2_exports.scale([0, 0], offsetVector, -1);
    var p02 = vec2_exports.add([0, 0], points[0], offsetVector);
    var p12 = vec2_exports.add([0, 0], points[1], offsetVector);
    var p2 = vec2_exports.add([0, 0], points[1], invOffsetVector);
    var p3 = vec2_exports.add([0, 0], points[0], invOffsetVector);
    return "M ".concat(p02, " L ").concat(p12, " A ").concat([padding, padding, "0,0,0", p2].join(","), " L ").concat(p3, " A ").concat([padding, padding, "0,0,0", p02].join(","));
  };
  if (!polyPoints || polyPoints.length < 1)
    return "";
  if (polyPoints.length === 1)
    return roundedHull1(polyPoints);
  if (polyPoints.length === 2)
    return roundedHull2(polyPoints);
  var segments = new Array(polyPoints.length);
  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {
    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];
    var p1 = polyPoints[segmentIndex];
    var offset = vec2_exports.scale([0, 0], unitNormal(p0, p1), padding);
    segments[segmentIndex] = [vec2_exports.add([0, 0], p0, offset), vec2_exports.add([0, 0], p1, offset)];
  }
  var arcData = "A ".concat([padding, padding, "0,0,0,"].join(","));
  segments = segments.map(function(segment, index) {
    var pathFragment = "";
    if (index === 0) {
      pathFragment = "M ".concat(segments[segments.length - 1][1], " ");
    }
    pathFragment += "".concat(arcData + segment[0], " L ").concat(segment[1]);
    return pathFragment;
  });
  return segments.join(" ");
}
function paddedHull(polyPoints, padding) {
  var pointCount = polyPoints.length;
  var smoothHull1 = function smoothHull12(points) {
    var p1 = [points[0][0], points[0][1] - padding];
    var p2 = [points[0][0], points[0][1] + padding];
    return "M ".concat(p1, " A ").concat([padding, padding, "0,0,0", p2].join(","), " A ").concat([padding, padding, "0,0,0", p1].join(","));
  };
  var smoothHull2 = function smoothHull22(points) {
    var v2 = vecFrom(points[0], points[1]);
    var extensionVec2 = vecScaleTo(v2, padding);
    var extension0 = vec2_exports.add([0, 0], points[0], vec2_exports.scale([0, 0], extensionVec2, -1));
    var extension1 = vec2_exports.add([0, 0], points[1], extensionVec2);
    var tangentHalfLength = 1.2 * padding;
    var controlDelta = vecScaleTo(vec2_exports.normalize([0, 0], v2), tangentHalfLength);
    var invControlDelta = vec2_exports.scale([0, 0], controlDelta, -1);
    var control0 = vec2_exports.add([0, 0], extension0, invControlDelta);
    var control1 = vec2_exports.add([0, 0], extension1, invControlDelta);
    var control3 = vec2_exports.add([0, 0], extension0, controlDelta);
    return "M ".concat(extension0, " C ").concat([control0, control1, extension1].join(","), " S ").concat([control3, extension0].join(","), " Z");
  };
  if (!polyPoints || pointCount < 1)
    return "";
  if (pointCount === 1)
    return smoothHull1(polyPoints);
  if (pointCount === 2)
    return smoothHull2(polyPoints);
  var hullPoints = polyPoints.map(function(point, index) {
    var pNext = polyPoints[(index + 1) % pointCount];
    return {
      p: point,
      v: vec2_exports.normalize([0, 0], vecFrom(point, pNext))
    };
  });
  for (var i2 = 0; i2 < hullPoints.length; ++i2) {
    var priorIndex = i2 > 0 ? i2 - 1 : pointCount - 1;
    var extensionVec = vec2_exports.normalize([0, 0], vec2_exports.add([0, 0], hullPoints[priorIndex].v, vec2_exports.scale([0, 0], hullPoints[i2].v, -1)));
    hullPoints[i2].p = vec2_exports.add([0, 0], hullPoints[i2].p, vec2_exports.scale([0, 0], extensionVec, padding));
  }
  return hullPoints.map(function(obj) {
    var point = obj.p;
    return {
      x: point[0],
      y: point[1]
    };
  });
}

// node_modules/@antv/g6-core/es/element/hull/convexHull.js
var cross4 = function cross5(a2, b10, o2) {
  return (a2.y - o2.y) * (b10.x - o2.x) - (a2.x - o2.x) * (b10.y - o2.y);
};
var genConvexHull = function genConvexHull2(items) {
  var points = items.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  });
  points.sort(function(a2, b10) {
    return a2.x === b10.x ? a2.y - b10.y : a2.x - b10.x;
  });
  if (points.length === 1) {
    return points;
  }
  var lower = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    while (lower.length >= 2 && cross4(lower[lower.length - 2], lower[lower.length - 1], points[i2]) <= 0) {
      lower.pop();
    }
    lower.push(points[i2]);
  }
  var upper = [];
  for (var i2 = points.length - 1; i2 >= 0; i2--) {
    while (upper.length >= 2 && cross4(upper[upper.length - 2], upper[upper.length - 1], points[i2]) <= 0) {
      upper.pop();
    }
    upper.push(points[i2]);
  }
  upper.pop();
  lower.pop();
  var strictHull = lower.concat(upper);
  return strictHull;
};

// node_modules/@antv/g6-core/es/element/hull/bubbleset.js
var defaultOps = {
  maxRoutingIterations: 100,
  maxMarchingIterations: 100,
  pixelGroupSize: 2,
  edgeR0: 10,
  edgeR1: 10,
  nodeR0: 5,
  nodeR1: 10,
  morphBuffer: 5,
  threshold: 1e-3,
  skip: 16,
  nodeInfluenceFactor: 1,
  edgeInfluenceFactor: 1,
  negativeNodeInfluenceFactor: -0.5
};
function MarchingSquares(contour, potentialArea, threshold) {
  var marched = false;
  var getVal = function getVal2(x2, y2) {
    return potentialArea.cells[x2 + y2 * potentialArea.width];
  };
  var getState = function getState2(x2, y2) {
    var squareVal = 0;
    if (getVal(x2 - 1, y2 - 1) >= threshold) {
      squareVal += 1;
    }
    if (getVal(x2, y2 - 1) > threshold) {
      squareVal += 2;
    }
    if (getVal(x2 - 1, y2) > threshold) {
      squareVal += 4;
    }
    if (getVal(x2, y2) > threshold) {
      squareVal += 8;
    }
    return squareVal;
  };
  var doMarch = function doMarch2(xPos, yPos) {
    var x2 = xPos;
    var y2 = yPos;
    var prevX;
    var prevY;
    for (var i2 = 0; i2 < potentialArea.width * potentialArea.height; i2++) {
      prevX = x2;
      prevY = y2;
      if (contour.findIndex(function(item) {
        return item.x === x2 && item.y === y2;
      }) > -1) {
        if (contour[0].x !== x2 || contour[0].y !== y2) {
        } else {
          return true;
        }
      } else {
        contour.push({
          x: x2,
          y: y2
        });
      }
      var state = getState(x2, y2);
      switch (state) {
        case -1:
          console.warn("Marched out of bounds");
          return true;
        case 0:
        case 3:
        case 2:
        case 7:
          x2++;
          break;
        case 12:
        case 14:
        case 4:
          x2--;
          break;
        case 6:
          if (prevX === 0) {
            if (prevY === -1) {
              x2 -= 1;
            } else {
              x2 += 1;
            }
          }
          break;
        case 1:
        case 13:
        case 5:
          y2--;
          break;
        case 9:
          if (prevX === 1) {
            if (prevY === 0) {
              y2 -= 1;
            } else {
              y2 += 1;
            }
          }
          break;
        case 10:
        case 8:
        case 11:
          y2++;
          break;
        default:
          console.warn("Marching squares invalid state: ".concat(state));
          return true;
      }
    }
  };
  this.march = function() {
    for (var x2 = 0; x2 < potentialArea.width && !marched; x2 += 1) {
      for (var y2 = 0; y2 < potentialArea.height && !marched; y2 += 1) {
        if (getVal(x2, y2) > threshold && getState(x2, y2) !== 15) {
          marched = doMarch(x2, y2);
        }
      }
    }
    return marched;
  };
}
var initGridCells = function initGridCells2(width, height, pixelGroupSize) {
  var scaleWidth = Math.ceil(width / pixelGroupSize);
  var scaleHeight = Math.ceil(height / pixelGroupSize);
  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);
  return {
    cells: gridCells,
    width: scaleWidth,
    height: scaleHeight
  };
};
var pickBestNeighbor = function pickBestNeighbor2(item, visited, nonMembers) {
  var closestNeighbour = null;
  var minCost = Number.POSITIVE_INFINITY;
  visited.forEach(function(neighbourItem) {
    var itemP = {
      x: item.getModel().x,
      y: item.getModel().y
    };
    var neighbourItemP = {
      x: neighbourItem.getModel().x,
      y: neighbourItem.getModel().y
    };
    var dist4 = squareDist(itemP, neighbourItemP);
    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);
    var numberObstacles = nonMembers.reduce(function(count, _item) {
      if (fractionToLine(_item, directLine) > 0) {
        return count + 1;
      }
      return count;
    }, 0);
    if (dist4 * Math.pow(numberObstacles + 1, 2) < minCost) {
      closestNeighbour = neighbourItem;
      minCost = dist4 * Math.pow(numberObstacles + 1, 2);
    }
  });
  return closestNeighbour;
};
var getIntersectItem = function getIntersectItem2(items, line) {
  var minDistance = Number.POSITIVE_INFINITY;
  var closestItem = null;
  items.forEach(function(item) {
    var distance11 = fractionToLine(item, line);
    if (distance11 >= 0 && distance11 < minDistance) {
      closestItem = item;
      minDistance = distance11;
    }
  });
  return closestItem;
};
var computeRoute = function computeRoute2(directLine, nonMembers, maxRoutingIterations, morphBuffer) {
  var checkedLines = [];
  var linesToCheck = [];
  linesToCheck.push(directLine);
  var hasIntersection = true;
  var iterations = 0;
  var pointExists = function pointExists2(point, lines) {
    var flag = false;
    lines.forEach(function(line) {
      if (flag)
        return;
      if (isPointsOverlap(point, {
        x: line.x1,
        y: line.y1
      }) || isPointsOverlap(point, {
        x: line.x2,
        y: line.y2
      })) {
        flag = true;
      }
    });
    return flag;
  };
  var isPointInNonMembers = function isPointInNonMembers2(point, _nonMembers) {
    for (var _i2 = 0, _nonMembers_1 = _nonMembers; _i2 < _nonMembers_1.length; _i2++) {
      var item = _nonMembers_1[_i2];
      var bbox = item.getBBox();
      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];
      if (isPointInPolygon(itemContour, point.x, point.y)) {
        return true;
      }
    }
    return false;
  };
  while (hasIntersection && iterations < maxRoutingIterations) {
    hasIntersection = false;
    var _loop_1 = function _loop_12() {
      var line = linesToCheck.pop();
      var closestItem = getIntersectItem(nonMembers, line);
      if (closestItem) {
        var _a2 = itemIntersectByLine(closestItem, line), intersections_1 = _a2[0], countIntersections = _a2[1];
        if (countIntersections === 2) {
          var testReroute = function testReroute2(isFirst) {
            var tempMorphBuffer = morphBuffer;
            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
            var pointInside = isPointInNonMembers(virtualNode, nonMembers);
            while (!exist && pointInside && tempMorphBuffer >= 1) {
              tempMorphBuffer /= 1.5;
              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);
              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);
              pointInside = isPointInNonMembers(virtualNode, nonMembers);
            }
            if (virtualNode && !exist && (!isFirst || !pointInside)) {
              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));
              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));
              hasIntersection = true;
            }
          };
          testReroute(true);
          if (!hasIntersection) {
            testReroute(false);
          }
        }
      }
      if (!hasIntersection) {
        checkedLines.push(line);
      }
      iterations += 1;
    };
    while (!hasIntersection && linesToCheck.length) {
      _loop_1();
    }
  }
  while (linesToCheck.length) {
    checkedLines.push(linesToCheck.pop());
  }
  return checkedLines;
};
function getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {
  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);
  if (optimalNeighbor === null) {
    return [];
  }
  var mergeLines = function mergeLines2(checkedLines2) {
    var finalRoute2 = [];
    while (checkedLines2.length > 0) {
      var line1 = checkedLines2.pop();
      if (checkedLines2.length === 0) {
        finalRoute2.push(line1);
        break;
      }
      var line2 = checkedLines2.pop();
      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);
      var closestItem = getIntersectItem(nonMembers, mergeLine);
      if (!closestItem) {
        checkedLines2.push(mergeLine);
      } else {
        finalRoute2.push(line1);
        checkedLines2.push(line2);
      }
    }
    return finalRoute2;
  };
  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);
  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);
  var finalRoute = mergeLines(checkedLines);
  return finalRoute;
}
var genBubbleSet = function genBubbleSet2(members, nonMembers, ops) {
  var options = Object.assign(defaultOps, ops);
  var centroid = getPointsCenter(members.map(function(item) {
    return {
      x: item.getModel().x,
      y: item.getModel().y
    };
  }));
  members = members.sort(function(a2, b10) {
    return squareDist({
      x: a2.getModel().x,
      y: a2.getModel().y
    }, centroid) - squareDist({
      x: b10.getModel().x,
      y: b10.getModel().y
    }, centroid);
  });
  var visited = [];
  var virtualEdges = [];
  members.forEach(function(item) {
    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);
    lines.forEach(function(l2) {
      virtualEdges.push(l2);
    });
    visited.push(item);
  });
  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);
  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize);
  var contour = [];
  var hull = [];
  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {
    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);
    contour = [];
    hull = [];
    if (!new MarchingSquares(contour, potentialArea, options.threshold).march())
      continue;
    var marchedPath = contour.map(function(point) {
      return {
        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),
        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)
      };
    });
    if (marchedPath) {
      var size2 = marchedPath.length;
      if (options.skip > 1) {
        size2 = Math.floor(marchedPath.length / options.skip);
        while (size2 < 3 && options.skip > 1) {
          options.skip -= 1;
          size2 = Math.floor(marchedPath.length / options.skip);
        }
      }
      for (var i2 = 0, j2 = 0; j2 < size2; j2 += 1, i2 += options.skip) {
        hull.push({
          x: marchedPath[i2].x,
          y: marchedPath[i2].y
        });
      }
    }
    var isContourValid = function isContourValid2() {
      for (var _i2 = 0, members_1 = members; _i2 < members_1.length; _i2++) {
        var item = members_1[_i2];
        var hullPoints = hull.map(function(point) {
          return [point.x, point.y];
        });
        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY))
          return false;
      }
      return true;
    };
    if (hull && isContourValid()) {
      return hull;
    }
    options.threshold *= 0.9;
    if (iterations <= options.maxMarchingIterations * 0.5) {
      options.memberInfluenceFactor *= 1.2;
      options.edgeInfluenceFactor *= 1.2;
    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {
      options.nonMemberInfluenceFactor *= 0.8;
    } else {
      break;
    }
  }
  return hull;
};
function getActiveRregion(members, edges, offset) {
  var activeRegion = {
    minX: Number.POSITIVE_INFINITY,
    minY: Number.POSITIVE_INFINITY,
    maxX: Number.NEGATIVE_INFINITY,
    maxY: Number.NEGATIVE_INFINITY,
    width: 0,
    height: 0,
    x: 0,
    y: 0
  };
  var bboxes = [];
  members.forEach(function(item) {
    bboxes.push(item.getBBox());
  });
  edges.forEach(function(l2) {
    bboxes.push(l2.getBBox());
  });
  for (var _i2 = 0, bboxes_1 = bboxes; _i2 < bboxes_1.length; _i2++) {
    var bbox = bboxes_1[_i2];
    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;
    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;
    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;
    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;
  }
  activeRegion.width = activeRegion.maxX - activeRegion.minX;
  activeRegion.height = activeRegion.maxY - activeRegion.minY;
  activeRegion.x = activeRegion.minX;
  activeRegion.y = activeRegion.minY;
  return activeRegion;
}
function fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {
  function pos2GridIx3(x2, offset) {
    var gridIx = Math.floor((x2 - offset) / options.pixelGroupSize);
    return gridIx < 0 ? 0 : gridIx;
  }
  function gridIx2Pos(x2, offset) {
    return x2 * options.pixelGroupSize + offset;
  }
  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);
  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);
  var getAffectedRegion = function getAffectedRegion2(bbox, thresholdR) {
    var startX = Math.min(pos2GridIx3(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);
    var startY = Math.min(pos2GridIx3(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);
    var endX = Math.min(pos2GridIx3(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);
    var endY = Math.min(pos2GridIx3(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);
    return [startX, startY, endX, endY];
  };
  var addItemInfluence = function addItemInfluence2(item, influenceFactor) {
    var bbox = item.getBBox();
    var _a2 = getAffectedRegion(bbox, options.nodeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y2 = startY; y2 < endY; y2 += 1) {
      for (var x2 = startX; x2 < endX; x2 += 1) {
        if (influenceFactor < 0 && potentialArea[x2 + y2 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x2, activeRegion.minX);
        var tempY = gridIx2Pos(y2, activeRegion.minY);
        var distanceSq = pointRectSquareDist({
          x: tempX,
          y: tempY
        }, {
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        });
        if (distanceSq < Math.pow(options.nodeR1, 2)) {
          var dr2 = Math.sqrt(distanceSq) - options.nodeR1;
          potentialArea.cells[x2 + y2 * potentialArea.width] += influenceFactor * dr2 * dr2;
        }
      }
    }
  };
  var addEdgeInfluence = function addEdgeInfluence2(line, influenceFactor) {
    var bbox = line.getBBox();
    var _a2 = getAffectedRegion(bbox, options.edgeR1), startX = _a2[0], startY = _a2[1], endX = _a2[2], endY = _a2[3];
    for (var y2 = startY; y2 < endY; y2 += 1) {
      for (var x2 = startX; x2 < endX; x2 += 1) {
        if (influenceFactor < 0 && potentialArea.cells[x2 + y2 * potentialArea.width] <= 0) {
          continue;
        }
        var tempX = gridIx2Pos(x2, activeRegion.minX);
        var tempY = gridIx2Pos(y2, activeRegion.minY);
        var minDistanceSq = pointLineSquareDist({
          x: tempX,
          y: tempY
        }, line);
        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {
          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;
          potentialArea.cells[x2 + y2 * potentialArea.width] += influenceFactor * mdr * mdr;
        }
      }
    }
  };
  if (options.nodeInfluenceFactor) {
    members.forEach(function(item) {
      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);
    });
  }
  if (options.edgeInfluenceFactor) {
    edges.forEach(function(edge) {
      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);
    });
  }
  if (options.negativeNodeInfluenceFactor) {
    nonMembers.forEach(function(item) {
      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);
    });
  }
}
function rerouteLine(item, buffer, intersections, wrapNormal) {
  var bbox = item.getBBox();
  var topIntersect = intersections[0], leftIntersect = intersections[1], bottomIntersect = intersections[2], rightIntersect = intersections[3];
  var cornerPos = {
    topLeft: {
      x: bbox.minX - buffer,
      y: bbox.minY - buffer
    },
    topRight: {
      x: bbox.maxX + buffer,
      y: bbox.minY - buffer
    },
    bottomLeft: {
      x: bbox.minX - buffer,
      y: bbox.maxY + buffer
    },
    bottomRight: {
      x: bbox.maxX + buffer,
      y: bbox.maxY + buffer
    }
  };
  var totalArea = bbox.height * bbox.width;
  function calcHalfArea(intersect1, intersect2) {
    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);
  }
  if (leftIntersect) {
    if (topIntersect)
      return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    if (bottomIntersect)
      return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    var topArea = calcHalfArea(leftIntersect, rightIntersect);
    if (topArea < totalArea * 0.5) {
      if (leftIntersect.y > rightIntersect.y)
        return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    }
    if (leftIntersect.y < rightIntersect.y)
      return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  if (rightIntersect) {
    if (topIntersect)
      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
    if (bottomIntersect)
      return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
  }
  var leftArea = calcHalfArea(topIntersect, bottomIntersect);
  if (leftArea < totalArea * 0.5) {
    if (topIntersect.x > bottomIntersect.x)
      return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;
    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;
  }
  if (topIntersect.x < bottomIntersect.x)
    return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;
  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;
}

// node_modules/@antv/g6-core/es/item/hull.js
var Hull = function() {
  function Hull2(graph, cfg) {
    this.cfg = deep_mix_default(this.getDefaultCfg(), cfg);
    this.graph = graph;
    this.id = this.cfg.id;
    this.group = this.cfg.group;
    this.members = this.cfg.members.map(function(item) {
      return is_string_default(item) ? graph.findById(item) : item;
    });
    this.nonMembers = this.cfg.nonMembers.map(function(item) {
      return is_string_default(item) ? graph.findById(item) : item;
    });
    this.setPadding();
    this.setType();
    this.path = this.calcPath(this.members, this.nonMembers);
    this.render();
  }
  Hull2.prototype.getDefaultCfg = function() {
    return {
      id: "g6-hull",
      type: "round-convex",
      members: [],
      nonMembers: [],
      style: {
        fill: "lightblue",
        stroke: "blue",
        opacity: 0.2
      },
      padding: 10
    };
  };
  Hull2.prototype.setPadding = function() {
    var nodeSize = this.members.length && this.members[0].getKeyShape().getCanvasBBox().width / 2;
    this.padding = this.cfg.padding > 0 ? this.cfg.padding + nodeSize : 10 + nodeSize;
    this.cfg.bubbleCfg = {
      nodeR0: this.padding - nodeSize,
      nodeR1: this.padding - nodeSize,
      morphBuffer: this.padding - nodeSize
    };
  };
  Hull2.prototype.setType = function() {
    this.type = this.cfg.type;
    if (this.members.length < 3) {
      this.type = "round-convex";
    }
    if (this.type !== "round-convex" && this.type !== "smooth-convex" && this.type !== "bubble") {
      console.warn("The hull type should be either round-convex, smooth-convex or bubble, round-convex is used by default.");
      this.type = "round-convex";
    }
  };
  Hull2.prototype.calcPath = function(members, nonMembers) {
    var contour, path, hull;
    switch (this.type) {
      case "round-convex":
        contour = genConvexHull(members);
        hull = roundedHull(contour.map(function(p2) {
          return [p2.x, p2.y];
        }), this.padding);
        path = parsePathString2(hull);
        break;
      case "smooth-convex":
        contour = genConvexHull(members);
        if (contour.length === 2) {
          hull = roundedHull(contour.map(function(p2) {
            return [p2.x, p2.y];
          }), this.padding);
          path = parsePathString2(hull);
        } else if (contour.length > 2) {
          hull = paddedHull(contour.map(function(p2) {
            return [p2.x, p2.y];
          }), this.padding);
          path = getClosedSpline(hull);
        }
        break;
      case "bubble":
        contour = genBubbleSet(members, nonMembers, this.cfg.bubbleCfg);
        path = contour.length >= 2 && getClosedSpline(contour);
        break;
      default:
    }
    return path;
  };
  Hull2.prototype.render = function() {
    this.group.addShape("path", {
      attrs: __assign2({
        path: this.path
      }, this.cfg.style),
      id: this.id,
      name: this.cfg.id,
      capture: false
    });
    this.group.toBack();
  };
  Hull2.prototype.addMember = function(item) {
    if (!item)
      return;
    if (is_string_default(item))
      item = this.graph.findById(item);
    this.members.push(item);
    var index = this.nonMembers.indexOf(item);
    if (index > -1) {
      this.nonMembers.splice(index, 1);
    }
    this.updateData(this.members, this.nonMembers);
    return true;
  };
  Hull2.prototype.addNonMember = function(item) {
    if (!item)
      return;
    if (is_string_default(item))
      item = this.graph.findById(item);
    this.nonMembers.push(item);
    var index = this.members.indexOf(item);
    if (index > -1) {
      this.members.splice(index, 1);
    }
    this.updateData(this.members, this.nonMembers);
    return true;
  };
  Hull2.prototype.removeMember = function(item) {
    if (!item)
      return;
    if (is_string_default(item))
      item = this.graph.findById(item);
    var index = this.members.indexOf(item);
    if (index > -1) {
      this.members.splice(index, 1);
      this.updateData(this.members, this.nonMembers);
      return true;
    }
    return false;
  };
  Hull2.prototype.removeNonMember = function(item) {
    if (!item)
      return;
    if (is_string_default(item))
      item = this.graph.findById(item);
    var index = this.nonMembers.indexOf(item);
    if (index > -1) {
      this.nonMembers.splice(index, 1);
      this.updateData(this.members, this.nonMembers);
      return true;
    }
    return false;
  };
  Hull2.prototype.updateData = function(members, nonMembers) {
    var _this = this;
    this.group.findById(this.id).remove();
    if (members)
      this.members = members.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
    if (nonMembers)
      this.nonMembers = nonMembers.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
    this.path = this.calcPath(this.members, this.nonMembers);
    this.render();
  };
  Hull2.prototype.updateStyle = function(cfg) {
    var path = this.group.findById(this.id);
    path.attr(__assign2({}, cfg));
  };
  Hull2.prototype.updateCfg = function(cfg) {
    var _this = this;
    this.cfg = deep_mix_default(this.cfg, cfg);
    this.id = this.cfg.id;
    this.group = this.cfg.group;
    if (cfg.members) {
      this.members = this.cfg.members.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
    }
    if (cfg.nonMembers) {
      this.nonMembers = this.cfg.nonMembers.map(function(item) {
        return is_string_default(item) ? _this.graph.findById(item) : item;
      });
    }
    this.setPadding();
    this.setType();
    this.path = this.calcPath(this.members, this.nonMembers);
    this.render();
  };
  Hull2.prototype.contain = function(item) {
    var _this = this;
    var nodeItem;
    if (is_string_default(item)) {
      nodeItem = this.graph.findById(item);
    } else {
      nodeItem = item;
    }
    var shapePoints;
    var shape = nodeItem.getKeyShape();
    if (nodeItem.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
    }
    shapePoints = shapePoints.map(function(canvasPoint) {
      var point = _this.graph.getPointByCanvas(canvasPoint[0], canvasPoint[1]);
      return [point.x, point.y];
    });
    return isPolygonsIntersect(shapePoints, pathToPoints(this.path));
  };
  Hull2.prototype.destroy = function() {
    this.group.remove();
    this.cfg = null;
  };
  return Hull2;
}();
var hull_default = Hull;

// node_modules/@antv/g6-core/es/graph/graph.js
var transform4 = ext_exports.transform;
var NODE2 = "node";
var AbstractGraph = function(_super) {
  __extends2(AbstractGraph2, _super);
  function AbstractGraph2(cfg) {
    var _this = _super.call(this) || this;
    _this.cfg = deep_mix_default(_this.getDefaultCfg(), cfg);
    _this.init();
    _this.animating = false;
    _this.destroyed = false;
    if (_this.cfg.enabledStack) {
      _this.undoStack = new stack_default(_this.cfg.maxStep);
      _this.redoStack = new stack_default(_this.cfg.maxStep);
    }
    return _this;
  }
  AbstractGraph2.prototype.init = function() {
    this.initCanvas();
    var viewController = new view_default(this);
    var modeController = new mode_default(this);
    var itemController = new item_default2(this);
    var stateController = new state_default(this);
    this.set({
      viewController,
      modeController,
      itemController,
      stateController
    });
    this.initLayoutController();
    this.initEventController();
    this.initGroups();
    this.initPlugins();
  };
  AbstractGraph2.prototype.initGroups = function() {
    var canvas = this.get("canvas");
    if (!canvas)
      return;
    var el = canvas.get("el");
    var _a2 = (el || {}).id, id2 = _a2 === void 0 ? "g6" : _a2;
    var group = canvas.addGroup({
      id: "".concat(id2, "-root"),
      className: global_default.rootContainerClassName
    });
    if (this.get("groupByTypes")) {
      var edgeGroup = group.addGroup({
        id: "".concat(id2, "-edge"),
        className: global_default.edgeContainerClassName
      });
      var nodeGroup = group.addGroup({
        id: "".concat(id2, "-node"),
        className: global_default.nodeContainerClassName
      });
      var comboGroup = group.addGroup({
        id: "".concat(id2, "-combo"),
        className: global_default.comboContainerClassName
      });
      comboGroup.toBack();
      this.set({
        nodeGroup,
        edgeGroup,
        comboGroup
      });
    }
    var delegateGroup = group.addGroup({
      id: "".concat(id2, "-delegate"),
      className: global_default.delegateContainerClassName
    });
    this.set({
      delegateGroup
    });
    this.set("group", group);
  };
  AbstractGraph2.prototype.getDefaultCfg = function() {
    return {
      container: void 0,
      width: void 0,
      height: void 0,
      renderer: "canvas",
      modes: {},
      plugins: [],
      data: {},
      fitViewPadding: 10,
      minZoom: 0.2,
      maxZoom: 10,
      event: true,
      groupByTypes: true,
      directed: false,
      autoPaint: true,
      nodes: [],
      edges: [],
      combos: [],
      vedges: [],
      itemMap: {},
      linkCenter: false,
      defaultNode: {},
      defaultEdge: {},
      nodeStateStyles: {},
      edgeStateStyles: {},
      states: {},
      animate: false,
      animateCfg: {
        onFrame: void 0,
        duration: 500,
        easing: "easeLinear"
      },
      callback: void 0,
      enabledStack: false,
      maxStep: 10,
      tooltips: []
    };
  };
  AbstractGraph2.prototype.set = function(key, val) {
    if (is_plain_object_default(key)) {
      this.cfg = __assign2(__assign2({}, this.cfg), key);
    } else {
      this.cfg[key] = val;
    }
    if (key === "enabledStack" && val && !this.undoStack && !this.redoStack) {
      this.undoStack = new stack_default(this.cfg.maxStep);
      this.redoStack = new stack_default(this.cfg.maxStep);
    }
    return this;
  };
  AbstractGraph2.prototype.get = function(key) {
    var _a2;
    return (_a2 = this.cfg) === null || _a2 === void 0 ? void 0 : _a2[key];
  };
  AbstractGraph2.prototype.getGroup = function() {
    return this.get("group");
  };
  AbstractGraph2.prototype.getContainer = function() {
    return this.get("container");
  };
  AbstractGraph2.prototype.getMinZoom = function() {
    return this.get("minZoom");
  };
  AbstractGraph2.prototype.setMinZoom = function(ratio) {
    return this.set("minZoom", ratio);
  };
  AbstractGraph2.prototype.getMaxZoom = function() {
    return this.get("maxZoom");
  };
  AbstractGraph2.prototype.setMaxZoom = function(ratio) {
    return this.set("maxZoom", ratio);
  };
  AbstractGraph2.prototype.getWidth = function() {
    return this.get("width");
  };
  AbstractGraph2.prototype.getHeight = function() {
    return this.get("height");
  };
  AbstractGraph2.prototype.clearItemStates = function(item, states) {
    if (is_string_default(item)) {
      item = this.findById(item);
    }
    var itemController = this.get("itemController");
    if (!states) {
      states = item.get("states");
    }
    itemController.clearItemStates(item, states);
    var stateController = this.get("stateController");
    stateController.updateStates(item, states, false);
  };
  AbstractGraph2.prototype.node = function(nodeFn) {
    if (typeof nodeFn === "function") {
      this.set("nodeMapper", nodeFn);
    }
  };
  AbstractGraph2.prototype.edge = function(edgeFn) {
    if (typeof edgeFn === "function") {
      this.set("edgeMapper", edgeFn);
    }
  };
  AbstractGraph2.prototype.combo = function(comboFn) {
    if (typeof comboFn === "function") {
      this.set("comboMapper", comboFn);
    }
  };
  AbstractGraph2.prototype.findById = function(id2) {
    return this.get("itemMap")[id2];
  };
  AbstractGraph2.prototype.find = function(type, fn2) {
    var result;
    var items = this.get("".concat(type, "s"));
    each_default(items, function(item, i2) {
      if (fn2(item, i2)) {
        result = item;
        return result;
      }
    });
    return result;
  };
  AbstractGraph2.prototype.findAll = function(type, fn2) {
    var result = [];
    each_default(this.get("".concat(type, "s")), function(item, i2) {
      if (fn2(item, i2)) {
        result.push(item);
      }
    });
    return result;
  };
  AbstractGraph2.prototype.findAllByState = function(type, state) {
    return this.findAll(type, function(item) {
      return item.hasState(state);
    });
  };
  AbstractGraph2.prototype.getAnimateCfgWithCallback = function(_a2) {
    var animateCfg = _a2.animateCfg, callback = _a2.callback;
    var animateConfig;
    if (!animateCfg) {
      animateConfig = {
        duration: 500,
        callback
      };
    } else {
      animateConfig = clone_default(animateCfg);
      if (animateCfg.callback) {
        var animateCfgCallback_1 = animateCfg.callback;
        animateConfig.callback = function() {
          callback();
          animateCfgCallback_1();
        };
      } else {
        animateConfig.callback = callback;
      }
    }
    return animateConfig;
  };
  AbstractGraph2.prototype.translate = function(dx, dy, animate, animateCfg) {
    var _this = this;
    var group = this.get("group");
    var matrix = clone_default(group.getMatrix());
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    if (animate) {
      var animateConfig = this.getAnimateCfgWithCallback({
        animateCfg,
        callback: function callback() {
          return _this.emit("viewportchange", {
            action: "translate",
            matrix: group.getMatrix()
          });
        }
      });
      move(group, {
        x: group.getCanvasBBox().x + dx,
        y: group.getCanvasBBox().y + dy
      }, animate, animateConfig || {
        duration: 500,
        easing: "easeCubic"
      });
    } else {
      matrix = transform4(matrix, [["t", dx, dy]]);
      group.setMatrix(matrix);
      this.emit("viewportchange", {
        action: "translate",
        matrix
      });
      this.autoPaint();
    }
  };
  AbstractGraph2.prototype.moveTo = function(x2, y2, animate, animateCfg) {
    var group = this.get("group");
    move(group, {
      x: x2,
      y: y2
    }, animate, animateCfg || {
      duration: 500,
      easing: "easeCubic"
    });
    this.emit("viewportchange", {
      action: "move",
      matrix: group.getMatrix()
    });
  };
  AbstractGraph2.prototype.fitView = function(padding, rules) {
    if (padding) {
      this.set("fitViewPadding", padding);
    }
    var viewController = this.get("viewController");
    if (rules) {
      viewController.fitViewByRules(rules);
    } else {
      viewController.fitView();
    }
    this.autoPaint();
  };
  AbstractGraph2.prototype.fitCenter = function() {
    var viewController = this.get("viewController");
    viewController.fitCenter();
    this.autoPaint();
  };
  AbstractGraph2.prototype.addBehaviors = function(behaviors2, modes) {
    var modeController = this.get("modeController");
    modeController.manipulateBehaviors(behaviors2, modes, true);
    return this;
  };
  AbstractGraph2.prototype.removeBehaviors = function(behaviors2, modes) {
    var modeController = this.get("modeController");
    modeController.manipulateBehaviors(behaviors2, modes, false);
    return this;
  };
  AbstractGraph2.prototype.updateBehavior = function(behavior, newCfg, mode) {
    var modeController = this.get("modeController");
    modeController.updateBehavior(behavior, newCfg, mode);
    return this;
  };
  AbstractGraph2.prototype.zoom = function(ratio, center, animate, animateCfg) {
    var _this = this;
    var group = this.get("group");
    var matrix = clone_default(group.getMatrix());
    var minZoom = this.get("minZoom");
    var maxZoom = this.get("maxZoom");
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    if (center) {
      matrix = transform4(matrix, [["t", -center.x, -center.y], ["s", ratio, ratio], ["t", center.x, center.y]]);
    } else {
      matrix = transform4(matrix, [["s", ratio, ratio]]);
    }
    if (minZoom && matrix[0] < minZoom || maxZoom && matrix[0] > maxZoom) {
      return false;
    }
    if (animate) {
      var aniMatrix_1 = clone_default(group.getMatrix());
      if (!aniMatrix_1) {
        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      var initialRatio_1 = aniMatrix_1[0];
      var targetRatio_1 = initialRatio_1 * ratio;
      var animateConfig = this.getAnimateCfgWithCallback({
        animateCfg,
        callback: function callback() {
          return _this.emit("viewportchange", {
            action: "zoom",
            matrix: group.getMatrix()
          });
        }
      });
      group.animate(function(ratio2) {
        if (ratio2 === 1) {
          aniMatrix_1 = matrix;
        } else {
          var scale9 = lerp5(initialRatio_1, targetRatio_1, ratio2) / aniMatrix_1[0];
          if (center) {
            aniMatrix_1 = transform4(aniMatrix_1, [["t", -center.x, -center.y], ["s", scale9, scale9], ["t", center.x, center.y]]);
          } else {
            aniMatrix_1 = transform4(aniMatrix_1, [["s", scale9, scale9]]);
          }
        }
        return {
          matrix: aniMatrix_1
        };
      }, animateConfig);
    } else {
      group.setMatrix(matrix);
      this.emit("viewportchange", {
        action: "zoom",
        matrix
      });
      this.autoPaint();
    }
    return true;
  };
  AbstractGraph2.prototype.zoomTo = function(toRatio, center, animate, animateCfg) {
    var ratio = toRatio / this.getZoom();
    return this.zoom(ratio, center, animate, animateCfg);
  };
  AbstractGraph2.prototype.focusItem = function(item, animate, animateCfg) {
    var viewController = this.get("viewController");
    var isAnimate = false;
    if (animate)
      isAnimate = true;
    else if (animate === void 0)
      isAnimate = this.get("animate");
    var curAniamteCfg = {};
    if (animateCfg)
      curAniamteCfg = animateCfg;
    else if (animateCfg === void 0)
      curAniamteCfg = this.get("animateCfg");
    viewController.focus(item, isAnimate, curAniamteCfg);
    this.autoPaint();
  };
  AbstractGraph2.prototype.autoPaint = function() {
    if (this.get("autoPaint")) {
      this.paint();
    }
  };
  AbstractGraph2.prototype.paint = function() {
    this.emit("beforepaint");
    this.get("canvas").draw();
    this.emit("afterpaint");
  };
  AbstractGraph2.prototype.getPointByClient = function(clientX, clientY) {
    var viewController = this.get("viewController");
    return viewController.getPointByClient(clientX, clientY);
  };
  AbstractGraph2.prototype.getClientByPoint = function(x2, y2) {
    var viewController = this.get("viewController");
    return viewController.getClientByPoint(x2, y2);
  };
  AbstractGraph2.prototype.getPointByCanvas = function(canvasX, canvasY) {
    var viewController = this.get("viewController");
    return viewController.getPointByCanvas(canvasX, canvasY);
  };
  AbstractGraph2.prototype.getCanvasByPoint = function(x2, y2) {
    var viewController = this.get("viewController");
    return viewController.getCanvasByPoint(x2, y2);
  };
  AbstractGraph2.prototype.getGraphCenterPoint = function() {
    var bbox = this.get("group").getCanvasBBox();
    return {
      x: (bbox.minX + bbox.maxX) / 2,
      y: (bbox.minY + bbox.maxY) / 2
    };
  };
  AbstractGraph2.prototype.getViewPortCenterPoint = function() {
    return this.getPointByCanvas(this.get("width") / 2, this.get("height") / 2);
  };
  AbstractGraph2.prototype.showItem = function(item, stack) {
    if (stack === void 0) {
      stack = true;
    }
    var itemController = this.get("itemController");
    var object = itemController.changeItemVisibility(item, true);
    if (stack && this.get("enabledStack")) {
      var id2 = object.getID();
      var type = object.getType();
      var before = {};
      var after = {};
      switch (type) {
        case "node":
          before.nodes = [{
            id: id2,
            visible: false
          }];
          after.nodes = [{
            id: id2,
            visible: true
          }];
          break;
        case "edge":
          before.nodes = [{
            id: id2,
            visible: false
          }];
          after.edges = [{
            id: id2,
            visible: true
          }];
          break;
        case "combo":
          before.nodes = [{
            id: id2,
            visible: false
          }];
          after.combos = [{
            id: id2,
            visible: true
          }];
          break;
        default:
          break;
      }
      this.pushStack("visible", {
        before,
        after
      });
    }
  };
  AbstractGraph2.prototype.hideItem = function(item, stack) {
    if (stack === void 0) {
      stack = true;
    }
    var itemController = this.get("itemController");
    var object = itemController.changeItemVisibility(item, false);
    if (stack && this.get("enabledStack")) {
      var id2 = object.getID();
      var type = object.getType();
      var before = {};
      var after = {};
      switch (type) {
        case "node":
          before.nodes = [{
            id: id2,
            visible: true
          }];
          after.nodes = [{
            id: id2,
            visible: false
          }];
          break;
        case "edge":
          before.nodes = [{
            id: id2,
            visible: true
          }];
          after.edges = [{
            id: id2,
            visible: false
          }];
          break;
        case "combo":
          before.nodes = [{
            id: id2,
            visible: true
          }];
          after.combos = [{
            id: id2,
            visible: false
          }];
          break;
        default:
          break;
      }
      this.pushStack("visible", {
        before,
        after
      });
    }
  };
  AbstractGraph2.prototype.refreshItem = function(item) {
    var itemController = this.get("itemController");
    itemController.refreshItem(item);
  };
  AbstractGraph2.prototype.setAutoPaint = function(auto) {
    var self2 = this;
    self2.set("autoPaint", auto);
    var canvas = self2.get("canvas");
    canvas.set("autoDraw", auto);
  };
  AbstractGraph2.prototype.remove = function(item, stack) {
    if (stack === void 0) {
      stack = true;
    }
    this.removeItem(item, stack);
  };
  AbstractGraph2.prototype.removeItem = function(item, stack) {
    if (stack === void 0) {
      stack = true;
    }
    var nodeItem = item;
    if (is_string_default(item))
      nodeItem = this.findById(item);
    if (!nodeItem && is_string_default(item)) {
      console.warn("The item ".concat(item, " to be removed does not exist!"));
    } else if (nodeItem) {
      var type = "";
      if (nodeItem.getType)
        type = nodeItem.getType();
      if (stack && this.get("enabledStack")) {
        var deletedModel = __assign2(__assign2({}, nodeItem.getModel()), {
          itemType: type
        });
        var before = {};
        switch (type) {
          case "node": {
            before.nodes = [deletedModel];
            before.edges = [];
            var edges = nodeItem.getEdges();
            for (var i2 = edges.length - 1; i2 >= 0; i2--) {
              before.edges.push(__assign2(__assign2({}, edges[i2].getModel()), {
                itemType: "edge"
              }));
            }
            break;
          }
          case "edge":
            before.edges = [deletedModel];
            break;
          case "combo":
            before.combos = [deletedModel];
            break;
          default:
            break;
        }
        this.pushStack("delete", {
          before,
          after: {}
        });
      }
      if (type === "node") {
        var model = nodeItem.getModel();
        if (model.comboId) {
          this.updateComboTree(nodeItem, void 0, false);
        }
      }
      var itemController = this.get("itemController");
      itemController.removeItem(nodeItem);
      if (type === "combo") {
        var newComboTrees = reconstructTree(this.get("comboTrees"));
        this.set("comboTrees", newComboTrees);
      }
    }
  };
  AbstractGraph2.prototype.addItem = function(type, model, stack, sortCombo) {
    if (stack === void 0) {
      stack = true;
    }
    if (sortCombo === void 0) {
      sortCombo = true;
    }
    var currentComboSorted = this.get("comboSorted");
    this.set("comboSorted", currentComboSorted && !sortCombo);
    var itemController = this.get("itemController");
    if (!singleDataValidation(type, model)) {
      return false;
    }
    if (model.id && this.findById(model.id)) {
      console.warn("This item exists already. Be sure the id %c".concat(model.id, "%c is unique."), "font-size: 20px; color: red;", "");
      return;
    }
    var item;
    var comboTrees = this.get("comboTrees") || [];
    if (type === "combo") {
      var itemMap_1 = this.get("itemMap");
      var foundParent_1 = false;
      comboTrees.forEach(function(ctree) {
        if (foundParent_1)
          return;
        traverseTreeUp(ctree, function(child) {
          if (model.parentId === child.id) {
            foundParent_1 = true;
            var newCombo2 = __assign2({
              id: model.id,
              depth: child.depth + 2
            }, model);
            if (child.children)
              child.children.push(newCombo2);
            else
              child.children = [newCombo2];
            model.depth = newCombo2.depth;
            item = itemController.addItem(type, model);
          }
          var childItem = itemMap_1[child.id];
          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === "combo") {
            itemController.updateCombo(childItem, child.children);
          }
          return true;
        });
      });
      if (!foundParent_1) {
        var newCombo = __assign2({
          id: model.id,
          depth: 0
        }, model);
        model.depth = newCombo.depth;
        comboTrees.push(newCombo);
        item = itemController.addItem(type, model);
      }
      this.set("comboTrees", comboTrees);
    } else if (type === "node" && is_string_default(model.comboId) && comboTrees) {
      var parentCombo = this.findById(model.comboId);
      if (parentCombo && parentCombo.getType && parentCombo.getType() !== "combo") {
        console.warn("'".concat(model.comboId, "' is not a id of a combo in the graph, the node will be added without combo."));
      }
      item = itemController.addItem(type, model);
      var itemMap_2 = this.get("itemMap");
      var foundParent_2 = false, foundNode_1 = false;
      comboTrees.forEach(function(ctree) {
        if (foundNode_1 || foundParent_2)
          return;
        traverseTreeUp(ctree, function(child) {
          if (child.id === model.id) {
            foundNode_1 = true;
            return false;
          }
          if (model.comboId === child.id && !foundNode_1) {
            foundParent_2 = true;
            var cloneNode = clone_default(model);
            cloneNode.itemType = "node";
            if (child.children)
              child.children.push(cloneNode);
            else
              child.children = [cloneNode];
            cloneNode.depth = child.depth + 1;
          }
          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === "combo") {
            itemController.updateCombo(itemMap_2[child.id], child.children);
          }
          return true;
        });
      });
    } else {
      item = itemController.addItem(type, model);
    }
    if (type === "node" && model.comboId || type === "combo" && model.parentId) {
      var parentCombo = this.findById(model.comboId || model.parentId);
      if (parentCombo && parentCombo.getType && parentCombo.getType() === "combo")
        parentCombo.addChild(item);
    }
    var combos = this.get("combos");
    if (combos && combos.length > 0) {
      this.sortCombos();
    }
    this.autoPaint();
    if (stack && this.get("enabledStack")) {
      var addedModel = __assign2(__assign2({}, item.getModel()), {
        itemType: type
      });
      var after = {};
      switch (type) {
        case "node":
          after.nodes = [addedModel];
          break;
        case "edge":
          after.edges = [addedModel];
          break;
        case "combo":
          after.combos = [addedModel];
          break;
        default:
          break;
      }
      this.pushStack("add", {
        before: {},
        after
      });
    }
    return item;
  };
  AbstractGraph2.prototype.add = function(type, model, stack, sortCombo) {
    if (stack === void 0) {
      stack = true;
    }
    if (sortCombo === void 0) {
      sortCombo = true;
    }
    return this.addItem(type, model, stack, sortCombo);
  };
  AbstractGraph2.prototype.updateItem = function(item, cfg, stack) {
    var _this = this;
    if (stack === void 0) {
      stack = true;
    }
    var itemController = this.get("itemController");
    var currentItem;
    if (is_string_default(item)) {
      currentItem = this.findById(item);
    } else {
      currentItem = item;
    }
    var UnupdateModel = clone_default(currentItem.getModel());
    var type = "";
    if (currentItem.getType)
      type = currentItem.getType();
    var states = __spreadArray([], currentItem.getStates(), true);
    if (type === "combo") {
      each_default(states, function(state) {
        return _this.setItemState(currentItem, state, false);
      });
    }
    itemController.updateItem(currentItem, cfg);
    if (type === "combo") {
      each_default(states, function(state) {
        return _this.setItemState(currentItem, state, true);
      });
    }
    if (stack && this.get("enabledStack")) {
      var before = {
        nodes: [],
        edges: [],
        combos: []
      };
      var after = {
        nodes: [],
        edges: [],
        combos: []
      };
      var afterModel = __assign2({
        id: UnupdateModel.id
      }, cfg);
      switch (type) {
        case "node":
          before.nodes.push(UnupdateModel);
          after.nodes.push(afterModel);
          break;
        case "edge":
          before.edges.push(UnupdateModel);
          after.edges.push(afterModel);
          break;
        case "combo":
          before.combos.push(UnupdateModel);
          after.combos.push(afterModel);
          break;
        default:
          break;
      }
      if (type === "node") {
        before.nodes.push(UnupdateModel);
      }
      this.pushStack("update", {
        before,
        after
      });
    }
  };
  AbstractGraph2.prototype.update = function(item, cfg, stack) {
    if (stack === void 0) {
      stack = true;
    }
    this.updateItem(item, cfg, stack);
  };
  AbstractGraph2.prototype.setItemState = function(item, state, value) {
    if (is_string_default(item)) {
      item = this.findById(item);
    }
    var itemController = this.get("itemController");
    itemController.setItemState(item, state, value);
    var stateController = this.get("stateController");
    if (is_string_default(value)) {
      stateController.updateState(item, "".concat(state, ":").concat(value), true);
    } else {
      stateController.updateState(item, state, value);
    }
  };
  AbstractGraph2.prototype.priorityState = function(item, state) {
    var itemController = this.get("itemController");
    itemController.priorityState(item, state);
  };
  AbstractGraph2.prototype.data = function(data) {
    dataValidation(data);
    this.set("data", data);
  };
  AbstractGraph2.prototype.render = function() {
    var self2 = this;
    this.set("comboSorted", false);
    var data = this.get("data");
    if (this.get("enabledStack")) {
      this.clearStack();
    }
    if (!data) {
      throw new Error("data must be defined first");
    }
    var _a2 = data.nodes, nodes = _a2 === void 0 ? [] : _a2, _b = data.edges, edges = _b === void 0 ? [] : _b, _c = data.combos, combos = _c === void 0 ? [] : _c;
    this.clear(true);
    this.emit("beforerender");
    each_default(nodes, function(node) {
      self2.add("node", node, false, false);
    });
    if ((combos === null || combos === void 0 ? void 0 : combos.length) !== 0) {
      var comboTrees = plainCombosToTrees(combos, nodes);
      this.set("comboTrees", comboTrees);
      self2.addCombos(combos);
    }
    each_default(edges, function(edge) {
      self2.add("edge", edge, false, false);
    });
    var animate = self2.get("animate");
    if (self2.get("fitView") || self2.get("fitCenter")) {
      self2.set("animate", false);
    }
    var layoutController = self2.get("layoutController");
    if (layoutController) {
      layoutController.layout(success);
      if (this.destroyed)
        return;
    } else {
      if (self2.get("fitView")) {
        self2.fitView();
      }
      if (self2.get("fitCenter")) {
        self2.fitCenter();
      }
      self2.emit("afterrender");
      self2.set("animate", animate);
    }
    function success() {
      if (self2.get("fitView")) {
        self2.fitView();
      } else if (self2.get("fitCenter")) {
        self2.fitCenter();
      }
      self2.autoPaint();
      self2.emit("afterrender");
      if (self2.get("fitView") || self2.get("fitCenter")) {
        self2.set("animate", animate);
      }
    }
    if (!this.get("groupByTypes")) {
      if (combos && combos.length !== 0) {
        this.sortCombos();
      } else {
        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {
          var nodesArr = this.getNodes();
          nodesArr.forEach(function(node) {
            node.toFront();
          });
        } else {
          var edgesArr = this.getEdges();
          edgesArr.forEach(function(edge) {
            edge.toBack();
          });
        }
      }
    }
    if (this.get("enabledStack")) {
      this.pushStack("render");
    }
  };
  AbstractGraph2.prototype.read = function(data) {
    this.data(data);
    this.render();
  };
  AbstractGraph2.prototype.diffItems = function(type, items, models) {
    var self2 = this;
    var item;
    var itemMap = this.get("itemMap");
    each_default(models, function(model) {
      item = itemMap[model.id];
      if (item) {
        if (self2.get("animate") && type === NODE2) {
          var containerMatrix = item.getContainer().getMatrix();
          if (!containerMatrix)
            containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          item.set("originAttrs", {
            x: containerMatrix[6],
            y: containerMatrix[7]
          });
        }
        self2.updateItem(item, model, false);
      } else {
        item = self2.addItem(type, model, false);
      }
      if (item)
        items["".concat(type, "s")].push(item);
    });
  };
  AbstractGraph2.prototype.changeData = function(propsData, stack) {
    if (stack === void 0) {
      stack = true;
    }
    var self2 = this;
    var data = propsData || self2.get("data");
    if (!dataValidation(data)) {
      return this;
    }
    if (stack && this.get("enabledStack")) {
      this.pushStack("changedata", {
        before: self2.save(),
        after: data
      });
    }
    this.set("comboSorted", false);
    this.removeHulls();
    this.getNodes().map(function(node) {
      return self2.clearItemStates(node);
    });
    this.getEdges().map(function(edge) {
      return self2.clearItemStates(edge);
    });
    var canvas = this.get("canvas");
    var localRefresh = canvas.get("localRefresh");
    canvas.set("localRefresh", false);
    if (!self2.get("data")) {
      self2.data(data);
      self2.render();
    }
    var itemMap = this.get("itemMap");
    var items = {
      nodes: [],
      edges: []
    };
    var combosData = data.combos;
    if (combosData) {
      var comboTrees = plainCombosToTrees(combosData, data.nodes);
      this.set("comboTrees", comboTrees);
    } else {
      this.set("comboTrees", []);
    }
    this.diffItems("node", items, data.nodes);
    each_default(itemMap, function(item, id2) {
      itemMap[id2].getModel().depth = 0;
      if (item.getType && item.getType() === "edge")
        return;
      if (item.getType && item.getType() === "combo") {
        delete itemMap[id2];
        item.destroy();
      } else if (items.nodes.indexOf(item) < 0) {
        delete itemMap[id2];
        self2.remove(item, false);
      }
    });
    var comboItems = this.getCombos();
    var combosLength = comboItems.length;
    for (var i2 = combosLength - 1; i2 >= 0; i2--) {
      if (comboItems[i2].destroyed) {
        comboItems.splice(i2, 1);
      }
    }
    if (combosData) {
      self2.addCombos(combosData);
      if (!this.get("groupByTypes")) {
        this.sortCombos();
      }
    }
    this.diffItems("edge", items, data.edges);
    each_default(itemMap, function(item, id2) {
      if (item.getType && (item.getType() === "node" || item.getType() === "combo"))
        return;
      if (items.edges.indexOf(item) < 0) {
        delete itemMap[id2];
        self2.remove(item, false);
      }
    });
    this.set({
      nodes: items.nodes,
      edges: items.edges
    });
    var layoutController = this.get("layoutController");
    if (layoutController) {
      layoutController.changeData();
      if (self2.get("animate") && !layoutController.getLayoutType()) {
        self2.positionsAnimate();
      } else {
        self2.autoPaint();
      }
    }
    setTimeout(function() {
      canvas.set("localRefresh", localRefresh);
    }, 16);
    return this;
  };
  AbstractGraph2.prototype.addCombos = function(combos) {
    var self2 = this;
    var comboTrees = self2.get("comboTrees");
    var itemController = this.get("itemController");
    itemController.addCombos(comboTrees, combos);
  };
  AbstractGraph2.prototype.createCombo = function(combo, children) {
    var _this = this;
    this.set("comboSorted", false);
    var comboId = "";
    var comboConfig;
    if (!combo)
      return;
    if (is_string_default(combo)) {
      comboId = combo;
      comboConfig = {
        id: combo
      };
    } else {
      comboId = combo.id;
      if (!comboId) {
        console.warn("Create combo failed. Please assign a unique string id for the adding combo.");
        return;
      }
      comboConfig = combo;
    }
    var trees = children.map(function(elementId) {
      var item = _this.findById(elementId);
      var model = item.getModel();
      var type = "";
      if (item.getType)
        type = item.getType();
      var cItem = {
        id: item.getID(),
        itemType: type
      };
      if (type === "combo") {
        cItem.parentId = comboId;
        model.parentId = comboId;
      } else if (type === "node") {
        cItem.comboId = comboId;
        model.comboId = comboId;
      }
      return cItem;
    });
    comboConfig.children = trees;
    this.addItem("combo", comboConfig, false);
    this.set("comboSorted", false);
    var comboTrees = this.get("comboTrees");
    (comboTrees || []).forEach(function(ctree) {
      traverseTreeUp(ctree, function(child) {
        if (child.id === comboId) {
          child.itemType = "combo";
          child.children = trees;
          return false;
        }
        return true;
      });
    });
    if (comboTrees) {
      this.sortCombos();
    }
  };
  AbstractGraph2.prototype.uncombo = function(combo) {
    var _this = this;
    var _a2;
    var self2 = this;
    var comboItem = combo;
    if (is_string_default(combo)) {
      comboItem = this.findById(combo);
    }
    if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
      console.warn("The item is not a combo!");
      return;
    }
    var parentId = comboItem.getModel().parentId;
    var comboTrees = self2.get("comboTrees");
    if (!comboTrees)
      comboTrees = [];
    var itemMap = this.get("itemMap");
    var comboId = comboItem.get("id");
    var treeToBeUncombo;
    var brothers = [];
    var comboItems = this.get("combos");
    var parentItem = this.findById(parentId);
    comboTrees.forEach(function(ctree) {
      if (treeToBeUncombo)
        return;
      traverseTreeUp(ctree, function(subtree) {
        var _a3;
        if (subtree.id === comboId) {
          treeToBeUncombo = subtree;
          var edgeIds = comboItem.getEdges().map(function(edge) {
            return edge.getID();
          });
          edgeIds.forEach(function(edgeId) {
            _this.removeItem(edgeId, false);
          });
          var index2 = comboItems.indexOf(comboItem);
          comboItems.splice(index2, 1);
          delete itemMap[comboId];
          comboItem.destroy();
          _this.emit("afterremoveitem", {
            item: comboItem,
            type: "combo"
          });
        }
        if (parentId && treeToBeUncombo && subtree.id === parentId) {
          parentItem.removeCombo(comboItem);
          brothers = subtree.children;
          var index2 = brothers.indexOf(treeToBeUncombo);
          if (index2 !== -1) {
            brothers.splice(index2, 1);
          }
          (_a3 = treeToBeUncombo.children) === null || _a3 === void 0 ? void 0 : _a3.forEach(function(child) {
            var item = _this.findById(child.id);
            var childModel = item.getModel();
            if (item.getType && item.getType() === "combo") {
              child.parentId = parentId;
              delete child.comboId;
              childModel.parentId = parentId;
              delete childModel.comboId;
            } else if (item.getType && item.getType() === "node") {
              child.comboId = parentId;
              childModel.comboId = parentId;
            }
            parentItem.addChild(item);
            brothers.push(child);
          });
          return false;
        }
        return true;
      });
    });
    if (!parentId && treeToBeUncombo) {
      var index = comboTrees.indexOf(treeToBeUncombo);
      comboTrees.splice(index, 1);
      (_a2 = treeToBeUncombo.children) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
        child.parentId = void 0;
        var childModel = _this.findById(child.id).getModel();
        delete childModel.parentId;
        delete childModel.comboId;
        if (child.itemType !== "node")
          comboTrees.push(child);
      });
    }
  };
  AbstractGraph2.prototype.updateCombos = function(followCombo) {
    var _this = this;
    if (followCombo === void 0) {
      followCombo = false;
    }
    var self2 = this;
    var comboTrees = this.get("comboTrees");
    var itemController = self2.get("itemController");
    var itemMap = self2.get("itemMap");
    (comboTrees || []).forEach(function(ctree) {
      traverseTreeUp(ctree, function(child) {
        if (!child) {
          return true;
        }
        var childItem = itemMap[child.id];
        if (childItem && childItem.getType && childItem.getType() === "combo") {
          var states = __spreadArray([], childItem.getStates(), true);
          each_default(states, function(state) {
            return _this.setItemState(childItem, state, false);
          });
          itemController.updateCombo(childItem, child.children, followCombo);
          each_default(states, function(state) {
            return _this.setItemState(childItem, state, true);
          });
        }
        return true;
      });
    });
    self2.sortCombos();
  };
  AbstractGraph2.prototype.updateCombo = function(combo) {
    var _this = this;
    var self2 = this;
    var comboItem = combo;
    var comboId;
    if (is_string_default(combo)) {
      comboItem = this.findById(combo);
    }
    if (!comboItem || comboItem.getType && comboItem.getType() !== "combo") {
      console.warn("The item to be updated is not a combo!");
      return;
    }
    comboId = comboItem.get("id");
    var comboTrees = this.get("comboTrees");
    var itemController = self2.get("itemController");
    var itemMap = self2.get("itemMap");
    (comboTrees || []).forEach(function(ctree) {
      traverseTreeUp(ctree, function(child) {
        if (!child) {
          return true;
        }
        var childItem = itemMap[child.id];
        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === "combo") {
          var states = __spreadArray([], childItem.getStates(), true);
          each_default(states, function(state) {
            if (childItem.getStateStyle(state)) {
              _this.setItemState(childItem, state, false);
            }
          });
          itemController.updateCombo(childItem, child.children);
          each_default(states, function(state) {
            if (childItem.getStateStyle(state)) {
              _this.setItemState(childItem, state, true);
            }
          });
          if (comboId)
            comboId = child.parentId;
        }
        return true;
      });
    });
  };
  AbstractGraph2.prototype.updateComboTree = function(item, parentId, stack) {
    if (stack === void 0) {
      stack = true;
    }
    var self2 = this;
    this.set("comboSorted", false);
    var uItem;
    if (is_string_default(item)) {
      uItem = self2.findById(item);
    } else {
      uItem = item;
    }
    var model = uItem.getModel();
    var oldParentId = model.comboId || model.parentId;
    var type = "";
    if (uItem.getType)
      type = uItem.getType();
    if (parentId && type === "combo") {
      var comboTrees = this.get("comboTrees");
      var valid_1 = true;
      var itemSubTree_1;
      (comboTrees || []).forEach(function(ctree) {
        if (itemSubTree_1)
          return;
        traverseTree(ctree, function(subTree) {
          if (itemSubTree_1)
            return;
          if (subTree.id === uItem.getID()) {
            itemSubTree_1 = subTree;
          }
          return true;
        });
      });
      traverseTree(itemSubTree_1, function(subTree) {
        if (subTree.id === parentId) {
          valid_1 = false;
          return false;
        }
        return true;
      });
      if (!valid_1) {
        console.warn("Failed to update the combo tree! The parentId points to a descendant of the combo!");
        return;
      }
    }
    if (stack && this.get("enabledStack")) {
      var beforeData = {}, afterData = {};
      if (type === "combo") {
        beforeData.combos = [{
          id: model.id,
          parentId: model.parentId
        }];
        afterData.combos = [{
          id: model.id,
          parentId
        }];
      } else if (type === "node") {
        beforeData.nodes = [{
          id: model.id,
          parentId: model.comboId
        }];
        afterData.nodes = [{
          id: model.id,
          parentId
        }];
      }
      this.pushStack("updateComboTree", {
        before: beforeData,
        after: afterData
      });
    }
    if (model.parentId || model.comboId) {
      var combo = this.findById(model.parentId || model.comboId);
      if (combo) {
        combo.removeChild(uItem);
      }
    }
    if (type === "combo") {
      model.parentId = parentId;
    } else if (type === "node") {
      model.comboId = parentId;
    }
    if (parentId) {
      var parentCombo = this.findById(parentId);
      if (parentCombo) {
        parentCombo.addChild(uItem);
      }
    }
    if (oldParentId) {
      var parentCombo = this.findById(oldParentId);
      if (parentCombo) {
        parentCombo.removeChild(uItem);
      }
    }
    var newComboTrees = reconstructTree(this.get("comboTrees"), model.id, parentId);
    this.set("comboTrees", newComboTrees);
    this.updateCombos();
  };
  AbstractGraph2.prototype.save = function() {
    var nodes = [];
    var edges = [];
    var combos = [];
    each_default(this.get("nodes"), function(node) {
      nodes.push(node.getModel());
    });
    each_default(this.get("edges"), function(edge) {
      edges.push(edge.getModel());
    });
    each_default(this.get("combos"), function(combo) {
      combos.push(combo.getModel());
    });
    return {
      nodes,
      edges,
      combos
    };
  };
  AbstractGraph2.prototype.changeSize = function(width, height) {
    var viewController = this.get("viewController");
    viewController.changeSize(width, height);
    return this;
  };
  AbstractGraph2.prototype.refresh = function() {
    var self2 = this;
    self2.emit("beforegraphrefresh");
    if (self2.get("animate")) {
      self2.positionsAnimate();
    } else {
      var nodes = self2.get("nodes");
      var edges = self2.get("edges");
      var vedges = self2.get("edges");
      each_default(nodes, function(node) {
        node.refresh();
      });
      each_default(edges, function(edge) {
        edge.refresh();
      });
      each_default(vedges, function(vedge) {
        vedge.refresh();
      });
    }
    self2.emit("aftergraphrefresh");
    self2.autoPaint();
  };
  AbstractGraph2.prototype.getNodes = function() {
    return this.get("nodes");
  };
  AbstractGraph2.prototype.getEdges = function() {
    return this.get("edges");
  };
  AbstractGraph2.prototype.getCombos = function() {
    return this.get("combos");
  };
  AbstractGraph2.prototype.getComboChildren = function(combo) {
    if (is_string_default(combo)) {
      combo = this.findById(combo);
    }
    if (!combo || combo.getType && combo.getType() !== "combo") {
      console.warn("The combo does not exist!");
      return;
    }
    return combo.getChildren();
  };
  AbstractGraph2.prototype.positionsAnimate = function(referComboModel) {
    var self2 = this;
    self2.emit("beforeanimate");
    var animateCfg = self2.get("animateCfg");
    var onFrame = animateCfg.onFrame;
    var nodes = referComboModel ? self2.getNodes().concat(self2.getCombos()) : self2.getNodes();
    var toNodes = nodes.map(function(node) {
      var model = node.getModel();
      return {
        id: model.id,
        x: model.x,
        y: model.y
      };
    });
    if (self2.isAnimating()) {
      self2.stopAnimate();
    }
    var canvas = self2.get("canvas");
    canvas.animate(function(ratio) {
      each_default(toNodes, function(data) {
        var node = self2.findById(data.id);
        if (!node || node.destroyed) {
          return;
        }
        var originAttrs = node.get("originAttrs");
        var model = node.get("model");
        var containerMatrix = node.getContainer().getMatrix();
        if (originAttrs === void 0 || originAttrs === null) {
          if (containerMatrix) {
            originAttrs = {
              x: containerMatrix[6],
              y: containerMatrix[7]
            };
          }
          node.set("originAttrs", originAttrs || 0);
        }
        if (onFrame) {
          var attrs = onFrame(node, ratio, data, originAttrs || {
            x: 0,
            y: 0
          });
          node.set("model", Object.assign(model, attrs));
        } else if (originAttrs) {
          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;
          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;
        } else {
          model.x = data.x;
          model.y = data.y;
        }
      });
      self2.refreshPositions(referComboModel);
    }, {
      duration: animateCfg.duration,
      easing: animateCfg.easing,
      callback: function callback() {
        each_default(nodes, function(node) {
          node.set("originAttrs", null);
        });
        if (animateCfg.callback) {
          animateCfg.callback();
        }
        self2.emit("afteranimate");
        self2.animating = false;
      }
    });
  };
  AbstractGraph2.prototype.refreshPositions = function(referComboModel) {
    var self2 = this;
    self2.emit("beforegraphrefreshposition");
    var nodes = self2.get("nodes");
    var edges = self2.get("edges");
    var vedges = self2.get("vedges");
    var combos = self2.get("combos");
    var model;
    var updatedNodes = {};
    var updateItems = function updateItems2(items) {
      each_default(items, function(item) {
        model = item.getModel();
        var originAttrs = item.get("originAttrs");
        if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {
          return;
        }
        var changed = item.updatePosition({
          x: model.x,
          y: model.y
        });
        updatedNodes[model.id] = changed;
        if (model.comboId)
          updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;
      });
    };
    updateItems(nodes);
    if (combos && combos.length !== 0) {
      if (referComboModel) {
        updateItems(combos);
        setTimeout(function() {
          self2.updateCombos();
        }, 0);
      } else {
        self2.updateCombos();
      }
    }
    each_default(edges, function(edge) {
      var sourceModel = edge.getSource().getModel();
      var target = edge.getTarget();
      if (!is_plain_object_default(target)) {
        var targetModel = target.getModel();
        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {
          edge.refresh();
        }
      }
    });
    each_default(vedges, function(vedge) {
      vedge.refresh();
    });
    self2.emit("aftergraphrefreshposition");
    self2.autoPaint();
  };
  AbstractGraph2.prototype.stopAnimate = function() {
    this.get("canvas").stopAnimate();
  };
  AbstractGraph2.prototype.isAnimating = function() {
    return this.animating;
  };
  AbstractGraph2.prototype.getZoom = function() {
    var matrix = this.get("group").getMatrix();
    return matrix ? matrix[0] : 1;
  };
  AbstractGraph2.prototype.getCurrentMode = function() {
    var modeController = this.get("modeController");
    return modeController.getMode();
  };
  AbstractGraph2.prototype.setMode = function(mode) {
    var modeController = this.get("modeController");
    modeController.setMode(mode);
    return this;
  };
  AbstractGraph2.prototype.clear = function(avoidEmit) {
    var _a2;
    if (avoidEmit === void 0) {
      avoidEmit = false;
    }
    (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.clear();
    this.initGroups();
    this.set({
      itemMap: {},
      nodes: [],
      edges: [],
      groups: [],
      combos: [],
      comboTrees: []
    });
    if (!avoidEmit)
      this.emit("afterrender");
    return this;
  };
  AbstractGraph2.prototype.updateLayout = function(cfg, align, alignPoint) {
    var _this = this;
    var layoutController = this.get("layoutController");
    if (is_string_default(cfg)) {
      cfg = {
        type: cfg
      };
    }
    if (align) {
      var toPoint_1 = alignPoint;
      if (!toPoint_1) {
        if (align === "begin")
          toPoint_1 = {
            x: 0,
            y: 0
          };
        else
          toPoint_1 = {
            x: this.getWidth() / 2,
            y: this.getHeight() / 2
          };
      }
      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);
      var forceTypes = ["force", "gForce", "fruchterman"];
      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {
        cfg.center = [toPoint_1.x, toPoint_1.y];
      } else {
        this.once("afterlayout", function(e8) {
          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];
          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];
          var _a2 = _this.getGroup().getCanvasBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY = _a2.maxY;
          var bboxPoint = {
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2
          };
          if (align === "begin") {
            bboxPoint.x = minX;
            bboxPoint.y = minY;
          }
          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);
        });
      }
    }
    var oriLayoutCfg = this.get("layout");
    var layoutCfg = {};
    Object.assign(layoutCfg, oriLayoutCfg, cfg);
    this.set("layout", layoutCfg);
    if (!layoutController)
      return;
    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {
      layoutController.updateLayoutCfg(layoutCfg);
    } else {
      layoutController.changeLayout(layoutCfg);
    }
  };
  AbstractGraph2.prototype.destroyLayout = function() {
    var layoutController = this.get("layoutController");
    layoutController === null || layoutController === void 0 ? void 0 : layoutController.destroyLayout();
  };
  AbstractGraph2.prototype.layout = function() {
    var layoutController = this.get("layoutController");
    var layoutCfg = this.get("layout");
    if (!layoutCfg || !layoutController)
      return;
    if (layoutCfg.workerEnabled) {
      layoutController.layout();
      return;
    }
    if (layoutController.layoutMethod) {
      layoutController.relayout(true);
    } else {
      layoutController.layout();
    }
  };
  AbstractGraph2.prototype.collapseCombo = function(combo) {
    var _this = this;
    if (this.destroyed)
      return;
    if (is_string_default(combo)) {
      combo = this.findById(combo);
    }
    if (!combo) {
      console.warn("The combo to be collapsed does not exist!");
      return;
    }
    this.emit("beforecollapseexpandcombo", {
      action: "expand",
      item: combo
    });
    var comboModel = combo.getModel();
    var itemController = this.get("itemController");
    itemController.collapseCombo(combo);
    comboModel.collapsed = true;
    var edges = this.getEdges().concat(this.get("vedges"));
    var cnodes = [];
    var ccombos = [];
    var comboTrees = this.get("comboTrees");
    var found = false;
    (comboTrees || []).forEach(function(ctree) {
      if (found)
        return;
      traverseTree(ctree, function(subTree) {
        if (found && subTree.depth <= comboModel.depth)
          return false;
        if (comboModel.id === subTree.id)
          found = true;
        if (found) {
          var item = _this.findById(subTree.id);
          if (item && item.getType && item.getType() === "combo") {
            cnodes = cnodes.concat(item.getNodes());
            ccombos = ccombos.concat(item.getCombos());
          }
        }
        return true;
      });
    });
    var edgeWeightMap = {};
    var addedVEdges = [];
    edges.forEach(function(edge) {
      if (edge.isVisible() && !edge.getModel().isVEdge)
        return;
      var source = edge.getSource();
      var target = edge.getTarget();
      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || source.getModel().id === comboModel.id) {
        var edgeModel = edge.getModel();
        if (edgeModel.isVEdge) {
          _this.removeItem(edge, false);
          return;
        }
        var targetModel = target.getModel();
        while (!target.isVisible()) {
          target = _this.findById(targetModel.parentId || targetModel.comboId);
          if (!target || !targetModel.parentId && !targetModel.comboId)
            return;
          targetModel = target.getModel();
        }
        var targetId = targetModel.id;
        if (edgeWeightMap["".concat(comboModel.id, "-").concat(targetId)]) {
          edgeWeightMap["".concat(comboModel.id, "-").concat(targetId)] += edgeModel.size || 1;
          return;
        }
        var vedge = _this.addItem("vedge", {
          source: comboModel.id,
          target: targetId,
          isVEdge: true
        }, false);
        edgeWeightMap["".concat(comboModel.id, "-").concat(targetId)] = edgeModel.size || 1;
        addedVEdges.push(vedge);
      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || target.getModel().id === comboModel.id) {
        var edgeModel = edge.getModel();
        if (edgeModel.isVEdge) {
          _this.removeItem(edge, false);
          return;
        }
        var sourceModel = source.getModel();
        while (!source.isVisible()) {
          source = _this.findById(sourceModel.parentId || sourceModel.comboId);
          if (!source || !sourceModel.parentId && !sourceModel.comboId)
            return;
          sourceModel = source.getModel();
        }
        var sourceId = sourceModel.id;
        if (edgeWeightMap["".concat(sourceId, "-").concat(comboModel.id)]) {
          edgeWeightMap["".concat(sourceId, "-").concat(comboModel.id)] += edgeModel.size || 1;
          return;
        }
        var vedge = _this.addItem("vedge", {
          target: comboModel.id,
          source: sourceId,
          isVEdge: true
        }, false);
        edgeWeightMap["".concat(sourceId, "-").concat(comboModel.id)] = edgeModel.size || 1;
        addedVEdges.push(vedge);
      }
    });
    addedVEdges.forEach(function(vedge) {
      var vedgeModel = vedge.getModel();
      _this.updateItem(vedge, {
        size: edgeWeightMap["".concat(vedgeModel.source, "-").concat(vedgeModel.target)]
      }, false);
    });
    this.emit("aftercollapseexpandcombo", {
      action: "collapse",
      item: combo
    });
  };
  AbstractGraph2.prototype.expandCombo = function(combo) {
    var _this = this;
    if (is_string_default(combo)) {
      combo = this.findById(combo);
    }
    if (!combo || combo.getType && combo.getType() !== "combo") {
      console.warn("The combo to be collapsed does not exist!");
      return;
    }
    this.emit("beforecollapseexpandcombo", {
      action: "expand",
      item: combo
    });
    var comboModel = combo.getModel();
    var itemController = this.get("itemController");
    itemController.expandCombo(combo);
    comboModel.collapsed = false;
    var edges = this.getEdges().concat(this.get("vedges"));
    var cnodes = [];
    var ccombos = [];
    var comboTrees = this.get("comboTrees");
    var found = false;
    (comboTrees || []).forEach(function(ctree) {
      if (found)
        return;
      traverseTree(ctree, function(subTree) {
        if (found && subTree.depth <= comboModel.depth)
          return false;
        if (comboModel.id === subTree.id)
          found = true;
        if (found) {
          var item = _this.findById(subTree.id);
          if (item && item.getType && item.getType() === "combo") {
            cnodes = cnodes.concat(item.getNodes());
            ccombos = ccombos.concat(item.getCombos());
          }
        }
        return true;
      });
    });
    var edgeWeightMap = {};
    var addedVEdges = {};
    edges.forEach(function(edge) {
      if (edge.isVisible() && !edge.getModel().isVEdge)
        return;
      var source = edge.getSource();
      var target = edge.getTarget();
      var sourceId = source.get("id");
      var targetId = target.get("id");
      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || sourceId === comboModel.id) {
        if (edge.getModel().isVEdge) {
          _this.removeItem(edge, false);
          return;
        }
        var targetModel = target.getModel();
        while (!target.isVisible()) {
          target = _this.findById(targetModel.comboId || targetModel.parentId);
          if (!target || !targetModel.parentId && !targetModel.comboId) {
            return;
          }
          targetModel = target.getModel();
        }
        targetId = targetModel.id;
        var sourceModel = source.getModel();
        while (!source.isVisible()) {
          source = _this.findById(sourceModel.comboId || sourceModel.parentId);
          if (!source || !sourceModel.parentId && !sourceModel.comboId) {
            return;
          }
          if (sourceModel.comboId === comboModel.id || sourceModel.parentId === comboModel.id) {
            break;
          }
          sourceModel = source.getModel();
        }
        sourceId = sourceModel.id;
        if (targetId) {
          var vedgeId = "".concat(sourceId, "-").concat(targetId);
          if (edgeWeightMap[vedgeId]) {
            edgeWeightMap[vedgeId] += edge.getModel().size || 1;
            _this.updateItem(addedVEdges[vedgeId], {
              size: edgeWeightMap[vedgeId]
            }, false);
            return;
          }
          var vedge = _this.addItem("vedge", {
            source: sourceId,
            target: targetId,
            isVEdge: true
          }, false);
          edgeWeightMap[vedgeId] = edge.getModel().size || 1;
          addedVEdges[vedgeId] = vedge;
        }
      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || targetId === comboModel.id) {
        if (edge.getModel().isVEdge) {
          _this.removeItem(edge, false);
          return;
        }
        var sourceModel = source.getModel();
        while (!source.isVisible()) {
          source = _this.findById(sourceModel.comboId || sourceModel.parentId);
          if (!source || !sourceModel.parentId && !sourceModel.comboId) {
            return;
          }
          sourceModel = source.getModel();
        }
        sourceId = sourceModel.id;
        var targetModel = target.getModel();
        while (!target.isVisible()) {
          target = _this.findById(targetModel.comboId || targetModel.parentId);
          if (!target || !targetModel.parentId && !targetModel.comboId) {
            return;
          }
          if (targetModel.comboId === comboModel.id || targetModel.parentId === comboModel.id) {
            break;
          }
          targetModel = target.getModel();
        }
        targetId = targetModel.id;
        if (sourceId) {
          var vedgeId = "".concat(sourceId, "-").concat(targetId);
          if (edgeWeightMap[vedgeId]) {
            edgeWeightMap[vedgeId] += edge.getModel().size || 1;
            _this.updateItem(addedVEdges[vedgeId], {
              size: edgeWeightMap[vedgeId]
            }, false);
            return;
          }
          var vedge = _this.addItem("vedge", {
            target: targetId,
            source: sourceId,
            isVEdge: true
          }, false);
          edgeWeightMap[vedgeId] = edge.getModel().size || 1;
          addedVEdges[vedgeId] = vedge;
        }
      } else if ((cnodes.includes(source) || ccombos.includes(source)) && (cnodes.includes(target) || ccombos.includes(target))) {
        if (source.isVisible() && target.isVisible()) {
          edge.show();
        }
      }
    });
    this.emit("aftercollapseexpandcombo", {
      action: "expand",
      item: combo
    });
  };
  AbstractGraph2.prototype.collapseExpandCombo = function(combo) {
    if (is_string_default(combo)) {
      combo = this.findById(combo);
    }
    if (!combo || combo.getType && combo.getType() !== "combo")
      return;
    var comboModel = combo.getModel();
    var parentItem = this.findById(comboModel.parentId);
    while (parentItem) {
      var parentModel = parentItem.getModel();
      if (parentModel.collapsed) {
        console.warn("Fail to expand the combo since it's ancestor combo is collapsed.");
        parentItem = void 0;
        return;
      }
      parentItem = this.findById(parentModel.parentId);
    }
    var collapsed = comboModel.collapsed;
    if (collapsed) {
      this.expandCombo(combo);
    } else {
      this.collapseCombo(combo);
    }
    this.updateCombo(combo);
  };
  AbstractGraph2.prototype.sortCombos = function() {
    var _this = this;
    var comboSorted = this.get("comboSorted");
    if (comboSorted)
      return;
    this.set("comboSorted", true);
    var depthMap = [];
    var dataDepthMap = {};
    var comboTrees = this.get("comboTrees");
    (comboTrees || []).forEach(function(cTree) {
      traverseTree(cTree, function(child) {
        if (depthMap[child.depth])
          depthMap[child.depth].push(child.id);
        else
          depthMap[child.depth] = [child.id];
        dataDepthMap[child.id] = child.depth;
        return true;
      });
    });
    var edges = this.getEdges().concat(this.get("vedges"));
    (edges || []).forEach(function(edgeItem) {
      var edge = edgeItem.getModel();
      var sourceDepth = dataDepthMap[edge.source] || 0;
      var targetDepth = dataDepthMap[edge.target] || 0;
      var depth = Math.max(sourceDepth, targetDepth);
      if (depthMap[depth])
        depthMap[depth].push(edge.id);
      else
        depthMap[depth] = [edge.id];
    });
    depthMap.forEach(function(array) {
      if (!array || !array.length)
        return;
      for (var i2 = array.length - 1; i2 >= 0; i2--) {
        var item = _this.findById(array[i2]);
        if (item)
          item.toFront();
      }
    });
  };
  AbstractGraph2.prototype.getNeighbors = function(node, type) {
    var item = node;
    if (is_string_default(node)) {
      item = this.findById(node);
    }
    return item.getNeighbors(type);
  };
  AbstractGraph2.prototype.getNodeDegree = function(node, type, refresh) {
    if (type === void 0) {
      type = void 0;
    }
    if (refresh === void 0) {
      refresh = false;
    }
    var item = node;
    if (is_string_default(node)) {
      item = this.findById(node);
    }
    var degrees2 = this.get("degrees");
    if (!degrees2 || refresh) {
      degrees2 = degree_default(this.save());
      this.set("degrees", degrees2);
    }
    var nodeDegrees = degrees2[item.getID()];
    var res = 0;
    if (!nodeDegrees) {
      return 0;
    }
    switch (type) {
      case "in":
        res = nodeDegrees.inDegree;
        break;
      case "out":
        res = nodeDegrees.outDegree;
        break;
      case "all":
        res = nodeDegrees;
        break;
      default:
        res = nodeDegrees.degree;
        break;
    }
    return res;
  };
  AbstractGraph2.prototype.getUndoStack = function() {
    return this.undoStack;
  };
  AbstractGraph2.prototype.getRedoStack = function() {
    return this.redoStack;
  };
  AbstractGraph2.prototype.getStackData = function() {
    if (!this.get("enabledStack")) {
      return null;
    }
    return {
      undoStack: this.undoStack.toArray(),
      redoStack: this.redoStack.toArray()
    };
  };
  AbstractGraph2.prototype.clearStack = function() {
    if (this.get("enabledStack")) {
      this.undoStack.clear();
      this.redoStack.clear();
    }
  };
  AbstractGraph2.prototype.pushStack = function(action, data, stackType) {
    if (action === void 0) {
      action = "update";
    }
    if (stackType === void 0) {
      stackType = "undo";
    }
    if (!this.get("enabledStack")) {
      console.warn("\u8BF7\u5148\u542F\u7528 undo & redo \u529F\u80FD\uFF0C\u5728\u5B9E\u4F8B\u5316 Graph \u65F6\u5019\u914D\u7F6E enabledStack: true !");
      return;
    }
    var stackData = data ? clone_default(data) : {
      before: {},
      after: clone_default(this.save())
    };
    if (stackType === "redo") {
      this.redoStack.push({
        action,
        data: stackData
      });
    } else {
      this.undoStack.push({
        action,
        data: stackData
      });
    }
    this.emit("stackchange", {
      undoStack: this.undoStack,
      redoStack: this.redoStack
    });
  };
  AbstractGraph2.prototype.getAdjMatrix = function(cache3, directed) {
    if (cache3 === void 0) {
      cache3 = true;
    }
    if (directed === void 0)
      directed = this.get("directed");
    var currentAdjMatrix = this.get("adjMatrix");
    if (!currentAdjMatrix || !cache3) {
      currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
      this.set("adjMatrix", currentAdjMatrix);
    }
    return currentAdjMatrix;
  };
  AbstractGraph2.prototype.getShortestPathMatrix = function(cache3, directed) {
    if (cache3 === void 0) {
      cache3 = true;
    }
    if (directed === void 0)
      directed = this.get("directed");
    var currentAdjMatrix = this.get("adjMatrix");
    var currentShourtestPathMatrix = this.get("shortestPathMatrix");
    if (!currentAdjMatrix || !cache3) {
      currentAdjMatrix = adjacent_matrix_default(this.save(), directed);
      this.set("adjMatrix", currentAdjMatrix);
    }
    if (!currentShourtestPathMatrix || !cache3) {
      currentShourtestPathMatrix = floydWarshall_default(this.save(), directed);
      this.set("shortestPathMatrix", currentShourtestPathMatrix);
    }
    return currentShourtestPathMatrix;
  };
  AbstractGraph2.prototype.on = function(eventName, callback, once) {
    return _super.prototype.on.call(this, eventName, callback, once);
  };
  AbstractGraph2.prototype.destroy = function() {
    var _a2, _b, _c, _d, _e2;
    this.clear();
    this.clearStack();
    (_a2 = this.get("itemController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    (_b = this.get("modeController")) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.get("viewController")) === null || _c === void 0 ? void 0 : _c.destroy();
    (_d = this.get("stateController")) === null || _d === void 0 ? void 0 : _d.destroy();
    (_e2 = this.get("canvas")) === null || _e2 === void 0 ? void 0 : _e2.destroy();
    this.cfg = null;
    this.destroyed = true;
    this.redoStack = null;
    this.undoStack = null;
  };
  AbstractGraph2.prototype.createHull = function(cfg) {
    if (!cfg.members || cfg.members.length < 1) {
      console.warn("Create hull failed! The members is empty.");
      return;
    }
    var parent = this.get("hullGroup");
    var hullMap = this.get("hullMap");
    if (!hullMap) {
      hullMap = {};
      this.set("hullMap", hullMap);
    }
    if (!parent || parent.get("destroyed")) {
      parent = this.get("group").addGroup({
        id: "hullGroup"
      });
      parent.toBack();
      this.set("hullGroup", parent);
    }
    if (hullMap[cfg.id]) {
      console.warn("Existed hull id.");
      return hullMap[cfg.id];
    }
    var group = parent.addGroup({
      id: "".concat(cfg.id, "-container")
    });
    var hull = new hull_default(this, __assign2(__assign2({}, cfg), {
      group
    }));
    var hullId = hull.id;
    hullMap[hullId] = hull;
    return hull;
  };
  AbstractGraph2.prototype.getHulls = function() {
    return this.get("hullMap");
  };
  AbstractGraph2.prototype.getHullById = function(hullId) {
    return this.get("hullMap")[hullId];
  };
  AbstractGraph2.prototype.removeHull = function(hull) {
    var _a2;
    var hullInstance;
    if (is_string_default(hull)) {
      hullInstance = this.getHullById(hull);
    } else {
      hullInstance = hull;
    }
    (_a2 = this.get("hullMap")) === null || _a2 === void 0 ? true : delete _a2[hullInstance.id];
    hullInstance.destroy();
  };
  AbstractGraph2.prototype.removeHulls = function() {
    var hulls = this.getHulls();
    if (!hulls || !Object.keys(hulls).length)
      return;
    Object.keys(hulls).forEach(function(key) {
      var hull = hulls[key];
      hull.destroy();
    });
    this.set("hullMap", {});
  };
  return AbstractGraph2;
}(esm_default);
var graph_default = AbstractGraph;

// node_modules/@antv/g6-core/es/element/node.js
init_esm();

// node_modules/@antv/g6-core/es/element/shapeBase.js
init_esm();
function _typeof3(obj) {
  "@babel/helpers - typeof";
  return _typeof3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof3(obj);
}
var transform5 = ext_exports.transform;
var CLS_SHAPE_SUFFIX = "-shape";
var CLS_LABEL_SUFFIX = "-label";
var ARROWS = ["startArrow", "endArrow"];
var SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: void 0,
  fill: void 0,
  lineAppendWidth: 1,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  x: 0,
  y: 0,
  r: 10,
  width: 20,
  height: 20,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var PATH_SHAPE_DEFAULT_ATTRS = {
  lineWidth: 1,
  stroke: "#000",
  lineDash: void 0,
  startArrow: false,
  endArrow: false,
  opacity: void 0,
  strokeOpacity: void 0,
  fillOpacity: void 0,
  shadowColor: void 0,
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var SHAPES_DEFAULT_ATTRS = {
  edge: PATH_SHAPE_DEFAULT_ATTRS,
  node: SHAPE_DEFAULT_ATTRS,
  combo: SHAPE_DEFAULT_ATTRS
};
var CLS_LABEL_BG_SUFFIX = "-label-bg";
var shapeBase = {
  options: {
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    descriptionCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    }
  },
  itemType: "",
  type: "",
  getCustomConfig: function getCustomConfig(cfg) {
    return {};
  },
  getOptions: function getOptions(cfg, updateType) {
    if (updateType === "move" || (updateType === null || updateType === void 0 ? void 0 : updateType.includes("bbox"))) {
      return {};
    }
    return deep_mix_default({}, this.options, this.getCustomConfig(cfg) || {}, cfg);
  },
  draw: function draw3(cfg, group) {
    group["shapeMap"] = {};
    this.mergeStyle = this.getOptions(cfg);
    var shape = this.drawShape(cfg, group);
    shape.set("className", this.itemType + CLS_SHAPE_SUFFIX);
    group["shapeMap"][this.itemType + CLS_SHAPE_SUFFIX] = shape;
    if (cfg.label) {
      var label = this.drawLabel(cfg, group);
      label.set("className", this.itemType + CLS_LABEL_SUFFIX);
      group["shapeMap"][this.itemType + CLS_LABEL_SUFFIX] = label;
    }
    return shape;
  },
  afterDraw: function afterDraw2(cfg, group, keyShape) {
  },
  drawShape: function drawShape2(cfg, group) {
    return null;
  },
  drawLabel: function drawLabel(cfg, group) {
    var defaultLabelCfg = (this.mergeStyle || this.getOptions(cfg) || {}).labelCfg;
    var labelCfg = defaultLabelCfg || {};
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate7 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      draggable: true,
      className: "text-shape",
      name: "text-shape",
      labelRelated: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate7) && rotate7 !== "") {
      var labelBBox = label.getBBox();
      var labelMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (labelStyle.rotateCenter) {
        switch (labelStyle.rotateCenter) {
          case "center":
            labelMatrix = transform5(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate7], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
          case "lefttop":
            labelMatrix = transform5(labelMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate7], ["t", labelStyle.x, labelStyle.y]]);
            break;
          case "leftcenter":
            labelMatrix = transform5(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate7], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
            break;
          default:
            labelMatrix = transform5(labelMatrix, [["t", -labelBBox.width / 2, -labelBBox.height / 2], ["r", rotate7], ["t", labelBBox.width / 2, labelBBox.height / 2]]);
            break;
        }
      } else {
        labelMatrix = transform5(labelMatrix, [["t", -labelStyle.x, -labelStyle.y - labelBBox.height / 2], ["r", rotate7], ["t", labelStyle.x, labelStyle.y + labelBBox.height / 2]]);
      }
      label.setMatrix(labelMatrix);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg(cfg, group, label) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = mix({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {
    return {
      text: cfg.label
    };
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, labelCfg) {
    return {};
  },
  getLabelStyle: function getLabelStyle(cfg, labelCfg, group) {
    var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
    var attrName = "".concat(this.itemType, "Label");
    var defaultStyle = global_default[attrName] ? global_default[attrName].style : null;
    return __assign2(__assign2(__assign2({}, defaultStyle), calculateStyle), labelCfg.style);
  },
  getShapeStyle: function getShapeStyle(cfg) {
    return cfg.style;
  },
  update: function update2(cfg, item, updateType) {
    this.updateShapeStyle(cfg, item, updateType);
    this.updateLabel(cfg, item, updateType);
  },
  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = item.getKeyShape();
    var shapeStyle = mix({}, shape.attr(), cfg.style);
    var _loop_1 = function _loop_12(key2) {
      var _b;
      var style = shapeStyle[key2];
      if (is_plain_object_default(style)) {
        var subShape = ((_a2 = group["shapeMap"]) === null || _a2 === void 0 ? void 0 : _a2[key2]) || group.find(function(element) {
          return element.get("name") === key2;
        });
        subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
      } else {
        shape.attr((_b = {}, _b[key2] = style, _b));
      }
    };
    for (var key in shapeStyle) {
      _loop_1(key);
    }
  },
  updateLabel: function updateLabel(cfg, item, updateType) {
    var _a2, _b;
    if (cfg.label || cfg.label === "") {
      var group = item.getContainer();
      var _c = (this.mergeStyle || this.getOptions({}, updateType) || {}).labelCfg, labelCfg = _c === void 0 ? {} : _c;
      var labelClassName_1 = this.itemType + CLS_LABEL_SUFFIX;
      var label = group["shapeMap"][labelClassName_1] || group.find(function(ele) {
        return ele.get("className") === labelClassName_1;
      });
      var labelBgClassname_1 = this.itemType + CLS_LABEL_BG_SUFFIX;
      var labelBg = group["shapeMap"][labelBgClassname_1] || group.find(function(ele) {
        return ele.get("className") === labelBgClassname_1;
      });
      if (!label) {
        var newLabel = this.drawLabel(cfg, group);
        newLabel.set("className", labelClassName_1);
        group["shapeMap"][labelClassName_1] = newLabel;
      } else {
        if (!updateType || updateType === "bbox|label" || this.itemType === "edge" && updateType !== "style") {
          labelCfg = deep_mix_default(labelCfg, cfg.labelCfg);
        }
        var calculateStyle = this.getLabelStyleByPosition(cfg, labelCfg, group);
        var cfgStyle = (_a2 = cfg.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style;
        var labelStyle = __assign2(__assign2({}, calculateStyle), cfgStyle);
        var rotate7 = labelStyle.rotate;
        delete labelStyle.rotate;
        if (!isNaN(rotate7) && rotate7 !== "") {
          var rotateMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
          rotateMatrix = transform5(rotateMatrix, [["t", -labelStyle.x, -labelStyle.y], ["r", rotate7], ["t", labelStyle.x, labelStyle.y]]);
          labelStyle.matrix = rotateMatrix;
          label.attr(labelStyle);
        } else {
          if (((_b = label.getMatrix()) === null || _b === void 0 ? void 0 : _b[4]) !== 1) {
            label.resetMatrix();
          }
          label.attr(labelStyle);
        }
        if (!labelBg) {
          if (labelStyle.background) {
            labelBg = this.drawLabelBg(cfg, group, label);
            labelBg.set("classname", labelBgClassname_1);
            group["shapeMap"][labelBgClassname_1] = labelBg;
            label.toFront();
          }
        } else if (labelStyle.background) {
          var calculateBgStyle = this.getLabelBgStyleByPosition(label, labelCfg);
          labelBg.attr(calculateBgStyle);
        } else {
          group.removeChild(labelBg);
        }
      }
    }
  },
  afterUpdate: function afterUpdate2(cfg, item) {
  },
  setState: function setState3(name, value, item) {
    var _a2, _b;
    var _c;
    var shape = item.get("keyShape");
    if (!shape || shape.destroyed)
      return;
    var type = item.getType();
    var stateName = is_boolean_default(value) ? name : "".concat(name, ":").concat(value);
    var shapeStateStyle = this.getStateStyle(stateName, item);
    var itemStateStyle = item.getStateStyle(stateName);
    if (!itemStateStyle && !shapeStateStyle) {
      return;
    }
    var styles = mix({}, itemStateStyle || shapeStateStyle);
    var group = item.getContainer();
    var keptAttrs = {
      x: 1,
      y: 1,
      cx: 1,
      cy: 1,
      matrix: 1
    };
    if (type === "combo") {
      keptAttrs.r = 1;
      keptAttrs.width = 1;
      keptAttrs.height = 1;
    }
    if (value) {
      var _loop_2 = function _loop_22(key2) {
        var _d;
        var style = styles[key2];
        if (is_plain_object_default(style) && !ARROWS.includes(key2)) {
          var subShape = ((_c = group["shapeMap"]) === null || _c === void 0 ? void 0 : _c[key2]) || group.find(function(element) {
            return element.get("name") === key2;
          });
          subShape === null || subShape === void 0 ? void 0 : subShape.attr(style);
        } else {
          shape.attr((_d = {}, _d[key2] = style, _d));
        }
      };
      for (var key in styles) {
        _loop_2(key);
      }
    } else {
      var enableStatesStyle = cloneBesidesImg(item.getCurrentStatesStyle());
      var model = item.getModel();
      var originStyle_1 = mix({}, model.style, cloneBesidesImg(item.getOriginStyle()));
      var keyShapeName_1 = shape.get("name");
      var shapeAttrs_1 = shape.attr();
      var keyShapeStyles_1 = {};
      Object.keys(shapeAttrs_1).forEach(function(key2) {
        if (key2 === "img")
          return;
        var attr = shapeAttrs_1[key2];
        if (attr && _typeof3(attr) === "object") {
          keyShapeStyles_1[key2] = clone_default(attr);
        } else {
          keyShapeStyles_1[key2] = attr;
        }
      });
      var filtetDisableStatesStyle = {};
      var _loop_3 = function _loop_32(p3) {
        var style = styles[p3];
        if (is_plain_object_default(style) && !ARROWS.includes(p3)) {
          var subShape_1 = group["shapeMap"][p3] || group.find(function(ele) {
            return ele.get("name") === p3;
          });
          if (subShape_1) {
            var subShapeStyles_1 = cloneBesidesImg(subShape_1.attr());
            each_default(style, function(v2, key2) {
              if (p3 === keyShapeName_1 && keyShapeStyles_1[key2] && !keptAttrs[key2]) {
                delete keyShapeStyles_1[key2];
                var value_1 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                shape.attr(key2, value_1);
              } else if (subShapeStyles_1[key2] || subShapeStyles_1[key2] === 0) {
                delete subShapeStyles_1[key2];
                var value_2 = originStyle_1[p3][key2] || SHAPES_DEFAULT_ATTRS[type][key2];
                subShape_1.attr(key2, value_2);
              }
            });
            filtetDisableStatesStyle[p3] = subShapeStyles_1;
          }
        } else {
          if (keyShapeStyles_1[p3] && !keptAttrs[p3]) {
            delete keyShapeStyles_1[p3];
            var value_3 = originStyle_1[p3] || (originStyle_1[keyShapeName_1] ? originStyle_1[keyShapeName_1][p3] : void 0) || SHAPES_DEFAULT_ATTRS[type][p3];
            shape.attr(p3, value_3);
          }
        }
      };
      for (var p2 in styles) {
        _loop_3(p2);
      }
      if (!keyShapeName_1) {
        mix(filtetDisableStatesStyle, keyShapeStyles_1);
      } else {
        filtetDisableStatesStyle[keyShapeName_1] = keyShapeStyles_1;
      }
      for (var key in enableStatesStyle) {
        if (keptAttrs[key])
          continue;
        var enableStyle = enableStatesStyle[key];
        if (!is_plain_object_default(enableStyle) || ARROWS.includes(key)) {
          if (!keyShapeName_1) {
            mix(originStyle_1, (_a2 = {}, _a2[key] = enableStyle, _a2));
          } else {
            mix(originStyle_1[keyShapeName_1], (_b = {}, _b[key] = enableStyle, _b));
            delete originStyle_1[key];
          }
          delete enableStatesStyle[key];
        }
      }
      var originstyles = {};
      deep_mix_default(originstyles, originStyle_1, filtetDisableStatesStyle, enableStatesStyle);
      var keyShapeSetted = false;
      var _loop_4 = function _loop_42(originKey2) {
        var _e2, _f;
        var style = originstyles[originKey2];
        if (is_plain_object_default(style) && !ARROWS.includes(originKey2)) {
          var subShape = group["shapeMap"][originKey2] || group.find(function(ele) {
            return ele.get("name") === originKey2;
          });
          if (subShape) {
            if (subShape.get("type") === "text" || subShape.get("labelRelated")) {
              delete style.x;
              delete style.y;
              delete style.matrix;
            }
            if (originKey2 === keyShapeName_1) {
              if (type === "combo") {
                delete style.r;
                delete style.width;
                delete style.height;
              }
              keyShapeSetted = true;
            }
            subShape.attr(style);
          }
        } else if (!keyShapeSetted) {
          var value_4 = style || SHAPES_DEFAULT_ATTRS[type][originKey2];
          if (type === "combo") {
            if (!keyShapeName_1) {
              shape.attr((_e2 = {}, _e2[originKey2] = value_4, _e2));
            }
          } else {
            shape.attr((_f = {}, _f[originKey2] = value_4, _f));
          }
        }
      };
      for (var originKey in originstyles) {
        _loop_4(originKey);
      }
    }
  },
  getStateStyle: function getStateStyle(name, item) {
    var model = item.getModel();
    var type = item.getType();
    var _a2 = this.getOptions(model), stateStyles = _a2.stateStyles, _b = _a2.style, style = _b === void 0 ? {} : _b;
    var modelStateStyle = model.stateStyles ? model.stateStyles[name] : stateStyles && stateStyles[name];
    if (type === "combo") {
      return clone_default(modelStateStyle);
    }
    return mix({}, style, modelStateStyle);
  },
  getControlPoints: function getControlPoints3(cfg) {
    return cfg.controlPoints;
  },
  getAnchorPoints: function getAnchorPoints3(cfg) {
    var _a2, _b;
    var anchorPoints = (cfg === null || cfg === void 0 ? void 0 : cfg.anchorPoints) || ((_a2 = this.getCustomConfig(cfg)) === null || _a2 === void 0 ? void 0 : _a2.anchorPoints) || ((_b = this.options) === null || _b === void 0 ? void 0 : _b.anchorPoints);
    return anchorPoints;
  }
};

// node_modules/@antv/g6-core/es/element/node.js
var singleNode = {
  itemType: "node",
  shapeType: "single-node",
  labelPosition: "center",
  offset: global_default.nodeLabel.offset,
  getSize: function getSize(cfg) {
    var _a2;
    var size2 = ((_a2 = this.mergeStyle) === null || _a2 === void 0 ? void 0 : _a2.size) || cfg.size || this.getOptions({}).size || global_default.defaultNode.size;
    if (is_array_default(size2) && size2.length === 1) {
      size2 = [size2[0], size2[0]];
    }
    if (!is_array_default(size2)) {
      size2 = [size2, size2];
    }
    return size2;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition2(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    if (labelPosition === "center") {
      return {
        x: 0,
        y: 0,
        text: cfg.label,
        textBaseline: "middle",
        textAlign: "center"
      };
    }
    var offset = labelCfg.offset;
    if (is_nil_default(offset)) {
      offset = this.offset;
    }
    var size2 = this.getSize(cfg);
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -size2[1] / 2 - offset,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: size2[1] / 2 + offset,
          textBaseline: "top",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -size2[0] / 2 - offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "right"
        };
        break;
      default:
        style = {
          x: size2[0] / 2 + offset,
          y: 0,
          textBaseline: "middle",
          textAlign: "left"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition2(label, labelCfg) {
    var _a2;
    if (!label)
      return {};
    var backgroundStyle = (_a2 = labelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.background;
    if (!backgroundStyle)
      return {};
    var bbox = label.getBBox();
    var padding = formatPadding(backgroundStyle.padding);
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    return __assign2(__assign2({
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0]
    }, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight
    });
  },
  drawShape: function drawShape3(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "node-shape"
    });
    group["shapeMap"]["node-shape"] = shape;
    return shape;
  },
  updateLinkPoints: function updateLinkPoints(cfg, group) {
    var defaultLinkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints;
    if (markLeft) {
      currentLinkPoints = markLeft.attr();
    }
    if (markRight && !currentLinkPoints) {
      currentLinkPoints = markRight.attr();
    }
    if (markTop && !currentLinkPoints) {
      currentLinkPoints = markTop.attr();
    }
    if (markBottom && !currentLinkPoints) {
      currentLinkPoints = markBottom.attr();
    }
    if (!currentLinkPoints)
      currentLinkPoints = defaultLinkPoints;
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, bottom = _a2.bottom;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign2(__assign2({}, styles), {
          x: -width / 2,
          y: 0
        }));
      }
    } else if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign2(__assign2({}, styles), {
          x: -width / 2,
          y: 0
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      }
      markRight.attr(__assign2(__assign2({}, styles), {
        x: width / 2,
        y: 0
      }));
    } else if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign2(__assign2({}, styles), {
          x: width / 2,
          y: 0
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      }
      markTop.attr(__assign2(__assign2({}, styles), {
        x: 0,
        y: -height / 2
      }));
    } else if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign2(__assign2({}, styles), {
          x: 0,
          y: -height / 2
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (markBottom) {
      if (!bottom && bottom !== void 0) {
        markBottom.remove();
        delete group["shapeMap"]["link-point-bottom"];
      } else {
        markBottom.attr(__assign2(__assign2({}, styles), {
          x: 0,
          y: height / 2
        }));
      }
    } else if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign2(__assign2({}, styles), {
          x: 0,
          y: height / 2
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  updateShape: function updateShape(cfg, item, keyShapeStyle, hasIcon, updateType) {
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign2({}, keyShapeStyle));
    if (true) {
      this.updateLabel(cfg, item, updateType);
    }
    if (hasIcon) {
      this.updateIcon(cfg, item);
    }
  },
  updateIcon: function updateIcon(cfg, item) {
    var _this = this;
    var group = item.getContainer();
    var icon = (this.mergeStyle || this.getOptions(cfg)).icon;
    var _a2 = cfg.icon ? cfg.icon : {
      show: void 0,
      text: void 0
    }, show = _a2.show, text = _a2.text;
    var iconShape = group["shapeMap"]["".concat(this.type, "-icon")] || group.find(function(ele) {
      return ele.get("name") === "".concat(_this.type, "-icon");
    });
    if (iconShape) {
      if (show || show === void 0) {
        var iconConfig = mix({}, iconShape.attr(), icon);
        var _b = iconConfig.width, w2 = _b === void 0 ? 20 : _b, _c = iconConfig.height, h2 = _c === void 0 ? 20 : _c;
        if (iconConfig.fontFamily === "iconfont" || iconConfig.hasOwnProperty("text")) {
          w2 = 0;
          h2 = 0;
        }
        iconShape.attr(__assign2(__assign2({}, iconConfig), {
          x: -w2 / 2,
          y: -h2 / 2
        }));
      } else {
        iconShape.remove();
      }
    } else if (show) {
      var name_5 = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][name_5] = group.addShape("text", {
          attrs: __assign2({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: name_5,
          name: name_5
        });
      } else {
        var w2 = icon.width, h2 = icon.height;
        group["shapeMap"][name_5] = group.addShape("image", {
          attrs: __assign2(__assign2({}, icon), {
            x: -w2 / 2,
            y: -h2 / 2
          }),
          className: name_5,
          name: name_5
        });
      }
      var labelShape = group["shapeMap"]["node-label"] || group.find(function(ele) {
        return ele.get("name") === "node-label";
      });
      if (labelShape) {
        labelShape.toFront();
      }
    }
  }
};
var singleNodeDef = __assign2(__assign2({}, shapeBase), singleNode);
shape_default2.registerNode("single-node", singleNodeDef);

// node_modules/@antv/g6-core/es/element/edge.js
init_esm();
var CLS_SHAPE = "edge-shape";
function revertAlign(labelPosition) {
  var textAlign = labelPosition;
  if (labelPosition === "start") {
    textAlign = "end";
  } else if (labelPosition === "end") {
    textAlign = "start";
  }
  return textAlign;
}
var singleEdge = {
  itemType: "edge",
  labelPosition: "center",
  refX: 0,
  refY: 0,
  labelAutoRotate: false,
  options: {
    size: global_default.defaultEdge.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultEdge.style.stroke,
      lineAppendWidth: global_default.defaultEdge.style.lineAppendWidth
    },
    labelCfg: {
      style: {
        fill: global_default.edgeLabel.style.fill,
        fontSize: global_default.edgeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign2({}, global_default.edgeStateStyles)
  },
  getPath: function getPath(points) {
    var path = [];
    each_default(points, function(point, index) {
      if (index === 0) {
        path.push(["M", point.x, point.y]);
      } else {
        path.push(["L", point.x, point.y]);
      }
    });
    return path;
  },
  getShapeStyle: function getShapeStyle2(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size2 = cfg.size || global_default.defaultEdge.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var path = this.getPath(points);
    var styles = mix({}, global_default.defaultEdge.style, {
      stroke: global_default.defaultEdge.color,
      lineWidth: size2,
      path
    }, style);
    return styles;
  },
  updateShapeStyle: function updateShapeStyle2(cfg, item, updateType) {
    var _a2;
    var group = item.getContainer();
    var shape = ((_a2 = item.getKeyShape) === null || _a2 === void 0 ? void 0 : _a2.call(item)) || group["shapeMap"]["edge-shape"];
    var size2 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = cfg.style || {};
    if (previousStyle.stroke === void 0) {
      previousStyle.stroke = cfg.color;
    }
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var routeCfg = {
      radius: previousStyle.radius
    };
    if (!controlPoints) {
      routeCfg = {
        source,
        target,
        offset: previousStyle.offset,
        radius: previousStyle.radius
      };
    }
    var path = this.getPath(points, routeCfg);
    var style = {};
    if (updateType === "move") {
      style = {
        path
      };
    } else {
      if (currentAttr.endArrow && previousStyle.endArrow === false) {
        cfg.style.endArrow = {
          path: ""
        };
      }
      if (currentAttr.startArrow && previousStyle.startArrow === false) {
        cfg.style.startArrow = {
          path: ""
        };
      }
      style = __assign2({}, cfg.style);
      if (style.lineWidth === void 0)
        style.lineWdith = (is_number_default(size2) ? size2 : size2 === null || size2 === void 0 ? void 0 : size2[0]) || currentAttr.lineWidth;
      if (style.path === void 0)
        style.path = path;
      if (style.stroke === void 0)
        style.stroke = currentAttr.stroke || cfg.color;
    }
    if (shape) {
      shape.attr(style);
    }
  },
  getLabelStyleByPosition: function getLabelStyleByPosition3(cfg, labelCfg, group) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var style = {};
    var pathShape = group === null || group === void 0 ? void 0 : group["shapeMap"][CLS_SHAPE];
    var pointPercent;
    if (labelPosition === "start") {
      pointPercent = 0;
    } else if (labelPosition === "end") {
      pointPercent = 1;
    } else {
      pointPercent = 0.5;
    }
    var offsetX = labelCfg.refX || this.refX;
    var offsetY = labelCfg.refY || this.refY;
    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {
      style.x = cfg.startPoint.x + offsetX;
      style.y = cfg.startPoint.y + offsetY;
      style.text = cfg.label;
      return style;
    }
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate))
      autoRotate = this.labelAutoRotate;
    else
      autoRotate = labelCfg.autoRotate;
    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);
    style.x = offsetStyle.x;
    style.y = offsetStyle.y;
    style.rotate = offsetStyle.rotate;
    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);
    style.text = cfg.label;
    return style;
  },
  getLabelBgStyleByPosition: function getLabelBgStyleByPosition3(label, labelCfg) {
    if (!label) {
      return {};
    }
    var bbox = label.getBBox();
    var backgroundStyle = labelCfg.style && labelCfg.style.background;
    if (!backgroundStyle) {
      return {};
    }
    var padding = backgroundStyle.padding;
    var backgroundWidth = bbox.width + padding[1] + padding[3];
    var backgroundHeight = bbox.height + padding[0] + padding[2];
    var style = __assign2(__assign2({}, backgroundStyle), {
      width: backgroundWidth,
      height: backgroundHeight,
      x: bbox.minX - padding[3],
      y: bbox.minY - padding[0],
      matrix: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    });
    var autoRotate;
    if (is_nil_default(labelCfg.autoRotate))
      autoRotate = this.labelAutoRotate;
    else
      autoRotate = labelCfg.autoRotate;
    if (autoRotate) {
      style.matrix = label.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    return style;
  },
  _getTextAlign: function _getTextAlign(labelPosition, angle3) {
    var textAlign = "center";
    if (!angle3) {
      return labelPosition;
    }
    angle3 = angle3 % (Math.PI * 2);
    if (labelPosition !== "center") {
      if (angle3 >= 0 && angle3 <= Math.PI / 2 || angle3 >= 3 / 2 * Math.PI && angle3 < 2 * Math.PI) {
        textAlign = labelPosition;
      } else {
        textAlign = revertAlign(labelPosition);
      }
    }
    return textAlign;
  },
  getControlPoints: function getControlPoints4(cfg) {
    return cfg.controlPoints;
  },
  getPathPoints: function getPathPoints(cfg) {
    return cfg;
  },
  drawShape: function drawShape4(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    var shape = group.addShape("path", {
      className: CLS_SHAPE,
      name: CLS_SHAPE,
      attrs: shapeStyle
    });
    group["shapeMap"][CLS_SHAPE] = shape;
    return shape;
  },
  drawLabel: function drawLabel2(cfg, group) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);
    var rotate7 = labelStyle.rotate;
    delete labelStyle.rotate;
    var label = group.addShape("text", {
      attrs: labelStyle,
      name: "text-shape",
      labelRelated: true
    });
    group["shapeMap"]["text-shape"] = label;
    if (!isNaN(rotate7) && rotate7 !== "") {
      label.rotateAtStart(rotate7);
    }
    if (labelStyle.background) {
      var rect2 = this.drawLabelBg(cfg, group, label, labelStyle, rotate7);
      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;
      rect2.set("classname", labelBgClassname);
      group["shapeMap"][labelBgClassname] = rect2;
      label.toFront();
    }
    return label;
  },
  drawLabelBg: function drawLabelBg2(cfg, group, label, labelStyle, rotate7) {
    var defaultLabelCfg = this.options.labelCfg;
    var labelCfg = deep_mix_default({}, defaultLabelCfg, cfg.labelCfg);
    var style = this.getLabelBgStyleByPosition(label, labelCfg);
    var rect2 = group.addShape("rect", {
      name: "text-bg-shape",
      attrs: style,
      labelRelated: true
    });
    group["shapeMap"]["text-bg-shape"] = rect2;
    return rect2;
  }
};
var singleEdgeDef = __assign2(__assign2({}, shapeBase), singleEdge);
shape_default2.registerEdge("single-edge", singleEdgeDef);
shape_default2.registerEdge("line", {
  getControlPoints: function getControlPoints5() {
    return void 0;
  }
}, "single-edge");
shape_default2.registerEdge("spline", {
  getPath: function getPath2(points) {
    var path = getSpline(points);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("arc", {
  curveOffset: 20,
  clockwise: 1,
  getControlPoints: function getControlPoints6(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var midPoint = {
      x: (startPoint.x + endPoint.x) / 2,
      y: (startPoint.y + endPoint.y) / 2
    };
    var center;
    var arcPoint;
    if (cfg.controlPoints !== void 0) {
      arcPoint = cfg.controlPoints[0];
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 0 : 1;
      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {
        this.clockwise = center.x > arcPoint.x ? 1 : 0;
      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {
        this.clockwise = center.y < arcPoint.y ? 0 : 1;
      } else {
        this.clockwise = center.y < arcPoint.y ? 1 : 0;
      }
      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {
        return [];
      }
    } else {
      if (cfg.curveOffset === void 0) {
        cfg.curveOffset = this.curveOffset;
      }
      if (is_array_default(cfg.curveOffset)) {
        cfg.curveOffset = cfg.curveOffset[0];
      }
      if (cfg.curveOffset < 0) {
        this.clockwise = 0;
      } else {
        this.clockwise = 1;
      }
      var vec = {
        x: endPoint.x - startPoint.x,
        y: endPoint.y - startPoint.y
      };
      var edgeAngle = Math.atan2(vec.y, vec.x);
      arcPoint = {
        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,
        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y
      };
      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);
    }
    var radius = distance4(startPoint, center);
    var controlPoints = [{
      x: radius,
      y: radius
    }];
    return controlPoints;
  },
  getPath: function getPath3(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    if (points.length === 2) {
      path.push(["L", points[1].x, points[1].y]);
    } else {
      path.push(["A", points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);
    }
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("quadratic", {
  curvePosition: 0.5,
  curveOffset: -20,
  getControlPoints: function getControlPoints7(cfg) {
    var controlPoints = cfg.controlPoints;
    if (!controlPoints || !controlPoints.length) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      if (cfg.curveOffset === void 0)
        cfg.curveOffset = this.curveOffset;
      if (cfg.curvePosition === void 0)
        cfg.curvePosition = this.curvePosition;
      if (is_array_default(this.curveOffset))
        cfg.curveOffset = cfg.curveOffset[0];
      if (is_array_default(this.curvePosition))
        cfg.curvePosition = cfg.curveOffset[0];
      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);
      controlPoints = [innerPoint];
    }
    return controlPoints;
  },
  getPath: function getPath4(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["Q", points[1].x, points[1].y, points[2].x, points[2].y]);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("cubic", {
  curvePosition: [1 / 2, 1 / 2],
  curveOffset: [-20, 20],
  getControlPoints: function getControlPoints8(cfg) {
    var controlPoints = cfg.controlPoints;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {
      var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);
      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);
      controlPoints = [innerPoint1, innerPoint2];
    }
    return controlPoints;
  },
  getPath: function getPath5(points) {
    var path = [];
    path.push(["M", points[0].x, points[0].y]);
    path.push(["C", points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);
    return path;
  }
}, "single-edge");
shape_default2.registerEdge("cubic-vertical", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints9(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0)
      cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset))
      cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var yDist = endPoint.y - startPoint.y;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x,
      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]
    };
    var innerPoint2 = {
      x: endPoint.x,
      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]
    };
    return [innerPoint1, innerPoint2];
  }
}, "cubic");
shape_default2.registerEdge("cubic-horizontal", {
  curvePosition: [1 / 2, 1 / 2],
  minCurveOffset: [0, 0],
  curveOffset: void 0,
  getControlPoints: function getControlPoints10(cfg) {
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    if (cfg.curvePosition === void 0)
      cfg.curvePosition = this.curvePosition;
    if (cfg.curveOffset === void 0)
      cfg.curveOffset = this.curveOffset;
    if (cfg.minCurveOffset === void 0)
      cfg.minCurveOffset = this.minCurveOffset;
    if (is_number_default(cfg.curveOffset))
      cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];
    if (is_number_default(cfg.minCurveOffset))
      cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];
    if (is_number_default(cfg.curvePosition))
      cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];
    var xDist = endPoint.x - startPoint.x;
    var curveOffset = [0, 0];
    if (cfg.curveOffset) {
      curveOffset = cfg.curveOffset;
    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {
      curveOffset = cfg.minCurveOffset;
    }
    var innerPoint1 = {
      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],
      y: startPoint.y
    };
    var innerPoint2 = {
      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],
      y: endPoint.y
    };
    var controlPoints = [innerPoint1, innerPoint2];
    return controlPoints;
  }
}, "cubic");
shape_default2.registerEdge("loop", {
  getPathPoints: function getPathPoints2(cfg) {
    return getLoopCfgs(cfg);
  },
  getControlPoints: function getControlPoints11(cfg) {
    return cfg.controlPoints;
  },
  afterDraw: function afterDraw3(cfg) {
    cfg.controlPoints = void 0;
  },
  afterUpdate: function afterUpdate3(cfg) {
    cfg.controlPoints = void 0;
  }
}, "cubic");

// node_modules/@antv/g6-core/es/element/combo.js
init_esm();
var singleCombo = {
  itemType: "combo",
  shapeType: "single-combo",
  labelPosition: "top",
  refX: global_default.comboLabel.refX,
  refY: global_default.comboLabel.refY,
  options: {
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign2({}, global_default.comboStateStyles)
  },
  getSize: function getSize2(cfg) {
    var size2 = clone_default(cfg.size || this.options.size || global_default.defaultCombo.size);
    if (is_array_default(size2) && size2.length === 1) {
      size2 = [size2[0], size2[0]];
    }
    if (!is_array_default(size2)) {
      size2 = [size2, size2];
    }
    return size2;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition4(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = padding[0];
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var size2 = this.getSize(cfg);
    var r2 = Math.max(cfgStyle.r, size2[0] / 2) || size2[0] / 2;
    var dis = r2 + padding;
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0,
          y: -dis - refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: dis + refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: -dis + refX,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: dis + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  drawShape: function drawShape5(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    var shape = group.addShape(shapeType, {
      attrs: style,
      draggable: true,
      name: "combo-shape"
    });
    return shape;
  },
  updateShape: function updateShape2(cfg, item, keyShapeStyle) {
    var keyShape = item.get("keyShape");
    var animate = cfg.animate === void 0 ? this.options.animate : cfg.animate;
    if (animate && keyShape.animate) {
      keyShape.animate(keyShapeStyle, {
        duration: 200,
        easing: "easeLinear"
      });
    } else {
      keyShape.attr(__assign2({}, keyShapeStyle));
    }
    this.updateLabel(cfg, item);
  }
};
var singleComboDef = __assign2(__assign2({}, shapeBase), singleCombo);
shape_default2.registerCombo("single-combo", singleComboDef);

// node_modules/@antv/g6-core/es/element/combos/circle.js
init_esm();
shape_default2.registerCombo("circle", {
  options: {
    size: [global_default.defaultCombo.size[0], global_default.defaultCombo.size[0]],
    padding: global_default.defaultCombo.padding[0],
    animate: true,
    style: {
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize
      },
      refX: 0,
      refY: 0
    },
    stateStyles: __assign2({}, global_default.comboStateStyles)
  },
  shapeType: "circle",
  labelPosition: "top",
  drawShape: function drawShape6(cfg, group) {
    var style = this.getShapeStyle(cfg);
    delete style.height;
    delete style.width;
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "circle-combo",
      name: "circle-combo",
      draggable: true
    });
    return keyShape;
  },
  getShapeStyle: function getShapeStyle3(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = padding[0];
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var r2;
    if (cfg.fixSize) {
      r2 = is_number_default(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];
    } else {
      var size2 = this.getSize(cfg);
      if (!is_number_default(style.r) || isNaN(style.r))
        r2 = size2[0] / 2 || global_default.defaultCombo.style.r;
      else
        r2 = Math.max(style.r, size2[0] / 2) || size2[0] / 2;
    }
    style.r = r2 + padding;
    var styles = __assign2({
      x: 0,
      y: 0
    }, style);
    if (cfg.style)
      cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    return styles;
  },
  update: function update3(cfg, item) {
    var size2 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_array_default(padding))
      padding = padding[0];
    var cfgStyle = clone_default(cfg.style);
    var r2;
    if (cfg.fixSize) {
      r2 = is_number_default(cfg.fixSize) ? cfg.fixSize : cfg.fixSize[0];
    } else {
      r2 = Math.max(cfgStyle.r, size2[0] / 2) || size2[0] / 2;
    }
    cfgStyle.r = r2 + padding;
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.r = cfgStyle.r;
    }
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style)
      cfg.style.r = r2;
    else {
      cfg.style = {
        r: r2
      };
    }
    this.updateShape(cfg, item, style, true);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/combos/rect.js
init_esm();
shape_default2.registerCombo("rect", {
  options: {
    size: [40, 5],
    padding: [25, 20, 15, 20],
    animate: true,
    style: {
      radius: 0,
      stroke: global_default.defaultCombo.style.stroke,
      fill: global_default.defaultCombo.style.fill,
      lineWidth: global_default.defaultCombo.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.comboLabel.style.fill,
        fontSize: global_default.comboLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign2({}, global_default.comboStateStyles)
  },
  shapeType: "rect",
  labelPosition: "top",
  drawShape: function drawShape7(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "rect-combo",
      name: "rect-combo",
      draggable: true
    });
    return keyShape;
  },
  getLabelStyleByPosition: function getLabelStyleByPosition5(cfg, labelCfg) {
    var labelPosition = labelCfg.position || this.labelPosition;
    var cfgStyle = cfg.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var refX = labelCfg.refX, refY = labelCfg.refY;
    if (is_nil_default(refX)) {
      refX = this.refX;
    }
    if (is_nil_default(refY)) {
      refY = this.refY;
    }
    var leftDis = cfgStyle.width / 2 + padding[3];
    var topDis = cfgStyle.height / 2 + padding[0];
    var style;
    switch (labelPosition) {
      case "top":
        style = {
          x: 0 - leftDis + refX,
          y: 0 - topDis + refY,
          textBaseline: "top",
          textAlign: "left"
        };
        break;
      case "bottom":
        style = {
          x: 0,
          y: topDis + refY,
          textBaseline: "bottom",
          textAlign: "center"
        };
        break;
      case "left":
        style = {
          x: 0 - leftDis + refY,
          y: 0,
          textAlign: "left"
        };
        break;
      case "center":
        style = {
          x: 0,
          y: 0,
          text: cfg.label,
          textAlign: "center"
        };
        break;
      default:
        style = {
          x: leftDis + refX,
          y: 0,
          textAlign: "right"
        };
        break;
    }
    style.text = cfg.label;
    return style;
  },
  getShapeStyle: function getShapeStyle4(cfg) {
    var defaultStyle = this.options.style;
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    var size2 = this.getSize(cfg);
    var width;
    var height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      if (!is_number_default(style.width) || isNaN(style.width))
        width = size2[0] || global_default.defaultCombo.style.width;
      else
        width = Math.max(style.width, size2[0]) || size2[0];
      if (!is_number_default(style.height) || isNaN(style.height))
        height = size2[1] || global_default.defaultCombo.style.height;
      else
        height = Math.max(style.height, size2[1]) || size2[1];
    }
    var x2 = -width / 2 - padding[3];
    var y2 = -height / 2 - padding[0];
    style.width = width + padding[1] + padding[3];
    style.height = height + padding[0] + padding[2];
    var styles = __assign2({
      x: x2,
      y: y2
    }, style);
    if (!cfg.style) {
      cfg.style = {
        width,
        height
      };
    } else {
      cfg.style.width = width;
      cfg.style.height = height;
    }
    return styles;
  },
  update: function update4(cfg, item) {
    var size2 = this.getSize(cfg);
    var padding = cfg.padding || this.options.padding;
    if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var cfgStyle = clone_default(cfg.style);
    var width, height;
    var fixSize = cfg.collapsed && cfg.fixCollapseSize ? cfg.fixCollapseSize : cfg.fixSize;
    if (fixSize) {
      if (is_number_default(fixSize)) {
        width = fixSize;
        height = fixSize;
      } else {
        width = fixSize[0];
        height = fixSize[1];
      }
    } else {
      width = Math.max(cfgStyle.width, size2[0]) || size2[0];
      height = Math.max(cfgStyle.height, size2[1]) || size2[1];
    }
    cfgStyle.width = width + padding[1] + padding[3];
    cfgStyle.height = height + padding[0] + padding[2];
    var itemCacheSize = item.get("sizeCache");
    if (itemCacheSize) {
      itemCacheSize.width = cfgStyle.width;
      itemCacheSize.height = cfgStyle.height;
    }
    cfgStyle.x = -width / 2 - padding[3];
    cfgStyle.y = -height / 2 - padding[0];
    var strokeStyle = {
      stroke: cfg.color
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, keyShape.attr(), strokeStyle, cfgStyle);
    if (cfg.style) {
      cfg.style.width = width;
      cfg.style.height = height;
    } else {
      cfg.style = {
        width,
        height
      };
    }
    this.updateShape(cfg, item, style, false);
  },
  updateShape: function updateShape3(cfg, item, keyShapeStyle) {
    var keyShape = item.get("keyShape");
    var animate = cfg.animate === void 0 ? this.options.animate : cfg.animate;
    if (animate && keyShape.animate) {
      keyShape.animate(keyShapeStyle, {
        duration: 200,
        easing: "easeLinear"
      });
    } else {
      keyShape.attr(__assign2({}, keyShapeStyle));
    }
    this.updateLabel(cfg, item);
  }
}, "single-combo");

// node_modules/@antv/g6-core/es/element/nodes/simple-circle.js
init_esm();
shape_default2.registerNode("simple-circle", {
  options: {
    size: global_default.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    stateStyles: __assign2({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-circle",
  labelPosition: "center",
  shapeMap: {},
  drawShape: function drawShape8(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    return keyShape;
  },
  getShapeStyle: function getShapeStyle5(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var r2 = size2[0] / 2;
    var styles = __assign2({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update5(cfg, item, updateType) {
    var size2 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      r: size2[0] / 2
    };
    var keyShape = item.get("keyShape");
    var style = deep_mix_default({}, keyShape.attr(), strokeStyle, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/simple-rect.js
init_esm();
shape_default2.registerNode("simple-rect", {
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: global_default.defaultNode.style.stroke,
      fill: global_default.defaultNode.style.fill,
      lineWidth: global_default.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: global_default.nodeLabel.style.fill,
        fontSize: global_default.nodeLabel.style.fontSize,
        fontFamily: global_default.windowFontFamily
      }
    },
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign2({}, global_default.nodeStateStyles)
  },
  shapeType: "simple-rect",
  labelPosition: "center",
  drawShape: function drawShape9(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    return keyShape;
  },
  getShapeStyle: function getShapeStyle6(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var width = style.width || size2[0];
    var height = style.height || size2[1];
    var styles = __assign2({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update6(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var size2 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size2[0] = keyShape.attr("width") || defaultStyle.width;
      size2[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size2[0] / 2,
      y: -size2[1] / 2,
      width: size2[0],
      height: size2[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/nodes/image.js
shape_default2.registerNode("image", {
  options: {
    img: "https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ",
    size: 200,
    labelCfg: {
      style: {
        fontFamily: global_default.windowFontFamily
      }
    },
    clipCfg: {
      show: false,
      type: "circle",
      r: 50,
      rx: 50,
      ry: 35,
      width: 50,
      height: 35,
      points: [[30, 12], [12, 30], [30, 48], [48, 30]],
      path: [["M", 25, 25], ["L", 50, 25], ["A", 12.5, 12.5, 0, 1, 1, 50, 50], ["A", 12.5, 12.5, 0, 1, 0, 50, 50], ["L", 25, 75], ["Z"]],
      x: 0,
      y: 0
    }
  },
  shapeType: "image",
  labelPosition: "bottom",
  drawShape: function drawShape10(cfg, group) {
    var shapeType = this.shapeType;
    var style = this.getShapeStyle(cfg);
    delete style.fill;
    var shape = group.addShape(shapeType, {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    this.drawClip(cfg, shape);
    return shape;
  },
  drawClip: function drawClip(cfg, shape) {
    var clip = (this.mergeStyle || this.getOptions(cfg)).clipCfg;
    if (!clip.show) {
      return;
    }
    var type = clip.type, x2 = clip.x, y2 = clip.y, style = clip.style;
    if (type === "circle") {
      var r2 = clip.r;
      shape.setClip({
        type: "circle",
        attrs: __assign2({
          r: r2,
          x: x2,
          y: y2
        }, style)
      });
    } else if (type === "rect") {
      var width = clip.width, height = clip.height;
      var rectX = x2 - width / 2;
      var rectY = y2 - height / 2;
      shape.setClip({
        type: "rect",
        attrs: __assign2({
          x: rectX,
          y: rectY,
          width,
          height
        }, style)
      });
    } else if (type === "ellipse") {
      var rx = clip.rx, ry = clip.ry;
      shape.setClip({
        type: "ellipse",
        attrs: __assign2({
          x: x2,
          y: y2,
          rx,
          ry
        }, style)
      });
    } else if (type === "polygon") {
      var points = clip.points;
      shape.setClip({
        type: "polygon",
        attrs: __assign2({
          points
        }, style)
      });
    } else if (type === "path") {
      var path = clip.path;
      shape.setClip({
        type: "path",
        attrs: __assign2({
          path
        }, style)
      });
    }
  },
  getShapeStyle: function getShapeStyle7(cfg) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), defaultStyle = _a2.style, img = _a2.img;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    if (defaultStyle) {
      width = defaultStyle.width || size2[0];
      height = defaultStyle.height || size2[1];
    }
    var style = __assign2({
      x: -width / 2,
      y: -height / 2,
      width,
      height,
      img
    }, defaultStyle);
    return style;
  },
  updateShapeStyle: function updateShapeStyle3(cfg, item) {
    var group = item.getContainer();
    var shapeClassName = "".concat(this.itemType, "-shape");
    var shape = group["shapeMap"][shapeClassName] || group.find(function(element) {
      return element.get("className") === shapeClassName;
    }) || item.getKeyShape();
    var shapeStyle = this.getShapeStyle(cfg);
    if (shape && !shape.destroyed) {
      shape.attr(shapeStyle);
    }
  }
}, "single-node");

// node_modules/@antv/g6-core/es/element/arrow.js
var arrow_default = {
  triangle: function triangle(width, length5, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length5 === void 0) {
      length5 = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length5, ",-").concat(width / 2, " L ").concat(begin + length5, ",").concat(width / 2, " Z");
    return path;
  },
  vee: function vee(width, length5, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length5 === void 0) {
      length5 = 20;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 L ").concat(begin + length5, ",-").concat(width / 2, "\n        L ").concat(begin + 2 * length5 / 3, ",0 L ").concat(begin + length5, ",").concat(width / 2, " Z");
    return path;
  },
  circle: function circle(r2, d2) {
    if (r2 === void 0) {
      r2 = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ", 0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(r2 * 2, ",0\n            a ").concat(r2, ",").concat(r2, " 0 1,0 ").concat(-r2 * 2, ",0");
    return path;
  },
  rect: function rect(width, length5, d2) {
    if (width === void 0) {
      width = 10;
    }
    if (length5 === void 0) {
      length5 = 10;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",").concat(-width / 2, " \n        L ").concat(begin + length5, ",").concat(-width / 2, " \n        L ").concat(begin + length5, ",").concat(width / 2, " \n        L ").concat(begin, ",").concat(width / 2, " Z");
    return path;
  },
  diamond: function diamond(width, length5, d2) {
    if (width === void 0) {
      width = 15;
    }
    if (length5 === void 0) {
      length5 = 15;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var path = "M ".concat(begin, ",0 \n        L ").concat(begin + length5 / 2, ",").concat(-width / 2, " \n        L ").concat(begin + length5, ",0 \n        L ").concat(begin + length5 / 2, ",").concat(width / 2, " Z");
    return path;
  },
  triangleRect: function triangleRect(tWidth, tLength, rWidth, rLength, gap, d2) {
    if (tWidth === void 0) {
      tWidth = 15;
    }
    if (tLength === void 0) {
      tLength = 15;
    }
    if (rWidth === void 0) {
      rWidth = 15;
    }
    if (rLength === void 0) {
      rLength = 3;
    }
    if (gap === void 0) {
      gap = 5;
    }
    if (d2 === void 0) {
      d2 = 0;
    }
    var begin = d2 * 2;
    var rectBegin = begin + tLength + gap;
    var path = "M ".concat(begin, ",0 L ").concat(begin + tLength, ",-").concat(tWidth / 2, " L ").concat(begin + tLength, ",").concat(tWidth / 2, " Z\n            M ").concat(rectBegin, ", -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " -").concat(rWidth / 2, "\n            L ").concat(rectBegin + rLength, " ").concat(rWidth / 2, "\n            L ").concat(rectBegin, " ").concat(rWidth / 2, "\n            Z");
    return path;
  }
};

// node_modules/@antv/g6-core/es/element/marker.js
var marker_default = {
  collapse: function collapse(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x2 - r2 + 4, y2], ["L", x2 + r2 - 4, y2]];
  },
  expand: function expand(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["a", r2, r2, 0, 1, 0, r2 * 2, 0], ["a", r2, r2, 0, 1, 0, -r2 * 2, 0], ["M", x2 - r2 + 4, y2], ["L", x2 - r2 + 2 * r2 - 4, y2], ["M", x2 - r2 + r2, y2 - r2 + 4], ["L", x2, y2 + r2 - 4]];
  },
  upTriangle: function upTriangle(x2, y2, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x2 - l1, y2 + l2], ["L", x2 + l1, y2 + l2], ["L", x2, y2 - r2], ["Z"]];
  },
  downTriangle: function downTriangle(x2, y2, r2) {
    var l1 = r2 * Math.cos(Math.PI / 6);
    var l2 = r2 * Math.sin(Math.PI / 6);
    return [["M", x2 - l1, y2 - l2], ["L", x2 + l1, y2 - l2], ["L", x2, y2 + r2], ["Z"]];
  }
};

// node_modules/@antv/g6-core/es/element/index.js
var element_default2 = shape_default2;

// node_modules/@antv/g6-core/es/util/color.js
var color_exports = {};
__export(color_exports, {
  defaultSubjectColors: () => defaultSubjectColors
});
var defaultSubjectColors = ["#5F95FF", "#61DDAA", "#65789B", "#F6BD16", "#7262FD", "#78D3F8", "#9661BC", "#F6903D", "#008685", "#F08BB4"];

// node_modules/@antv/g6-core/es/util/index.js
var transform6 = ext_exports.transform;
var Util = __assign2(__assign2(__assign2(__assign2(__assign2(__assign2({}, base_exports), graphic_exports), path_exports2), math_exports), color_exports), {
  transform: transform6,
  mat3: mat3_exports
});
var util_default = Util;

// node_modules/@antv/g6-core/es/graph/controller/layout.js
init_esm();
var LayoutController = function() {
  function LayoutController3(graph) {
    this.graph = graph;
    this.layoutCfg = graph.get("layout") || {};
    this.layoutType = this.getLayoutType();
    this.layoutMethods = [];
    this.initLayout();
  }
  LayoutController3.prototype.initLayout = function() {
  };
  LayoutController3.prototype.getLayoutType = function() {
    return this.getLayoutCfgType(this.layoutCfg);
  };
  LayoutController3.prototype.getLayoutCfgType = function(layoutCfg) {
    var type = layoutCfg.type;
    if (type) {
      return type;
    }
    var pipes = layoutCfg.pipes;
    if (Array.isArray(pipes)) {
      return pipes.map(function(pipe) {
        return (pipe === null || pipe === void 0 ? void 0 : pipe.type) || "";
      });
    }
    return null;
  };
  LayoutController3.prototype.isLayoutTypeSame = function(cfg) {
    var current = this.getLayoutCfgType(cfg);
    if (Array.isArray(this.layoutType)) {
      return this.layoutType.every(function(type, index) {
        return type === current[index];
      });
    }
    return (cfg === null || cfg === void 0 ? void 0 : cfg.type) === this.layoutType;
  };
  LayoutController3.prototype.refreshLayout = function() {
    var _a2 = this, graph = _a2.graph, layoutType = _a2.layoutType, data = _a2.data;
    if (!graph)
      return;
    if (graph.get("animate")) {
      graph.positionsAnimate(layoutType === "comboCombined");
    } else {
      graph.refreshPositions(layoutType === "comboCombined");
    }
  };
  LayoutController3.prototype.changeLayout = function(cfg) {
    this.layoutCfg = cfg;
    this.destoryLayoutMethods();
    this.layout();
  };
  LayoutController3.prototype.changeData = function() {
    this.destoryLayoutMethods();
    this.layout();
  };
  LayoutController3.prototype.destoryLayoutMethods = function() {
    var layoutMethods = this.layoutMethods;
    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod) {
      layoutMethod.destroy();
    });
    this.layoutMethods = [];
  };
  LayoutController3.prototype.destroyLayout = function() {
    var graph = this.graph;
    this.destoryLayoutMethods();
    graph.set("layout", void 0);
    this.layoutCfg = void 0;
    this.layoutType = void 0;
    this.layoutMethods = void 0;
  };
  LayoutController3.prototype.setDataFromGraph = function() {
    var nodes = [];
    var hiddenNodes = [];
    var edges = [];
    var hiddenEdges = [];
    var comboEdges = [];
    var combos = [];
    var hiddenCombos = [];
    var nodeItems = this.graph.getNodes();
    var edgeItems = this.graph.getEdges();
    var comboItems = this.graph.getCombos();
    var nodeLength = nodeItems.length;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var nodeItem = nodeItems[i2];
      if (!nodeItem || nodeItem.destroyed)
        continue;
      var model = nodeItem.getModel();
      if (!nodeItem.isVisible()) {
        hiddenNodes.push(model);
        continue;
      }
      nodes.push(model);
    }
    var edgeLength = edgeItems.length;
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edgeItem = edgeItems[i2];
      if (!edgeItem || edgeItem.destroyed)
        continue;
      var model = edgeItem.getModel();
      if (!edgeItem.isVisible()) {
        hiddenEdges.push(model);
        continue;
      }
      if (!model.isComboEdge)
        edges.push(model);
      else
        comboEdges.push(model);
    }
    var comboLength = comboItems.length;
    for (var i2 = 0; i2 < comboLength; i2++) {
      var comboItem = comboItems[i2];
      if (comboItem.destroyed)
        continue;
      var model = comboItem.getModel();
      if (!comboItem.isVisible()) {
        hiddenCombos.push(model);
        continue;
      }
      combos.push(model);
    }
    return {
      nodes,
      hiddenNodes,
      edges,
      hiddenEdges,
      combos,
      hiddenCombos,
      comboEdges
    };
  };
  LayoutController3.prototype.reLayoutMethod = function(layoutMethod, layoutCfg) {
    var _this = this;
    return new Promise(function(reslove, reject) {
      var graph = _this.graph;
      var layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type;
      layoutCfg.onLayoutEnd = function() {
        graph.emit("aftersublayout", {
          type: layoutType
        });
        reslove();
      };
      layoutMethod.init(_this.data);
      if (layoutType === "force") {
        layoutMethod.ticking = false;
        layoutMethod.forceSimulation.stop();
      }
      graph.emit("beforesublayout", {
        type: layoutType
      });
      layoutMethod.execute();
      if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd)
        layoutCfg.onLayoutEnd();
    });
  };
  LayoutController3.prototype.relayout = function(reloadData) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods, layoutCfg = _a2.layoutCfg;
    if (reloadData) {
      this.data = this.setDataFromGraph();
      var nodes = this.data.nodes;
      if (!nodes) {
        return false;
      }
      this.initPositions(layoutCfg.center, nodes);
    }
    graph.emit("beforelayout");
    var start = Promise.resolve();
    layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod, index) {
      var currentCfg = layoutCfg[index];
      start = start.then(function() {
        return _this.reLayoutMethod(layoutMethod, currentCfg);
      });
    });
    if (layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length) {
      start.then(function() {
        if (layoutCfg.onAllLayoutEnd)
          layoutCfg.onAllLayoutEnd();
      }).catch(function(error) {
        console.warn("relayout failed", error);
      });
    }
  };
  LayoutController3.prototype.filterLayoutData = function(data, cfg) {
    var nodes = data.nodes, edges = data.edges, rest = __rest2(data, ["nodes", "edges"]);
    if (!nodes) {
      return data;
    }
    var nodesFilter;
    var edegsFilter;
    if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.nodesFilter)) {
      nodesFilter = cfg.nodesFilter;
    } else {
      nodesFilter = function nodesFilter2() {
        return true;
      };
    }
    var fNodes = nodes.filter(nodesFilter);
    if (is_function_default(cfg === null || cfg === void 0 ? void 0 : cfg.edgesFilter)) {
      edegsFilter = cfg.edgesFilter;
    } else {
      var nodesMap_1 = fNodes.reduce(function(acc, cur) {
        acc[cur.id] = true;
        return acc;
      }, {});
      edegsFilter = function edegsFilter2(edge) {
        return nodesMap_1[edge.source] && nodesMap_1[edge.target];
      };
    }
    return __assign2({
      nodes: fNodes,
      edges: edges.filter(edegsFilter)
    }, rest);
  };
  LayoutController3.prototype.getLayoutBBox = function(nodes) {
    var graph = this.graph;
    var graphGroupNodes = group_by_default(graph.getNodes(), function(n2) {
      return n2.getModel().layoutOrder;
    });
    var layoutNodes = Object.values(graphGroupNodes).map(function(value) {
      var bbox = calculationItemsBBox(value);
      bbox.size = [bbox.width, bbox.height];
      return bbox;
    });
    var groupNodes = Object.values(group_by_default(nodes, "layoutOrder"));
    return {
      groupNodes,
      layoutNodes
    };
  };
  LayoutController3.prototype.layoutAnimate = function() {
  };
  LayoutController3.prototype.moveToZero = function() {
    var graph = this.graph;
    var data = graph.get("data");
    var nodes = data.nodes;
    if (nodes[0].x === void 0 || nodes[0].x === null || isNaN2(nodes[0].x)) {
      return;
    }
    var meanCenter = [0, 0];
    var nodeLength = nodes.length;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      meanCenter[0] += node.x;
      meanCenter[1] += node.y;
    }
    meanCenter[0] /= nodes.length;
    meanCenter[1] /= nodes.length;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      node.x -= meanCenter[0];
      node.y -= meanCenter[1];
    }
  };
  LayoutController3.prototype.initPositions = function(center, nodes) {
    var graph = this.graph;
    if (!nodes) {
      return false;
    }
    var nodeLength = nodes ? nodes.length : 0;
    if (!nodeLength)
      return;
    var width = graph.get("width") * 0.85;
    var height = graph.get("height") * 0.85;
    var horiNum = Math.ceil(Math.sqrt(nodeLength) * (width / height));
    var vertiNum = Math.ceil(nodeLength / horiNum);
    var horiGap = width / (horiNum - 1);
    var vertiGap = height / (vertiNum - 1);
    if (!isFinite(horiGap) || !horiGap)
      horiGap = 0;
    if (!isFinite(vertiGap) || !horiGap)
      vertiGap = 0;
    var beginX = center[0] - width / 2;
    var beginY = center[1] - height / 2;
    var allHavePos = true;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      if (isNaN2(+node.x)) {
        allHavePos = false;
        node.x = i2 % horiNum * horiGap + beginX;
      }
      if (isNaN2(+node.y)) {
        allHavePos = false;
        node.y = Math.floor(i2 / horiNum) * vertiGap + beginY;
      }
    }
    return allHavePos;
  };
  LayoutController3.prototype.destroy = function() {
    this.graph = null;
    this.destoryLayoutMethods();
    this.destroyed = true;
  };
  return LayoutController3;
}();
var layout_default = LayoutController;

// node_modules/@antv/g6-core/es/graph/controller/event.js
var EventController2 = function() {
  function EventController4(graph) {
    this.graph = graph;
    this.destroyed = false;
    this.initEvents();
  }
  return EventController4;
}();
var event_default = EventController2;

// node_modules/@antv/g6-core/es/index.js
var registerNode = element_default2.registerNode;
var registerEdge = element_default2.registerEdge;
var registerCombo = element_default2.registerCombo;
var registerBehavior = behavior_default2.registerBehavior;
var BaseGlobal = global_default;
var es_default2 = {
  version: global_default.version,
  AbstractGraph: graph_default,
  BaseGlobal,
  Util: util_default,
  Shape: element_default2,
  Node: node_default,
  Edge: edge_default,
  Combo: combo_default,
  Hull: hull_default,
  registerNode: element_default2.registerNode,
  registerEdge: element_default2.registerEdge,
  registerCombo: element_default2.registerCombo,
  registerBehavior: behavior_default2.registerBehavior,
  Arrow: arrow_default,
  Marker: marker_default,
  AbstractLayout: layout_default,
  AbstractEvent: event_default
};

// node_modules/@antv/g6-pc/es/index.js
var AlgorithmAsync = __toESM(require_asyncIndex());

// node_modules/@antv/g-canvas/esm/shape/index.js
var shape_exports = {};
__export(shape_exports, {
  Base: () => base_default2,
  Circle: () => circle_default2,
  Ellipse: () => ellipse_default3,
  Image: () => image_default,
  Line: () => line_default3,
  Marker: () => marker_default2,
  Path: () => path_default2,
  Polygon: () => polygon_default3,
  Polyline: () => polyline_default3,
  Rect: () => rect_default2,
  Text: () => text_default2
});

// node_modules/@antv/g-canvas/node_modules/tslib/tslib.es6.js
var extendStatics4 = function(d2, b10) {
  extendStatics4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics4(d2, b10);
};
function __extends4(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics4(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign3 = function() {
  __assign3 = Object.assign || function __assign16(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign3.apply(this, arguments);
};
function __rest3(s2, e8) {
  var t4 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t4[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
}

// node_modules/@antv/g-canvas/esm/util/util.js
init_esm();
function getPixelRatio() {
  return window ? window.devicePixelRatio : 1;
}
function distance7(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x2, y2) {
  return x2 >= minX && x2 <= minX + width && y2 >= minY && y2 <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint2(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}

// node_modules/@antv/g-canvas/esm/util/draw.js
init_esm();

// node_modules/@antv/g-canvas/esm/util/parse.js
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop(steps, gradient) {
  var arr = steps.match(regexColorStop);
  each_default(arr, function(item) {
    var itemArr = item.split(":");
    gradient.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient(context, element, gradientStr) {
  var arr = regexLG.exec(gradientStr);
  var angle3 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end2;
  if (angle3 >= 0 && angle3 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end2 = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end2 = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle3 && angle3 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end2 = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end2 = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x2 = (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y2 = tanTheta * (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient = context.createLinearGradient(start.x, start.y, x2, y2);
  addStop(steps, gradient);
  return gradient;
}
function parseRadialGradient(context, element, gradientStr) {
  var arr = regexRG.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr2 = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr2 === 0) {
    var colors = steps.match(regexColorStop);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r2 = Math.sqrt(width * width + height * height) / 2;
  var gradient = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr2 * r2);
  addStop(steps, gradient);
  return gradient;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern;
  var img;
  var arr = regexPR.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern = context.createPattern(img, repeat);
    element.set("pattern", pattern);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern;
}
function parseStyle(context, element, color3) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color3;
  }
  if (is_string_default(color3)) {
    if (color3[1] === "(" || color3[2] === "(") {
      if (color3[0] === "l") {
        return parseLineGradient(context, element, color3);
      }
      if (color3[0] === "r") {
        return parseRadialGradient(context, element, color3);
      }
      if (color3[0] === "p") {
        return parsePattern(context, element, color3);
      }
    }
    return color3;
  }
  if (color3 instanceof CanvasPattern) {
    return color3;
  }
}
function parseRadius2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}

// node_modules/@antv/g-canvas/esm/util/arc-params.js
function vMag2(v2) {
  return Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
}
function vRatio2(u2, v2) {
  return vMag2(u2) * vMag2(v2) ? (u2[0] * v2[0] + u2[1] * v2[1]) / (vMag2(u2) * vMag2(v2)) : 1;
}
function vAngle2(u2, v2) {
  return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vRatio2(u2, v2));
}
function getArcParams2(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod_default(to_radian_default(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f2 = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
  if (arcFlag === sweepFlag) {
    f2 *= -1;
  }
  if (isNaN(f2)) {
    f2 = 0;
  }
  var cxp = ry ? f2 * rx * yp / ry : 0;
  var cyp = rx ? f2 * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u2 = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v2 = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle2([1, 0], u2);
  var dTheta = vAngle2(u2, v2);
  if (vRatio2(u2, v2) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio2(u2, v2) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    rx: isSamePoint2(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint2(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}

// node_modules/@antv/g-canvas/esm/util/arrow.js
var sin2 = Math.sin;
var cos2 = Math.cos;
var atan2 = Math.atan2;
var PI2 = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x3 = x1 - x2;
  var y3 = y1 - y2;
  var rad = atan2(y3, x3);
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      path: "M" + 10 * cos2(PI2 / 6) + "," + 10 * sin2(PI2 / 6) + " L0,0 L" + 10 * cos2(PI2 / 6) + ",-" + 10 * sin2(PI2 / 6),
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d2 = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest3(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x3 = x1 - x2;
  var y3 = y1 - y2;
  var rad = atan2(y3, x3);
  if (d2) {
    x2 = x2 - cos2(rad) * d2;
    y2 = y2 - sin2(rad) * d2;
  }
  var arrowShape = new path_default2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign3(__assign3({}, restAttrs), {
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d2) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos2(rad) * d2,
    dy: sin2(rad) * d2
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}

// node_modules/@antv/g-canvas/esm/util/draw.js
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k2 in attrs) {
    var v2 = attrs[k2];
    var name_1 = SHAPE_ATTRS_MAP[k2] ? SHAPE_ATTRS_MAP[k2] : k2;
    if (name_1 === "matrix" && v2) {
      context.transform(v2[0], v2[1], v2[3], v2[4], v2[6], v2[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      is_array_default(v2) && context.setLineDash(v2);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v2 = parseStyle(context, element, v2);
      } else if (name_1 === "globalAlpha") {
        v2 = v2 * context.globalAlpha;
      }
      context[name_1] = v2;
    }
  }
}
function drawChildren(context, children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each_default(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children, region);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children, region);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i2 = 0; i2 < elements.length; i2++) {
    var el = elements[i2];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i2 = 0; i2 < children.length; i2++) {
    var child = children[i2];
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"), region);
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance11 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i2 = 0; i2 < path.length; i2++) {
    var params = path[i2];
    var command = params[0];
    if (i2 === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i2 === path.length - 2 && path[i2 + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path[i2 + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i2 === path.length - 1 && endArrow && endArrow.d) {
      if (path[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance11 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance11.dx, dy = distance11.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i2];
          if (!arcParams) {
            arcParams = getArcParams2(currentPoint, params);
            arcParamsCache[i2] = arcParams;
          }
        } else {
          arcParams = getArcParams2(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r2 = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r2, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
      default:
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len5 = params.length;
      currentPoint = [params[len5 - 2], params[len5 - 1]];
    }
  }
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each_default(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min_default(minXArr),
    minY: min_default(minYArr),
    maxX: max_default(maxXArr),
    maxY: max_default(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}

// node_modules/@antv/g-canvas/esm/group.js
init_esm();
var Group = function(_super) {
  __extends4(Group3, _super);
  function Group3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group3.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  Group3.prototype.getShapeBase = function() {
    return shape_exports;
  };
  Group3.prototype.getGroupBase = function() {
    return Group3;
  };
  Group3.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  Group3.prototype.cacheCanvasBBox = function() {
    var children = this.cfg.children;
    var xArr = [];
    var yArr = [];
    each_default(children, function(child) {
      var bbox2 = child.cfg.cacheCanvasBBox;
      if (bbox2 && child.cfg.isInView) {
        xArr.push(bbox2.minX, bbox2.maxX);
        yArr.push(bbox2.minY, bbox2.maxY);
      }
    });
    var bbox = null;
    if (xArr.length) {
      var minX = min_default(xArr);
      var maxX = max_default(xArr);
      var minY = min_default(yArr);
      var maxY = max_default(yArr);
      bbox = {
        minX,
        minY,
        x: minX,
        y: minY,
        maxX,
        maxY,
        width: maxX - minX,
        height: maxY - minY
      };
      var canvas = this.cfg.canvas;
      if (canvas) {
        var viewRange = canvas.getViewRange();
        this.set("isInView", intersectRect(bbox, viewRange));
      }
    } else {
      this.set("isInView", false);
    }
    this.set("cacheCanvasBBox", bbox);
  };
  Group3.prototype.draw = function(context, region) {
    var children = this.cfg.children;
    var allowDraw = region ? this.cfg.refresh : true;
    if (children.length && allowDraw) {
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, this.getClip());
      drawChildren(context, children, region);
      context.restore();
      this.cacheCanvasBBox();
    }
    this.cfg.refresh = null;
    this.set("hasChanged", false);
  };
  Group3.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("hasChanged", false);
  };
  return Group3;
}(group_default2);
var group_default3 = Group;

// node_modules/@antv/g-canvas/esm/shape/base.js
var ShapeBase = function(_super) {
  __extends4(ShapeBase3, _super);
  function ShapeBase3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShapeBase3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase3.prototype.getShapeBase = function() {
    return shape_exports;
  };
  ShapeBase3.prototype.getGroupBase = function() {
    return group_default3;
  };
  ShapeBase3.prototype.onCanvasChange = function(changeType) {
    refreshElement(this, changeType);
  };
  ShapeBase3.prototype.calculateBBox = function() {
    var type = this.get("type");
    var lineWidth = this.getHitLineWidth();
    var bboxMethod = getMethod(type);
    var box2 = bboxMethod(this);
    var halfLineWidth = lineWidth / 2;
    var minX = box2.x - halfLineWidth;
    var minY = box2.y - halfLineWidth;
    var maxX = box2.x + box2.width + halfLineWidth;
    var maxY = box2.y + box2.height + halfLineWidth;
    return {
      x: minX,
      minX,
      y: minY,
      minY,
      width: box2.width + lineWidth,
      height: box2.height + lineWidth,
      maxX,
      maxY
    };
  };
  ShapeBase3.prototype.isFill = function() {
    return !!this.attrs["fill"] || this.isClipShape();
  };
  ShapeBase3.prototype.isStroke = function() {
    return !!this.attrs["stroke"];
  };
  ShapeBase3.prototype._applyClip = function(context, clip) {
    if (clip) {
      context.save();
      applyAttrsToContext(context, clip);
      clip.createPath(context);
      context.restore();
      context.clip();
      clip._afterDraw();
    }
  };
  ShapeBase3.prototype.draw = function(context, region) {
    var clip = this.cfg.clipShape;
    if (region) {
      if (this.cfg.refresh === false) {
        this.set("hasChanged", false);
        return;
      }
      var bbox = this.getCanvasBBox();
      if (!intersectRect(region, bbox)) {
        this.set("hasChanged", false);
        if (this.cfg.isInView) {
          this._afterDraw();
        }
        return;
      }
    }
    context.save();
    applyAttrsToContext(context, this);
    this._applyClip(context, clip);
    this.drawPath(context);
    context.restore();
    this._afterDraw();
  };
  ShapeBase3.prototype.getCanvasViewBox = function() {
    var canvas = this.cfg.canvas;
    if (canvas) {
      return canvas.getViewRange();
    }
    return null;
  };
  ShapeBase3.prototype.cacheCanvasBBox = function() {
    var canvasBBox = this.getCanvasViewBox();
    if (canvasBBox) {
      var bbox = this.getCanvasBBox();
      var isInView = intersectRect(bbox, canvasBBox);
      this.set("isInView", isInView);
      if (isInView) {
        this.set("cacheCanvasBBox", bbox);
      } else {
        this.set("cacheCanvasBBox", null);
      }
    }
  };
  ShapeBase3.prototype._afterDraw = function() {
    this.cacheCanvasBBox();
    this.set("hasChanged", false);
    this.set("refresh", null);
  };
  ShapeBase3.prototype.skipDraw = function() {
    this.set("cacheCanvasBBox", null);
    this.set("isInView", null);
    this.set("hasChanged", false);
  };
  ShapeBase3.prototype.drawPath = function(context) {
    this.createPath(context);
    this.strokeAndFill(context);
    this.afterDrawPath(context);
  };
  ShapeBase3.prototype.fill = function(context) {
    context.fill();
  };
  ShapeBase3.prototype.stroke = function(context) {
    context.stroke();
  };
  ShapeBase3.prototype.strokeAndFill = function(context) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isFill()) {
      if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = strokeOpacity;
        }
        this.stroke(context);
      }
    }
    this.afterDrawPath(context);
  };
  ShapeBase3.prototype.createPath = function(context) {
  };
  ShapeBase3.prototype.afterDrawPath = function(context) {
  };
  ShapeBase3.prototype.isInShape = function(refX, refY) {
    var isStroke = this.isStroke();
    var isFill = this.isFill();
    var lineWidth = this.getHitLineWidth();
    return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
  };
  ShapeBase3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    return false;
  };
  ShapeBase3.prototype.getHitLineWidth = function() {
    if (!this.isStroke()) {
      return 0;
    }
    var attrs = this.attrs;
    return attrs["lineWidth"] + attrs["lineAppendWidth"];
  };
  return ShapeBase3;
}(shape_default);
var base_default2 = ShapeBase;

// node_modules/@antv/g-canvas/esm/shape/circle.js
var Circle = function(_super) {
  __extends4(Circle3, _super);
  function Circle3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Circle3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r2 = attrs.r;
    var halfLineWidth = lineWidth / 2;
    var absDistance = distance7(cx, cy, x2, y2);
    if (isFill && isStroke) {
      return absDistance <= r2 + halfLineWidth;
    }
    if (isFill) {
      return absDistance <= r2;
    }
    if (isStroke) {
      return absDistance >= r2 - halfLineWidth && absDistance <= r2 + halfLineWidth;
    }
    return false;
  };
  Circle3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var r2 = attrs.r;
    context.beginPath();
    context.arc(cx, cy, r2, 0, Math.PI * 2, false);
    context.closePath();
  };
  return Circle3;
}(base_default2);
var circle_default2 = Circle;

// node_modules/@antv/g-canvas/esm/shape/ellipse.js
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse = function(_super) {
  __extends4(Ellipse3, _super);
  function Ellipse3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Ellipse3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var halfLineWith = lineWidth / 2;
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx, ry = attrs.ry;
    var squareX = (x2 - cx) * (x2 - cx);
    var squareY = (y2 - cy) * (y2 - cy);
    if (isFill && isStroke) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (isFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (isStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  };
  Ellipse3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var cx = attrs.x;
    var cy = attrs.y;
    var rx = attrs.rx;
    var ry = attrs.ry;
    context.beginPath();
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r2 = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.translate(cx, cy);
      context.scale(scaleX, scaleY);
      context.arc(0, 0, r2, 0, Math.PI * 2);
      context.restore();
      context.closePath();
    }
  };
  return Ellipse3;
}(base_default2);
var ellipse_default3 = Ellipse;

// node_modules/@antv/g-canvas/esm/shape/image.js
function isCanvas(dom) {
  return dom instanceof HTMLElement && is_string_default(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = function(_super) {
  __extends4(ImageShape2, _super);
  function ImageShape2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ImageShape2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  ImageShape2.prototype.initAttrs = function(attrs) {
    this._setImage(attrs.img);
  };
  ImageShape2.prototype.isStroke = function() {
    return false;
  };
  ImageShape2.prototype.isOnlyHitBox = function() {
    return true;
  };
  ImageShape2.prototype._afterLoading = function() {
    if (this.get("toDraw") === true) {
      var canvas = this.get("canvas");
      if (canvas) {
        canvas.draw();
      } else {
        this.createPath(this.get("context"));
      }
    }
  };
  ImageShape2.prototype._setImage = function(img) {
    var _this = this;
    var attrs = this.attrs;
    if (is_string_default(img)) {
      var image_1 = new Image();
      image_1.onload = function() {
        if (_this.destroyed) {
          return false;
        }
        _this.attr("img", image_1);
        _this.set("loading", false);
        _this._afterLoading();
        var callback = _this.get("callback");
        if (callback) {
          callback.call(_this);
        }
      };
      image_1.crossOrigin = "Anonymous";
      image_1.src = img;
      this.set("loading", true);
    } else if (img instanceof Image) {
      if (!attrs.width) {
        attrs.width = img.width;
      }
      if (!attrs.height) {
        attrs.height = img.height;
      }
    } else if (isCanvas(img)) {
      if (!attrs.width) {
        attrs.width = Number(img.getAttribute("width"));
      }
      if (!attrs.height) {
        attrs.height, Number(img.getAttribute("height"));
      }
    }
  };
  ImageShape2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "img") {
      this._setImage(value);
    }
  };
  ImageShape2.prototype.createPath = function(context) {
    if (this.get("loading")) {
      this.set("toDraw", true);
      this.set("context", context);
      return;
    }
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
    var img = attrs.img;
    if (img instanceof Image || isCanvas(img)) {
      if (!is_nil_default(sx) && !is_nil_default(sy) && !is_nil_default(swidth) && !is_nil_default(sheight)) {
        context.drawImage(img, sx, sy, swidth, sheight, x2, y2, width, height);
      } else {
        context.drawImage(img, x2, y2, width, height);
      }
    }
  };
  return ImageShape2;
}(base_default2);
var image_default = ImageShape;

// node_modules/@antv/g-canvas/esm/util/in-stroke/line.js
function inLine(x1, y1, x2, y2, lineWidth, x3, y3) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY + halfWidth)) {
    return false;
  }
  return line_default.pointToLine(x1, y1, x2, y2, x3, y3) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/shape/line.js
var Line2 = function(_super) {
  __extends4(Line5, _super);
  function Line5() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Line5.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line5.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  Line5.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    this.setArrow();
  };
  Line5.prototype.setArrow = function() {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      addStartArrow(this, attrs, x2, y2, x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, x1, y1, x2, y2);
    }
  };
  Line5.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x22 = _a2.x2, y22 = _a2.y2;
    return inLine(x1, y1, x22, y22, lineWidth, x2, y2);
  };
  Line5.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    var startArrowDistance = {
      dx: 0,
      dy: 0
    };
    var endArrowDistance = {
      dx: 0,
      dy: 0
    };
    if (startArrow && startArrow.d) {
      startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
    }
    if (endArrow && endArrow.d) {
      endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
    }
    context.beginPath();
    context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
    context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
  };
  Line5.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Line5.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return line_default.length(x1, y1, x2, y2);
  };
  Line5.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return line_default.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line5;
}(base_default2);
var line_default3 = Line2;

// node_modules/@antv/g-canvas/esm/shape/marker.js
init_esm();
var Symbols = {
  circle: function(x2, y2, r2) {
    return [
      ["M", x2 - r2, y2],
      ["A", r2, r2, 0, 1, 0, x2 + r2, y2],
      ["A", r2, r2, 0, 1, 0, x2 - r2, y2]
    ];
  },
  square: function(x2, y2, r2) {
    return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2 - r2], ["L", x2 + r2, y2 + r2], ["L", x2 - r2, y2 + r2], ["Z"]];
  },
  diamond: function(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["L", x2, y2 - r2], ["L", x2 + r2, y2], ["L", x2, y2 + r2], ["Z"]];
  },
  triangle: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["Z"]];
  },
  "triangle-down": function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
  }
};
var Marker = function(_super) {
  __extends4(Marker3, _super);
  function Marker3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Marker3.prototype.initAttrs = function(attrs) {
    this._resetParamsCache();
  };
  Marker3.prototype._resetParamsCache = function() {
    this.set("paramsCache", {});
  };
  Marker3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
      this._resetParamsCache();
    }
  };
  Marker3.prototype.isOnlyHitBox = function() {
    return true;
  };
  Marker3.prototype._getR = function(attrs) {
    return is_nil_default(attrs.r) ? attrs.radius : attrs.r;
  };
  Marker3.prototype._getPath = function() {
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y;
    var symbol = attrs.symbol || "circle";
    var r2 = this._getR(attrs);
    var method;
    var path;
    if (is_function_default(symbol)) {
      method = symbol;
      path = method(x2, y2, r2);
      path = pathToAbsolute2(path);
    } else {
      method = Marker3.Symbols[symbol];
      if (!method) {
        console.warn(symbol + " marker is not supported.");
        return null;
      }
      path = method(x2, y2, r2);
    }
    return path;
  };
  Marker3.prototype.createPath = function(context) {
    var path = this._getPath();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, { path }, paramsCache);
  };
  Marker3.Symbols = Symbols;
  return Marker3;
}(base_default2);
var marker_default2 = Marker;

// node_modules/@antv/g-canvas/esm/shape/path.js
init_esm();

// node_modules/@antv/g-canvas/esm/util/in-path/point-in-path.js
function isPointInPath(shape, x2, y2) {
  var ctx2 = getOffScreenContext();
  shape.createPath(ctx2);
  return ctx2.isPointInPath(x2, y2);
}

// node_modules/@antv/g-canvas/esm/util/in-path/polygon.js
var tolerance = 1e-6;
function dcmp(x2) {
  if (Math.abs(x2) < tolerance) {
    return 0;
  }
  return x2 < 0 ? -1 : 1;
}
function onSegment2(p1, p2, q2) {
  if ((q2[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q2[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q2[0] && q2[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q2[1] && q2[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon2(points, x2, y2) {
  var isHit = false;
  var n2 = points.length;
  if (n2 <= 2) {
    return false;
  }
  for (var i2 = 0; i2 < n2; i2++) {
    var p1 = points[i2];
    var p2 = points[(i2 + 1) % n2];
    if (onSegment2(p1, p2, [x2, y2])) {
      return true;
    }
    if (dcmp(p1[1] - y2) > 0 !== dcmp(p2[1] - y2) > 0 && dcmp(x2 - (y2 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}

// node_modules/@antv/g-canvas/esm/util/path.js
init_vec3();

// node_modules/@antv/g-canvas/esm/util/in-stroke/arc.js
function arc(cx, cy, r2, startAngle, endAngle, lineWidth, x2, y2) {
  var angle3 = (Math.atan2(y2 - cy, x2 - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle3 < startAngle || angle3 > endAngle) {
    return false;
  }
  var point = {
    x: cx + r2 * Math.cos(angle3),
    y: cy + r2 * Math.sin(angle3)
  };
  return distance7(point.x, point.y, x2, y2) <= lineWidth / 2;
}

// node_modules/@antv/g-canvas/esm/util/path.js
var transform7 = ext_exports.transform;
function hasArc(path) {
  var hasArc2 = false;
  var count = path.length;
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x2, y2, length5) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i2 = 0; i2 < segments.length; i2++) {
    var segment = segments[i2];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x2, y2)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x2, y2);
        break;
      case "Q":
        var qDistance = quadratic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x2, y2);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = cubic_default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], x2, y2, length5);
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p2 = [x2, y2, 1];
        var r2 = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m2 = transform7(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3(p2, p2, m2);
        isHit = arc(0, 0, r2, startAngle, endAngle, lineWidth, p2[0], p2[1]);
        break;
      default:
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path) {
  var count = path.length;
  var polygons = [];
  var polylines = [];
  var points = [];
  for (var i2 = 0; i2 < count; i2++) {
    var params = path[i2];
    var cmd = params[0];
    if (cmd === "M") {
      if (points.length) {
        polylines.push(points);
        points = [];
      }
      points.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points.length) {
        polygons.push(points);
        points = [];
      }
    } else {
      points.push([params[1], params[2]]);
    }
  }
  if (points.length > 0) {
    polylines.push(points);
  }
  return {
    polygons,
    polylines
  };
}
var path_default3 = __assign3({ hasArc, extractPolygons, isPointInStroke }, path_exports);

// node_modules/@antv/g-canvas/esm/shape/path.js
function isInPolygons(polygons, x2, y2) {
  var isHit = false;
  for (var i2 = 0; i2 < polygons.length; i2++) {
    var points = polygons[i2];
    isHit = isInPolygon2(points, x2, y2);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path = function(_super) {
  __extends4(Path3, _super);
  function Path3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Path3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { startArrow: false, endArrow: false });
  };
  Path3.prototype.initAttrs = function(attrs) {
    this._setPathArr(attrs.path);
    this.setArrow();
  };
  Path3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name === "path") {
      this._setPathArr(value);
    }
    this.setArrow();
  };
  Path3.prototype._setPathArr = function(path) {
    this.attrs.path = pathToAbsolute2(path);
    var hasArc2 = path_default3.hasArc(path);
    this.set("hasArc", hasArc2);
    this.set("paramsCache", {});
    this.set("segments", null);
    this.set("curve", null);
    this.set("tCache", null);
    this.set("totalLength", null);
  };
  Path3.prototype.getSegments = function() {
    var segments = this.get("segements");
    if (!segments) {
      segments = getSegments(this.attr("path"));
      this.set("segments", segments);
    }
    return segments;
  };
  Path3.prototype.setArrow = function() {
    var attrs = this.attr();
    var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
    if (startArrow) {
      var tangent = this.getStartTangent();
      addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
    if (endArrow) {
      var tangent = this.getEndTangent();
      addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
    }
  };
  Path3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var segments = this.getSegments();
    var hasArc2 = this.get("hasArc");
    var isHit = false;
    if (isStroke) {
      var length_1 = this.getTotalLength();
      isHit = path_default3.isPointInStroke(segments, lineWidth, x2, y2, length_1);
    }
    if (!isHit && isFill) {
      if (hasArc2) {
        isHit = isPointInPath(this, x2, y2);
      } else {
        var path = this.attr("path");
        var extractResutl = path_default3.extractPolygons(path);
        isHit = isInPolygons(extractResutl.polygons, x2, y2) || isInPolygons(extractResutl.polylines, x2, y2);
      }
    }
    return isHit;
  };
  Path3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var paramsCache = this.get("paramsCache");
    drawPath(this, context, attrs, paramsCache);
  };
  Path3.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  Path3.prototype.getTotalLength = function() {
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this._calculateCurve();
    this._setTcache();
    return this.get("totalLength");
  };
  Path3.prototype.getPoint = function(ratio) {
    var tCache = this.get("tCache");
    if (!tCache) {
      this._calculateCurve();
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    var curve = this.get("curve");
    if (!tCache || tCache.length === 0) {
      if (curve) {
        return {
          x: curve[0][1],
          y: curve[0][2]
        };
      }
      return null;
    }
    each_default(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index = i2;
      }
    });
    var seg = curve[index];
    if (is_nil_default(seg) || is_nil_default(index)) {
      return null;
    }
    var l2 = seg.length;
    var nextSeg = curve[index + 1];
    return cubic_default.pointAt(seg[l2 - 2], seg[l2 - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
  };
  Path3.prototype._calculateCurve = function() {
    var path = this.attr().path;
    this.set("curve", path_default3.pathToCurve(path));
  };
  Path3.prototype._setTcache = function() {
    var totalLength = 0;
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    var segmentN;
    var l2;
    var curve = this.get("curve");
    if (!curve) {
      return;
    }
    each_default(curve, function(segment, i2) {
      segmentN = curve[i2 + 1];
      l2 = segment.length;
      if (segmentN) {
        totalLength += cubic_default.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
      }
    });
    this.set("totalLength", totalLength);
    if (totalLength === 0) {
      this.set("tCache", []);
      return;
    }
    each_default(curve, function(segment, i2) {
      segmentN = curve[i2 + 1];
      l2 = segment.length;
      if (segmentN) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = cubic_default.length(segment[l2 - 2], segment[l2 - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
        tempLength += segmentL || 0;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Path3.prototype.getStartTangent = function() {
    var segments = this.getSegments();
    var result;
    if (segments.length > 1) {
      var startPoint = segments[0].currentPoint;
      var endPoint = segments[1].currentPoint;
      var tangent = segments[1].startTangent;
      result = [];
      if (tangent) {
        result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
        result.push([startPoint[0], startPoint[1]]);
      } else {
        result.push([endPoint[0], endPoint[1]]);
        result.push([startPoint[0], startPoint[1]]);
      }
    }
    return result;
  };
  Path3.prototype.getEndTangent = function() {
    var segments = this.getSegments();
    var length5 = segments.length;
    var result;
    if (length5 > 1) {
      var startPoint = segments[length5 - 2].currentPoint;
      var endPoint = segments[length5 - 1].currentPoint;
      var tangent = segments[length5 - 1].endTangent;
      result = [];
      if (tangent) {
        result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
        result.push([endPoint[0], endPoint[1]]);
      } else {
        result.push([startPoint[0], startPoint[1]]);
        result.push([endPoint[0], endPoint[1]]);
      }
    }
    return result;
  };
  return Path3;
}(base_default2);
var path_default2 = Path;

// node_modules/@antv/g-canvas/esm/util/in-stroke/polyline.js
function inPolyline(points, lineWidth, x2, y2, isClose) {
  var count = points.length;
  if (count < 2) {
    return false;
  }
  for (var i2 = 0; i2 < count - 1; i2++) {
    var x1 = points[i2][0];
    var y1 = points[i2][1];
    var x22 = points[i2 + 1][0];
    var y22 = points[i2 + 1][1];
    if (inLine(x1, y1, x22, y22, lineWidth, x2, y2)) {
      return true;
    }
  }
  if (isClose) {
    var first = points[0];
    var last2 = points[count - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x2, y2)) {
      return true;
    }
  }
  return false;
}

// node_modules/@antv/g-canvas/esm/shape/polygon.js
var Polygon = function(_super) {
  __extends4(Polygon3, _super);
  function Polygon3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Polygon3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var points = this.attr().points;
    var isHit = false;
    if (isStroke) {
      isHit = inPolyline(points, lineWidth, x2, y2, true);
    }
    if (!isHit && isFill) {
      isHit = isInPolygon2(points, x2, y2);
    }
    return isHit;
  };
  Polygon3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var points = attrs.points;
    if (points.length < 2) {
      return;
    }
    context.beginPath();
    for (var i2 = 0; i2 < points.length; i2++) {
      var point = points[i2];
      if (i2 === 0) {
        context.moveTo(point[0], point[1]);
      } else {
        context.lineTo(point[0], point[1]);
      }
    }
    context.closePath();
  };
  return Polygon3;
}(base_default2);
var polygon_default3 = Polygon;

// node_modules/@antv/g-canvas/esm/shape/polyline.js
init_esm();
var PolyLine = function(_super) {
  __extends4(PolyLine2, _super);
  function PolyLine2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PolyLine2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { startArrow: false, endArrow: false });
  };
  PolyLine2.prototype.initAttrs = function(attrs) {
    this.setArrow();
  };
  PolyLine2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    this.setArrow();
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  PolyLine2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  PolyLine2.prototype.setArrow = function() {
    var attrs = this.attr();
    var _a2 = this.attrs, points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length5 = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length5 - 1][0];
    var y2 = points[length5 - 1][1];
    if (startArrow) {
      addStartArrow(this, attrs, points[1][0], points[1][1], x1, y1);
    }
    if (endArrow) {
      addEndArrow(this, attrs, points[length5 - 2][0], points[length5 - 2][1], x2, y2);
    }
  };
  PolyLine2.prototype.isFill = function() {
    return false;
  };
  PolyLine2.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    if (!isStroke || !lineWidth) {
      return false;
    }
    var points = this.attr().points;
    return inPolyline(points, lineWidth, x2, y2, false);
  };
  PolyLine2.prototype.isStroke = function() {
    return true;
  };
  PolyLine2.prototype.createPath = function(context) {
    var _a2 = this.attr(), points = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
    var length5 = points.length;
    if (points.length < 2) {
      return;
    }
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length5 - 1][0];
    var y2 = points[length5 - 1][1];
    if (startArrow && startArrow.d) {
      var distance11 = getShortenOffset(x1, y1, points[1][0], points[1][1], startArrow.d);
      x1 += distance11.dx;
      y1 += distance11.dy;
    }
    if (endArrow && endArrow.d) {
      var distance11 = getShortenOffset(points[length5 - 2][0], points[length5 - 2][1], x2, y2, endArrow.d);
      x2 -= distance11.dx;
      y2 -= distance11.dy;
    }
    context.beginPath();
    context.moveTo(x1, y1);
    for (var i2 = 0; i2 < length5 - 1; i2++) {
      var point = points[i2];
      context.lineTo(point[0], point[1]);
    }
    context.lineTo(x2, y2);
  };
  PolyLine2.prototype.afterDrawPath = function(context) {
    var startArrowShape = this.get("startArrowShape");
    var endArrowShape = this.get("endArrowShape");
    if (startArrowShape) {
      startArrowShape.draw(context);
    }
    if (endArrowShape) {
      endArrowShape.draw(context);
    }
  };
  PolyLine2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", polyline_default.length(points));
    return this.get("totalLength");
  };
  PolyLine2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    each_default(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index = i2;
      }
    });
    return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };
  PolyLine2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each_default(points, function(p2, i2) {
      if (points[i2 + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = line_default.length(p2[0], p2[1], points[i2 + 1][0], points[i2 + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  PolyLine2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  PolyLine2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l2 = points.length - 1;
    var result = [];
    result.push([points[l2 - 1][0], points[l2 - 1][1]]);
    result.push([points[l2][0], points[l2][1]]);
    return result;
  };
  return PolyLine2;
}(base_default2);
var polyline_default3 = PolyLine;

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect.js
function inRect(minX, minY, width, height, lineWidth, x2, y2) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x2, y2) || inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x2, y2) || inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x2, y2) || inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x2, y2);
}

// node_modules/@antv/g-canvas/esm/util/in-stroke/rect-radius.js
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x2, y2) {
  var halfWidth = lineWidth / 2;
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x2, y2) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x2, y2) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x2, y2) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x2, y2) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x2, y2) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x2, y2) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x2, y2) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x2, y2);
}

// node_modules/@antv/g-canvas/esm/shape/rect.js
var Rect = function(_super) {
  __extends4(Rect3, _super);
  function Rect3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Rect3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect3.prototype.isInStrokeOrPath = function(x2, y2, isStroke, isFill, lineWidth) {
    var attrs = this.attr();
    var minX = attrs.x;
    var minY = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      var halfWidth = lineWidth / 2;
      if (isFill && isStroke) {
        return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x2, y2);
      }
      if (isFill) {
        return inBox(minX, minY, width, height, x2, y2);
      }
      if (isStroke) {
        return inRect(minX, minY, width, height, lineWidth, x2, y2);
      }
    } else {
      var isHit = false;
      if (isStroke) {
        isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x2, y2);
      }
      if (!isHit && isFill) {
        isHit = isPointInPath(this, x2, y2);
      }
      return isHit;
    }
  };
  Rect3.prototype.createPath = function(context) {
    var attrs = this.attr();
    var x2 = attrs.x;
    var y2 = attrs.y;
    var width = attrs.width;
    var height = attrs.height;
    var radius = attrs.radius;
    context.beginPath();
    if (radius === 0) {
      context.rect(x2, y2, width, height);
    } else {
      var _a2 = parseRadius2(radius), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      context.moveTo(x2 + r1, y2);
      context.lineTo(x2 + width - r2, y2);
      r2 !== 0 && context.arc(x2 + width - r2, y2 + r2, r2, -Math.PI / 2, 0);
      context.lineTo(x2 + width, y2 + height - r3);
      r3 !== 0 && context.arc(x2 + width - r3, y2 + height - r3, r3, 0, Math.PI / 2);
      context.lineTo(x2 + r4, y2 + height);
      r4 !== 0 && context.arc(x2 + r4, y2 + height - r4, r4, Math.PI / 2, Math.PI);
      context.lineTo(x2, y2 + r1);
      r1 !== 0 && context.arc(x2 + r1, y2 + r1, r1, Math.PI, Math.PI * 1.5);
      context.closePath();
    }
  };
  return Rect3;
}(base_default2);
var rect_default2 = Rect;

// node_modules/@antv/g-canvas/esm/shape/text.js
var Text = function(_super) {
  __extends4(Text3, _super);
  function Text3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Text3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign3(__assign3({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text3.prototype.isOnlyHitBox = function() {
    return true;
  };
  Text3.prototype.initAttrs = function(attrs) {
    this._assembleFont();
    if (attrs.text) {
      this._setText(attrs.text);
    }
  };
  Text3.prototype._assembleFont = function() {
    var attrs = this.attrs;
    attrs.font = assembleFont(attrs);
  };
  Text3.prototype._setText = function(text) {
    var textArr = null;
    if (is_string_default(text) && text.indexOf("\n") !== -1) {
      textArr = text.split("\n");
    }
    this.set("textArr", textArr);
  };
  Text3.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (name.startsWith("font")) {
      this._assembleFont();
    }
    if (name === "text") {
      this._setText(value);
    }
  };
  Text3.prototype._getSpaceingY = function() {
    var attrs = this.attrs;
    var lineHeight = attrs.lineHeight;
    var fontSize = attrs.fontSize * 1;
    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
  };
  Text3.prototype._drawTextArr = function(context, textArr, isFill) {
    var attrs = this.attrs;
    var textBaseline = attrs.textBaseline;
    var x2 = attrs.x;
    var y2 = attrs.y;
    var fontSize = attrs.fontSize * 1;
    var spaceingY = this._getSpaceingY();
    var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
    var subY;
    each_default(textArr, function(subText, index) {
      subY = y2 + index * (spaceingY + fontSize) - height + fontSize;
      if (textBaseline === "middle")
        subY += height - fontSize - (height - fontSize) / 2;
      if (textBaseline === "top")
        subY += height - fontSize;
      if (!is_nil_default(subText)) {
        if (isFill) {
          context.fillText(subText, x2, subY);
        } else {
          context.strokeText(subText, x2, subY);
        }
      }
    });
  };
  Text3.prototype._drawText = function(context, isFill) {
    var attrs = this.attr();
    var x2 = attrs.x;
    var y2 = attrs.y;
    var textArr = this.get("textArr");
    if (textArr) {
      this._drawTextArr(context, textArr, isFill);
    } else {
      var text = attrs.text;
      if (!is_nil_default(text)) {
        if (isFill) {
          context.fillText(text, x2, y2);
        } else {
          context.strokeText(text, x2, y2);
        }
      }
    }
  };
  Text3.prototype.strokeAndFill = function(context) {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
    if (this.isStroke()) {
      if (lineWidth > 0) {
        if (!is_nil_default(strokeOpacity) && strokeOpacity !== 1) {
          context.globalAlpha = opacity;
        }
        this.stroke(context);
      }
    }
    if (this.isFill()) {
      if (!is_nil_default(fillOpacity) && fillOpacity !== 1) {
        context.globalAlpha = fillOpacity;
        this.fill(context);
        context.globalAlpha = opacity;
      } else {
        this.fill(context);
      }
    }
    this.afterDrawPath(context);
  };
  Text3.prototype.fill = function(context) {
    this._drawText(context, true);
  };
  Text3.prototype.stroke = function(context) {
    this._drawText(context, false);
  };
  return Text3;
}(base_default2);
var text_default2 = Text;

// node_modules/@antv/g-canvas/esm/util/hit.js
function invertFromMatrix(v2, matrix) {
  if (matrix) {
    var invertMatrix3 = invert4(matrix);
    return multiplyVec2(invertMatrix3, v2);
  }
  return v2;
}
function getRefXY(element, x2, y2) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a2 = invertFromMatrix([x2, y2, 1], totalMatrix), refX = _a2[0], refY = _a2[1];
    return [refX, refY];
  }
  return [x2, y2];
}
function preTest(element, x2, y2) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a2 = getRefXY(element, x2, y2), refX = _a2[0], refY = _a2[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x2 >= bbox.minX && x2 <= bbox.maxX && y2 >= bbox.minY && y2 <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape2(container2, x2, y2) {
  if (!preTest(container2, x2, y2)) {
    return null;
  }
  var shape = null;
  var children = container2.getChildren();
  var count = children.length;
  for (var i2 = count - 1; i2 >= 0; i2--) {
    var child = children[i2];
    if (child.isGroup()) {
      shape = getShape2(child, x2, y2);
    } else if (preTest(child, x2, y2)) {
      var curShape = child;
      var _a2 = getRefXY(child, x2, y2), refX = _a2[0], refY = _a2[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}

// node_modules/@antv/g-canvas/esm/canvas.js
var Canvas2 = function(_super) {
  __extends4(Canvas4, _super);
  function Canvas4() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Canvas4.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg["renderer"] = "canvas";
    cfg["autoDraw"] = true;
    cfg["localRefresh"] = true;
    cfg["refreshElements"] = [];
    cfg["clipView"] = true;
    cfg["quickHit"] = false;
    return cfg;
  };
  Canvas4.prototype.onCanvasChange = function(changeType) {
    if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
      this.set("refreshElements", [this]);
      this.draw();
    }
  };
  Canvas4.prototype.getShapeBase = function() {
    return shape_exports;
  };
  Canvas4.prototype.getGroupBase = function() {
    return group_default3;
  };
  Canvas4.prototype.getPixelRatio = function() {
    var pixelRatio = this.get("pixelRatio") || getPixelRatio();
    return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
  };
  Canvas4.prototype.getViewRange = function() {
    return {
      minX: 0,
      minY: 0,
      maxX: this.cfg.width,
      maxY: this.cfg.height
    };
  };
  Canvas4.prototype.createDom = function() {
    var element = document.createElement("canvas");
    var context = element.getContext("2d");
    this.set("context", context);
    return element;
  };
  Canvas4.prototype.setDOMSize = function(width, height) {
    _super.prototype.setDOMSize.call(this, width, height);
    var context = this.get("context");
    var el = this.get("el");
    var pixelRatio = this.getPixelRatio();
    el.width = pixelRatio * width;
    el.height = pixelRatio * height;
    if (pixelRatio > 1) {
      context.scale(pixelRatio, pixelRatio);
    }
  };
  Canvas4.prototype.clear = function() {
    _super.prototype.clear.call(this);
    this._clearFrame();
    var context = this.get("context");
    var element = this.get("el");
    context.clearRect(0, 0, element.width, element.height);
  };
  Canvas4.prototype.getShape = function(x2, y2) {
    var shape;
    if (this.get("quickHit")) {
      shape = getShape2(this, x2, y2);
    } else {
      shape = _super.prototype.getShape.call(this, x2, y2, null);
    }
    return shape;
  };
  Canvas4.prototype._getRefreshRegion = function() {
    var elements = this.get("refreshElements");
    var viewRegion = this.getViewRange();
    var region;
    if (elements.length && elements[0] === this) {
      region = viewRegion;
    } else {
      region = getMergedRegion(elements);
      if (region) {
        region.minX = Math.floor(region.minX);
        region.minY = Math.floor(region.minY);
        region.maxX = Math.ceil(region.maxX);
        region.maxY = Math.ceil(region.maxY);
        region.maxY += 1;
        var clipView = this.get("clipView");
        if (clipView) {
          region = mergeView(region, viewRegion);
        }
      }
    }
    return region;
  };
  Canvas4.prototype.refreshElement = function(element) {
    var refreshElements = this.get("refreshElements");
    refreshElements.push(element);
  };
  Canvas4.prototype._clearFrame = function() {
    var drawFrame = this.get("drawFrame");
    if (drawFrame) {
      cancelAnimationFrame2(drawFrame);
      this.set("drawFrame", null);
      this.set("refreshElements", []);
    }
  };
  Canvas4.prototype.draw = function() {
    var drawFrame = this.get("drawFrame");
    if (this.get("autoDraw") && drawFrame) {
      return;
    }
    this._startDraw();
  };
  Canvas4.prototype._drawAll = function() {
    var context = this.get("context");
    var element = this.get("el");
    var children = this.getChildren();
    context.clearRect(0, 0, element.width, element.height);
    applyAttrsToContext(context, this);
    drawChildren(context, children);
    this.set("refreshElements", []);
  };
  Canvas4.prototype._drawRegion = function() {
    var context = this.get("context");
    var refreshElements = this.get("refreshElements");
    var children = this.getChildren();
    var region = this._getRefreshRegion();
    if (region) {
      context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.save();
      context.beginPath();
      context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
      context.clip();
      applyAttrsToContext(context, this);
      checkRefresh(this, children, region);
      drawChildren(context, children, region);
      context.restore();
    } else if (refreshElements.length) {
      clearChanged(refreshElements);
    }
    each_default(refreshElements, function(element) {
      if (element.get("hasChanged")) {
        element.set("hasChanged", false);
      }
    });
    this.set("refreshElements", []);
  };
  Canvas4.prototype._startDraw = function() {
    var _this = this;
    var drawFrame = this.get("drawFrame");
    if (!drawFrame) {
      drawFrame = requestAnimationFrame2(function() {
        if (_this.get("localRefresh")) {
          _this._drawRegion();
        } else {
          _this._drawAll();
        }
        _this.set("drawFrame", null);
      });
      this.set("drawFrame", drawFrame);
    }
  };
  Canvas4.prototype.skipDraw = function() {
  };
  Canvas4.prototype.removeDom = function() {
    var el = this.get("el");
    el.width = 0;
    el.height = 0;
    el.parentNode.removeChild(el);
  };
  return Canvas4;
}(canvas_default);
var canvas_default2 = Canvas2;

// node_modules/@antv/g-svg/esm/shape/index.js
var shape_exports2 = {};
__export(shape_exports2, {
  Base: () => base_default3,
  Circle: () => circle_default3,
  Dom: () => dom_default,
  Ellipse: () => ellipse_default4,
  Image: () => image_default2,
  Line: () => line_default4,
  Marker: () => marker_default3,
  Path: () => path_default4,
  Polygon: () => polygon_default4,
  Polyline: () => polyline_default4,
  Rect: () => rect_default3,
  Text: () => text_default3
});

// node_modules/@antv/g-svg/node_modules/tslib/tslib.es6.js
var extendStatics5 = function(d2, b10) {
  extendStatics5 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics5(d2, b10);
};
function __extends5(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics5(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
var __assign4 = function() {
  __assign4 = Object.assign || function __assign16(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
    }
    return t4;
  };
  return __assign4.apply(this, arguments);
};

// node_modules/@antv/g-svg/esm/util/dom.js
init_esm();

// node_modules/@antv/g-svg/esm/constant.js
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};

// node_modules/@antv/g-svg/esm/util/dom.js
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = to_array_default(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings = Array.from(parentNode.childNodes).filter(function(node) {
    return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
  });
  var target = siblings[targetIndex];
  var currentIndex = siblings.indexOf(element);
  if (target) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}

// node_modules/@antv/g-svg/esm/util/svg.js
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id2 = context.find("filter", cfg);
    if (!id2) {
      id2 = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id2 + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform14 = [];
    for (var i2 = 0; i2 < 9; i2 += 3) {
      transform14.push(matrix[i2] + "," + matrix[i2 + 1]);
    }
    transform14 = transform14.join(",");
    if (transform14.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform14 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id2 = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id2 + ")");
  }
}

// node_modules/@antv/g-svg/esm/util/draw.js
function drawChildren2(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement2(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a2, b10) {
          return children_1.indexOf(a2) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr") {
    } else if (changeType === "add") {
      element.draw(context);
    }
  }
}

// node_modules/@antv/g-svg/esm/group.js
init_esm();
var Group2 = function(_super) {
  __extends5(Group3, _super);
  function Group3() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Group3.prototype.isEntityGroup = function() {
    return true;
  };
  Group3.prototype.createDom = function() {
    var element = createSVGElement("g");
    this.set("el", element);
    var parent = this.getParent();
    if (parent) {
      var parentNode = parent.get("el");
      if (parentNode) {
        parentNode.appendChild(element);
      } else {
        parentNode = parent.createDom();
        parent.set("el", parentNode);
        parentNode.appendChild(element);
      }
    }
    return element;
  };
  Group3.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.createPath(context, targetAttrs);
    }
  };
  Group3.prototype.onCanvasChange = function(changeType) {
    refreshElement2(this, changeType);
  };
  Group3.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  Group3.prototype.getGroupBase = function() {
    return Group3;
  };
  Group3.prototype.draw = function(context) {
    var children = this.getChildren();
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        this.createDom();
      }
      setClip(this, context);
      this.createPath(context);
      if (children.length) {
        drawChildren2(context, children);
      }
    }
  };
  Group3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    setTransform(this);
  };
  return Group3;
}(group_default2);
var group_default4 = Group2;

// node_modules/@antv/g-svg/esm/shape/base.js
var ShapeBase2 = function(_super) {
  __extends5(ShapeBase3, _super);
  function ShapeBase3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "svg";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  ShapeBase3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
  };
  ShapeBase3.prototype.afterAttrsChange = function(targetAttrs) {
    _super.prototype.afterAttrsChange.call(this, targetAttrs);
    var canvas = this.get("canvas");
    if (canvas && canvas.get("autoDraw")) {
      var context = canvas.get("context");
      this.draw(context, targetAttrs);
    }
  };
  ShapeBase3.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  ShapeBase3.prototype.getGroupBase = function() {
    return group_default4;
  };
  ShapeBase3.prototype.onCanvasChange = function(changeType) {
    refreshElement2(this, changeType);
  };
  ShapeBase3.prototype.calculateBBox = function() {
    var el = this.get("el");
    var bbox = null;
    if (el) {
      bbox = el.getBBox();
    } else {
      var bboxMethod = getMethod(this.get("type"));
      if (bboxMethod) {
        bbox = bboxMethod(this);
      }
    }
    if (bbox) {
      var x2 = bbox.x, y2 = bbox.y, width = bbox.width, height = bbox.height;
      var lineWidth = this.getHitLineWidth();
      var halfWidth = lineWidth / 2;
      var minX = x2 - halfWidth;
      var minY = y2 - halfWidth;
      var maxX = x2 + width + halfWidth;
      var maxY = y2 + height + halfWidth;
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY,
        width: width + lineWidth,
        height: height + lineWidth
      };
    }
    return {
      x: 0,
      y: 0,
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
      width: 0,
      height: 0
    };
  };
  ShapeBase3.prototype.isFill = function() {
    var _a2 = this.attr(), fill = _a2.fill, fillStyle = _a2.fillStyle;
    return (fill || fillStyle || this.isClipShape()) && this.canFill;
  };
  ShapeBase3.prototype.isStroke = function() {
    var _a2 = this.attr(), stroke = _a2.stroke, strokeStyle = _a2.strokeStyle;
    return (stroke || strokeStyle) && this.canStroke;
  };
  ShapeBase3.prototype.draw = function(context, targetAttrs) {
    var el = this.get("el");
    if (this.get("destroyed")) {
      if (el) {
        el.parentNode.removeChild(el);
      }
    } else {
      if (!el) {
        createDom(this);
      }
      setClip(this, context);
      this.createPath(context, targetAttrs);
      this.shadow(context, targetAttrs);
      this.strokeAndFill(context, targetAttrs);
      this.transform(targetAttrs);
    }
  };
  ShapeBase3.prototype.createPath = function(context, targetAttrs) {
  };
  ShapeBase3.prototype.strokeAndFill = function(context, targetAttrs) {
    var attrs = targetAttrs || this.attr();
    var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
    var el = this.get("el");
    if (this.canFill) {
      if (!targetAttrs) {
        this._setColor(context, "fill", fill || fillStyle);
      } else if ("fill" in attrs) {
        this._setColor(context, "fill", fill);
      } else if ("fillStyle" in attrs) {
        this._setColor(context, "fill", fillStyle);
      }
      if (fillOpacity) {
        el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
      }
    }
    if (this.canStroke && lineWidth > 0) {
      if (!targetAttrs) {
        this._setColor(context, "stroke", stroke || strokeStyle);
      } else if ("stroke" in attrs) {
        this._setColor(context, "stroke", stroke);
      } else if ("strokeStyle" in attrs) {
        this._setColor(context, "stroke", strokeStyle);
      }
      if (strokeOpacity) {
        el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
      }
      if (lineWidth) {
        el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
      }
    }
  };
  ShapeBase3.prototype._setColor = function(context, attr, value) {
    var el = this.get("el");
    if (!value) {
      el.setAttribute(SVG_ATTR_MAP[attr], "none");
      return;
    }
    value = value.trim();
    if (/^[r,R,L,l]{1}[\s]*\(/.test(value)) {
      var id2 = context.find("gradient", value);
      if (!id2) {
        id2 = context.addGradient(value);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
    } else if (/^[p,P]{1}[\s]*\(/.test(value)) {
      var id2 = context.find("pattern", value);
      if (!id2) {
        id2 = context.addPattern(value);
      }
      el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
    } else {
      el.setAttribute(SVG_ATTR_MAP[attr], value);
    }
  };
  ShapeBase3.prototype.shadow = function(context, targetAttrs) {
    var attrs = this.attr();
    var _a2 = targetAttrs || attrs, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY, shadowBlur = _a2.shadowBlur, shadowColor = _a2.shadowColor;
    if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
      setShadow(this, context);
    }
  };
  ShapeBase3.prototype.transform = function(targetAttrs) {
    var attrs = this.attr();
    var matrix = (targetAttrs || attrs).matrix;
    if (matrix) {
      setTransform(this);
    }
  };
  ShapeBase3.prototype.isInShape = function(refX, refY) {
    return this.isPointInPath(refX, refY);
  };
  ShapeBase3.prototype.isPointInPath = function(refX, refY) {
    var el = this.get("el");
    var canvas = this.get("canvas");
    var bbox = canvas.get("el").getBoundingClientRect();
    var clientX = refX + bbox.left;
    var clientY = refY + bbox.top;
    var element = document.elementFromPoint(clientX, clientY);
    if (element && element.isEqualNode(el)) {
      return true;
    }
    return false;
  };
  ShapeBase3.prototype.getHitLineWidth = function() {
    var _a2 = this.attrs, lineWidth = _a2.lineWidth, lineAppendWidth = _a2.lineAppendWidth;
    if (this.isStroke()) {
      return lineWidth + lineAppendWidth;
    }
    return 0;
  };
  return ShapeBase3;
}(shape_default);
var base_default3 = ShapeBase2;

// node_modules/@antv/g-svg/esm/shape/circle.js
init_esm();
var Circle2 = function(_super) {
  __extends5(Circle3, _super);
  function Circle3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Circle3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x: 0, y: 0, r: 0 });
  };
  Circle3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Circle3;
}(base_default3);
var circle_default3 = Circle2;

// node_modules/@antv/g-svg/esm/shape/dom.js
init_esm();
var Dom = function(_super) {
  __extends5(Dom2, _super);
  function Dom2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dom";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Dom2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    if (typeof attrs["html"] === "function") {
      var element = attrs["html"].call(this, attrs);
      if (element instanceof Element || element instanceof HTMLDocument) {
        var children = el.childNodes;
        for (var i2 = children.length - 1; i2 >= 0; i2--) {
          el.removeChild(children[i2]);
        }
        el.appendChild(element);
      } else {
        el.innerHTML = element;
      }
    } else {
      el.innerHTML = attrs["html"];
    }
  };
  return Dom2;
}(base_default3);
var dom_default = Dom;

// node_modules/@antv/g-svg/esm/shape/ellipse.js
init_esm();
var Ellipse2 = function(_super) {
  __extends5(Ellipse3, _super);
  function Ellipse3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "ellipse";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Ellipse3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
  };
  Ellipse3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "x" || attr === "y") {
        el.setAttribute("c" + attr, value);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Ellipse3;
}(base_default3);
var ellipse_default4 = Ellipse2;

// node_modules/@antv/g-svg/esm/shape/image.js
init_esm();
var Image2 = function(_super) {
  __extends5(Image3, _super);
  function Image3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "image";
    _this.canFill = false;
    _this.canStroke = false;
    return _this;
  }
  Image3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
  };
  Image3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "img") {
        _this._setImage(attrs.img);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Image3.prototype.setAttr = function(name, value) {
    this.attrs[name] = value;
    if (name === "img") {
      this._setImage(value);
    }
  };
  Image3.prototype._setImage = function(img) {
    var attrs = this.attr();
    var el = this.get("el");
    if (is_string_default(img)) {
      el.setAttribute("href", img);
    } else if (img instanceof window.Image) {
      if (!attrs.width) {
        el.setAttribute("width", img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", img.src);
    } else if (img instanceof HTMLElement && is_string_default(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
      el.setAttribute("href", img.toDataURL());
    } else if (img instanceof ImageData) {
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", "" + img.width);
      canvas.setAttribute("height", "" + img.height);
      canvas.getContext("2d").putImageData(img, 0, 0);
      if (!attrs.width) {
        el.setAttribute("width", "" + img.width);
        this.attr("width", img.width);
      }
      if (!attrs.height) {
        el.setAttribute("height", "" + img.height);
        this.attr("height", img.height);
      }
      el.setAttribute("href", canvas.toDataURL());
    }
  };
  return Image3;
}(base_default3);
var image_default2 = Image2;

// node_modules/@antv/g-svg/esm/shape/line.js
init_esm();
var Line3 = function(_super) {
  __extends5(Line5, _super);
  function Line5() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "line";
    _this.canFill = false;
    _this.canStroke = true;
    return _this;
  }
  Line5.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
  };
  Line5.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "startArrow" || attr === "endArrow") {
        if (value) {
          var id2 = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Line5.prototype.getTotalLength = function() {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return line_default.length(x1, y1, x2, y2);
  };
  Line5.prototype.getPoint = function(ratio) {
    var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
    return line_default.pointAt(x1, y1, x2, y2, ratio);
  };
  return Line5;
}(base_default3);
var line_default4 = Line3;

// node_modules/@antv/g-svg/esm/shape/marker/index.js
init_esm();

// node_modules/@antv/g-svg/esm/shape/marker/symbols.js
var Symbols2 = {
  circle: function(x2, y2, r2) {
    return [
      ["M", x2, y2],
      ["m", -r2, 0],
      ["a", r2, r2, 0, 1, 0, r2 * 2, 0],
      ["a", r2, r2, 0, 1, 0, -r2 * 2, 0]
    ];
  },
  square: function(x2, y2, r2) {
    return [["M", x2 - r2, y2 - r2], ["L", x2 + r2, y2 - r2], ["L", x2 + r2, y2 + r2], ["L", x2 - r2, y2 + r2], ["Z"]];
  },
  diamond: function(x2, y2, r2) {
    return [["M", x2 - r2, y2], ["L", x2, y2 - r2], ["L", x2 + r2, y2], ["L", x2, y2 + r2], ["Z"]];
  },
  triangle: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 + diffY], ["L", x2, y2 - diffY], ["L", x2 + r2, y2 + diffY], ["z"]];
  },
  triangleDown: function(x2, y2, r2) {
    var diffY = r2 * Math.sin(1 / 3 * Math.PI);
    return [["M", x2 - r2, y2 - diffY], ["L", x2 + r2, y2 - diffY], ["L", x2, y2 + diffY], ["Z"]];
  }
};
var symbols_default = {
  get: function(type) {
    return Symbols2[type];
  },
  register: function(type, func) {
    Symbols2[type] = func;
  },
  remove: function(type) {
    delete Symbols2[type];
  },
  getAll: function() {
    return Symbols2;
  }
};

// node_modules/@antv/g-svg/esm/shape/marker/index.js
var Marker2 = function(_super) {
  __extends5(Marker3, _super);
  function Marker3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "marker";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Marker3.prototype.createPath = function(context) {
    var el = this.get("el");
    el.setAttribute("d", this._assembleMarker());
  };
  Marker3.prototype._assembleMarker = function() {
    var d2 = this._getPath();
    if (is_array_default(d2)) {
      return d2.map(function(path) {
        return path.join(" ");
      }).join("");
    }
    return d2;
  };
  Marker3.prototype._getPath = function() {
    var attrs = this.attr();
    var x2 = attrs.x, y2 = attrs.y;
    var r2 = attrs.r || attrs.radius;
    var symbol = attrs.symbol || "circle";
    var method;
    if (is_function_default(symbol)) {
      method = symbol;
    } else {
      method = symbols_default.get(symbol);
    }
    if (!method) {
      console.warn(method + " symbol is not exist.");
      return null;
    }
    return method(x2, y2, r2);
  };
  Marker3.symbolsFactory = symbols_default;
  return Marker3;
}(base_default3);
var marker_default3 = Marker2;

// node_modules/@antv/g-svg/esm/shape/path.js
init_esm();
var Path2 = function(_super) {
  __extends5(Path3, _super);
  function Path3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "path";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Path3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { startArrow: false, endArrow: false });
  };
  Path3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "path" && is_array_default(value)) {
        el.setAttribute("d", _this._formatPath(value));
      } else if (attr === "startArrow" || attr === "endArrow") {
        if (value) {
          var id2 = is_object_default(value) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
          el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
        } else {
          el.removeAttribute(SVG_ATTR_MAP[attr]);
        }
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Path3.prototype._formatPath = function(value) {
    var newValue = value.map(function(path) {
      return path.join(" ");
    }).join("");
    if (~newValue.indexOf("NaN")) {
      return "";
    }
    return newValue;
  };
  Path3.prototype.getTotalLength = function() {
    var el = this.get("el");
    return el ? el.getTotalLength() : null;
  };
  Path3.prototype.getPoint = function(ratio) {
    var el = this.get("el");
    var totalLength = this.getTotalLength();
    if (totalLength === 0) {
      return null;
    }
    var point = el ? el.getPointAtLength(ratio * totalLength) : null;
    return point ? {
      x: point.x,
      y: point.y
    } : null;
  };
  return Path3;
}(base_default3);
var path_default4 = Path2;

// node_modules/@antv/g-svg/esm/shape/polygon.js
init_esm();
var Polygon2 = function(_super) {
  __extends5(Polygon3, _super);
  function Polygon3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polygon";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polygon3.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "points" && is_array_default(value) && value.length >= 2) {
        el.setAttribute("points", value.map(function(point) {
          return point[0] + "," + point[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  return Polygon3;
}(base_default3);
var polygon_default4 = Polygon2;

// node_modules/@antv/g-svg/esm/shape/polyline.js
init_esm();
var Polyline = function(_super) {
  __extends5(Polyline2, _super);
  function Polyline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "polyline";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Polyline2.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { startArrow: false, endArrow: false });
  };
  Polyline2.prototype.onAttrChange = function(name, value, originValue) {
    _super.prototype.onAttrChange.call(this, name, value, originValue);
    if (["points"].indexOf(name) !== -1) {
      this._resetCache();
    }
  };
  Polyline2.prototype._resetCache = function() {
    this.set("totalLength", null);
    this.set("tCache", null);
  };
  Polyline2.prototype.createPath = function(context, targetAttrs) {
    var attrs = this.attr();
    var el = this.get("el");
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "points" && is_array_default(value) && value.length >= 2) {
        el.setAttribute("points", value.map(function(point) {
          return point[0] + "," + point[1];
        }).join(" "));
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Polyline2.prototype.getTotalLength = function() {
    var points = this.attr().points;
    var totalLength = this.get("totalLength");
    if (!is_nil_default(totalLength)) {
      return totalLength;
    }
    this.set("totalLength", polyline_default.length(points));
    return this.get("totalLength");
  };
  Polyline2.prototype.getPoint = function(ratio) {
    var points = this.attr().points;
    var tCache = this.get("tCache");
    if (!tCache) {
      this._setTcache();
      tCache = this.get("tCache");
    }
    var subt;
    var index;
    each_default(tCache, function(v2, i2) {
      if (ratio >= v2[0] && ratio <= v2[1]) {
        subt = (ratio - v2[0]) / (v2[1] - v2[0]);
        index = i2;
      }
    });
    return line_default.pointAt(points[index][0], points[index][1], points[index + 1][0], points[index + 1][1], subt);
  };
  Polyline2.prototype._setTcache = function() {
    var points = this.attr().points;
    if (!points || points.length === 0) {
      return;
    }
    var totalLength = this.getTotalLength();
    if (totalLength <= 0) {
      return;
    }
    var tempLength = 0;
    var tCache = [];
    var segmentT;
    var segmentL;
    each_default(points, function(p2, i2) {
      if (points[i2 + 1]) {
        segmentT = [];
        segmentT[0] = tempLength / totalLength;
        segmentL = line_default.length(p2[0], p2[1], points[i2 + 1][0], points[i2 + 1][1]);
        tempLength += segmentL;
        segmentT[1] = tempLength / totalLength;
        tCache.push(segmentT);
      }
    });
    this.set("tCache", tCache);
  };
  Polyline2.prototype.getStartTangent = function() {
    var points = this.attr().points;
    var result = [];
    result.push([points[1][0], points[1][1]]);
    result.push([points[0][0], points[0][1]]);
    return result;
  };
  Polyline2.prototype.getEndTangent = function() {
    var points = this.attr().points;
    var l2 = points.length - 1;
    var result = [];
    result.push([points[l2 - 1][0], points[l2 - 1][1]]);
    result.push([points[l2][0], points[l2][1]]);
    return result;
  };
  return Polyline2;
}(base_default3);
var polyline_default4 = Polyline;

// node_modules/@antv/g-svg/esm/shape/rect.js
init_esm();

// node_modules/@antv/g-svg/esm/util/format.js
init_esm();
function parseRadius3(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (is_array_default(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}

// node_modules/@antv/g-svg/esm/shape/rect.js
var Rect2 = function(_super) {
  __extends5(Rect3, _super);
  function Rect3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rect";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Rect3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
  };
  Rect3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    var completed = false;
    var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
    each_default(targetAttrs || attrs, function(value, attr) {
      if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
        el.setAttribute("d", _this._assembleRect(attrs));
        completed = true;
      } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
  };
  Rect3.prototype._assembleRect = function(attrs) {
    var x2 = attrs.x;
    var y2 = attrs.y;
    var w2 = attrs.width;
    var h2 = attrs.height;
    var radius = attrs.radius;
    if (!radius) {
      return "M " + x2 + "," + y2 + " l " + w2 + ",0 l 0," + h2 + " l" + -w2 + " 0 z";
    }
    var r2 = parseRadius3(radius);
    if (is_array_default(radius)) {
      if (radius.length === 1) {
        r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius[0];
      } else if (radius.length === 2) {
        r2.r1 = r2.r3 = radius[0];
        r2.r2 = r2.r4 = radius[1];
      } else if (radius.length === 3) {
        r2.r1 = radius[0];
        r2.r2 = r2.r4 = radius[1];
        r2.r3 = radius[2];
      } else {
        r2.r1 = radius[0];
        r2.r2 = radius[1];
        r2.r3 = radius[2];
        r2.r4 = radius[3];
      }
    } else {
      r2.r1 = r2.r2 = r2.r3 = r2.r4 = radius;
    }
    var d2 = [
      ["M " + (x2 + r2.r1) + "," + y2],
      ["l " + (w2 - r2.r1 - r2.r2) + ",0"],
      ["a " + r2.r2 + "," + r2.r2 + ",0,0,1," + r2.r2 + "," + r2.r2],
      ["l 0," + (h2 - r2.r2 - r2.r3)],
      ["a " + r2.r3 + "," + r2.r3 + ",0,0,1," + -r2.r3 + "," + r2.r3],
      ["l " + (r2.r3 + r2.r4 - w2) + ",0"],
      ["a " + r2.r4 + "," + r2.r4 + ",0,0,1," + -r2.r4 + "," + -r2.r4],
      ["l 0," + (r2.r4 + r2.r1 - h2)],
      ["a " + r2.r1 + "," + r2.r1 + ",0,0,1," + r2.r1 + "," + -r2.r1],
      ["z"]
    ];
    return d2.join(" ");
  };
  return Rect3;
}(base_default3);
var rect_default3 = Rect2;

// node_modules/@antv/g-svg/esm/shape/text.js
init_esm();
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text2 = function(_super) {
  __extends5(Text3, _super);
  function Text3() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "text";
    _this.canFill = true;
    _this.canStroke = true;
    return _this;
  }
  Text3.prototype.getDefaultAttrs = function() {
    var attrs = _super.prototype.getDefaultAttrs.call(this);
    return __assign4(__assign4({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
  };
  Text3.prototype.createPath = function(context, targetAttrs) {
    var _this = this;
    var attrs = this.attr();
    var el = this.get("el");
    this._setFont();
    each_default(targetAttrs || attrs, function(value, attr) {
      if (attr === "text") {
        _this._setText("" + value);
      } else if (attr === "matrix" && value) {
        setTransform(_this);
      } else if (SVG_ATTR_MAP[attr]) {
        el.setAttribute(SVG_ATTR_MAP[attr], value);
      }
    });
    el.setAttribute("paint-order", "stroke");
    el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
  };
  Text3.prototype._setFont = function() {
    var el = this.get("el");
    var _a2 = this.attr(), textBaseline = _a2.textBaseline, textAlign = _a2.textAlign;
    var browser2 = detect();
    if (browser2 && browser2.name === "firefox") {
      el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
    } else {
      el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
    }
    el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
  };
  Text3.prototype._setText = function(text) {
    var el = this.get("el");
    var _a2 = this.attr(), x2 = _a2.x, _b = _a2.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
    if (!text) {
      el.innerHTML = "";
    } else if (~text.indexOf("\n")) {
      var textArr = text.split("\n");
      var textLen_1 = textArr.length - 1;
      var arr_1 = "";
      each_default(textArr, function(segment, i2) {
        if (i2 === 0) {
          if (baseline === "alphabetic") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
          } else if (baseline === "top") {
            arr_1 += '<tspan x="' + x2 + '" dy="0.9em">' + segment + "</tspan>";
          } else if (baseline === "middle") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
          } else if (baseline === "bottom") {
            arr_1 += '<tspan x="' + x2 + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
          } else if (baseline === "hanging") {
            arr_1 += '<tspan x="' + x2 + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
          }
        } else {
          arr_1 += '<tspan x="' + x2 + '" dy="1em">' + segment + "</tspan>";
        }
      });
      el.innerHTML = arr_1;
    } else {
      el.innerHTML = text;
    }
  };
  return Text3;
}(base_default3);
var text_default3 = Text2;

// node_modules/@antv/g-svg/esm/defs/index.js
init_esm();

// node_modules/@antv/g-svg/esm/defs/gradient.js
init_esm();
var regexLG2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop2 = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop2(steps) {
  var arr = steps.match(regexColorStop2);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a2, b10) {
    a2 = a2.split(":");
    b10 = b10.split(":");
    return Number(a2[0]) - Number(b10[0]);
  });
  each_default(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient2(color3, el) {
  var arr = regexLG2.exec(color3);
  var angle3 = mod_default(to_radian_default(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end2;
  if (angle3 >= 0 && angle3 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end2 = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle3 && angle3 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end2 = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle3 && angle3 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end2 = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end2 = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle3);
  var tanTheta2 = tanTheta * tanTheta;
  var x2 = (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y2 = tanTheta * (end2.x - start.x + tanTheta * (end2.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x2);
  el.setAttribute("y2", y2);
  el.innerHTML = addStop2(steps);
}
function parseRadialGradient2(color3, self2) {
  var arr = regexRG2.exec(color3);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r2 = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r2);
  self2.innerHTML = addStop2(steps);
}
var Gradient = function() {
  function Gradient2(cfg) {
    this.cfg = {};
    var el = null;
    var id2 = unique_id_default("gradient_");
    if (cfg.toLowerCase()[0] === "l") {
      el = createSVGElement("linearGradient");
      parseLineGradient2(cfg, el);
    } else {
      el = createSVGElement("radialGradient");
      parseRadialGradient2(cfg, el);
    }
    el.setAttribute("id", id2);
    this.el = el;
    this.id = id2;
    this.cfg = cfg;
    return this;
  }
  Gradient2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Gradient2;
}();
var gradient_default = Gradient;

// node_modules/@antv/g-svg/esm/defs/shadow.js
init_esm();
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = function() {
  function Shadow2(cfg) {
    this.type = "filter";
    this.cfg = {};
    this.type = "filter";
    var el = createSVGElement("filter");
    each_default(SHADOW_DIMENSION, function(v2, k2) {
      el.setAttribute(k2, v2);
    });
    this.el = el;
    this.id = unique_id_default("filter_");
    this.el.id = this.id;
    this.cfg = cfg;
    this._parseShadow(cfg, el);
    return this;
  }
  Shadow2.prototype.match = function(type, cfg) {
    if (this.type !== type) {
      return false;
    }
    var flag = true;
    var config = this.cfg;
    each_default(Object.keys(config), function(attr) {
      if (config[attr] !== cfg[attr]) {
        flag = false;
        return false;
      }
    });
    return flag;
  };
  Shadow2.prototype.update = function(name, value) {
    var config = this.cfg;
    config[ATTR_MAP[name]] = value;
    this._parseShadow(config, this.el);
    return this;
  };
  Shadow2.prototype._parseShadow = function(config, el) {
    var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
    el.innerHTML = child;
  };
  return Shadow2;
}();
var shadow_default = Shadow;

// node_modules/@antv/g-svg/esm/defs/arrow.js
init_esm();
var Arrow = function() {
  function Arrow2(attrs, type) {
    this.cfg = {};
    var el = createSVGElement("marker");
    var id2 = unique_id_default("marker_");
    el.setAttribute("id", id2);
    var shape = createSVGElement("path");
    shape.setAttribute("stroke", attrs.stroke || "none");
    shape.setAttribute("fill", attrs.fill || "none");
    el.appendChild(shape);
    el.setAttribute("overflow", "visible");
    el.setAttribute("orient", "auto-start-reverse");
    this.el = el;
    this.child = shape;
    this.id = id2;
    var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
    this.stroke = attrs.stroke || "#000";
    if (cfg === true) {
      this._setDefaultPath(type, shape);
    } else {
      this.cfg = cfg;
      this._setMarker(attrs.lineWidth, shape);
    }
    return this;
  }
  Arrow2.prototype.match = function() {
    return false;
  };
  Arrow2.prototype._setDefaultPath = function(type, el) {
    var parent = this.el;
    el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
    parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
    parent.setAttribute("refY", "" + 5);
  };
  Arrow2.prototype._setMarker = function(r2, el) {
    var parent = this.el;
    var path = this.cfg.path;
    var d2 = this.cfg.d;
    if (is_array_default(path)) {
      path = path.map(function(segment) {
        return segment.join(" ");
      }).join("");
    }
    el.setAttribute("d", path);
    parent.appendChild(el);
    if (d2) {
      parent.setAttribute("refX", "" + d2 / r2);
    }
  };
  Arrow2.prototype.update = function(fill) {
    var child = this.child;
    if (child.attr) {
      child.attr("fill", fill);
    } else {
      child.setAttribute("fill", fill);
    }
  };
  return Arrow2;
}();
var arrow_default2 = Arrow;

// node_modules/@antv/g-svg/esm/defs/clip.js
init_esm();
var Clip = function() {
  function Clip2(cfg) {
    this.type = "clip";
    this.cfg = {};
    var el = createSVGElement("clipPath");
    this.el = el;
    this.id = unique_id_default("clip_");
    el.id = this.id;
    var shapeEl = cfg.cfg.el;
    el.appendChild(shapeEl);
    this.cfg = cfg;
    return this;
  }
  Clip2.prototype.match = function() {
    return false;
  };
  Clip2.prototype.remove = function() {
    var el = this.el;
    el.parentNode.removeChild(el);
  };
  return Clip2;
}();
var clip_default = Clip;

// node_modules/@antv/g-svg/esm/defs/pattern.js
init_esm();
var regexPR2 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = function() {
  function Pattern2(cfg) {
    this.cfg = {};
    var el = createSVGElement("pattern");
    el.setAttribute("patternUnits", "userSpaceOnUse");
    var child = createSVGElement("image");
    el.appendChild(child);
    var id2 = unique_id_default("pattern_");
    el.id = id2;
    this.el = el;
    this.id = id2;
    this.cfg = cfg;
    var arr = regexPR2.exec(cfg);
    var source = arr[2];
    child.setAttribute("href", source);
    var img = new Image();
    if (!source.match(/^data:/i)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = source;
    function onload() {
      el.setAttribute("width", "" + img.width);
      el.setAttribute("height", "" + img.height);
    }
    if (img.complete) {
      onload();
    } else {
      img.onload = onload;
      img.src = img.src;
    }
    return this;
  }
  Pattern2.prototype.match = function(type, attr) {
    return this.cfg === attr;
  };
  return Pattern2;
}();
var pattern_default = Pattern;

// node_modules/@antv/g-svg/esm/defs/index.js
var Defs = function() {
  function Defs2(canvas) {
    var el = createSVGElement("defs");
    var id2 = unique_id_default("defs_");
    el.id = id2;
    canvas.appendChild(el);
    this.children = [];
    this.defaultArrow = {};
    this.el = el;
    this.canvas = canvas;
  }
  Defs2.prototype.find = function(type, attr) {
    var children = this.children;
    var result = null;
    for (var i2 = 0; i2 < children.length; i2++) {
      if (children[i2].match(type, attr)) {
        result = children[i2].id;
        break;
      }
    }
    return result;
  };
  Defs2.prototype.findById = function(id2) {
    var children = this.children;
    var flag = null;
    for (var i2 = 0; i2 < children.length; i2++) {
      if (children[i2].id === id2) {
        flag = children[i2];
        break;
      }
    }
    return flag;
  };
  Defs2.prototype.add = function(item) {
    this.children.push(item);
    item.canvas = this.canvas;
    item.parent = this;
  };
  Defs2.prototype.getDefaultArrow = function(attrs, name) {
    var stroke = attrs.stroke || attrs.strokeStyle;
    if (this.defaultArrow[stroke]) {
      return this.defaultArrow[stroke].id;
    }
    var arrow = new arrow_default2(attrs, name);
    this.defaultArrow[stroke] = arrow;
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addGradient = function(cfg) {
    var gradient = new gradient_default(cfg);
    this.el.appendChild(gradient.el);
    this.add(gradient);
    return gradient.id;
  };
  Defs2.prototype.addArrow = function(attrs, name) {
    var arrow = new arrow_default2(attrs, name);
    this.el.appendChild(arrow.el);
    this.add(arrow);
    return arrow.id;
  };
  Defs2.prototype.addShadow = function(cfg) {
    var shadow = new shadow_default(cfg);
    this.el.appendChild(shadow.el);
    this.add(shadow);
    return shadow.id;
  };
  Defs2.prototype.addPattern = function(cfg) {
    var pattern = new pattern_default(cfg);
    this.el.appendChild(pattern.el);
    this.add(pattern);
    return pattern.id;
  };
  Defs2.prototype.addClip = function(cfg) {
    var clip = new clip_default(cfg);
    this.el.appendChild(clip.el);
    this.add(clip);
    return clip.id;
  };
  return Defs2;
}();
var defs_default = Defs;

// node_modules/@antv/g-svg/esm/canvas.js
var Canvas3 = function(_super) {
  __extends5(Canvas4, _super);
  function Canvas4(cfg) {
    return _super.call(this, __assign4(__assign4({}, cfg), {
      autoDraw: true,
      renderer: "svg"
    })) || this;
  }
  Canvas4.prototype.getShapeBase = function() {
    return shape_exports2;
  };
  Canvas4.prototype.getGroupBase = function() {
    return group_default4;
  };
  Canvas4.prototype.getShape = function(x2, y2, ev) {
    var target = ev.target || ev.srcElement;
    if (!SHAPE_TO_TAGS[target.tagName]) {
      var parent_1 = target.parentNode;
      while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
        parent_1 = parent_1.parentNode;
      }
      target = parent_1;
    }
    return this.find(function(child) {
      return child.get("el") === target;
    });
  };
  Canvas4.prototype.createDom = function() {
    var element = createSVGElement("svg");
    var context = new defs_default(element);
    element.setAttribute("width", "" + this.get("width"));
    element.setAttribute("height", "" + this.get("height"));
    this.set("context", context);
    return element;
  };
  Canvas4.prototype.onCanvasChange = function(changeType) {
    var context = this.get("context");
    var el = this.get("el");
    if (changeType === "sort") {
      var children_1 = this.get("children");
      if (children_1 && children_1.length) {
        sortDom(this, function(a2, b10) {
          return children_1.indexOf(a2) - children_1.indexOf(b10) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
        var defsEl = context.el;
        defsEl.innerHTML = "";
        el.appendChild(defsEl);
      }
    } else if (changeType === "matrix") {
      setTransform(this);
    } else if (changeType === "clip") {
      setClip(this, context);
    } else if (changeType === "changeSize") {
      el.setAttribute("width", "" + this.get("width"));
      el.setAttribute("height", "" + this.get("height"));
    }
  };
  Canvas4.prototype.draw = function() {
    var context = this.get("context");
    var children = this.getChildren();
    setClip(this, context);
    if (children.length) {
      drawChildren2(context, children);
    }
  };
  return Canvas4;
}(canvas_default);
var canvas_default3 = Canvas3;

// node_modules/@antv/g6-pc/es/graph/graph.js
init_esm();

// node_modules/@antv/g6-pc/es/util/color.js
var color_exports2 = {};
__export(color_exports2, {
  getColorSetsBySubjectColors: () => getColorSetsBySubjectColors,
  getColorsWithSubjectColor: () => getColorsWithSubjectColor,
  mixColor: () => mixColor
});
var import_color11 = __toESM(require_color());

// node_modules/@antv/g6-pc/node_modules/@ant-design/colors/dist/index.esm.js
var import_tinycolor2 = __toESM(require_tinycolor());
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function getHue(hsv, i2, light) {
  var hue2;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue2 = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue2 = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue2 < 0) {
    hue2 += 360;
  } else if (hue2 >= 360) {
    hue2 -= 360;
  }
  return hue2;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate(color3) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = (0, import_tinycolor2.default)(color3);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = pColor.toHsv();
    var colorString = (0, import_tinycolor2.default)({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue(hsv, i2, true)
    }).toHexString();
    patterns.push(colorString);
  }
  patterns.push(pColor.toHexString());
  for (var _i2 = 1; _i2 <= darkColorCount; _i2 += 1) {
    var _hsv = pColor.toHsv();
    var _colorString = (0, import_tinycolor2.default)({
      h: getHue(_hsv, _i2),
      s: getSaturation(_hsv, _i2),
      v: getValue(_hsv, _i2)
    }).toHexString();
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref2) {
      var index = _ref2.index, opacity = _ref2.opacity;
      var darkColorString = import_tinycolor2.default.mix(opts.backgroundColor || "#141414", patterns[index], opacity * 100).toHexString();
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
var red = presetPalettes.red;
var volcano = presetPalettes.volcano;
var gold = presetPalettes.gold;
var orange = presetPalettes.orange;
var yellow = presetPalettes.yellow;
var lime = presetPalettes.lime;
var green = presetPalettes.green;
var cyan = presetPalettes.cyan;
var blue = presetPalettes.blue;
var geekblue = presetPalettes.geekblue;
var purple = presetPalettes.purple;
var magenta = presetPalettes.magenta;
var grey = presetPalettes.grey;

// node_modules/@antv/g6-pc/es/util/color.js
var mixColor = function mixColor2(backColor3, frontColor, frontAlpha) {
  var bc = (0, import_color11.default)(backColor3);
  var fc = (0, import_color11.default)(frontColor);
  return (0, import_color11.default)([(1 - frontAlpha) * bc.red() + frontAlpha * fc.red(), (1 - frontAlpha) * bc.green() + frontAlpha * fc.green(), (1 - frontAlpha) * bc.blue() + frontAlpha * fc.blue()]).rgb();
};
var getColorsWithDefaultTheme = function getColorsWithDefaultTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var subjectColor005 = mixColor(backColor3, subjectColor3, 0.05).rgb().toString();
  var subjectColor01 = mixColor(backColor3, subjectColor3, 0.1).rgb().toString();
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor04 = mixColor(backColor3, subjectColor3, 0.4).rgb().toString();
  var disableColor002 = mixColor(backColor3, disableColor, 0.02).rgb().toString();
  var disableColor005 = mixColor(backColor3, disableColor, 0.05).rgb().toString();
  var disableColor01 = mixColor(backColor3, disableColor, 0.1).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "default",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color11.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    mainStroke: subjectColor3,
    mainFill: subjectColor01,
    activeStroke: subjectColor3,
    activeFill: subjectColor005,
    inactiveStroke: subjectColor04,
    inactiveFill: subjectColor005,
    selectedStroke: subjectColor3,
    selectedFill: backColor3,
    highlightStroke: deeperSubject,
    highlightFill: subjectColor02,
    disableStroke: disableColor03,
    disableFill: disableColor005,
    edgeMainStroke: disableColor03,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor02,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor01,
    comboMainStroke: disableColor03,
    comboMainFill: disableColor002,
    comboActiveStroke: subjectColor3,
    comboActiveFill: subjectColor005,
    comboInactiveStroke: disableColor03,
    comboInactiveFill: disableColor002,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor002,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor002,
    comboDisableStroke: disableColor02,
    comboDisableFill: disableColor005
  };
};
var getColorsWithDarkTheme = function getColorsWithDarkTheme2(subjectColor3, backColor3, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (disableColor === void 0) {
    disableColor = "#777";
  }
  var subjectColor02 = mixColor(backColor3, subjectColor3, 0.2).rgb().toString();
  var subjectColor03 = mixColor(backColor3, subjectColor3, 0.3).rgb().toString();
  var subjectColor06 = mixColor(backColor3, subjectColor3, 0.6).rgb().toString();
  var subjectColor08 = mixColor(backColor3, subjectColor3, 0.8).rgb().toString();
  var disableColor02 = mixColor(backColor3, disableColor, 0.2).rgb().toString();
  var disableColor025 = mixColor(backColor3, disableColor, 0.25).rgb().toString();
  var disableColor03 = mixColor(backColor3, disableColor, 0.3).rgb().toString();
  var disableColor04 = mixColor(backColor3, disableColor, 0.4).rgb().toString();
  var disableColor05 = mixColor(backColor3, disableColor, 0.5).rgb().toString();
  var paletteFromSubject = generate(subjectColor3, {
    theme: "dark",
    backgroundColor: backColor3
  });
  var subjectHex = (0, import_color11.default)(subjectColor3).hex().toLowerCase();
  var subjectIdx = paletteFromSubject.indexOf(subjectHex);
  var deeperSubject = subjectColor3;
  if (subjectIdx !== -1) {
    deeperSubject = paletteFromSubject[subjectIdx + 1];
  }
  return {
    mainStroke: subjectColor08,
    mainFill: subjectColor02,
    activeStroke: subjectColor3,
    activeFill: subjectColor03,
    inactiveStroke: subjectColor08,
    inactiveFill: subjectColor02,
    selectedStroke: subjectColor3,
    selectedFill: subjectColor02,
    highlightStroke: subjectColor3,
    highlightFill: subjectColor06,
    disableStroke: disableColor05,
    disableFill: disableColor025,
    edgeMainStroke: disableColor,
    edgeActiveStroke: subjectColor3,
    edgeInactiveStroke: disableColor,
    edgeSelectedStroke: subjectColor3,
    edgeHighlightStroke: subjectColor3,
    edgeDisableStroke: disableColor03,
    comboMainStroke: disableColor04,
    comboMainFill: disableColor025,
    comboActiveStroke: subjectColor3,
    comboActiveFill: disableColor02,
    comboInactiveStroke: disableColor04,
    comboInactiveFill: disableColor025,
    comboSelectedStroke: subjectColor3,
    comboSelectedFill: disableColor02,
    comboHighlightStroke: deeperSubject,
    comboHighlightFill: disableColor025,
    comboDisableStroke: disableColor04,
    comboDisableFill: disableColor02
  };
};
var getColorsWithSubjectColor = function getColorsWithSubjectColor2(subjectColor3, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  if (theme === "default")
    return getColorsWithDefaultTheme(subjectColor3, backColor3, "rgb(150, 150, 150)");
  return getColorsWithDarkTheme(subjectColor3, backColor3, "#777");
};
var getColorSetsBySubjectColors = function getColorSetsBySubjectColors2(subjectColors, backColor3, theme, disableColor) {
  if (backColor3 === void 0) {
    backColor3 = "#fff";
  }
  if (theme === void 0) {
    theme = "default";
  }
  if (disableColor === void 0) {
    disableColor = "rgb(150, 150, 150)";
  }
  var sets = [];
  subjectColors.forEach(function(sColor) {
    sets.push(getColorsWithSubjectColor(sColor, backColor3, theme, disableColor));
  });
  return sets;
};

// node_modules/@antv/g6-pc/es/global.js
var subjectColor2 = "rgb(95, 149, 255)";
var backColor2 = "rgb(255, 255, 255)";
var textColor2 = "rgb(0, 0, 0)";
var colorSet2 = getColorsWithSubjectColor(subjectColor2, backColor2);
var global_default2 = {
  version: "0.6.4",
  rootContainerClassName: "root-container",
  nodeContainerClassName: "node-container",
  edgeContainerClassName: "edge-container",
  comboContainerClassName: "combo-container",
  delegateContainerClassName: "delegate-container",
  defaultLoopPosition: "top",
  nodeLabel: {
    style: {
      fill: "#000",
      fontSize: 12,
      textAlign: "center",
      textBaseline: "middle"
    },
    offset: 4
  },
  defaultNode: {
    type: "circle",
    style: {
      lineWidth: 1,
      stroke: colorSet2.mainStroke,
      fill: colorSet2.mainFill
    },
    size: 20,
    color: colorSet2.mainStroke,
    linkPoints: {
      size: 8,
      lineWidth: 1,
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke
    }
  },
  nodeStateStyles: {
    active: {
      fill: colorSet2.activeFill,
      stroke: colorSet2.activeStroke,
      lineWidth: 2,
      shadowColor: colorSet2.mainStroke,
      shadowBlur: 10
    },
    selected: {
      fill: colorSet2.selectedFill,
      stroke: colorSet2.selectedStroke,
      lineWidth: 4,
      shadowColor: colorSet2.selectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      fill: colorSet2.highlightFill,
      stroke: colorSet2.highlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      fill: colorSet2.inactiveFill,
      stroke: colorSet2.inactiveStroke,
      lineWidth: 1
    },
    disable: {
      fill: colorSet2.disableFill,
      stroke: colorSet2.disableStroke,
      lineWidth: 1
    }
  },
  edgeLabel: {
    style: {
      fill: textColor2,
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 12
    }
  },
  defaultEdge: {
    type: "line",
    size: 1,
    style: {
      stroke: colorSet2.edgeMainStroke,
      lineAppendWidth: 2
    },
    color: colorSet2.edgeMainStroke
  },
  edgeStateStyles: {
    active: {
      stroke: colorSet2.edgeActiveStroke,
      lineWidth: 1
    },
    selected: {
      stroke: colorSet2.edgeSelectedStroke,
      lineWidth: 2,
      shadowColor: colorSet2.edgeSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.edgeHighlightStroke,
      lineWidth: 2,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.edgeInactiveStroke,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.edgeDisableStroke,
      lineWidth: 1
    }
  },
  comboLabel: {
    style: {
      fill: textColor2,
      textBaseline: "middle",
      fontSize: 12
    },
    refY: 10,
    refX: 10
  },
  defaultCombo: {
    type: "circle",
    style: {
      fill: colorSet2.comboMainFill,
      lineWidth: 1,
      stroke: colorSet2.comboMainStroke,
      r: 5,
      width: 20,
      height: 10
    },
    size: [20, 5],
    color: colorSet2.comboMainStroke,
    padding: [25, 20, 15, 20]
  },
  comboStateStyles: {
    active: {
      stroke: colorSet2.comboActiveStroke,
      lineWidth: 1,
      fill: colorSet2.comboActiveFill
    },
    selected: {
      stroke: colorSet2.comboSelectedStroke,
      lineWidth: 2,
      fill: colorSet2.comboSelectedFill,
      shadowColor: colorSet2.comboSelectedStroke,
      shadowBlur: 10,
      "text-shape": {
        fontWeight: 500
      }
    },
    highlight: {
      stroke: colorSet2.comboHighlightStroke,
      lineWidth: 2,
      fill: colorSet2.comboHighlightFill,
      "text-shape": {
        fontWeight: 500
      }
    },
    inactive: {
      stroke: colorSet2.comboInactiveStroke,
      fill: colorSet2.comboInactiveFill,
      lineWidth: 1
    },
    disable: {
      stroke: colorSet2.comboDisableStroke,
      fill: colorSet2.comboDisableFill,
      lineWidth: 1
    }
  },
  delegateStyle: {
    fill: "#F3F9FF",
    fillOpacity: 0.5,
    stroke: "#1890FF",
    strokeOpacity: 0.9,
    lineDash: [5, 5]
  },
  textWaterMarkerConfig: {
    width: 150,
    height: 100,
    compatible: false,
    text: {
      x: 0,
      y: 60,
      lineHeight: 20,
      rotate: 20,
      fontSize: 14,
      fontFamily: "Microsoft YaHei",
      fill: "rgba(0, 0, 0, 0.1)",
      baseline: "Middle"
    }
  },
  imageWaterMarkerConfig: {
    width: 150,
    height: 130,
    compatible: false,
    image: {
      x: 0,
      y: 0,
      width: 30,
      height: 20,
      rotate: 0
    }
  },
  waterMarkerImage: "https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg"
};

// node_modules/@antv/dom-util/esm/add-event-listener.js
function addEventListener(target, eventType, callback) {
  if (target) {
    if (typeof target.addEventListener === "function") {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target.attachEvent === "function") {
      target.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}

// node_modules/@antv/dom-util/esm/create-dom.js
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom2(str7) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str7) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container2 = CONTAINERS[name];
  str7 = typeof str7 === "string" ? str7.replace(/(^\s*)|(\s*$)/g, "") : str7;
  container2.innerHTML = "" + str7;
  var dom = container2.childNodes[0];
  if (dom && container2.contains(dom)) {
    container2.removeChild(dom);
  }
  return dom;
}

// node_modules/@antv/dom-util/esm/modify-css.js
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}

// node_modules/@antv/g6-pc/es/graph/controller/event.js
init_esm();
var cloneEvent3 = util_default.cloneEvent;
var isViewportChanged3 = util_default.isViewportChanged;
var EventController3 = function(_super) {
  __extends(EventController4, _super);
  function EventController4(graph) {
    var _this = _super.call(this, graph) || this;
    _this.extendEvents = [];
    _this.dragging = false;
    _this.preItem = null;
    _this.graph = graph;
    _this.destroyed = false;
    _this.initEvents();
    return _this;
  }
  EventController4.prototype.initEvents = function() {
    var _a2 = this, graph = _a2.graph, _b = _a2.extendEvents, extendEvents = _b === void 0 ? [] : _b;
    var canvas = graph.get("canvas");
    var el = canvas.get("el");
    var canvasHandler = wrap_behavior_default(this, "onCanvasEvents");
    var originHandler = wrap_behavior_default(this, "onExtendEvents");
    var wheelHandler = wrap_behavior_default(this, "onWheelEvent");
    canvas.off("*").on("*", canvasHandler);
    this.canvasHandler = canvasHandler;
    extendEvents.push(addEventListener(el, "DOMMouseScroll", wheelHandler));
    extendEvents.push(addEventListener(el, "mousewheel", wheelHandler));
    if (typeof window !== "undefined") {
      extendEvents.push(addEventListener(window, "keydown", originHandler));
      extendEvents.push(addEventListener(window, "keyup", originHandler));
      extendEvents.push(addEventListener(window, "focus", originHandler));
    }
  };
  EventController4.getItemRoot = function(shape) {
    while (shape && !shape.get("item")) {
      shape = shape.get("parent");
    }
    return shape;
  };
  EventController4.prototype.onCanvasEvents = function(evt) {
    var graph = this.graph;
    var canvas = graph.get("canvas");
    var target = evt.target;
    var eventType = evt.type;
    evt.canvasX = evt.x;
    evt.canvasY = evt.y;
    var point = {
      x: evt.canvasX,
      y: evt.canvasY
    };
    var group = graph.get("group");
    var matrix = group.getMatrix();
    if (!matrix) {
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    }
    if (isViewportChanged3(matrix)) {
      point = graph.getPointByClient(evt.clientX, evt.clientY);
    }
    evt.x = point.x;
    evt.y = point.y;
    evt.currentTarget = graph;
    if (target === canvas) {
      if (eventType === "mousemove" || eventType === "mouseleave") {
        this.handleMouseMove(evt, "canvas");
      }
      evt.target = canvas;
      evt.item = null;
      graph.emit(eventType, evt);
      graph.emit("canvas:".concat(eventType), evt);
      return;
    }
    var itemShape = EventController4.getItemRoot(target);
    if (!itemShape) {
      graph.emit(eventType, evt);
      return;
    }
    var item = itemShape.get("item");
    if (item.destroyed) {
      return;
    }
    var type = item.getType();
    evt.target = target;
    evt.item = item;
    if (evt.canvasX === evt.x && evt.canvasY === evt.y) {
      var canvasPoint = graph.getCanvasByPoint(evt.x, evt.y);
      evt.canvasX = canvasPoint.x;
      evt.canvasY = canvasPoint.y;
    }
    graph.emit(eventType, evt);
    if (evt.name && !evt.name.includes(":"))
      graph.emit("".concat(type, ":").concat(eventType), evt);
    else
      graph.emit(evt.name, evt);
    if (eventType === "dragstart") {
      this.dragging = true;
    }
    if (eventType === "dragend") {
      this.dragging = false;
    }
    if (eventType === "mousemove") {
      this.handleMouseMove(evt, type);
    }
  };
  EventController4.prototype.onExtendEvents = function(evt) {
    this.graph.emit(evt.type, evt);
  };
  EventController4.prototype.onWheelEvent = function(evt) {
    if (is_nil_default(evt.wheelDelta)) {
      evt.wheelDelta = -evt.detail;
    }
    this.graph.emit("wheel", evt);
  };
  EventController4.prototype.handleMouseMove = function(evt, type) {
    var _a2 = this, graph = _a2.graph, preItem = _a2.preItem;
    var canvas = graph.get("canvas");
    var item = evt.target === canvas ? null : evt.item;
    evt = cloneEvent3(evt);
    if (preItem && preItem !== item && !preItem.destroyed) {
      evt.item = preItem;
      this.emitCustomEvent(preItem.getType(), "mouseleave", evt);
      if (this.dragging) {
        this.emitCustomEvent(preItem.getType(), "dragleave", evt);
      }
    }
    if (item && preItem !== item) {
      evt.item = item;
      this.emitCustomEvent(type, "mouseenter", evt);
      if (this.dragging) {
        this.emitCustomEvent(type, "dragenter", evt);
      }
    }
    this.preItem = item;
  };
  EventController4.prototype.emitCustomEvent = function(itemType, eventType, evt) {
    evt.type = eventType;
    this.graph.emit("".concat(itemType, ":").concat(eventType), evt);
  };
  EventController4.prototype.destroy = function() {
    var _a2 = this, graph = _a2.graph, canvasHandler = _a2.canvasHandler, extendEvents = _a2.extendEvents;
    var canvas = graph.get("canvas");
    canvas.off("*", canvasHandler);
    each_default(extendEvents, function(event) {
      event.remove();
    });
    this.dragging = false;
    this.preItem = null;
    this.extendEvents.length = 0;
    this.canvasHandler = null;
    this.destroyed = true;
  };
  return EventController4;
}(event_default);
var event_default2 = EventController3;

// node_modules/@antv/g6-pc/es/layout/index.js
var import_lib = __toESM(require_lib());

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var import_hierarchy = __toESM(require_lib2());

// node_modules/@antv/g6-pc/es/util/layout.js
var layout_exports = {};
__export(layout_exports, {
  arrayToTextureData: () => arrayToTextureData,
  attributesToTextureData: () => attributesToTextureData,
  buildTextureData: () => buildTextureData,
  buildTextureDataWithOneEdgeAttr: () => buildTextureDataWithOneEdgeAttr,
  buildTextureDataWithTwoEdgeAttr: () => buildTextureDataWithTwoEdgeAttr,
  proccessToFunc: () => proccessToFunc,
  radialLayout: () => radialLayout
});
init_esm();
var traverseTree3 = util_default.traverseTree;
var proccessToFunc = function proccessToFunc2(value, defaultV) {
  var func;
  if (!value) {
    func = function func2(d2) {
      return defaultV || 1;
    };
  } else if (is_number_default(value)) {
    func = function func2(d2) {
      return value;
    };
  } else {
    func = value;
  }
  return func;
};
var buildTextureData = function buildTextureData2(nodes, edges) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len5 = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = dests.length;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, dests.length);
    for (var j2 = 0; j2 < len5; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithOneEdgeAttr = function buildTextureDataWithOneEdgeAttr2(nodes, edges, attrs) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs(e8));
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs(e8));
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len5 = dests.length;
    dataArray[i2 * 4 + 2] = offset;
    dataArray[i2 * 4 + 3] = len5 / 2;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len5 / 2);
    for (var j2 = 0; j2 < len5; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var buildTextureDataWithTwoEdgeAttr = function buildTextureDataWithTwoEdgeAttr2(nodes, edges, attrs1, attrs2) {
  var dataArray = [];
  var nodeDict = [];
  var mapIdPos = {};
  var i2 = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var n2 = nodes[i2];
    mapIdPos[n2.id] = i2;
    dataArray.push(n2.x);
    dataArray.push(n2.y);
    dataArray.push(0);
    dataArray.push(0);
    nodeDict.push([]);
  }
  for (i2 = 0; i2 < edges.length; i2++) {
    var e8 = edges[i2];
    nodeDict[mapIdPos[e8.source]].push(mapIdPos[e8.target]);
    nodeDict[mapIdPos[e8.source]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.source]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.source]].push(0);
    nodeDict[mapIdPos[e8.target]].push(mapIdPos[e8.source]);
    nodeDict[mapIdPos[e8.target]].push(attrs1(e8));
    nodeDict[mapIdPos[e8.target]].push(attrs2(e8));
    nodeDict[mapIdPos[e8.target]].push(0);
  }
  var maxEdgePerVetex = 0;
  for (i2 = 0; i2 < nodes.length; i2++) {
    var offset = dataArray.length;
    var dests = nodeDict[i2];
    var len5 = dests.length;
    dataArray[i2 * 4 + 2] = offset + 1048576 * len5 / 4;
    dataArray[i2 * 4 + 3] = 0;
    maxEdgePerVetex = Math.max(maxEdgePerVetex, len5 / 4);
    for (var j2 = 0; j2 < len5; ++j2) {
      var dest = dests[j2];
      dataArray.push(+dest);
    }
  }
  while (dataArray.length % 4 !== 0) {
    dataArray.push(0);
  }
  return {
    array: new Float32Array(dataArray),
    maxEdgePerVetex
  };
};
var attributesToTextureData = function attributesToTextureData2(attributeNames, items) {
  var dataArray = [];
  var attributeNum = attributeNames.length;
  var attributteStringMap = {};
  items.forEach(function(item) {
    attributeNames.forEach(function(name, i2) {
      if (attributteStringMap[item[name]] === void 0) {
        attributteStringMap[item[name]] = Object.keys(attributteStringMap).length;
      }
      dataArray.push(attributteStringMap[item[name]]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  });
  return {
    array: new Float32Array(dataArray),
    count: Object.keys(attributteStringMap).length
  };
};
var arrayToTextureData = function arrayToTextureData2(valueArrays) {
  var dataArray = [];
  var attributeNum = valueArrays.length;
  var itemNum = valueArrays[0].length;
  var _loop_1 = function _loop_12(j3) {
    valueArrays.forEach(function(valueArray, i2) {
      dataArray.push(valueArray[j3]);
      if (i2 === attributeNum - 1) {
        while (dataArray.length % 4 !== 0) {
          dataArray.push(0);
        }
      }
    });
  };
  for (var j2 = 0; j2 < itemNum; j2++) {
    _loop_1(j2);
  }
  return new Float32Array(dataArray);
};
var radialLayout = function radialLayout2(data, layout2) {
  var VERTICAL_LAYOUTS = ["V", "TB", "BT"];
  var min6 = {
    x: Infinity,
    y: Infinity
  };
  var max7 = {
    x: -Infinity,
    y: -Infinity
  };
  var rScale = "x";
  var radScale = "y";
  if (layout2 && VERTICAL_LAYOUTS.indexOf(layout2) >= 0) {
    radScale = "x";
    rScale = "y";
  }
  var count = 0;
  traverseTree3(data, function(node) {
    count++;
    if (node.x > max7.x) {
      max7.x = node.x;
    }
    if (node.x < min6.x) {
      min6.x = node.x;
    }
    if (node.y > max7.y) {
      max7.y = node.y;
    }
    if (node.y < min6.y) {
      min6.y = node.y;
    }
    return true;
  });
  var avgRad = Math.PI * 2 / count;
  var radDiff = max7[radScale] - min6[radScale];
  if (radDiff === 0) {
    return data;
  }
  traverseTree3(data, function(node) {
    var radial = (node[radScale] - min6[radScale]) / radDiff * (Math.PI * 2 - avgRad) + avgRad;
    var r2 = Math.abs(rScale === "x" ? node.x - data.x : node.y - data.y);
    node.x = r2 * Math.cos(radial);
    node.y = r2 * Math.sin(radial);
    return true;
  });
  return data;
};

// node_modules/@antv/g6-pc/es/util/gpu.js
var gpu_exports = {};
__export(gpu_exports, {
  gpuDetector: () => gpuDetector
});
var gpuDetector = function gpuDetector2() {
  if (typeof window === "undefined" || typeof document === "undefined")
    return {};
  return {
    canvas: !!window.CanvasRenderingContext2D,
    webgl: function() {
      try {
        var canvas = document.createElement("canvas");
        return !!(window.WebGLRenderingContext && (canvas.getContext("webgl") || canvas.getContext("experimental-webgl")));
      } catch (e8) {
        return false;
      }
    }(),
    workers: !!window.Worker,
    fileapi: window.File && window.FileReader && window.FileList && window.Blob,
    getWebGLErrorMessage: function getWebGLErrorMessage() {
      var element = document.createElement("div");
      element.id = "webgl-error-message";
      element.style.fontFamily = "monospace";
      element.style.fontSize = "13px";
      element.style.fontWeight = "normal";
      element.style.textAlign = "center";
      element.style.background = "#fff";
      element.style.color = "#000";
      element.style.padding = "1.5em";
      element.style.width = "400px";
      element.style.margin = "5em auto 0";
      if (!this.webgl) {
        element.innerHTML = window.WebGLRenderingContext ? ['Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br />', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n") : ['Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" rel="external nofollow" rel="external nofollow" style="color:#000">WebGL</a>.<br/>', 'Find out how to get it <a href="http://get.webgl.org/" rel="external nofollow" rel="external nofollow" style="color:#000">here</a>.'].join("\n");
      }
      return element;
    },
    addGetWebGLMessage: function addGetWebGLMessage(parameters) {
      parameters = parameters || {};
      var parent = parameters.parent !== void 0 ? parameters.parent : document.body;
      var id2 = parameters.id !== void 0 ? parameters.id : "oldie";
      var element = gpuDetector2().getWebGLErrorMessage();
      element.id = id2;
      parent.appendChild(element);
    }
  };
};

// node_modules/@antv/g6-pc/es/util/index.js
var G6Util = __assign(__assign(__assign(__assign({}, util_default), color_exports2), layout_exports), gpu_exports);
var util_default2 = G6Util;

// node_modules/@antv/g6-pc/es/layout/tree-layout.js
var radialLayout3 = util_default2.radialLayout;
var TreeLayout = function() {
  function TreeLayout2(cfg) {
    this.type = cfg.type;
    this.radial = cfg.radial;
    this.config = cfg;
  }
  TreeLayout2.prototype.init = function(data) {
    var _this = this;
    this.data = data;
    if (this.radial) {
      this.layoutMethod = function(data2) {
        var layoutData = import_hierarchy.default[_this.type](data2, _this.config);
        radialLayout3(layoutData);
        return layoutData;
      };
      return;
    }
    this.layoutMethod = function(data2) {
      return import_hierarchy.default[_this.type](data2, _this.config);
    };
  };
  TreeLayout2.prototype.execute = function() {
    return this.layoutMethod(this.data, this.config);
  };
  TreeLayout2.prototype.layout = function(data) {
    this.init(data);
    return this.execute();
  };
  return TreeLayout2;
}();
var tree_layout_default = TreeLayout;

// node_modules/@antv/g6-pc/es/layout/index.js
(0, import_lib.registerLayout)("grid", import_lib.GridLayout);
(0, import_lib.registerLayout)("random", import_lib.RandomLayout);
(0, import_lib.registerLayout)("force", import_lib.ForceLayout);
(0, import_lib.registerLayout)("circular", import_lib.CircularLayout);
(0, import_lib.registerLayout)("dagre", import_lib.DagreLayout);
(0, import_lib.registerLayout)("dagreCompound", import_lib.DagreCompoundLayout);
(0, import_lib.registerLayout)("radial", import_lib.RadialLayout);
(0, import_lib.registerLayout)("concentric", import_lib.ConcentricLayout);
(0, import_lib.registerLayout)("mds", import_lib.MDSLayout);
(0, import_lib.registerLayout)("fruchterman", import_lib.FruchtermanLayout);
(0, import_lib.registerLayout)("fruchterman-gpu", import_lib.FruchtermanGPULayout);
(0, import_lib.registerLayout)("gForce", import_lib.GForceLayout);
(0, import_lib.registerLayout)("gForce-gpu", import_lib.GForceGPULayout);
(0, import_lib.registerLayout)("comboForce", import_lib.ComboForceLayout);
(0, import_lib.registerLayout)("comboCombined", import_lib.ComboCombinedLayout);
(0, import_lib.registerLayout)("forceAtlas2", import_lib.ForceAtlas2Layout);
var registerLayout = function registerLayout2(name, layoutOverride) {
  layoutOverride.isCustomLayout = true;
  import_lib.Layouts[name] = (0, import_lib.registerLayout)(name, layoutOverride);
};

// node_modules/@antv/g6-pc/es/layout/worker/work.js
var WebWorker = function() {
  function WebWorker2(worker, workerScirptURL) {
    var code = worker.toString();
    var blob = new Blob(["importScripts('".concat(workerScirptURL, "');(").concat(code, ")()")], {
      type: "text/javascript"
    });
    return new Worker(URL.createObjectURL(blob));
  }
  return WebWorker2;
}();
var work_default = WebWorker;

// node_modules/@antv/g6-pc/es/layout/worker/layout.worker.js
var LayoutWorker = function LayoutWorker2(workerScriptURL) {
  if (workerScriptURL === void 0) {
    workerScriptURL = "https://unpkg.com/@antv/layout@latest/dist/layout.min.js";
  }
  function workerCode() {
    var LAYOUT_MESSAGE2 = {
      RUN: "LAYOUT_RUN",
      END: "LAYOUT_END",
      ERROR: "LAYOUT_ERROR",
      TICK: "LAYOUT_TICK",
      GPURUN: "GPU_LAYOUT_RUN",
      GPUEND: "GPU_LAYOUT_END"
    };
    layout.registerLayout("grid", layout.GridLayout);
    layout.registerLayout("random", layout.RandomLayout);
    layout.registerLayout("force", layout.ForceLayout);
    layout.registerLayout("circular", layout.CircularLayout);
    layout.registerLayout("dagre", layout.DagreLayout);
    layout.registerLayout("dagreCompound", layout.DagreCompoundLayout);
    layout.registerLayout("radial", layout.RadialLayout);
    layout.registerLayout("concentric", layout.ConcentricLayout);
    layout.registerLayout("mds", layout.MDSLayout);
    layout.registerLayout("fruchterman", layout.FruchtermanLayout);
    layout.registerLayout("fruchterman-gpu", layout.FruchtermanGPULayout);
    layout.registerLayout("gForce", layout.GForceLayout);
    layout.registerLayout("gForce-gpu", layout.GForceGPULayout);
    layout.registerLayout("comboForce", layout.ComboForceLayout);
    layout.registerLayout("comboCombined", layout.ComboCombinedLayout);
    layout.registerLayout("forceAtlas2", layout.ForceAtlas2Layout);
    function isLayoutMessage(event) {
      var type = event.data.type;
      return type === LAYOUT_MESSAGE2.RUN || type === LAYOUT_MESSAGE2.GPURUN;
    }
    function handleLayoutMessage(event) {
      var _this = this;
      var type = event.data.type;
      switch (type) {
        case LAYOUT_MESSAGE2.RUN: {
          var _a2 = event.data, nodes_1 = _a2.nodes, edges = _a2.edges, _b = _a2.layoutCfg, layoutCfg = _b === void 0 ? {} : _b;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          var layoutMethod_1;
          layoutCfg.onLayoutEnd = function() {
            _this.postMessage({
              type: LAYOUT_MESSAGE2.END,
              nodes: nodes_1
            });
            layoutMethod_1 === null || layoutMethod_1 === void 0 ? void 0 : layoutMethod_1.destroy();
          };
          layoutMethod_1 = new LayoutClass(layoutCfg);
          layoutMethod_1.init({
            nodes: nodes_1,
            edges
          });
          layoutMethod_1.execute();
          break;
        }
        case LAYOUT_MESSAGE2.GPURUN: {
          var _c = event.data, nodes = _c.nodes, edges = _c.edges, _d = _c.layoutCfg, layoutCfg = _d === void 0 ? {} : _d, canvas = _c.canvas;
          var layoutType = layoutCfg.type;
          var LayoutClass = layout.getLayoutByName(layoutType);
          if (!LayoutClass) {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " not found")
            });
            break;
          }
          if (layoutType.split("-")[1] !== "gpu") {
            this.postMessage({
              type: LAYOUT_MESSAGE2.ERROR,
              message: "layout ".concat(layoutType, " does not support GPU")
            });
            break;
          }
          var layoutMethod = new LayoutClass(layoutCfg);
          layoutMethod.init({
            nodes,
            edges
          });
          layoutMethod.executeWithWorker(canvas, this);
          break;
        }
        default:
          break;
      }
    }
    onmessage = function onmessage2(event) {
      if (isLayoutMessage(event)) {
        handleLayoutMessage(event);
      }
    };
  }
  var layoutWorker = new work_default(workerCode, workerScriptURL);
  return layoutWorker;
};

// node_modules/@antv/g6-pc/es/layout/worker/layoutConst.js
var LAYOUT_MESSAGE = {
  RUN: "LAYOUT_RUN",
  END: "LAYOUT_END",
  ERROR: "LAYOUT_ERROR",
  TICK: "LAYOUT_TICK",
  GPURUN: "GPU_LAYOUT_RUN",
  GPUEND: "GPU_LAYOUT_END"
};

// node_modules/@antv/g6-pc/es/graph/controller/layout.js
init_esm();
function _typeof5(obj) {
  "@babel/helpers - typeof";
  return _typeof5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof5(obj);
}
var mockRaf = function mockRaf2(cb) {
  return setTimeout(cb, 16);
};
var mockCaf = function mockCaf2(reqId) {
  return clearTimeout(reqId);
};
var helper = {
  requestAnimationFrame: function requestAnimationFrame3(callback) {
    var fn2 = typeof window !== "undefined" ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || mockRaf : mockRaf;
    return fn2(callback);
  },
  cancelAnimationFrame: function cancelAnimationFrame3(requestId) {
    var fn2 = typeof window !== "undefined" ? window.cancelAnimationFrame || window.webkitCancelAnimationFrame || mockCaf : mockCaf;
    return fn2(requestId);
  }
};
var GPU_LAYOUT_NAMES = ["fruchterman", "gForce"];
var LAYOUT_PIPES_ADJUST_NAMES = ["force", "grid", "circular"];
var LayoutController2 = function(_super) {
  __extends(LayoutController3, _super);
  function LayoutController3(graph) {
    var _this = _super.call(this, graph) || this;
    _this.graph = graph;
    _this.layoutCfg = graph.get("layout") || {};
    _this.layoutType = _this.getLayoutType();
    _this.worker = null;
    _this.workerData = {};
    _this.initLayout();
    return _this;
  }
  LayoutController3.prototype.initLayout = function() {
  };
  LayoutController3.prototype.getWorker = function() {
    if (this.worker) {
      return this.worker;
    }
    if (typeof Worker === "undefined") {
      console.warn("Web worker is not supported in current browser.");
      this.worker = null;
    } else {
      this.worker = LayoutWorker(this.layoutCfg.workerScriptURL);
    }
    return this.worker;
  };
  LayoutController3.prototype.stopWorker = function() {
    var workerData = this.workerData;
    if (!this.worker) {
      return;
    }
    this.worker.terminate();
    this.worker = null;
    if (workerData.requestId) {
      helper.cancelAnimationFrame(workerData.requestId);
      workerData.requestId = null;
    }
    if (workerData.requestId2) {
      helper.cancelAnimationFrame(workerData.requestId2);
      workerData.requestId2 = null;
    }
  };
  LayoutController3.prototype.execLayoutMethod = function(layoutCfg, order) {
    var _this = this;
    return new Promise(function(reslove, reject) {
      return __awaiter(_this, void 0, void 0, function() {
        var graph, layoutType, isForce, onTick_1, tick, enableTick, layoutMethod, onTick_2, tick, layoutData;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              graph = this.graph;
              if (!graph || graph.get("destroyed"))
                return [
                  2
                ];
              layoutType = layoutCfg.type;
              layoutCfg.onLayoutEnd = function() {
                graph.emit("aftersublayout", {
                  type: layoutType
                });
                reslove();
              };
              if (layoutType && this.isGPU) {
                if (!this.hasGPUVersion(layoutType)) {
                  console.warn("The '".concat(layoutType, "' layout does not support GPU calculation for now, it will run in CPU."));
                } else {
                  layoutType = "".concat(layoutType, "-gpu");
                }
              }
              isForce = layoutType === "force" || layoutType === "g6force" || layoutType === "gForce";
              if (isForce) {
                onTick_1 = layoutCfg.onTick;
                tick = function tick2() {
                  if (onTick_1) {
                    onTick_1();
                  }
                  graph.refreshPositions();
                };
                layoutCfg.tick = tick;
              } else if (layoutType === "comboForce" || layoutType === "comboCombined") {
                layoutCfg.comboTrees = graph.get("comboTrees");
              }
              enableTick = false;
              try {
                layoutMethod = new import_lib.Layouts[layoutType](layoutCfg);
              } catch (e8) {
                console.warn("The layout method: '".concat(layoutType, "' does not exist! Please specify it first."));
                reject();
              }
              enableTick = layoutMethod.enableTick;
              if (enableTick) {
                onTick_2 = layoutCfg.onTick;
                tick = function tick2() {
                  if (onTick_2) {
                    onTick_2();
                  }
                  graph.refreshPositions();
                };
                layoutMethod.tick = tick;
              }
              layoutData = this.filterLayoutData(this.data, layoutCfg);
              addLayoutOrder(layoutData, order);
              layoutMethod.init(layoutData);
              graph.emit("beforesublayout", {
                type: layoutType
              });
              return [
                4,
                layoutMethod.execute()
              ];
            case 1:
              _a2.sent();
              if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd)
                layoutCfg.onLayoutEnd();
              this.layoutMethods[order] = layoutMethod;
              return [
                2
              ];
          }
        });
      });
    });
  };
  LayoutController3.prototype.updateLayoutMethod = function(layoutMethod, layoutCfg) {
    var _this = this;
    return new Promise(function(reslove, reject) {
      return __awaiter(_this, void 0, void 0, function() {
        var graph, layoutType, layoutData;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              graph = this.graph;
              layoutType = layoutCfg === null || layoutCfg === void 0 ? void 0 : layoutCfg.type;
              layoutCfg.onLayoutEnd = function() {
                graph.emit("aftersublayout", {
                  type: layoutType
                });
                reslove();
              };
              layoutData = this.filterLayoutData(this.data, layoutCfg);
              layoutMethod.init(layoutData);
              layoutMethod.updateCfg(layoutCfg);
              graph.emit("beforesublayout", {
                type: layoutType
              });
              return [
                4,
                layoutMethod.execute()
              ];
            case 1:
              _a2.sent();
              if (layoutMethod.isCustomLayout && layoutCfg.onLayoutEnd)
                layoutCfg.onLayoutEnd();
              return [
                2
              ];
          }
        });
      });
    });
  };
  LayoutController3.prototype.layout = function(success) {
    var _this = this;
    var graph = this.graph;
    this.data = this.setDataFromGraph();
    var _a2 = this.data, nodes = _a2.nodes, hiddenNodes = _a2.hiddenNodes;
    if (!nodes) {
      return false;
    }
    var width = graph.get("width");
    var height = graph.get("height");
    var layoutCfg = {};
    Object.assign(layoutCfg, {
      width,
      height,
      center: [width / 2, height / 2]
    }, this.layoutCfg);
    this.layoutCfg = layoutCfg;
    this.destoryLayoutMethods();
    graph.emit("beforelayout");
    this.initPositions(layoutCfg.center, nodes);
    this.initPositions(layoutCfg.center, hiddenNodes);
    var layoutType = layoutCfg.type;
    if (layoutType && layoutType.split("-")[1] === "gpu") {
      layoutType = layoutType.split("-")[0];
      layoutCfg.gpuEnabled = true;
    }
    var enableGPU = false;
    if (layoutCfg.gpuEnabled) {
      enableGPU = true;
      if (!gpuDetector().webgl) {
        console.warn("Your browser does not support webGL or GPGPU. The layout will run in CPU.");
        enableGPU = false;
      }
    }
    this.isGPU = enableGPU;
    var onLayoutEnd = layoutCfg.onLayoutEnd, layoutEndFormatted = layoutCfg.layoutEndFormatted, adjust = layoutCfg.adjust;
    if (!layoutEndFormatted) {
      layoutCfg.layoutEndFormatted = true;
      layoutCfg.onAllLayoutEnd = function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                if (onLayoutEnd) {
                  onLayoutEnd();
                }
                this.refreshLayout();
                if (!(adjust && layoutCfg.pipes))
                  return [
                    3,
                    2
                  ];
                return [
                  4,
                  this.adjustPipesBox(this.data, adjust)
                ];
              case 1:
                _a3.sent();
                this.refreshLayout();
                _a3.label = 2;
              case 2:
                graph.emit("afterlayout");
                return [
                  2
                ];
            }
          });
        });
      };
    }
    this.stopWorker();
    if (layoutCfg.workerEnabled && this.layoutWithWorker(this.data)) {
      return true;
    }
    var start = Promise.resolve();
    var hasLayout = false;
    if (layoutCfg.type) {
      hasLayout = true;
      start = start.then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                return [
                  4,
                  this.execLayoutMethod(layoutCfg, 0)
                ];
              case 1:
                return [
                  2,
                  _a3.sent()
                ];
            }
          });
        });
      });
    } else if (layoutCfg.pipes) {
      hasLayout = true;
      layoutCfg.pipes.forEach(function(cfg, index) {
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [
                    4,
                    this.execLayoutMethod(cfg, index)
                  ];
                case 1:
                  return [
                    2,
                    _a3.sent()
                  ];
              }
            });
          });
        });
      });
    }
    if (hasLayout) {
      start.then(function() {
        if (layoutCfg.onAllLayoutEnd)
          layoutCfg.onAllLayoutEnd();
        if (success)
          success();
      }).catch(function(error) {
        console.warn("graph layout failed,", error);
      });
    }
    return false;
  };
  LayoutController3.prototype.layoutWithWorker = function(data) {
    var _this = this;
    var _a2 = this, layoutCfg = _a2.layoutCfg, graph = _a2.graph;
    var worker = this.getWorker();
    var workerData = this.workerData;
    if (!worker) {
      return false;
    }
    workerData.requestId = null;
    workerData.requestId2 = null;
    workerData.currentTick = null;
    workerData.currentTickData = null;
    graph.emit("beforelayout");
    var start = Promise.resolve();
    var hasLayout = false;
    if (layoutCfg.type) {
      hasLayout = true;
      start = start.then(function() {
        return _this.runWebworker(worker, data, layoutCfg);
      });
    } else if (layoutCfg.pipes) {
      hasLayout = true;
      var _loop_1 = function _loop_12(cfg2) {
        start = start.then(function() {
          return _this.runWebworker(worker, data, cfg2);
        });
      };
      for (var _i2 = 0, _b = layoutCfg.pipes; _i2 < _b.length; _i2++) {
        var cfg = _b[_i2];
        _loop_1(cfg);
      }
    }
    if (hasLayout) {
      start.then(function() {
        if (layoutCfg.onAllLayoutEnd)
          layoutCfg.onAllLayoutEnd();
      }).catch(function(error) {
        console.error("layout failed", error);
      });
    }
    return true;
  };
  LayoutController3.prototype.runWebworker = function(worker, allData, layoutCfg) {
    var _this = this;
    var isGPU = this.isGPU;
    var data = this.filterLayoutData(allData, layoutCfg);
    var nodes = data.nodes, edges = data.edges;
    var offScreenCanvas = document.createElement("canvas");
    var gpuWorkerAbility = isGPU && typeof window !== "undefined" && window.navigator && !navigator["gpu"] && "OffscreenCanvas" in window && "transferControlToOffscreen" in offScreenCanvas;
    var filteredLayoutCfg = filterObject(layoutCfg, function(value) {
      return typeof value !== "function";
    });
    if (!gpuWorkerAbility) {
      worker.postMessage({
        type: LAYOUT_MESSAGE.RUN,
        nodes,
        edges,
        layoutCfg: filteredLayoutCfg
      });
    } else {
      var offscreen = offScreenCanvas.transferControlToOffscreen();
      filteredLayoutCfg.type = "".concat(filteredLayoutCfg.type, "-gpu");
      worker.postMessage({
        type: LAYOUT_MESSAGE.GPURUN,
        nodes,
        edges,
        layoutCfg: filteredLayoutCfg,
        canvas: offscreen
      }, [offscreen]);
    }
    return new Promise(function(reslove, reject) {
      worker.onmessage = function(event) {
        _this.handleWorkerMessage(reslove, reject, event, data, layoutCfg);
      };
    });
  };
  LayoutController3.prototype.handleWorkerMessage = function(reslove, reject, event, data, layoutCfg) {
    var _a2 = this, graph = _a2.graph, workerData = _a2.workerData;
    var eventData = event.data;
    var type = eventData.type;
    var onTick = function onTick2() {
      if (layoutCfg.onTick) {
        layoutCfg.onTick();
      }
    };
    switch (type) {
      case LAYOUT_MESSAGE.TICK:
        workerData.currentTick = eventData.currentTick;
        workerData.currentTickData = eventData;
        if (!workerData.requestId) {
          workerData.requestId = helper.requestAnimationFrame(function requestId() {
            updateLayoutPosition(data, eventData);
            graph.refreshPositions();
            onTick();
            if (eventData.currentTick === eventData.totalTicks) {
              reslove();
            } else if (workerData.currentTick === eventData.totalTicks) {
              workerData.requestId2 = helper.requestAnimationFrame(function requestId2() {
                updateLayoutPosition(data, workerData.currentTickData);
                graph.refreshPositions();
                workerData.requestId2 = null;
                onTick();
                reslove();
              });
            }
            workerData.requestId = null;
          });
        }
        break;
      case LAYOUT_MESSAGE.END:
        if (workerData.currentTick == null) {
          updateLayoutPosition(data, eventData);
          reslove();
        }
        break;
      case LAYOUT_MESSAGE.GPUEND:
        if (workerData.currentTick == null) {
          updateGPUWorkerLayoutPosition(data, eventData);
          reslove();
        }
        break;
      case LAYOUT_MESSAGE.ERROR:
        console.warn("Web-Worker layout error!", eventData.message);
        reject();
        break;
      default:
        reject();
        break;
    }
  };
  LayoutController3.prototype.updateLayoutCfg = function(cfg) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, layoutMethods = _a2.layoutMethods;
    var layoutCfg = mix({}, this.layoutCfg, cfg);
    this.layoutCfg = layoutCfg;
    if (!(layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.length)) {
      this.layout();
      return;
    }
    this.data = this.setDataFromGraph();
    this.stopWorker();
    if (cfg.workerEnabled && this.layoutWithWorker(this.data)) {
      return;
    }
    graph.emit("beforelayout");
    var start = Promise.resolve();
    var hasLayout = false;
    if (layoutMethods.length === 1) {
      hasLayout = true;
      start = start.then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                return [
                  4,
                  this.updateLayoutMethod(layoutMethods[0], layoutCfg)
                ];
              case 1:
                return [
                  2,
                  _a3.sent()
                ];
            }
          });
        });
      });
    } else {
      hasLayout = true;
      layoutMethods === null || layoutMethods === void 0 ? void 0 : layoutMethods.forEach(function(layoutMethod, index) {
        var currentCfg = layoutCfg.pipes[index];
        start = start.then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a3) {
              switch (_a3.label) {
                case 0:
                  return [
                    4,
                    this.updateLayoutMethod(layoutMethod, currentCfg)
                  ];
                case 1:
                  return [
                    2,
                    _a3.sent()
                  ];
              }
            });
          });
        });
      });
    }
    if (hasLayout) {
      start.then(function() {
        if (layoutCfg.onAllLayoutEnd)
          layoutCfg.onAllLayoutEnd();
      }).catch(function(error) {
        console.warn("layout failed", error);
      });
    }
  };
  LayoutController3.prototype.adjustPipesBox = function(data, adjust) {
    var _this = this;
    return new Promise(function(resolve2) {
      var nodes = data.nodes;
      if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        resolve2();
      }
      if (!LAYOUT_PIPES_ADJUST_NAMES.includes(adjust)) {
        console.warn("The adjust type ".concat(adjust, " is not supported yet, please assign it with 'force', 'grid', or 'circular'."));
        resolve2();
      }
      var layoutCfg = {
        center: _this.layoutCfg.center,
        nodeSize: function nodeSize(d2) {
          return Math.max(d2.height, d2.width);
        },
        preventOverlap: true,
        onLayoutEnd: function onLayoutEnd() {
        }
      };
      var _a2 = _this.getLayoutBBox(nodes), groupNodes = _a2.groupNodes, layoutNodes = _a2.layoutNodes;
      var preNodes = clone_default(layoutNodes);
      layoutCfg.onLayoutEnd = function() {
        layoutNodes === null || layoutNodes === void 0 ? void 0 : layoutNodes.forEach(function(ele, index) {
          var _a3, _b, _c;
          var dx = ele.x - ((_a3 = preNodes[index]) === null || _a3 === void 0 ? void 0 : _a3.x);
          var dy = ele.y - ((_b = preNodes[index]) === null || _b === void 0 ? void 0 : _b.y);
          (_c = groupNodes[index]) === null || _c === void 0 ? void 0 : _c.forEach(function(n2) {
            n2.x += dx;
            n2.y += dy;
          });
        });
        resolve2();
      };
      var layoutMethod = new import_lib.Layouts[adjust](layoutCfg);
      layoutMethod.layout({
        nodes: layoutNodes
      });
    });
  };
  LayoutController3.prototype.hasGPUVersion = function(layoutName) {
    return GPU_LAYOUT_NAMES.includes(layoutName);
  };
  LayoutController3.prototype.destroy = function() {
    this.destoryLayoutMethods();
    var worker = this.worker;
    if (worker) {
      worker.terminate();
      this.worker = null;
    }
    this.destroyed = true;
    this.graph.set("layout", void 0);
    this.layoutCfg = void 0;
    this.layoutType = void 0;
    this.layoutMethods = void 0;
    this.graph = null;
  };
  return LayoutController3;
}(layout_default);
var layout_default2 = LayoutController2;
function updateLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var layoutNodes = layoutData.nodes;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    node.x = layoutNodes[i2].x;
    node.y = layoutNodes[i2].y;
  }
}
function filterObject(collection, callback) {
  var result = {};
  if (collection && _typeof5(collection) === "object") {
    Object.keys(collection).forEach(function(key) {
      if (collection.hasOwnProperty(key) && callback(collection[key])) {
        result[key] = collection[key];
      }
    });
    return result;
  }
  return collection;
}
function updateGPUWorkerLayoutPosition(data, layoutData) {
  var nodes = data.nodes;
  var vertexEdgeData = layoutData.vertexEdgeData;
  var nodeLength = nodes.length;
  for (var i2 = 0; i2 < nodeLength; i2++) {
    var node = nodes[i2];
    var x2 = vertexEdgeData[4 * i2];
    var y2 = vertexEdgeData[4 * i2 + 1];
    node.x = x2;
    node.y = y2;
  }
}
function addLayoutOrder(data, order) {
  var _a2;
  if (!((_a2 = data === null || data === void 0 ? void 0 : data.nodes) === null || _a2 === void 0 ? void 0 : _a2.length)) {
    return;
  }
  var nodes = data.nodes;
  nodes.forEach(function(node) {
    node.layoutOrder = order;
  });
}

// node_modules/@antv/g6-pc/es/graph/graph.js
var transform8 = ext_exports.transform;
var SVG = "svg";
var Graph4 = function(_super) {
  __extends(Graph5, _super);
  function Graph5(cfg) {
    var _this = _super.call(this, cfg) || this;
    var defaultNode = _this.get("defaultNode");
    if (!defaultNode) {
      _this.set("defaultNode", {
        type: "circle"
      });
    }
    if (!defaultNode.type) {
      defaultNode.type = "circle";
      _this.set("defaultNode", defaultNode);
    }
    _this.destroyed = false;
    return _this;
  }
  Graph5.prototype.initLayoutController = function() {
    var layoutController = new layout_default2(this);
    this.set({
      layoutController
    });
  };
  Graph5.prototype.initEventController = function() {
    var eventController = new event_default2(this);
    this.set({
      eventController
    });
  };
  Graph5.prototype.initCanvas = function() {
    var container2 = this.get("container");
    if (typeof container2 === "string") {
      container2 = document.getElementById(container2);
      this.set("container", container2);
    }
    if (!container2) {
      throw new Error("invalid container");
    }
    var clientWidth = container2.clientWidth, clientHeight = container2.clientHeight;
    var width = this.get("width") || clientWidth;
    var height = this.get("height") || clientHeight;
    if (!this.get("width") && !this.get("height")) {
      this.set("width", clientWidth);
      this.set("height", clientHeight);
    }
    var renderer = this.get("renderer");
    var canvas;
    if (renderer === SVG) {
      canvas = new canvas_default3({
        container: container2,
        width,
        height
      });
    } else {
      var canvasCfg = {
        container: container2,
        width,
        height
      };
      var pixelRatio = this.get("pixelRatio");
      if (pixelRatio) {
        canvasCfg.pixelRatio = pixelRatio;
      }
      canvas = new canvas_default2(canvasCfg);
    }
    this.set("canvas", canvas);
  };
  Graph5.prototype.initPlugins = function() {
    var self2 = this;
    each_default(self2.get("plugins"), function(plugin) {
      if (!plugin.destroyed && plugin.initPlugin) {
        plugin.initPlugin(self2);
      }
    });
  };
  Graph5.prototype.downloadImageWatermark = function(watermarker, context, width, height) {
    return __awaiter(this, void 0, void 0, function() {
      var watermarkStr, watermarkbase64, img;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            watermarkStr = watermarker.style.backgroundImage;
            watermarkbase64 = watermarkStr.slice(5, watermarkStr.length - 2);
            img = new Image();
            img.src = watermarkbase64;
            return [
              4,
              new Promise(function(resolve2) {
                img.onload = function() {
                  var pat = context.createPattern(img, "repeat");
                  context.rect(0, 0, width, height);
                  context.fillStyle = pat;
                  context.fill();
                  resolve2("");
                };
              })
            ];
          case 1:
            _a2.sent();
            return [
              2
            ];
        }
      });
    });
  };
  Graph5.prototype.asyncToDataUrl = function(type, backgroundColor, callback, widths, heights, vCanvasEl) {
    var _this = this;
    var watermarker = document.querySelector(".g6-graph-watermarker");
    var canvas = this.get("canvas");
    var renderer = canvas.getRenderer();
    var canvasDom = vCanvasEl || canvas.get("el");
    var dataURL = "";
    if (!type)
      type = "image/png";
    setTimeout(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var cloneNode, svgDocType, svgDoc, svgData, imageData, context, width, height, compositeOperation, pixelRatio;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!(renderer === "svg"))
                return [
                  3,
                  1
                ];
              cloneNode = canvasDom.cloneNode(true);
              svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
              svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
              svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
              svgData = new XMLSerializer().serializeToString(svgDoc);
              dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
              return [
                3,
                4
              ];
            case 1:
              imageData = void 0;
              context = canvasDom.getContext("2d");
              width = widths || this.get("width");
              height = heights || this.get("height");
              compositeOperation = void 0;
              if (!watermarker)
                return [
                  3,
                  3
                ];
              return [
                4,
                this.downloadImageWatermark(watermarker, context, width, height)
              ];
            case 2:
              _a2.sent();
              _a2.label = 3;
            case 3:
              if (backgroundColor) {
                pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
                try {
                  imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
                  compositeOperation = context.globalCompositeOperation;
                  context.globalCompositeOperation = "destination-over";
                  context.fillStyle = backgroundColor;
                  context.fillRect(0, 0, width, height);
                } catch (error) {
                  console.error("Download image failed. Out of memory at ImageData creation");
                }
              }
              dataURL = canvasDom.toDataURL(type);
              if (backgroundColor) {
                context.clearRect(0, 0, width, height);
                context.putImageData(imageData, 0, 0);
                context.globalCompositeOperation = compositeOperation;
              }
              _a2.label = 4;
            case 4:
              if (callback)
                callback(dataURL);
              return [
                2
              ];
          }
        });
      });
    }, 16);
  };
  Graph5.prototype.toDataURL = function(type, backgroundColor) {
    var canvas = this.get("canvas");
    var renderer = canvas.getRenderer();
    var canvasDom = canvas.get("el");
    if (!type)
      type = "image/png";
    var dataURL = "";
    if (renderer === "svg") {
      var cloneNode = canvasDom.cloneNode(true);
      var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
      var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
      svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
      var svgData = new XMLSerializer().serializeToString(svgDoc);
      dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
    } else {
      var imageData = void 0;
      var context = canvasDom.getContext("2d");
      var width = this.get("width");
      var height = this.get("height");
      var compositeOperation = void 0;
      if (backgroundColor) {
        var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
        try {
          imageData = context.getImageData(0, 0, width * pixelRatio, height * pixelRatio);
          compositeOperation = context.globalCompositeOperation;
          context.globalCompositeOperation = "destination-over";
          context.fillStyle = backgroundColor;
          context.fillRect(0, 0, width, height);
        } catch (error) {
          console.error("Download image failed. Out of memory at ImageData creation");
        }
      }
      dataURL = canvasDom.toDataURL(type);
      if (backgroundColor) {
        context.clearRect(0, 0, width, height);
        context.putImageData(imageData, 0, 0);
        context.globalCompositeOperation = compositeOperation;
      }
    }
    return dataURL;
  };
  Graph5.prototype.toFullDataURL = function(callback, type, imageConfig) {
    var bbox = this.get("group").getCanvasBBox();
    var height = bbox.height;
    var width = bbox.width;
    var renderer = this.get("renderer");
    var vContainerDOM = createDom2('<div id="virtual-image"></div>');
    var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
    var padding = imageConfig ? imageConfig.padding : void 0;
    if (!padding)
      padding = [0, 0, 0, 0];
    else if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var vHeight = height + padding[0] + padding[2];
    var vWidth = width + padding[1] + padding[3];
    var canvasOptions = {
      container: vContainerDOM,
      height: vHeight,
      width: vWidth,
      quickHit: true
    };
    var vCanvas = renderer === "svg" ? new canvas_default3(canvasOptions) : new canvas_default2(canvasOptions);
    var group = this.get("group");
    var vGroup = group.clone();
    var matrix = clone_default(vGroup.getMatrix());
    if (!matrix)
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var centerX = (bbox.maxX + bbox.minX) / 2;
    var centerY = (bbox.maxY + bbox.minY) / 2;
    matrix = transform8(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
    vGroup.resetMatrix();
    vGroup.setMatrix(matrix);
    vCanvas.add(vGroup);
    var vCanvasEl = vCanvas.get("el");
    var dataURL = "";
    if (!type)
      type = "image/png";
    setTimeout(function() {
      if (renderer === "svg") {
        var cloneNode = vCanvasEl.cloneNode(true);
        var svgDocType = document.implementation.createDocumentType("svg", "-//W3C//DTD SVG 1.1//EN", "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd");
        var svgDoc = document.implementation.createDocument("http://www.w3.org/2000/svg", "svg", svgDocType);
        svgDoc.replaceChild(cloneNode, svgDoc.documentElement);
        var svgData = new XMLSerializer().serializeToString(svgDoc);
        dataURL = "data:image/svg+xml;charset=utf8,".concat(encodeURIComponent(svgData));
      } else {
        var imageData = void 0;
        var context = vCanvasEl.getContext("2d");
        var compositeOperation = void 0;
        if (backgroundColor) {
          var pixelRatio = typeof window !== "undefined" ? window.devicePixelRatio : 1;
          try {
            imageData = context.getImageData(0, 0, vWidth * pixelRatio, vHeight * pixelRatio);
            compositeOperation = context.globalCompositeOperation;
            context.globalCompositeOperation = "destination-over";
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, vWidth, vHeight);
          } catch (error) {
            console.error("Download image failed. Out of memory at ImageData creation");
          }
        }
        dataURL = vCanvasEl.toDataURL(type);
        if (backgroundColor) {
          context.clearRect(0, 0, vWidth, vHeight);
          context.putImageData(imageData, 0, 0);
          context.globalCompositeOperation = compositeOperation;
        }
      }
      if (callback)
        callback(dataURL);
    }, 16);
  };
  Graph5.prototype.downloadFullImage = function(name, type, imageConfig) {
    var _this = this;
    var bbox = this.get("group").getCanvasBBox();
    var height = bbox.height;
    var width = bbox.width;
    var renderer = this.get("renderer");
    var vContainerDOM = createDom2('<div id="virtual-image"></div>');
    var watermarker = document.querySelector(".g6-graph-watermarker");
    var backgroundColor = imageConfig ? imageConfig.backgroundColor : void 0;
    var padding = imageConfig ? imageConfig.padding : void 0;
    if (!padding)
      padding = [0, 0, 0, 0];
    else if (is_number_default(padding))
      padding = [padding, padding, padding, padding];
    var vHeight = height + padding[0] + padding[2];
    var vWidth = width + padding[1] + padding[3];
    if (watermarker) {
      var _a2 = this.get("graphWaterMarker").cfg || {}, wmWidth = _a2.width, wmHeight = _a2.height;
      vHeight = Math.ceil(vHeight / wmHeight) * wmHeight;
      vWidth = Math.ceil(vWidth / wmWidth) * wmWidth;
    }
    var canvasOptions = {
      container: vContainerDOM,
      height: vHeight,
      width: vWidth
    };
    var vCanvas = renderer === "svg" ? new canvas_default3(canvasOptions) : new canvas_default2(canvasOptions);
    var group = this.get("group");
    var vGroup = group.clone();
    var matrix = clone_default(vGroup.getMatrix());
    if (!matrix)
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var centerX = (bbox.maxX + bbox.minX) / 2;
    var centerY = (bbox.maxY + bbox.minY) / 2;
    matrix = transform8(matrix, [["t", -centerX, -centerY], ["t", width / 2 + padding[3], height / 2 + padding[0]]]);
    vGroup.resetMatrix();
    vGroup.setMatrix(matrix);
    vCanvas.add(vGroup);
    var vCanvasEl = vCanvas.get("el");
    if (!type)
      type = "image/png";
    this.asyncToDataUrl(type, backgroundColor, function(dataURL) {
      var link = document.createElement("a");
      var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : ".".concat(type.split("/")[1]));
      _this.dataURLToImage(dataURL, renderer, link, fileName);
      var e8 = document.createEvent("MouseEvents");
      e8.initEvent("click", false, false);
      link.dispatchEvent(e8);
    }, vWidth, vHeight, vCanvasEl);
  };
  Graph5.prototype.downloadImage = function(name, type, backgroundColor) {
    var _this = this;
    var self2 = this;
    if (self2.isAnimating()) {
      self2.stopAnimate();
    }
    var canvas = self2.get("canvas");
    var renderer = canvas.getRenderer();
    if (!type)
      type = "image/png";
    var fileName = (name || "graph") + (renderer === "svg" ? ".svg" : type.split("/")[1]);
    var link = document.createElement("a");
    self2.asyncToDataUrl(type, backgroundColor, function(dataURL) {
      _this.dataURLToImage(dataURL, renderer, link, fileName);
      var e8 = document.createEvent("MouseEvents");
      e8.initEvent("click", false, false);
      link.dispatchEvent(e8);
    });
  };
  Graph5.prototype.dataURLToImage = function(dataURL, renderer, link, fileName) {
    if (!dataURL || dataURL === "data:") {
      console.error("Download image failed. The graph is too large or there is invalid attribute values in graph items");
      return;
    }
    if (typeof window !== "undefined") {
      if (window.Blob && window.URL && renderer !== "svg") {
        var arr = dataURL.split(",");
        var mime = "";
        if (arr && arr.length > 0) {
          var match = arr[0].match(/:(.*?);/);
          if (match && match.length >= 2)
            mime = match[1];
        }
        var bstr = atob(arr[1]);
        var n2 = bstr.length;
        var u8arr = new Uint8Array(n2);
        while (n2--) {
          u8arr[n2] = bstr.charCodeAt(n2);
        }
        var blobObj_1 = new Blob([u8arr], {
          type: mime
        });
        if (window.navigator.msSaveBlob) {
          window.navigator.msSaveBlob(blobObj_1, fileName);
        } else {
          link.addEventListener("click", function() {
            link.download = fileName;
            link.href = window.URL.createObjectURL(blobObj_1);
          });
        }
      } else {
        link.addEventListener("click", function() {
          link.download = fileName;
          link.href = dataURL;
        });
      }
    }
  };
  Graph5.prototype.addPlugin = function(plugin) {
    var self2 = this;
    if (plugin.destroyed) {
      return;
    }
    self2.get("plugins").push(plugin);
    plugin.initPlugin(self2);
  };
  Graph5.prototype.removePlugin = function(plugin) {
    var plugins = this.get("plugins");
    var index = plugins.indexOf(plugin);
    if (index >= 0) {
      plugin.destroyPlugin();
      plugins.splice(index, 1);
    }
  };
  Graph5.prototype.setImageWaterMarker = function(imgURL, config) {
    if (imgURL === void 0) {
      imgURL = global_default2.waterMarkerImage;
    }
    var container2 = this.get("container");
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
    }
    if (!container2.style.position) {
      container2.style.position = "relative";
    }
    var canvas = this.get("graphWaterMarker");
    var waterMarkerConfig = deep_mix_default({}, global_default2.imageWaterMarkerConfig, config);
    var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, image = waterMarkerConfig.image;
    if (!canvas) {
      var canvasCfg = {
        container: container2,
        width,
        height,
        capture: false
      };
      var pixelRatio = this.get("pixelRatio");
      if (pixelRatio) {
        canvasCfg.pixelRatio = pixelRatio;
      }
      canvas = new canvas_default2(canvasCfg);
      this.set("graphWaterMarker", canvas);
    }
    canvas.get("el").style.display = "none";
    var ctx2 = canvas.get("context");
    var rotate7 = image.rotate, x2 = image.x, y2 = image.y;
    ctx2.rotate(-rotate7 * Math.PI / 180);
    var img = new Image();
    img.crossOrigin = "anonymous";
    img.src = imgURL;
    img.onload = function() {
      ctx2.drawImage(img, x2, y2, image.width, image.height);
      ctx2.rotate(rotate7 * Math.PI / 180);
      if (!compatible) {
        var box2 = document.querySelector(".g6-graph-watermarker");
        if (!box2) {
          box2 = document.createElement("div");
          box2.className = "g6-graph-watermarker";
        }
        box2.className = "g6-graph-watermarker";
        if (!canvas.destroyed) {
          box2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:-1;");
          container2.appendChild(box2);
        }
      } else {
        container2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
      }
    };
  };
  Graph5.prototype.setTextWaterMarker = function(texts, config) {
    var container2 = this.get("container");
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
    }
    if (!container2.style.position) {
      container2.style.position = "relative";
    }
    var canvas = this.get("graphWaterMarker");
    var waterMarkerConfig = deep_mix_default({}, global_default2.textWaterMarkerConfig, config);
    var width = waterMarkerConfig.width, height = waterMarkerConfig.height, compatible = waterMarkerConfig.compatible, text = waterMarkerConfig.text;
    if (!canvas) {
      var canvasCfg = {
        container: container2,
        width,
        height,
        capture: false
      };
      var pixelRatio = this.get("pixelRatio");
      if (pixelRatio) {
        canvasCfg.pixelRatio = pixelRatio;
      }
      canvas = new canvas_default2(canvasCfg);
      this.set("graphWaterMarker", canvas);
    }
    canvas.get("el").style.display = "none";
    var ctx2 = canvas.get("context");
    var rotate7 = text.rotate, fill = text.fill, fontFamily = text.fontFamily, fontSize = text.fontSize, baseline = text.baseline, x2 = text.x, y2 = text.y, lineHeight = text.lineHeight;
    ctx2.rotate(-rotate7 * Math.PI / 180);
    ctx2.font = "".concat(fontSize, "px ").concat(fontFamily);
    ctx2.fillStyle = fill;
    ctx2.textBaseline = baseline;
    for (var i2 = texts.length - 1; i2 >= 0; i2--) {
      ctx2.fillText(texts[i2], x2, y2 + i2 * lineHeight);
    }
    ctx2.rotate(rotate7 * Math.PI / 180);
    if (!compatible) {
      var box2 = document.querySelector(".g6-graph-watermarker");
      if (!box2) {
        box2 = document.createElement("div");
        box2.className = "g6-graph-watermarker";
      }
      box2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:none;z-index:99;");
      container2.appendChild(box2);
    } else {
      container2.style.cssText = "background-image: url(".concat(canvas.get("el").toDataURL("image/png"), ");background-repeat:repeat;");
    }
  };
  Graph5.prototype.destroy = function() {
    var _a2, _b, _c, _d;
    each_default(this.get("plugins"), function(plugin) {
      plugin.destroyPlugin();
    });
    var tooltipDOMs = this.get("tooltips");
    if (tooltipDOMs) {
      for (var i2 = 0; i2 < tooltipDOMs.length; i2++) {
        var container2 = tooltipDOMs[i2];
        if (!container2)
          continue;
        var parent_1 = container2.parentElement;
        if (!parent_1)
          continue;
        parent_1.removeChild(container2);
      }
    }
    (_a2 = this.get("eventController")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    (_b = this.get("layoutController")) === null || _b === void 0 ? void 0 : _b.destroy();
    (_c = this.get("graphWaterMarker")) === null || _c === void 0 ? void 0 : _c.destroy();
    (_d = document.querySelector(".g6-graph-watermarker")) === null || _d === void 0 ? void 0 : _d.remove();
    _super.prototype.destroy.call(this);
  };
  return Graph5;
}(graph_default);
var graph_default2 = Graph4;

// node_modules/@antv/g6-pc/es/graph/tree-graph.js
var import_hierarchy2 = __toESM(require_lib2());
init_esm();
var radialLayout4 = util_default2.radialLayout;
var traverseTree4 = util_default2.traverseTree;
var TreeGraph = function(_super) {
  __extends(TreeGraph2, _super);
  function TreeGraph2(cfg) {
    var _this = _super.call(this, cfg) || this;
    _this.layoutAnimating = false;
    _this.set("removeList", []);
    _this.set("layoutMethod", _this.getLayout());
    return _this;
  }
  TreeGraph2.prototype.getLayout = function() {
    var layout2 = this.get("layout");
    if (!layout2) {
      return null;
    }
    if (typeof layout2 === "function") {
      return layout2;
    }
    if (!layout2.type) {
      layout2.type = "dendrogram";
    }
    if (!layout2.direction) {
      layout2.direction = "TB";
    }
    if (layout2.radial) {
      return function(data) {
        var layoutData = import_hierarchy2.default[layout2.type](data, layout2);
        radialLayout4(layoutData);
        return layoutData;
      };
    }
    return function(data) {
      return import_hierarchy2.default[layout2.type](data, layout2);
    };
  };
  TreeGraph2.indexOfChild = function(children, id2) {
    var index = -1;
    each_default(children, function(former, i2) {
      if (id2 === former.id) {
        index = i2;
        return false;
      }
    });
    return index;
  };
  TreeGraph2.prototype.getDefaultCfg = function() {
    var cfg = _super.prototype.getDefaultCfg.call(this);
    cfg.animate = true;
    return cfg;
  };
  TreeGraph2.prototype.innerAddChild = function(treeData, parent, animate) {
    var self2 = this;
    var model = treeData.data;
    if (model) {
      model.x = treeData.x;
      model.y = treeData.y;
      model.depth = treeData.depth;
    }
    var node = self2.addItem("node", model, false);
    if (parent) {
      node.set("parent", parent);
      if (animate) {
        var origin_1 = parent.get("originAttrs");
        if (origin_1) {
          node.set("originAttrs", origin_1);
        } else {
          var parentModel = parent.getModel();
          node.set("originAttrs", {
            x: parentModel.x,
            y: parentModel.y
          });
        }
      }
      var childrenList = parent.get("children");
      if (!childrenList) {
        parent.set("children", [node]);
      } else {
        childrenList.push(node);
      }
      self2.addItem("edge", {
        source: parent.get("id"),
        target: node.get("id"),
        id: "".concat(parent.get("id"), ":").concat(node.get("id"))
      }, false);
    }
    each_default(treeData.children || [], function(child) {
      self2.innerAddChild(child, node, animate);
    });
    self2.emit("afteraddchild", {
      item: node,
      parent
    });
    return node;
  };
  TreeGraph2.prototype.innerUpdateChild = function(data, parent, animate) {
    var self2 = this;
    var current = self2.findById(data.id);
    if (!current) {
      self2.innerAddChild(data, parent, animate);
      return;
    }
    each_default(data.children || [], function(child2) {
      self2.innerUpdateChild(child2, current, animate);
    });
    var children = current.get("children");
    if (children) {
      var len5 = children.length;
      if (len5 > 0) {
        for (var i2 = children.length - 1; i2 >= 0; i2--) {
          var child = children[i2].getModel();
          if (TreeGraph2.indexOfChild(data.children || [], child.id) === -1) {
            self2.innerRemoveChild(child.id, {
              x: data.x,
              y: data.y
            }, animate);
            children.splice(i2, 1);
          }
        }
      }
    }
    var oriX;
    var oriY;
    if (current.get("originAttrs")) {
      oriX = current.get("originAttrs").x;
      oriY = current.get("originAttrs").y;
    }
    var model = current.getModel();
    if (animate) {
      current.set("originAttrs", {
        x: model.x,
        y: model.y
      });
    }
    current.set("model", data.data);
    if (oriX !== data.x || oriY !== data.y) {
      current.updatePosition({
        x: data.x,
        y: data.y
      });
    }
  };
  TreeGraph2.prototype.innerRemoveChild = function(id2, to2, animate) {
    var self2 = this;
    var node = self2.findById(id2);
    if (!node) {
      return;
    }
    each_default(node.get("children"), function(child) {
      self2.innerRemoveChild(child.getModel().id, to2, animate);
    });
    if (animate) {
      var model = node.getModel();
      node.set("to", to2);
      node.set("originAttrs", {
        x: model.x,
        y: model.y
      });
      self2.get("removeList").push(node);
    } else {
      self2.removeItem(node, false);
    }
  };
  TreeGraph2.prototype.changeData = function(data) {
    var self2 = this;
    this.getNodes().map(function(node) {
      return self2.clearItemStates(node);
    });
    this.getEdges().map(function(edge) {
      return self2.clearItemStates(edge);
    });
    if (data) {
      self2.data(data);
      self2.render();
    } else {
      self2.layout(this.get("fitView"));
    }
  };
  TreeGraph2.prototype.changeLayout = function(layout2) {
    console.warn("Please call updateLayout instead of changeLayout. changeLayout will be discarded soon");
    var self2 = this;
    self2.updateLayout(layout2);
  };
  TreeGraph2.prototype.updateLayout = function(layout2) {
    var self2 = this;
    if (!layout2) {
      console.warn("layout cannot be null");
      return;
    }
    self2.set("layout", layout2);
    self2.set("layoutMethod", self2.getLayout());
    self2.layout();
  };
  TreeGraph2.prototype.refreshLayout = function(fitView) {
    console.warn("Please call layout instead of refreshLayout. refreshLayout will be discarded soon");
    var self2 = this;
    self2.layout(fitView);
  };
  TreeGraph2.prototype.layout = function(fitView) {
    var self2 = this;
    var data = self2.get("data");
    var layoutMethod = self2.get("layoutMethod");
    var layoutData = layoutMethod ? layoutMethod(data, self2.get("layout")) : data;
    var animate = self2.get("animate");
    self2.emit("beforerefreshlayout", {
      data,
      layoutData
    });
    self2.emit("beforelayout");
    self2.innerUpdateChild(layoutData, void 0, animate);
    if (fitView) {
      var viewController = self2.get("viewController");
      viewController.fitView();
    }
    if (!animate) {
      self2.refresh();
      self2.paint();
    } else {
      self2.layoutAnimate(layoutData);
    }
    self2.emit("afterrefreshlayout", {
      data,
      layoutData
    });
    self2.emit("afterlayout");
  };
  TreeGraph2.prototype.addChild = function(data, parent) {
    var self2 = this;
    self2.emit("beforeaddchild", {
      model: data,
      parent
    });
    if (!is_string_default(parent)) {
      parent = parent.get("id");
    }
    var parentData = self2.findDataById(parent);
    if (parentData) {
      if (!parentData.children) {
        parentData.children = [];
      }
      parentData.children.push(data);
      self2.changeData();
    }
  };
  TreeGraph2.prototype.updateChildren = function(data, parentId) {
    var self2 = this;
    if (!parentId || !self2.findById(parentId)) {
      console.warn("Update children failed! There is no node with id '".concat(parentId, "'"));
      return;
    }
    var parentModel = self2.findDataById(parentId);
    parentModel.children = data;
    self2.changeData();
  };
  TreeGraph2.prototype.updateChild = function(data, parentId) {
    var self2 = this;
    if (!parentId || !self2.findById(parentId)) {
      self2.changeData(data);
      return;
    }
    var parentModel = self2.findDataById(parentId);
    var current = self2.findById(data.id);
    if (!parentModel.children) {
      parentModel.children = [];
    }
    if (!current) {
      parentModel.children.push(data);
    } else {
      var index = TreeGraph2.indexOfChild(parentModel.children, data.id);
      parentModel.children[index] = data;
    }
    self2.changeData();
  };
  TreeGraph2.prototype.removeChild = function(id2) {
    var self2 = this;
    var node = self2.findById(id2);
    if (!node) {
      return;
    }
    var parent = node.get("parent");
    if (parent && !parent.destroyed) {
      var parentNode = self2.findDataById(parent.get("id"));
      var siblings = parentNode && parentNode.children || [];
      var model = node.getModel();
      var index = TreeGraph2.indexOfChild(siblings, model.id);
      siblings.splice(index, 1);
    }
    self2.changeData();
  };
  TreeGraph2.prototype.findDataById = function(id2, parent) {
    var self2 = this;
    if (!parent) {
      parent = self2.get("data");
    }
    if (id2 === parent.id) {
      return parent;
    }
    var result = null;
    each_default(parent.children || [], function(child) {
      if (child.id === id2) {
        result = child;
        return false;
      }
      result = self2.findDataById(id2, child);
      if (result) {
        return false;
      }
    });
    return result;
  };
  TreeGraph2.prototype.layoutAnimate = function(data, onFrame) {
    var self2 = this;
    var animateCfg = this.get("animateCfg");
    self2.emit("beforeanimate", {
      data
    });
    self2.getEdges().forEach(function(edge) {
      var model = edge.get("model");
      if (!model.sourceAnchor) {
        model.sourceAnchor = edge.get("sourceAnchorIndex");
      }
    });
    this.get("canvas").animate(function(ratio) {
      traverseTree4(data, function(child) {
        var node = self2.findById(child.id);
        if (node) {
          var origin_2 = node.get("originAttrs");
          var model = node.get("model");
          if (!origin_2) {
            origin_2 = {
              x: model.x,
              y: model.y
            };
            node.set("originAttrs", origin_2);
          }
          if (onFrame) {
            var attrs = onFrame(node, ratio, origin_2, data);
            node.set("model", Object.assign(model, attrs));
          } else {
            model.x = origin_2.x + (child.x - origin_2.x) * ratio;
            model.y = origin_2.y + (child.y - origin_2.y) * ratio;
          }
        }
        return true;
      });
      each_default(self2.get("removeList"), function(node) {
        var model = node.getModel();
        var from = node.get("originAttrs");
        var to2 = node.get("to");
        model.x = from.x + (to2.x - from.x) * ratio;
        model.y = from.y + (to2.y - from.y) * ratio;
      });
      self2.refreshPositions();
    }, {
      duration: animateCfg.duration,
      easing: animateCfg.ease,
      callback: function callback() {
        each_default(self2.getNodes(), function(node) {
          node.set("originAttrs", null);
        });
        each_default(self2.get("removeList"), function(node) {
          self2.removeItem(node);
        });
        self2.set("removeList", []);
        if (animateCfg.callback) {
          animateCfg.callback();
        }
        self2.emit("afteranimate", {
          data
        });
      },
      delay: animateCfg.delay
    });
  };
  TreeGraph2.prototype.stopLayoutAnimate = function() {
    this.get("canvas").stopAnimate();
    this.emit("layoutanimateend", {
      data: this.get("data")
    });
    this.layoutAnimating = false;
  };
  TreeGraph2.prototype.isLayoutAnimating = function() {
    return this.layoutAnimating;
  };
  TreeGraph2.prototype.render = function() {
    var self2 = this;
    var data = self2.get("data");
    if (!data || !is_object_default(data) || !Object.keys(data).length) {
      throw new Error("data must be defined first");
    }
    self2.clear();
    self2.emit("beforerender");
    self2.layout(this.get("fitView"));
    self2.emit("afterrender");
  };
  TreeGraph2.prototype.save = function() {
    return this.get("data");
  };
  return TreeGraph2;
}(graph_default2);
var tree_graph_default = TreeGraph;

// node_modules/@antv/g6-plugin/es/base.js
init_esm();
var PluginBase = function() {
  function PluginBase2(cfgs) {
    this._cfgs = deep_mix_default(this.getDefaultCfgs(), cfgs);
    this._events = {};
    this.destroyed = false;
  }
  PluginBase2.prototype.getDefaultCfgs = function() {
    return {};
  };
  PluginBase2.prototype.initPlugin = function(graph) {
    var self2 = this;
    self2.set("graph", graph);
    var events = self2.getEvents();
    var bindEvents = {};
    each_default(events, function(v2, k2) {
      var event = wrap_behavior_default(self2, v2);
      bindEvents[k2] = event;
      graph.on(k2, event);
    });
    this._events = bindEvents;
    this.init();
  };
  PluginBase2.prototype.getEvents = function() {
    return {};
  };
  PluginBase2.prototype.get = function(key) {
    var _a2;
    return (_a2 = this._cfgs) === null || _a2 === void 0 ? void 0 : _a2[key];
  };
  PluginBase2.prototype.set = function(key, val) {
    this._cfgs[key] = val;
  };
  PluginBase2.prototype.destroy = function() {
  };
  PluginBase2.prototype.destroyPlugin = function() {
    this.destroy();
    var graph = this.get("graph");
    var events = this._events;
    each_default(events, function(v2, k2) {
      graph.off(k2, v2);
    });
    this._events = null;
    this._cfgs = null;
    this.destroyed = true;
  };
  return PluginBase2;
}();
var base_default4 = PluginBase;

// node_modules/@antv/g6-plugin/es/grid/index.js
var __extends6 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var GRID_PNG = "url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGRlZnM+PHBhdHRlcm4gaWQ9ImdyaWQiIHdpZHRoPSI0MCIgaGVpZ2h0PSI0MCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHBhdGggZD0iTSAwIDEwIEwgNDAgMTAgTSAxMCAwIEwgMTAgNDAgTSAwIDIwIEwgNDAgMjAgTSAyMCAwIEwgMjAgNDAgTSAwIDMwIEwgNDAgMzAgTSAzMCAwIEwgMzAgNDAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2UwZTBlMCIgb3BhY2l0eT0iMC4yIiBzdHJva2Utd2lkdGg9IjEiLz48cGF0aCBkPSJNIDQwIDAgTCAwIDAgMCA0MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZTBlMGUwIiBzdHJva2Utd2lkdGg9IjEiLz48L3BhdHRlcm4+PC9kZWZzPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjZ3JpZCkiLz48L3N2Zz4=)";
var Grid2 = function(_super) {
  __extends6(Grid4, _super);
  function Grid4(config) {
    return _super.call(this, config) || this;
  }
  Grid4.prototype.getDefaultCfgs = function() {
    return {
      img: GRID_PNG,
      follow: true
    };
  };
  Grid4.prototype.init = function() {
    var graph = this.get("graph");
    var graphContainer = graph.get("container");
    var canvas = graph.get("canvas").get("el");
    var img = this.get("img") || GRID_PNG;
    var container2 = createDom2(`<div class='g6-grid-container' style="position:absolute;overflow:hidden;z-index: -1;"></div>`);
    var gridContainer = createDom2("<div\n        class='g6-grid'\n        style='position:absolute;\n        background-image: ".concat(img, ";\n        user-select: none\n        '></div>"));
    this.set("container", container2);
    this.set("gridContainer", gridContainer);
    this.positionInit();
    container2.appendChild(gridContainer);
    graphContainer.insertBefore(container2, canvas);
  };
  Grid4.prototype.positionInit = function() {
    var graph = this.get("graph");
    var minZoom = graph.get("minZoom");
    var width = graph.get("width");
    var height = graph.get("height");
    modifyCSS(this.get("container"), {
      width: "".concat(width, "px"),
      height: "".concat(height, "px")
    });
    var gridContainerWidth = width * 80 / minZoom;
    var gridContainerHeight = height * 80 / minZoom;
    modifyCSS(this.get("gridContainer"), {
      width: "".concat(gridContainerWidth, "px"),
      height: "".concat(gridContainerHeight, "px"),
      left: "-".concat(gridContainerWidth / 2, "px"),
      top: "-".concat(gridContainerHeight / 2, "px")
    });
  };
  Grid4.prototype.getEvents = function() {
    return {
      viewportchange: "updateGrid"
    };
  };
  Grid4.prototype.updateGrid = function(param) {
    var gridContainer = this.get("gridContainer");
    var matrix = param.matrix;
    if (!matrix)
      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var isFollow = this.get("follow");
    var transform14 = "matrix(".concat(matrix[0], ", ").concat(matrix[1], ", ").concat(matrix[3], ", ").concat(matrix[4], ", ").concat(isFollow ? matrix[6] : "0", ", ").concat(isFollow ? matrix[7] : "0", ")");
    modifyCSS(gridContainer, {
      transform: transform14
    });
  };
  Grid4.prototype.getContainer = function() {
    return this.get("container");
  };
  Grid4.prototype.destroy = function() {
    var graph = this.get("graph");
    var graphContainer = graph.get("container");
    var container2 = this.get("container");
    graphContainer.removeChild(container2);
  };
  return Grid4;
}(base_default4);
var grid_default = Grid2;

// node_modules/@antv/g6-plugin/es/menu/index.js
init_esm();
var import_insert_css = __toESM(require_insert_css());
var __extends7 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css.default)("\n  .g6-component-contextmenu {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .g6-contextmenu-ul {\n    padding: 0;\n    margin: 0;\n    list-style: none;\n  }\n\n");
var Menu = function(_super) {
  __extends7(Menu3, _super);
  function Menu3(config) {
    return _super.call(this, config) || this;
  }
  Menu3.prototype.getDefaultCfgs = function() {
    return {
      offsetX: 6,
      offsetY: 6,
      handleMenuClick: void 0,
      getContent: function getContent(e8) {
        return "\n          <ul class='g6-contextmenu-ul'>\n            <li>\u83DC\u5355\u98791</li>\n            <li>\u83DC\u5355\u98792</li>\n          </ul>\n        ";
      },
      shouldBegin: function shouldBegin2(e8) {
        return true;
      },
      onHide: function onHide() {
        return true;
      },
      itemTypes: ["node", "edge", "combo"],
      trigger: "contextmenu"
    };
  };
  Menu3.prototype.getEvents = function() {
    if (this.get("trigger") === "click") {
      return {
        click: "onMenuShow",
        touchend: "onMenuShow"
      };
    }
    return {
      contextmenu: "onMenuShow"
    };
  };
  Menu3.prototype.init = function() {
    var className = this.get("className");
    var menu = createDom2("<div class=".concat(className || "g6-component-contextmenu", "></div>"));
    modifyCSS(menu, {
      top: "0px",
      position: "absolute",
      visibility: "hidden"
    });
    var container2 = this.get("container");
    if (!container2) {
      container2 = this.get("graph").get("container");
    }
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
    }
    container2.appendChild(menu);
    this.set("menu", menu);
  };
  Menu3.prototype.onMenuShow = function(e8) {
    var self2 = this;
    e8.preventDefault();
    var itemTypes = this.get("itemTypes");
    if (!e8.item) {
      if (itemTypes.indexOf("canvas") === -1) {
        self2.onMenuHide();
        return;
      }
    } else {
      if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1) {
        self2.onMenuHide();
        return;
      }
    }
    var shouldBegin2 = this.get("shouldBegin");
    if (!shouldBegin2(e8))
      return;
    var menuDom = this.get("menu");
    var getContent = this.get("getContent");
    var graph = this.get("graph");
    var menu = getContent(e8, graph);
    if (is_string_default(menu)) {
      menuDom.innerHTML = menu;
    } else {
      menuDom.innerHTML = menu.outerHTML;
    }
    this.removeMenuEventListener();
    var handleMenuClick = this.get("handleMenuClick");
    if (handleMenuClick) {
      var handleMenuClickWrapper = function handleMenuClickWrapper2(evt) {
        handleMenuClick(evt.target, e8.item, graph);
      };
      this.set("handleMenuClickWrapper", handleMenuClickWrapper);
      menuDom.addEventListener("click", handleMenuClickWrapper);
    }
    var width = graph.get("width");
    var height = graph.get("height");
    var bbox = menuDom.getBoundingClientRect();
    var offsetX = this.get("offsetX") || 0;
    var offsetY = this.get("offsetY") || 0;
    var graphTop = graph.getContainer().offsetTop;
    var graphLeft = graph.getContainer().offsetLeft;
    var x2 = e8.canvasX + graphLeft + offsetX;
    var y2 = e8.canvasY + graphTop + offsetY;
    if (x2 + bbox.width > width) {
      x2 = e8.canvasX - bbox.width - offsetX + graphLeft;
    }
    if (y2 + bbox.height > height) {
      y2 = e8.canvasY - bbox.height - offsetY + graphTop;
    }
    modifyCSS(menuDom, {
      top: "".concat(y2, "px"),
      left: "".concat(x2, "px"),
      visibility: "visible"
    });
    var triggeredByFirstClick = this.get("trigger") === "click";
    var handler = function handler2(evt) {
      if (triggeredByFirstClick) {
        triggeredByFirstClick = false;
        return;
      }
      self2.onMenuHide();
    };
    document.body.addEventListener("click", handler);
    this.set("handler", handler);
  };
  Menu3.prototype.removeMenuEventListener = function() {
    var handleMenuClickWrapper = this.get("handleMenuClickWrapper");
    var handler = this.get("handler");
    if (handleMenuClickWrapper) {
      var menuDom = this.get("menu");
      menuDom.removeEventListener("click", handleMenuClickWrapper);
      this.set("handleMenuClickWrapper", null);
    }
    if (handler) {
      document.body.removeEventListener("click", handler);
    }
  };
  Menu3.prototype.onMenuHide = function() {
    var menuDom = this.get("menu");
    if (menuDom) {
      modifyCSS(menuDom, {
        visibility: "hidden"
      });
    }
    this.removeMenuEventListener();
  };
  Menu3.prototype.destroy = function() {
    var menu = this.get("menu");
    this.removeMenuEventListener();
    if (menu) {
      var container2 = this.get("container");
      if (!container2) {
        container2 = this.get("graph").get("container");
      }
      if (is_string_default(container2)) {
        container2 = document.getElementById(container2);
      }
      container2.removeChild(menu);
    }
  };
  return Menu3;
}(base_default4);
var menu_default = Menu;

// node_modules/@antv/g6-plugin/es/minimap/index.js
init_esm();
var __extends8 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign5.apply(this, arguments);
};
var max5 = Math.max;
var transform9 = ext_exports.transform;
var DEFAULT_MODE = "default";
var KEYSHAPE_MODE = "keyShape";
var DELEGATE_MODE = "delegate";
var SVG2 = "svg";
var MiniMap = function(_super) {
  __extends8(MiniMap2, _super);
  function MiniMap2(config) {
    var _this = _super.call(this, config) || this;
    _this.handleUpdateCanvas = debounce_default(function(event) {
      var self2 = _this;
      if (self2.destroyed)
        return;
      self2.updateCanvas();
    }, 100, false);
    return _this;
  }
  MiniMap2.prototype.getDefaultCfgs = function() {
    return {
      container: null,
      className: "g6-minimap",
      viewportClassName: "g6-minimap-viewport",
      type: "default",
      padding: 50,
      size: [200, 120],
      delegateStyle: {
        fill: "#40a9ff",
        stroke: "#096dd9"
      },
      refresh: true
    };
  };
  MiniMap2.prototype.getEvents = function() {
    return {
      beforepaint: "updateViewport",
      beforeanimate: "disableRefresh",
      afteranimate: "enableRefresh",
      viewportchange: "disableOneRefresh"
    };
  };
  MiniMap2.prototype.disableRefresh = function() {
    this.set("refresh", false);
  };
  MiniMap2.prototype.enableRefresh = function() {
    this.set("refresh", true);
    this.updateCanvas();
  };
  MiniMap2.prototype.disableOneRefresh = function() {
    this.set("viewportChange", true);
  };
  MiniMap2.prototype.initViewport = function() {
    var _this = this;
    var cfgs = this._cfgs;
    var size2 = cfgs.size, graph = cfgs.graph;
    if (this.destroyed)
      return;
    var canvas = this.get("canvas");
    var containerDOM = canvas.get("container");
    var viewport = createDom2("\n      <div\n        class=".concat(cfgs.viewportClassName, "\n        style='position:absolute;\n          left:0;\n          top:0;\n          box-sizing:border-box;\n          outline: 2px solid #1980ff'\n        draggable=true>\n      </div>"));
    var isFireFox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
    var x2 = 0;
    var y2 = 0;
    var dragging = false;
    var left = 0;
    var top = 0;
    var width = 0;
    var height = 0;
    var ratio = 0;
    var zoom = 0;
    viewport.addEventListener("dragstart", function(e8) {
      var _a2, _b;
      if (e8.dataTransfer) {
        var img = new Image();
        img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' %3E%3Cpath /%3E%3C/svg%3E";
        (_b = (_a2 = e8.dataTransfer).setDragImage) === null || _b === void 0 ? void 0 : _b.call(_a2, img, 0, 0);
        try {
          e8.dataTransfer.setData("text/html", "view-port-minimap");
        } catch (_c) {
          e8.dataTransfer.setData("text", "view-port-minimap");
        }
      }
      cfgs.refresh = false;
      if (e8.target !== viewport) {
        return;
      }
      var style = viewport.style;
      left = parseInt(style.left, 10);
      top = parseInt(style.top, 10);
      width = parseInt(style.width, 10);
      height = parseInt(style.height, 10);
      if (width > size2[0] || height > size2[1]) {
        return;
      }
      zoom = graph.getZoom();
      ratio = _this.get("ratio");
      dragging = true;
      x2 = e8.clientX;
      y2 = e8.clientY;
    }, false);
    viewport.addEventListener(isFireFox ? "dragover" : "drag", function(e8) {
      if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
        return;
      }
      var dx = x2 - e8.clientX;
      var dy = y2 - e8.clientY;
      if (left - dx < 0 || left - dx + width >= size2[0]) {
        dx = 0;
      }
      if (top - dy < 0 || top - dy + height >= size2[1]) {
        dy = 0;
      }
      left -= dx;
      top -= dy;
      modifyCSS(viewport, {
        left: "".concat(left, "px"),
        top: "".concat(top, "px")
      });
      graph.translate(dx * zoom / ratio, dy * zoom / ratio);
      x2 = e8.clientX;
      y2 = e8.clientY;
    }, false);
    viewport.addEventListener("dragend", function() {
      dragging = false;
      cfgs.refresh = true;
    }, false);
    this.set("viewport", viewport);
    containerDOM.appendChild(viewport);
  };
  MiniMap2.prototype.updateViewport = function() {
    if (this.destroyed)
      return;
    var ratio = this.get("ratio");
    var dx = this.get("dx");
    var dy = this.get("dy");
    var totaldx = this.get("totaldx");
    var totaldy = this.get("totaldy");
    var graph = this.get("graph");
    var size2 = this.get("size");
    var graphWidth = graph.get("width");
    var graphHeight = graph.get("height");
    var topLeft = graph.getPointByCanvas(0, 0);
    var bottomRight = graph.getPointByCanvas(graphWidth, graphHeight);
    var viewport = this.get("viewport");
    if (!viewport) {
      this.initViewport();
    }
    var width = (bottomRight.x - topLeft.x) * ratio;
    var height = (bottomRight.y - topLeft.y) * ratio;
    var left = topLeft.x * ratio + totaldx;
    var top = topLeft.y * ratio + totaldy;
    var right = left + width;
    var bottom = top + height;
    if (left < 0) {
      width += left;
      left = 0;
    }
    if (right > size2[0]) {
      width = width - (right - size2[0]);
    }
    if (top < 0) {
      height += top;
      top = 0;
    }
    if (bottom > size2[1]) {
      height = height - (bottom - size2[1]);
    }
    this.set("ratio", ratio);
    var correctLeft = "".concat(left, "px");
    var correctTop = "".concat(top, "px");
    modifyCSS(viewport, {
      left: correctLeft,
      top: correctTop,
      width: "".concat(width, "px"),
      height: "".concat(height, "px")
    });
  };
  MiniMap2.prototype.updateGraphShapes = function() {
    var graph = this._cfgs.graph;
    var canvas = this.get("canvas");
    var graphGroup = graph.get("group");
    if (graphGroup.destroyed)
      return;
    var clonedGroup = graphGroup.clone();
    clonedGroup.resetMatrix();
    canvas.clear();
    canvas.add(clonedGroup);
    var renderer = graph.get("renderer");
    if (renderer === SVG2) {
      this.updateVisible(clonedGroup);
    }
  };
  MiniMap2.prototype.updateVisible = function(ele) {
    var _this = this;
    if (!ele.isGroup() && !ele.get("visible")) {
      ele.hide();
    } else {
      var children = ele.get("children");
      if (!children || !children.length)
        return;
      children.forEach(function(child) {
        if (!child.get("visible"))
          child.hide();
        _this.updateVisible(child);
      });
    }
  };
  MiniMap2.prototype.updateKeyShapes = function() {
    var _this = this;
    var graph = this._cfgs.graph;
    var canvas = this.get("canvas");
    var group = canvas.get("children")[0] || canvas.addGroup();
    each_default(graph.getEdges(), function(edge) {
      _this.updateOneEdgeKeyShape(edge, group);
    });
    each_default(graph.getNodes(), function(node) {
      _this.updateOneNodeKeyShape(node, group);
    });
    var combos = graph.getCombos();
    if (combos && combos.length) {
      var comboGroup_1 = group.find(function(e8) {
        return e8.get("name") === "comboGroup";
      }) || group.addGroup({
        name: "comboGroup"
      });
      setTimeout(function() {
        if (_this.destroyed)
          return;
        each_default(combos, function(combo) {
          _this.updateOneComboKeyShape(combo, comboGroup_1);
        });
        comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.sort();
        comboGroup_1 === null || comboGroup_1 === void 0 ? void 0 : comboGroup_1.toBack();
        _this.updateCanvas();
      }, 250);
    }
    this.clearDestroyedShapes();
  };
  MiniMap2.prototype.updateOneComboKeyShape = function(item, comboGroup) {
    if (this.destroyed)
      return;
    var itemMap = this.get("itemMap") || {};
    var mappedItem = itemMap[item.get("id")];
    var bbox = item.getBBox();
    var cKeyShape = item.get("keyShape").clone();
    var keyShapeStyle = cKeyShape.attr();
    var attrs = {
      x: bbox.centerX,
      y: bbox.centerY
    };
    if (!mappedItem) {
      mappedItem = cKeyShape;
      comboGroup.add(mappedItem);
    } else {
      attrs = Object.assign(keyShapeStyle, attrs);
    }
    var shapeType = mappedItem.get("type");
    if (shapeType === "rect" || shapeType === "image") {
      attrs.x = bbox.minX;
      attrs.y = bbox.minY;
    }
    mappedItem.attr(attrs);
    if (!item.isVisible())
      mappedItem.hide();
    else
      mappedItem.show();
    mappedItem.exist = true;
    var zIndex = item.getModel().depth;
    if (!isNaN(zIndex))
      mappedItem.set("zIndex", zIndex);
    itemMap[item.get("id")] = mappedItem;
    this.set("itemMap", itemMap);
  };
  MiniMap2.prototype.updateOneNodeKeyShape = function(item, group) {
    var itemMap = this.get("itemMap") || {};
    var mappedItem = itemMap[item.get("id")];
    var bbox = item.getBBox();
    var cKeyShape = item.get("keyShape").clone();
    var keyShapeStyle = cKeyShape.attr();
    var attrs = {
      x: bbox.centerX,
      y: bbox.centerY
    };
    if (!mappedItem) {
      mappedItem = cKeyShape;
      group.add(mappedItem);
    } else {
      attrs = Object.assign(keyShapeStyle, attrs);
    }
    var shapeType = mappedItem.get("type");
    if (shapeType === "rect" || shapeType === "image") {
      attrs.x = bbox.minX;
      attrs.y = bbox.minY;
    }
    mappedItem.attr(attrs);
    if (!item.isVisible())
      mappedItem.hide();
    else
      mappedItem.show();
    mappedItem.exist = true;
    var zIndex = item.getModel().depth;
    if (!isNaN(zIndex))
      mappedItem.set("zIndex", zIndex);
    itemMap[item.get("id")] = mappedItem;
    this.set("itemMap", itemMap);
  };
  MiniMap2.prototype.updateDelegateShapes = function() {
    var _this = this;
    var graph = this._cfgs.graph;
    var canvas = this.get("canvas");
    var group = canvas.get("children")[0] || canvas.addGroup();
    each_default(graph.getEdges(), function(edge) {
      _this.updateOneEdgeKeyShape(edge, group);
    });
    each_default(graph.getNodes(), function(node) {
      _this.updateOneNodeDelegateShape(node, group);
    });
    var combos = graph.getCombos();
    if (combos && combos.length) {
      var comboGroup_2 = group.find(function(e8) {
        return e8.get("name") === "comboGroup";
      }) || group.addGroup({
        name: "comboGroup"
      });
      setTimeout(function() {
        if (_this.destroyed)
          return;
        each_default(combos, function(combo) {
          _this.updateOneComboKeyShape(combo, comboGroup_2);
        });
        comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.sort();
        comboGroup_2 === null || comboGroup_2 === void 0 ? void 0 : comboGroup_2.toBack();
        _this.updateCanvas();
      }, 250);
    }
    this.clearDestroyedShapes();
  };
  MiniMap2.prototype.clearDestroyedShapes = function() {
    var itemMap = this.get("itemMap") || {};
    var keys2 = Object.keys(itemMap);
    if (!keys2 || keys2.length === 0)
      return;
    for (var i2 = keys2.length - 1; i2 >= 0; i2--) {
      var shape = itemMap[keys2[i2]];
      var exist = shape.exist;
      shape.exist = false;
      if (!exist) {
        shape.remove();
        delete itemMap[keys2[i2]];
      }
    }
  };
  MiniMap2.prototype.updateOneEdgeKeyShape = function(item, group) {
    var itemMap = this.get("itemMap") || {};
    var mappedItem = itemMap[item.get("id")];
    if (mappedItem) {
      var path = item.get("keyShape").attr("path");
      mappedItem.attr("path", path);
    } else {
      mappedItem = item.get("keyShape").clone();
      group.add(mappedItem);
    }
    if (!item.isVisible())
      mappedItem.hide();
    else
      mappedItem.show();
    mappedItem.exist = true;
    itemMap[item.get("id")] = mappedItem;
    this.set("itemMap", itemMap);
  };
  MiniMap2.prototype.updateOneNodeDelegateShape = function(item, group) {
    var delegateStyle = this.get("delegateStyle");
    var itemMap = this.get("itemMap") || {};
    var mappedItem = itemMap[item.get("id")];
    var bbox = item.getBBox();
    if (mappedItem) {
      var attrs = {
        x: bbox.minX,
        y: bbox.minY,
        width: bbox.width,
        height: bbox.height
      };
      mappedItem.attr(attrs);
    } else {
      mappedItem = group.addShape("rect", {
        attrs: __assign5({
          x: bbox.minX,
          y: bbox.minY,
          width: bbox.width,
          height: bbox.height
        }, delegateStyle),
        name: "minimap-node-shape"
      });
    }
    if (!item.isVisible())
      mappedItem.hide();
    else
      mappedItem.show();
    mappedItem.exist = true;
    itemMap[item.get("id")] = mappedItem;
    this.set("itemMap", itemMap);
  };
  MiniMap2.prototype.init = function() {
    this.initContainer();
    this.get("graph").on("afterupdateitem", this.handleUpdateCanvas);
    this.get("graph").on("afteritemstatechange", this.handleUpdateCanvas);
    this.get("graph").on("afteradditem", this.handleUpdateCanvas);
    this.get("graph").on("afterremoveitem", this.handleUpdateCanvas);
    this.get("graph").on("afterrender", this.handleUpdateCanvas);
    this.get("graph").on("afterlayout", this.handleUpdateCanvas);
  };
  MiniMap2.prototype.initContainer = function() {
    var self2 = this;
    var graph = self2.get("graph");
    var size2 = self2.get("size");
    var className = self2.get("className");
    var parentNode = self2.get("container");
    var container2 = createDom2("<div class='".concat(className, "' style='width: ").concat(size2[0], "px; height: ").concat(size2[1], "px; overflow: hidden'></div>"));
    if (is_string_default(parentNode)) {
      parentNode = document.getElementById(parentNode);
    }
    if (parentNode) {
      parentNode.appendChild(container2);
    } else {
      graph.get("container").appendChild(container2);
    }
    self2.set("container", container2);
    var containerDOM = createDom2('<div class="g6-minimap-container" style="position: relative;"></div>');
    container2.appendChild(containerDOM);
    containerDOM.addEventListener("dragenter", function(e8) {
      e8.preventDefault();
    });
    containerDOM.addEventListener("dragover", function(e8) {
      e8.preventDefault();
    });
    var canvas;
    var renderer = graph.get("renderer");
    if (renderer === SVG2) {
      canvas = new canvas_default3({
        container: containerDOM,
        width: size2[0],
        height: size2[1]
      });
    } else {
      canvas = new canvas_default2({
        container: containerDOM,
        width: size2[0],
        height: size2[1]
      });
    }
    self2.set("canvas", canvas);
    self2.updateCanvas();
  };
  MiniMap2.prototype.updateCanvas = function() {
    if (this.destroyed)
      return;
    var isRefresh = this.get("refresh");
    if (!isRefresh) {
      return;
    }
    var graph = this.get("graph");
    if (graph.get("destroyed")) {
      return;
    }
    if (this.get("viewportChange")) {
      this.set("viewportChange", false);
      this.updateViewport();
    }
    var size2 = this.get("size");
    var canvas = this.get("canvas");
    var type = this.get("type");
    var padding = this.get("padding");
    if (canvas.destroyed) {
      return;
    }
    switch (type) {
      case DEFAULT_MODE:
        this.updateGraphShapes();
        break;
      case KEYSHAPE_MODE:
        this.updateKeyShapes();
        break;
      case DELEGATE_MODE:
        this.updateDelegateShapes();
        break;
      default:
        break;
    }
    var group = canvas.get("children")[0];
    if (!group)
      return;
    group.resetMatrix();
    var bbox = group.getCanvasBBox();
    var graphBBox = graph.get("canvas").getCanvasBBox();
    var graphZoom = graph.getZoom() || 1;
    var width = graphBBox.width / graphZoom;
    var height = graphBBox.height / graphZoom;
    if (Number.isFinite(bbox.width)) {
      width = max5(bbox.width, width);
      height = max5(bbox.height, height);
    }
    width += 2 * padding;
    height += 2 * padding;
    var ratio = Math.min(size2[0] / width, size2[1] / height);
    var matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var minX = 0;
    var minY = 0;
    if (Number.isFinite(bbox.minX)) {
      minX = -bbox.minX;
    }
    if (Number.isFinite(bbox.minY)) {
      minY = -bbox.minY;
    }
    var dx = (size2[0] - (width - 2 * padding) * ratio) / 2;
    var dy = (size2[1] - (height - 2 * padding) * ratio) / 2;
    matrix = transform9(matrix, [
      ["t", minX, minY],
      ["s", ratio, ratio],
      ["t", dx, dy]
    ]);
    group.setMatrix(matrix);
    this.set("ratio", ratio);
    this.set("totaldx", dx + minX * ratio);
    this.set("totaldy", dy + minY * ratio);
    this.set("dx", dx);
    this.set("dy", dy);
    this.updateViewport();
  };
  MiniMap2.prototype.getCanvas = function() {
    return this.get("canvas");
  };
  MiniMap2.prototype.getViewport = function() {
    return this.get("viewport");
  };
  MiniMap2.prototype.getContainer = function() {
    return this.get("container");
  };
  MiniMap2.prototype.destroy = function() {
    var _a2;
    (_a2 = this.get("canvas")) === null || _a2 === void 0 ? void 0 : _a2.destroy();
    var container2 = this.get("container");
    if (container2 === null || container2 === void 0 ? void 0 : container2.parentNode)
      container2.parentNode.removeChild(container2);
  };
  return MiniMap2;
}(base_default4);
var minimap_default = MiniMap;

// node_modules/@antv/g6-plugin/es/bundling/index.js
var __extends9 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
function getEucliDis(pointA, pointB, eps2) {
  var vx = pointA.x - pointB.x;
  var vy = pointA.y - pointB.y;
  if (!eps2 || Math.abs(vx) > eps2 || Math.abs(vy) > eps2) {
    return Math.sqrt(vx * vx + vy * vy);
  }
  return eps2;
}
function getDotProduct(ei2, ej) {
  return ei2.x * ej.x + ei2.y * ej.y;
}
function projectPointToEdge(p2, e8) {
  var k2 = (e8.source.y - e8.target.y) / (e8.source.x - e8.target.x);
  var x2 = (k2 * k2 * e8.source.x + k2 * (p2.y - e8.source.y) + p2.x) / (k2 * k2 + 1);
  var y2 = k2 * (x2 - e8.source.x) + e8.source.y;
  return {
    x: x2,
    y: y2
  };
}
var Bundling = function(_super) {
  __extends9(Bundling3, _super);
  function Bundling3(config) {
    return _super.call(this, config) || this;
  }
  Bundling3.prototype.getDefaultCfgs = function() {
    return {
      edgeBundles: [],
      edgePoints: [],
      K: 0.1,
      lambda: 0.1,
      divisions: 1,
      divRate: 2,
      cycles: 6,
      iterations: 90,
      iterRate: 0.6666667,
      bundleThreshold: 0.6,
      eps: 1e-6,
      onLayoutEnd: function onLayoutEnd() {
      },
      onTick: function onTick() {
      }
    };
  };
  Bundling3.prototype.init = function() {
    var graph = this.get("graph");
    var onTick = this.get("onTick");
    var tick = function tick2() {
      if (onTick) {
        onTick();
      }
      graph.refreshPositions();
    };
    this.set("tick", tick);
  };
  Bundling3.prototype.bundling = function(data) {
    var self2 = this;
    self2.set("data", data);
    if (self2.isTicking()) {
      return;
    }
    var edges = data.edges || [];
    var nodes = data.nodes || [];
    var nodeIdMap = {};
    var error = false;
    nodes.forEach(function(node) {
      if (node.x === null || !node.y === null || node.x === void 0 || !node.y === void 0) {
        error = true;
      }
      nodeIdMap[node.id] = node;
    });
    if (error)
      throw new Error("please layout the graph or assign x and y for nodes first");
    self2.set("nodeIdMap", nodeIdMap);
    var divisions = self2.get("divisions");
    var divRate = self2.get("divRate");
    var edgePoints = self2.divideEdges(divisions);
    self2.set("edgePoints", edgePoints);
    var edgeBundles = self2.getEdgeBundles();
    self2.set("edgeBundles", edgeBundles);
    var C3 = self2.get("cycles");
    var iterations = self2.get("iterations");
    var iterRate = self2.get("iterRate");
    var lambda = self2.get("lambda");
    for (var i2 = 0; i2 < C3; i2++) {
      var _loop_1 = function _loop_12(j3) {
        var forces = [];
        edges.forEach(function(e8, k2) {
          if (e8.source === e8.target)
            return;
          var source = nodeIdMap[e8.source];
          var target = nodeIdMap[e8.target];
          forces[k2] = self2.getEdgeForces({
            source,
            target
          }, k2, divisions, lambda);
          for (var p2 = 0; p2 < divisions + 1; p2++) {
            edgePoints[k2][p2].x += forces[k2][p2].x;
            edgePoints[k2][p2].y += forces[k2][p2].y;
          }
        });
      };
      for (var j2 = 0; j2 < iterations; j2++) {
        _loop_1(j2);
      }
      lambda = lambda / 2;
      divisions *= divRate;
      iterations *= iterRate;
      edgePoints = self2.divideEdges(divisions);
      self2.set("edgePoints", edgePoints);
    }
    edges.forEach(function(e8, i3) {
      if (e8.source === e8.target)
        return;
      e8.type = "polyline";
      e8.controlPoints = edgePoints[i3].slice(1, edgePoints[i3].length - 1);
    });
    var graph = self2.get("graph");
    graph.refresh();
  };
  Bundling3.prototype.updateBundling = function(cfg) {
    var self2 = this;
    var data = cfg.data;
    if (data) {
      self2.set("data", data);
    }
    if (self2.get("ticking")) {
      self2.set("ticking", false);
    }
    Object.keys(cfg).forEach(function(key) {
      self2.set(key, cfg[key]);
    });
    if (cfg.onTick) {
      var graph_1 = this.get("graph");
      self2.set("tick", function() {
        cfg.onTick();
        graph_1.refresh();
      });
    }
    self2.bundling(data);
  };
  Bundling3.prototype.divideEdges = function(divisions) {
    var self2 = this;
    var edges = self2.get("data").edges;
    var nodeIdMap = self2.get("nodeIdMap");
    var edgePoints = self2.get("edgePoints");
    if (!edgePoints || edgePoints === void 0)
      edgePoints = [];
    edges.forEach(function(edge, i2) {
      if (!edgePoints[i2] || edgePoints[i2] === void 0) {
        edgePoints[i2] = [];
      }
      var source = nodeIdMap[edge.source];
      var target = nodeIdMap[edge.target];
      if (divisions === 1) {
        edgePoints[i2].push({
          x: source.x,
          y: source.y
        });
        edgePoints[i2].push({
          x: 0.5 * (source.x + target.x),
          y: 0.5 * (source.y + target.y)
        });
        edgePoints[i2].push({
          x: target.x,
          y: target.y
        });
      } else {
        var edgeLength = 0;
        if (!edgePoints[i2] || edgePoints[i2] === []) {
          edgeLength = getEucliDis({
            x: source.x,
            y: source.y
          }, {
            x: target.x,
            y: target.y
          });
        } else {
          edgeLength = self2.getEdgeLength(edgePoints[i2]);
        }
        var divisionLength_1 = edgeLength / (divisions + 1);
        var currentDivisonLength_1 = divisionLength_1;
        var newEdgePoints_1 = [{
          x: source.x,
          y: source.y
        }];
        edgePoints[i2].forEach(function(ep, j2) {
          if (j2 === 0)
            return;
          var oriDivisionLength = getEucliDis(ep, edgePoints[i2][j2 - 1]);
          while (oriDivisionLength > currentDivisonLength_1) {
            var ratio = currentDivisonLength_1 / oriDivisionLength;
            var edgePoint = {
              x: edgePoints[i2][j2 - 1].x,
              y: edgePoints[i2][j2 - 1].y
            };
            edgePoint.x += ratio * (ep.x - edgePoints[i2][j2 - 1].x);
            edgePoint.y += ratio * (ep.y - edgePoints[i2][j2 - 1].y);
            newEdgePoints_1.push(edgePoint);
            oriDivisionLength -= currentDivisonLength_1;
            currentDivisonLength_1 = divisionLength_1;
          }
          currentDivisonLength_1 -= oriDivisionLength;
        });
        newEdgePoints_1.push({
          x: target.x,
          y: target.y
        });
        edgePoints[i2] = newEdgePoints_1;
      }
    });
    return edgePoints;
  };
  Bundling3.prototype.getEdgeLength = function(points) {
    var length5 = 0;
    points.forEach(function(p2, i2) {
      if (i2 === 0)
        return;
      length5 += getEucliDis(p2, points[i2 - 1]);
    });
    return length5;
  };
  Bundling3.prototype.getEdgeBundles = function() {
    var self2 = this;
    var data = self2.get("data");
    var edges = data.edges || [];
    var bundleThreshold = self2.get("bundleThreshold");
    var nodeIdMap = self2.get("nodeIdMap");
    var edgeBundles = self2.get("edgeBundles");
    if (!edgeBundles)
      edgeBundles = [];
    edges.forEach(function(e8, i2) {
      if (!edgeBundles[i2] || edgeBundles[i2] === void 0) {
        edgeBundles[i2] = [];
      }
    });
    edges.forEach(function(ei2, i2) {
      var iSource = nodeIdMap[ei2.source];
      var iTarget = nodeIdMap[ei2.target];
      edges.forEach(function(ej, j2) {
        if (j2 <= i2)
          return;
        var jSource = nodeIdMap[ej.source];
        var jTarget = nodeIdMap[ej.target];
        var score = self2.getBundleScore({
          source: iSource,
          target: iTarget
        }, {
          source: jSource,
          target: jTarget
        });
        if (score >= bundleThreshold) {
          edgeBundles[i2].push(j2);
          edgeBundles[j2].push(i2);
        }
      });
    });
    return edgeBundles;
  };
  Bundling3.prototype.getBundleScore = function(ei2, ej) {
    var self2 = this;
    ei2.vx = ei2.target.x - ei2.source.x;
    ei2.vy = ei2.target.y - ei2.source.y;
    ej.vx = ej.target.x - ej.source.x;
    ej.vy = ej.target.y - ej.source.y;
    ei2.length = getEucliDis({
      x: ei2.source.x,
      y: ei2.source.y
    }, {
      x: ei2.target.x,
      y: ei2.target.y
    });
    ej.length = getEucliDis({
      x: ej.source.x,
      y: ej.source.y
    }, {
      x: ej.target.x,
      y: ej.target.y
    });
    var aScore = self2.getAngleScore(ei2, ej);
    var sScore = self2.getScaleScore(ei2, ej);
    var pScore = self2.getPositionScore(ei2, ej);
    var vScore = self2.getVisibilityScore(ei2, ej);
    return aScore * sScore * pScore * vScore;
  };
  Bundling3.prototype.getAngleScore = function(ei2, ej) {
    var dotProduct = getDotProduct({
      x: ei2.vx,
      y: ei2.vy
    }, {
      x: ej.vx,
      y: ej.vy
    });
    return dotProduct / (ei2.length * ej.length);
  };
  Bundling3.prototype.getScaleScore = function(ei2, ej) {
    var aLength = (ei2.length + ej.length) / 2;
    var score = 2 / (aLength / Math.min(ei2.length, ej.length) + Math.max(ei2.length, ej.length) / aLength);
    return score;
  };
  Bundling3.prototype.getPositionScore = function(ei2, ej) {
    var aLength = (ei2.length + ej.length) / 2;
    var iMid = {
      x: (ei2.source.x + ei2.target.x) / 2,
      y: (ei2.source.y + ei2.target.y) / 2
    };
    var jMid = {
      x: (ej.source.x + ej.target.x) / 2,
      y: (ej.source.y + ej.target.y) / 2
    };
    var distance11 = getEucliDis(iMid, jMid);
    return aLength / (aLength + distance11);
  };
  Bundling3.prototype.getVisibilityScore = function(ei2, ej) {
    var vij = this.getEdgeVisibility(ei2, ej);
    var vji = this.getEdgeVisibility(ej, ei2);
    return vij < vji ? vij : vji;
  };
  Bundling3.prototype.getEdgeVisibility = function(ei2, ej) {
    var ps = projectPointToEdge(ej.source, ei2);
    var pt2 = projectPointToEdge(ej.target, ei2);
    var pMid = {
      x: (ps.x + pt2.x) / 2,
      y: (ps.y + pt2.y) / 2
    };
    var iMid = {
      x: (ei2.source.x + ei2.target.x) / 2,
      y: (ei2.source.y + ei2.target.y) / 2
    };
    return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt2));
  };
  Bundling3.prototype.getEdgeForces = function(e8, eidx, divisions, lambda) {
    var self2 = this;
    var edgePoints = self2.get("edgePoints");
    var K3 = self2.get("K");
    var kp = K3 / (getEucliDis(e8.source, e8.target) * (divisions + 1));
    var edgePointForces = [{
      x: 0,
      y: 0
    }];
    for (var i2 = 1; i2 < divisions; i2++) {
      var force = {
        x: 0,
        y: 0
      };
      var spring = self2.getSpringForce({
        pre: edgePoints[eidx][i2 - 1],
        cur: edgePoints[eidx][i2],
        next: edgePoints[eidx][i2 + 1]
      }, kp);
      var electrostatic = self2.getElectrostaticForce(i2, eidx);
      force.x = lambda * (spring.x + electrostatic.x);
      force.y = lambda * (spring.y + electrostatic.y);
      edgePointForces.push(force);
    }
    edgePointForces.push({
      x: 0,
      y: 0
    });
    return edgePointForces;
  };
  Bundling3.prototype.getSpringForce = function(divisions, kp) {
    var x2 = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;
    var y2 = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;
    x2 *= kp;
    y2 *= kp;
    return {
      x: x2,
      y: y2
    };
  };
  Bundling3.prototype.getElectrostaticForce = function(pidx, eidx) {
    var self2 = this;
    var eps2 = self2.get("eps");
    var edgeBundles = self2.get("edgeBundles");
    var edgePoints = self2.get("edgePoints");
    var edgeBundle = edgeBundles[eidx];
    var resForce = {
      x: 0,
      y: 0
    };
    edgeBundle.forEach(function(eb) {
      var force = {
        x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,
        y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y
      };
      if (Math.abs(force.x) > eps2 || Math.abs(force.y) > eps2) {
        var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);
        var diff = 1 / length_1;
        resForce.x += force.x * diff;
        resForce.y += force.y * diff;
      }
    });
    return resForce;
  };
  Bundling3.prototype.isTicking = function() {
    return this.get("ticking");
  };
  Bundling3.prototype.getSimulation = function() {
    return this.get("forceSimulation");
  };
  Bundling3.prototype.destroy = function() {
    if (this.get("ticking")) {
      this.getSimulation().stop();
    }
    _super.prototype.destroy.call(this);
  };
  return Bundling3;
}(base_default4);
var bundling_default = Bundling;

// node_modules/@antv/g6-plugin/es/fisheye/index.js
init_esm();
var __extends10 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign6 = function() {
  __assign6 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign6.apply(this, arguments);
};
var DELTA = 0.05;
var lensDelegateStyle = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 0.1,
  fill: "#ccc"
};
var Fisheye = function(_super) {
  __extends10(Fisheye3, _super);
  function Fisheye3(config) {
    return _super.call(this, config) || this;
  }
  Fisheye3.prototype.getDefaultCfgs = function() {
    return {
      trigger: "mousemove",
      d: 1.5,
      r: 300,
      delegateStyle: clone_default(lensDelegateStyle),
      showLabel: false,
      maxD: 5,
      minD: 0,
      scaleRBy: "unset",
      scaleDBy: "unset",
      showDPercent: true
    };
  };
  Fisheye3.prototype.getEvents = function() {
    var events;
    switch (this.get("trigger")) {
      case "click":
        events = {
          click: "magnify"
        };
        break;
      case "drag":
        events = {
          click: "createDelegate"
        };
        break;
      default:
        events = {
          mousemove: "magnify"
        };
        break;
    }
    return events;
  };
  Fisheye3.prototype.init = function() {
    var self2 = this;
    var r2 = self2.get("r");
    self2.set("cachedMagnifiedModels", []);
    self2.set("cachedOriginPositions", {});
    self2.set("r2", r2 * r2);
    var d2 = self2.get("d");
    self2.set("molecularParam", (d2 + 1) * r2);
  };
  Fisheye3.prototype.createDelegate = function(e8) {
    var _this = this;
    var self2 = this;
    var lensDelegate = self2.get("delegate");
    if (!lensDelegate || lensDelegate.destroyed) {
      self2.magnify(e8);
      lensDelegate = self2.get("delegate");
      lensDelegate.on("dragstart", function(evt) {
        self2.set("delegateCenterDiff", {
          x: lensDelegate.attr("x") - evt.x,
          y: lensDelegate.attr("y") - evt.y
        });
      });
      lensDelegate.on("drag", function(evt) {
        self2.magnify(evt);
      });
      if (this.get("scaleDBy") === "wheel") {
        lensDelegate.on("mousewheel", function(evt) {
          _this.scaleDByWheel(evt);
        });
      }
      if (this.get("scaleRBy") === "wheel") {
        lensDelegate.on("mousewheel", function(evt) {
          self2.scaleRByWheel(evt);
        });
      }
    }
  };
  Fisheye3.prototype.scaleRByWheel = function(e8) {
    var self2 = this;
    if (!e8 || !e8.originalEvent)
      return;
    if (e8.preventDefault)
      e8.preventDefault();
    var graph = self2.get("graph");
    var ratio;
    var lensDelegate = self2.get("delegate");
    var lensCenter = lensDelegate ? {
      x: lensDelegate.attr("x"),
      y: lensDelegate.attr("y")
    } : void 0;
    var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
    if (e8.originalEvent.wheelDelta < 0) {
      ratio = 1 - DELTA;
    } else {
      ratio = 1 / (1 - DELTA);
    }
    var maxR = self2.get("maxR");
    var minR = self2.get("minR");
    var r2 = self2.get("r");
    if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
      ratio = 1;
    }
    r2 *= ratio;
    self2.set("r", r2);
    self2.set("r2", r2 * r2);
    var d2 = self2.get("d");
    self2.set("molecularParam", (d2 + 1) * r2);
    self2.set("delegateCenterDiff", void 0);
    self2.magnify(e8, mousePos);
  };
  Fisheye3.prototype.scaleRByDrag = function(e8) {
    var self2 = this;
    if (!e8)
      return;
    var dragPrePos = self2.get("dragPrePos");
    var graph = self2.get("graph");
    var ratio;
    var mousePos = graph.getPointByClient(e8.clientX, e8.clientY);
    if (e8.x - dragPrePos.x < 0) {
      ratio = 1 - DELTA;
    } else {
      ratio = 1 / (1 - DELTA);
    }
    var maxR = self2.get("maxR");
    var minR = self2.get("minR");
    var r2 = self2.get("r");
    if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
      ratio = 1;
    }
    r2 *= ratio;
    self2.set("r", r2);
    self2.set("r2", r2 * r2);
    var d2 = self2.get("d");
    self2.set("molecularParam", (d2 + 1) * r2);
    self2.magnify(e8, mousePos);
    self2.set("dragPrePos", {
      x: e8.x,
      y: e8.y
    });
  };
  Fisheye3.prototype.scaleDByWheel = function(evt) {
    var self2 = this;
    if (!evt && !evt.originalEvent)
      return;
    if (evt.preventDefault)
      evt.preventDefault();
    var delta = 0;
    if (evt.originalEvent.wheelDelta < 0) {
      delta = -0.1;
    } else {
      delta = 0.1;
    }
    var d2 = self2.get("d");
    var newD = d2 + delta;
    var maxD = self2.get("maxD");
    var minD = self2.get("minD");
    if (newD < maxD && newD > minD) {
      self2.set("d", newD);
      var r2 = self2.get("r");
      self2.set("molecularParam", (newD + 1) * r2);
      var lensDelegate = self2.get("delegate");
      var lensCenter = lensDelegate ? {
        x: lensDelegate.attr("x"),
        y: lensDelegate.attr("y")
      } : void 0;
      self2.set("delegateCenterDiff", void 0);
      self2.magnify(evt, lensCenter);
    }
  };
  Fisheye3.prototype.scaleDByDrag = function(e8) {
    var self2 = this;
    var dragPrePos = self2.get("dragPrePos");
    var delta = e8.x - dragPrePos.x > 0 ? 0.1 : -0.1;
    var d2 = self2.get("d");
    var newD = d2 + delta;
    var maxD = self2.get("maxD");
    var minD = self2.get("minD");
    if (newD < maxD && newD > minD) {
      self2.set("d", newD);
      var r2 = self2.get("r");
      self2.set("molecularParam", (newD + 1) * r2);
      self2.magnify(e8);
    }
    self2.set("dragPrePos", {
      x: e8.x,
      y: e8.y
    });
  };
  Fisheye3.prototype.magnify = function(e8, mousePos) {
    var self2 = this;
    self2.restoreCache();
    var graph = self2.get("graph");
    var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
    var cachedOriginPositions = self2.get("cachedOriginPositions");
    var showLabel = self2.get("showLabel");
    var r2 = self2.get("r");
    var r22 = self2.get("r2");
    var d2 = self2.get("d");
    var molecularParam = self2.get("molecularParam");
    var nodes = graph.getNodes();
    var nodeLength = nodes.length;
    var mCenter = mousePos ? {
      x: mousePos.x,
      y: mousePos.y
    } : {
      x: e8.x,
      y: e8.y
    };
    if (self2.get("dragging") && (self2.get("trigger") === "mousemove" || self2.get("trigger") === "click")) {
      mCenter = self2.get("cacheCenter");
    }
    var delegateCenterDiff = self2.get("delegateCenterDiff");
    if (delegateCenterDiff) {
      mCenter.x += delegateCenterDiff.x;
      mCenter.y += delegateCenterDiff.y;
    }
    self2.updateDelegate(mCenter, r2);
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var model = nodes[i2].getModel();
      var x2 = model.x, y2 = model.y;
      if (isNaN(x2) || isNaN(y2))
        continue;
      var dist22 = (x2 - mCenter.x) * (x2 - mCenter.x) + (y2 - mCenter.y) * (y2 - mCenter.y);
      if (!isNaN(dist22) && dist22 < r22 && dist22 !== 0) {
        var dist4 = Math.sqrt(dist22);
        var magnifiedDist = molecularParam * dist4 / (d2 * dist4 + r2);
        var cos3 = (x2 - mCenter.x) / dist4;
        var sin3 = (y2 - mCenter.y) / dist4;
        model.x = cos3 * magnifiedDist + mCenter.x;
        model.y = sin3 * magnifiedDist + mCenter.y;
        if (!cachedOriginPositions[model.id]) {
          cachedOriginPositions[model.id] = {
            x: x2,
            y: y2,
            texts: []
          };
        }
        cachedMagnifiedModels.push(model);
        if (showLabel && 2 * dist4 < r2) {
          var node = nodes[i2];
          var nodeGroup = node.getContainer();
          var shapes = nodeGroup.getChildren();
          var shapeLength = shapes.length;
          for (var j2 = 0; j2 < shapeLength; j2++) {
            var shape = shapes[j2];
            if (shape.get("type") === "text") {
              cachedOriginPositions[model.id].texts.push({
                visible: shape.get("visible"),
                shape
              });
              shape.set("visible", true);
            }
          }
        }
      }
    }
    graph.refreshPositions();
  };
  Fisheye3.prototype.restoreCache = function() {
    var self2 = this;
    var cachedMagnifiedModels = self2.get("cachedMagnifiedModels");
    var cachedOriginPositions = self2.get("cachedOriginPositions");
    var cacheLength = cachedMagnifiedModels.length;
    for (var i2 = 0; i2 < cacheLength; i2++) {
      var node = cachedMagnifiedModels[i2];
      var id2 = node.id;
      var ori = cachedOriginPositions[id2];
      node.x = ori.x;
      node.y = ori.y;
      var textLength = ori.texts.length;
      for (var j2 = 0; j2 < textLength; j2++) {
        var text = ori.texts[j2];
        text.shape.set("visible", text.visible);
      }
    }
    self2.set("cachedMagnifiedModels", []);
    self2.set("cachedOriginPositions", {});
  };
  Fisheye3.prototype.updateParams = function(cfg) {
    var self2 = this;
    var r2 = cfg.r, d2 = cfg.d, trigger = cfg.trigger, minD = cfg.minD, maxD = cfg.maxD, minR = cfg.minR, maxR = cfg.maxR, scaleDBy = cfg.scaleDBy, scaleRBy = cfg.scaleRBy;
    if (!isNaN(cfg.r)) {
      self2.set("r", r2);
      self2.set("r2", r2 * r2);
    }
    if (!isNaN(d2)) {
      self2.set("d", d2);
    }
    if (!isNaN(maxD)) {
      self2.set("maxD", maxD);
    }
    if (!isNaN(minD)) {
      self2.set("minD", minD);
    }
    if (!isNaN(maxR)) {
      self2.set("maxR", maxR);
    }
    if (!isNaN(minR)) {
      self2.set("minR", minR);
    }
    var nd = self2.get("d");
    var nr2 = self2.get("r");
    self2.set("molecularParam", (nd + 1) * nr2);
    if (trigger === "mousemove" || trigger === "click" || trigger === "drag") {
      self2.set("trigger", trigger);
    }
    if (scaleDBy === "drag" || scaleDBy === "wheel" || scaleDBy === "unset") {
      self2.set("scaleDBy", scaleDBy);
      self2.get("delegate").remove();
      self2.get("delegate").destroy();
      var dPercentText = self2.get("dPercentText");
      if (dPercentText) {
        dPercentText.remove();
        dPercentText.destroy();
      }
    }
    if (scaleRBy === "drag" || scaleRBy === "wheel" || scaleRBy === "unset") {
      self2.set("scaleRBy", scaleRBy);
      self2.get("delegate").remove();
      self2.get("delegate").destroy();
      var dPercentText = self2.get("dPercentText");
      if (dPercentText) {
        dPercentText.remove();
        dPercentText.destroy();
      }
    }
  };
  Fisheye3.prototype.updateDelegate = function(mCenter, r2) {
    var _this = this;
    var self2 = this;
    var graph = self2.get("graph");
    var lensDelegate = self2.get("delegate");
    if (!lensDelegate || lensDelegate.destroyed) {
      var parent_1 = graph.get("group");
      var attrs = self2.get("delegateStyle") || lensDelegateStyle;
      lensDelegate = parent_1.addShape("circle", {
        attrs: __assign6({
          r: r2 / 1.5,
          x: mCenter.x,
          y: mCenter.y
        }, attrs),
        name: "lens-shape",
        draggable: true
      });
      if (this.get("trigger") !== "drag") {
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        } else if (this.get("scaleRBy") === "drag") {
          lensDelegate.on("dragstart", function(e8) {
            self2.set("dragging", true);
            self2.set("cacheCenter", {
              x: e8.x,
              y: e8.y
            });
            self2.set("dragPrePos", {
              x: e8.x,
              y: e8.y
            });
          });
          lensDelegate.on("drag", function(evt) {
            self2.scaleRByDrag(evt);
          });
          lensDelegate.on("dragend", function(e8) {
            self2.set("dragging", false);
          });
        }
        if (this.get("scaleDBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            _this.scaleDByWheel(evt);
          });
        } else if (this.get("scaleDBy") === "drag") {
          lensDelegate.on("dragstart", function(evt) {
            self2.set("dragging", true);
            self2.set("cacheCenter", {
              x: evt.x,
              y: evt.y
            });
            self2.set("dragPrePos", {
              x: evt.x,
              y: evt.y
            });
          });
          lensDelegate.on("drag", function(evt) {
            _this.scaleDByDrag(evt);
          });
          lensDelegate.on("dragend", function(evt) {
            self2.set("dragging", false);
          });
        }
      }
    } else {
      lensDelegate.attr({
        x: mCenter.x,
        y: mCenter.y,
        r: r2 / 1.5
      });
    }
    if (self2.get("showDPercent")) {
      var percent = Math.round((self2.get("d") - self2.get("minD")) / (self2.get("maxD") - self2.get("minD")) * 100);
      var dPercentText = self2.get("dPercentText");
      var textY = mCenter.y + r2 / 1.5 + 16;
      if (!dPercentText || dPercentText.destroyed) {
        var parent_2 = graph.get("group");
        dPercentText = parent_2.addShape("text", {
          attrs: {
            text: "".concat(percent, "%"),
            x: mCenter.x,
            y: textY,
            fill: "#aaa",
            stroke: "#fff",
            lineWidth: 1,
            fontSize: 12
          }
        });
        self2.set("dPercentText", dPercentText);
      } else {
        dPercentText.attr({
          text: "".concat(percent, "%"),
          x: mCenter.x,
          y: textY
        });
      }
    }
    self2.set("delegate", lensDelegate);
  };
  Fisheye3.prototype.clear = function() {
    var graph = this.get("graph");
    this.restoreCache();
    graph.refreshPositions();
    var lensDelegate = this.get("delegate");
    if (lensDelegate && !lensDelegate.destroyed) {
      lensDelegate.remove();
      lensDelegate.destroy();
    }
    var dPercentText = this.get("dPercentText");
    if (dPercentText && !dPercentText.destroyed) {
      dPercentText.remove();
      dPercentText.destroy();
    }
  };
  Fisheye3.prototype.destroy = function() {
    this.clear();
  };
  return Fisheye3;
}(base_default4);
var fisheye_default = Fisheye;

// node_modules/@antv/g6-plugin/es/toolBar/index.js
init_esm();
var import_insert_css2 = __toESM(require_insert_css());
var __extends11 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var DELTA2 = 0.05;
typeof document !== "undefined" && (0, import_insert_css2.default)("\n  .g6-component-toolbar {\n    position: absolute;\n    list-style-type: none;\n    padding: 6px;\n    left: 0px;\n    top: 0px;\n    background-color: rgba(255, 255, 255, 0.9);\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    margin: 0;\n  }\n  .g6-component-toolbar li {\n    float: left;\n    text-align: center;\n    width: 35px;\n    height: 24px;\n    cursor: pointer;\n		list-style-type:none;\n    list-style: none;\n    margin-left: 0px;\n  }\n  .g6-component-toolbar li .icon {\n    opacity: 0.7;\n  }\n  .g6-component-toolbar li .icon:hover {\n    opacity: 1;\n  }\n");
var getEventPath = function getEventPath2(evt) {
  if (!evt) {
    return [];
  }
  if (evt.composedPath) {
    return evt.composedPath();
  }
  var path = [];
  var el = evt.target;
  while (el) {
    path.push(el);
    if (el.tagName === "HTML") {
      path.push(document, window);
      return path;
    }
    el = el.parentElement;
  }
  return path;
};
var ToolBar = function(_super) {
  __extends11(ToolBar3, _super);
  function ToolBar3(config) {
    return _super.call(this, config) || this;
  }
  ToolBar3.prototype.getDefaultCfgs = function() {
    return {
      handleClick: void 0,
      getContent: function getContent(graph) {
        return `
          <ul class='g6-component-toolbar'>
            <li code='redo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M256 682.666667c0-102.741333 66.730667-213.333333 213.333333-213.333334 107.008 0 190.762667 56.576 230.570667 125.354667L611.968 682.666667H853.333333v-241.365334l-91.562666 91.562667C704.768 448.469333 601.130667 384 469.333333 384c-196.096 0-298.666667 150.229333-298.666666 298.666667h85.333333z" fill="" p-id="2041"></path>
              </svg>
            </li>
            <li code='undo'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M170.666667 682.666667h241.365333l-87.936-87.978667C363.904 525.909333 447.658667 469.333333 554.666667 469.333333c146.602667 0 213.333333 110.592 213.333333 213.333334h85.333333c0-148.437333-102.570667-298.666667-298.666666-298.666667-131.797333 0-235.392 64.469333-292.48 148.821333L170.666667 441.301333V682.666667z" fill="" p-id="2764"></path>
              </svg>
            </li>
            <li  code='zoomOut'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M658.432 428.736a33.216 33.216 0 0 1-33.152 33.152H525.824v99.456a33.216 33.216 0 0 1-66.304 0V461.888H360.064a33.152 33.152 0 0 1 0-66.304H459.52V296.128a33.152 33.152 0 0 1 66.304 0V395.52H625.28c18.24 0 33.152 14.848 33.152 33.152z m299.776 521.792a43.328 43.328 0 0 1-60.864-6.912l-189.248-220.992a362.368 362.368 0 0 1-215.36 70.848 364.8 364.8 0 1 1 364.8-364.736 363.072 363.072 0 0 1-86.912 235.968l192.384 224.64a43.392 43.392 0 0 1-4.8 61.184z m-465.536-223.36a298.816 298.816 0 0 0 298.432-298.432 298.816 298.816 0 0 0-298.432-298.432A298.816 298.816 0 0 0 194.24 428.8a298.816 298.816 0 0 0 298.432 298.432z"></path>
              </svg>
            </li>
            <li code='zoomIn'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
                <path d="M639.936 416a32 32 0 0 1-32 32h-256a32 32 0 0 1 0-64h256a32 32 0 0 1 32 32z m289.28 503.552a41.792 41.792 0 0 1-58.752-6.656l-182.656-213.248A349.76 349.76 0 0 1 480 768 352 352 0 1 1 832 416a350.4 350.4 0 0 1-83.84 227.712l185.664 216.768a41.856 41.856 0 0 1-4.608 59.072zM479.936 704c158.784 0 288-129.216 288-288S638.72 128 479.936 128a288.32 288.32 0 0 0-288 288c0 158.784 129.216 288 288 288z" p-id="3853"></path>
              </svg>
            </li>
            <li code='realZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M384 320v384H320V320h64z m256 0v384H576V320h64zM512 576v64H448V576h64z m0-192v64H448V384h64z m355.968 576H92.032A28.16 28.16 0 0 1 64 931.968V28.032C64 12.608 76.608 0 95.168 0h610.368L896 192v739.968a28.16 28.16 0 0 1-28.032 28.032zM704 64v128h128l-128-128z m128 192h-190.464V64H128v832h704V256z"></path>
              </svg>
            </li>
            <li code='autoZoom'>
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" width="20" height="24">
                <path d="M684.288 305.28l0.128-0.64-0.128-0.64V99.712c0-19.84 15.552-35.904 34.496-35.712a35.072 35.072 0 0 1 34.56 35.776v171.008h170.944c19.648 0 35.84 15.488 35.712 34.432a35.072 35.072 0 0 1-35.84 34.496h-204.16l-0.64-0.128a32.768 32.768 0 0 1-20.864-7.552c-1.344-1.024-2.816-1.664-3.968-2.816-0.384-0.32-0.512-0.768-0.832-1.088a33.472 33.472 0 0 1-9.408-22.848zM305.28 64a35.072 35.072 0 0 0-34.56 35.776v171.008H99.776A35.072 35.072 0 0 0 64 305.216c0 18.944 15.872 34.496 35.84 34.496h204.16l0.64-0.128a32.896 32.896 0 0 0 20.864-7.552c1.344-1.024 2.816-1.664 3.904-2.816 0.384-0.32 0.512-0.768 0.768-1.088a33.024 33.024 0 0 0 9.536-22.848l-0.128-0.64 0.128-0.704V99.712A35.008 35.008 0 0 0 305.216 64z m618.944 620.288h-204.16l-0.64 0.128-0.512-0.128c-7.808 0-14.72 3.2-20.48 7.68-1.28 1.024-2.752 1.664-3.84 2.752-0.384 0.32-0.512 0.768-0.832 1.088a33.664 33.664 0 0 0-9.408 22.912l0.128 0.64-0.128 0.704v204.288c0 19.712 15.552 35.904 34.496 35.712a35.072 35.072 0 0 0 34.56-35.776V753.28h170.944c19.648 0 35.84-15.488 35.712-34.432a35.072 35.072 0 0 0-35.84-34.496z m-593.92 11.52c-0.256-0.32-0.384-0.768-0.768-1.088-1.088-1.088-2.56-1.728-3.84-2.688a33.088 33.088 0 0 0-20.48-7.68l-0.512 0.064-0.64-0.128H99.84a35.072 35.072 0 0 0-35.84 34.496 35.072 35.072 0 0 0 35.712 34.432H270.72v171.008c0 19.84 15.552 35.84 34.56 35.776a35.008 35.008 0 0 0 34.432-35.712V720l-0.128-0.64 0.128-0.704a33.344 33.344 0 0 0-9.472-22.848zM512 374.144a137.92 137.92 0 1 0 0.128 275.84A137.92 137.92 0 0 0 512 374.08z"></path>
              </svg>
            </li>
          </ul>
        `;
      },
      zoomSensitivity: 2
    };
  };
  ToolBar3.prototype.init = function() {
    var _this = this;
    var graph = this.get("graph");
    var getContent = this.get("getContent");
    var toolBar = getContent(graph);
    var toolBarDOM = toolBar;
    if (is_string_default(toolBar)) {
      toolBarDOM = createDom2(toolBar);
    }
    var className = this.get("className");
    toolBarDOM.setAttribute("class", className || "g6-component-toolbar");
    var container2 = this.get("container");
    if (!container2) {
      container2 = this.get("graph").get("container");
    }
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
    }
    container2.appendChild(toolBarDOM);
    this.set("toolBar", toolBarDOM);
    var handleClick = this.get("handleClick");
    toolBarDOM.addEventListener("click", function(evt) {
      var current = getEventPath(evt).filter(function(p2) {
        return p2.nodeName === "LI";
      });
      if (current.length === 0) {
        return;
      }
      var code = current[0].getAttribute("code");
      if (!code) {
        return;
      }
      if (handleClick) {
        handleClick(code, graph);
      } else {
        _this.handleDefaultOperator(code, graph);
      }
    });
    var pos = this.get("position");
    if (pos) {
      modifyCSS(toolBarDOM, {
        top: "".concat(pos.y, "px"),
        left: "".concat(pos.x, "px")
      });
    }
    this.bindUndoRedo();
  };
  ToolBar3.prototype.bindUndoRedo = function() {
    var graph = this.get("graph");
    var undoDom = document.querySelector('.g6-component-toolbar li[code="undo"]');
    var undoDomIcon = document.querySelector('.g6-component-toolbar li[code="undo"] svg');
    var redoDom = document.querySelector('.g6-component-toolbar li[code="redo"]');
    var redoDomIcon = document.querySelector('.g6-component-toolbar li[code="redo"] svg');
    if (!undoDom || !undoDomIcon || !redoDom || !redoDomIcon) {
      return;
    }
    graph.on("stackchange", function(evt) {
      var undoStack = evt.undoStack, redoStack = evt.redoStack;
      var undoStackLen = undoStack.length;
      var redoStackLen = redoStack.length;
      if (undoStackLen === 1) {
        undoDom.setAttribute("style", "cursor: not-allowed");
        undoDomIcon.setAttribute("style", "opacity: 0.4");
      } else {
        undoDom.removeAttribute("style");
        undoDomIcon.removeAttribute("style");
      }
      if (redoStackLen === 0) {
        redoDom.setAttribute("style", "cursor: not-allowed");
        redoDomIcon.setAttribute("style", "opacity: 0.4");
      } else {
        redoDom.removeAttribute("style");
        redoDomIcon.removeAttribute("style");
      }
    });
  };
  ToolBar3.prototype.undo = function() {
    var graph = this.get("graph");
    var undoStack = graph.getUndoStack();
    if (!undoStack || undoStack.length === 1) {
      return;
    }
    var currentData = undoStack.pop();
    if (currentData) {
      var action = currentData.action;
      graph.pushStack(action, clone_default(currentData.data), "redo");
      var data_1 = currentData.data.before;
      if (action === "add") {
        data_1 = currentData.data.after;
      }
      if (!data_1)
        return;
      switch (action) {
        case "visible": {
          Object.keys(data_1).forEach(function(key) {
            var array = data_1[key];
            if (!array)
              return;
            array.forEach(function(model) {
              var item = graph.findById(model.id);
              if (model.visible) {
                graph.showItem(item, false);
              } else {
                graph.hideItem(item, false);
              }
            });
          });
          break;
        }
        case "render":
        case "update":
          Object.keys(data_1).forEach(function(key) {
            var array = data_1[key];
            if (!array)
              return;
            array.forEach(function(model) {
              graph.updateItem(model.id, model, false);
            });
          });
          break;
        case "changedata":
          graph.changeData(data_1, false);
          break;
        case "delete": {
          Object.keys(data_1).forEach(function(key) {
            var array = data_1[key];
            if (!array)
              return;
            array.forEach(function(model) {
              var itemType = model.itemType;
              delete model.itemType;
              graph.addItem(itemType, model, false);
            });
          });
          break;
        }
        case "add":
          Object.keys(data_1).forEach(function(key) {
            var array = data_1[key];
            if (!array)
              return;
            array.forEach(function(model) {
              graph.removeItem(model.id, false);
            });
          });
          break;
        case "updateComboTree":
          Object.keys(data_1).forEach(function(key) {
            var array = data_1[key];
            if (!array)
              return;
            array.forEach(function(model) {
              graph.updateComboTree(model.id, model.parentId, false);
            });
          });
          break;
        default:
      }
    }
  };
  ToolBar3.prototype.redo = function() {
    var graph = this.get("graph");
    var redoStack = graph.getRedoStack();
    if (!redoStack || redoStack.length === 0) {
      return;
    }
    var currentData = redoStack.pop();
    if (currentData) {
      var action = currentData.action;
      var data_2 = currentData.data.after;
      graph.pushStack(action, clone_default(currentData.data));
      if (action === "delete") {
        data_2 = currentData.data.before;
      }
      if (!data_2)
        return;
      switch (action) {
        case "visible": {
          Object.keys(data_2).forEach(function(key) {
            var array = data_2[key];
            if (!array)
              return;
            array.forEach(function(model) {
              var item = graph.findById(model.id);
              if (model.visible) {
                graph.showItem(item, false);
              } else {
                graph.hideItem(item, false);
              }
            });
          });
          break;
        }
        case "render":
        case "update":
          Object.keys(data_2).forEach(function(key) {
            var array = data_2[key];
            if (!array)
              return;
            array.forEach(function(model) {
              graph.updateItem(model.id, model, false);
            });
          });
          break;
        case "changedata":
          graph.changeData(data_2, false);
          break;
        case "delete":
          if (data_2.edges) {
            data_2.edges.forEach(function(model) {
              graph.removeItem(model.id, false);
            });
          }
          if (data_2.nodes) {
            data_2.nodes.forEach(function(model) {
              graph.removeItem(model.id, false);
            });
          }
          if (data_2.combos) {
            data_2.combos.forEach(function(model) {
              graph.removeItem(model.id, false);
            });
          }
          break;
        case "add": {
          Object.keys(data_2).forEach(function(key) {
            var array = data_2[key];
            if (!array)
              return;
            array.forEach(function(model) {
              var itemType = model.itemType;
              delete model.itemType;
              graph.addItem(itemType, model, false);
            });
          });
          break;
        }
        case "updateComboTree":
          Object.keys(data_2).forEach(function(key) {
            var array = data_2[key];
            if (!array)
              return;
            array.forEach(function(model) {
              graph.updateComboTree(model.id, model.parentId, false);
            });
          });
          break;
        default:
      }
    }
  };
  ToolBar3.prototype.handleDefaultOperator = function(code, graph) {
    var currentZoom = graph.getZoom();
    switch (code) {
      case "redo":
        this.redo();
        break;
      case "undo":
        this.undo();
        break;
      case "zoomOut": {
        var ratioOut = 1 / (1 - DELTA2 * this.get("zoomSensitivity"));
        var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
        if (ratioOut * currentZoom > maxZoom) {
          return;
        }
        graph.zoomTo(currentZoom * ratioOut);
        break;
      }
      case "zoomIn": {
        var ratioIn = 1 - DELTA2 * this.get("zoomSensitivity");
        var minZoom = this.get("minZoom") || graph.get("minZoom");
        if (ratioIn * currentZoom < minZoom) {
          return;
        }
        graph.zoomTo(currentZoom * ratioIn);
        break;
      }
      case "realZoom":
        graph.zoomTo(1);
        break;
      case "autoZoom":
        graph.fitView([20, 20]);
        break;
      default:
    }
  };
  ToolBar3.prototype.destroy = function() {
    var toolBar = this.get("toolBar");
    if (toolBar) {
      var container2 = this.get("container");
      if (!container2) {
        container2 = this.get("graph").get("container");
      }
      if (is_string_default(container2)) {
        container2 = document.getElementById(container2);
      }
      container2.removeChild(toolBar);
    }
    var handleClick = this.get("handleClick");
    if (handleClick) {
      toolBar.removeEventListener("click", handleClick);
    }
  };
  return ToolBar3;
}(base_default4);
var toolBar_default = ToolBar;

// node_modules/@antv/g6-plugin/es/tooltip/index.js
init_esm();
var import_insert_css3 = __toESM(require_insert_css());
var __extends12 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
typeof document !== "undefined" && (0, import_insert_css3.default)("\n  .g6-component-tooltip {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n  .tooltip-type {\n    padding: 0;\n    margin: 0;\n  }\n  .tooltip-id {\n    color: #531dab;\n  }\n");
var Tooltip = function(_super) {
  __extends12(Tooltip3, _super);
  function Tooltip3(config) {
    return _super.call(this, config) || this;
  }
  Tooltip3.prototype.getDefaultCfgs = function() {
    return {
      offsetX: 6,
      offsetY: 6,
      getContent: function getContent(e8) {
        return "\n          <h4 class='tooltip-type'>\u7C7B\u578B\uFF1A".concat(e8.item.getType(), "</h4>\n          <span class='tooltip-id'>ID\uFF1A").concat(e8.item.getID(), "</span>\n        ");
      },
      shouldBegin: function shouldBegin2(e8) {
        return true;
      },
      itemTypes: ["node", "edge", "combo"],
      trigger: "mouseenter",
      fixToNode: void 0
    };
  };
  Tooltip3.prototype.getEvents = function() {
    if (this.get("trigger") === "click") {
      return {
        "node:click": "onClick",
        "edge:click": "onClick",
        "combo:click": "onClick",
        "canvas:click": "onMouseLeave",
        afterremoveitem: "onMouseLeave",
        contextmenu: "onMouseLeave",
        drag: "onMouseLeave"
      };
    }
    return {
      "node:mouseenter": "onMouseEnter",
      "node:mouseleave": "onMouseLeave",
      "node:mousemove": "onMouseMove",
      "edge:mouseenter": "onMouseEnter",
      "edge:mouseleave": "onMouseLeave",
      "edge:mousemove": "onMouseMove",
      "combo:mouseenter": "onMouseEnter",
      "combo:mouseleave": "onMouseLeave",
      "combo:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave",
      contextmenu: "onMouseLeave",
      "node:drag": "onMouseLeave"
    };
  };
  Tooltip3.prototype.init = function() {
    var self2 = this;
    var className = self2.get("className") || "g6-component-tooltip";
    var tooltip = createDom2("<div class=".concat(className, "></div>"));
    var container2 = self2.get("container");
    if (!container2) {
      container2 = self2.get("graph").get("container");
    }
    if (is_string_default(container2)) {
      container2 = document.getElementById(container2);
    }
    modifyCSS(tooltip, {
      position: "absolute",
      visibility: "hidden",
      display: "none"
    });
    container2.appendChild(tooltip);
    if (self2.get("trigger") !== "click") {
      tooltip.addEventListener("mouseenter", function(e8) {
        modifyCSS(tooltip, {
          visibility: "visible",
          display: "unset"
        });
      });
      tooltip.addEventListener("mouseleave", function(e8) {
        self2.hideTooltip();
      });
    }
    self2.set("tooltip", tooltip);
  };
  Tooltip3.prototype.onClick = function(e8) {
    var itemTypes = this.get("itemTypes");
    if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
      return;
    var item = e8.item;
    var graph = this.get("graph");
    if (this.currentTarget === item) {
      this.currentTarget = null;
      this.hideTooltip();
      graph.emit("tooltipchange", {
        item: e8.item,
        action: "hide"
      });
    } else {
      this.currentTarget = item;
      this.showTooltip(e8);
      graph.emit("tooltipchange", {
        item: e8.item,
        action: "show"
      });
    }
  };
  Tooltip3.prototype.onMouseEnter = function(e8) {
    var itemTypes = this.get("itemTypes");
    if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
      return;
    var item = e8.item;
    var graph = this.get("graph");
    this.currentTarget = item;
    this.showTooltip(e8);
    graph.emit("tooltipchange", {
      item: e8.item,
      action: "show"
    });
  };
  Tooltip3.prototype.onMouseMove = function(e8) {
    var itemTypes = this.get("itemTypes");
    if (e8.item && e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
      return;
    if (!this.currentTarget || e8.item !== this.currentTarget) {
      return;
    }
    this.showTooltip(e8);
  };
  Tooltip3.prototype.onMouseLeave = function() {
    this.hideTooltip();
    var graph = this.get("graph");
    graph.emit("tooltipchange", {
      item: this.currentTarget,
      action: "hide"
    });
    this.currentTarget = null;
  };
  Tooltip3.prototype.clearContainer = function() {
    var container2 = this.get("tooltip");
    if (container2) {
      container2.innerHTML = "";
    }
  };
  Tooltip3.prototype.showTooltip = function(e8) {
    if (!e8.item) {
      return;
    }
    var itemTypes = this.get("itemTypes");
    if (e8.item.getType && itemTypes.indexOf(e8.item.getType()) === -1)
      return;
    var container2 = this.get("tooltip");
    var getContent = this.get("getContent");
    var tooltip = getContent(e8);
    if (is_string_default(tooltip)) {
      container2.innerHTML = tooltip;
    } else {
      this.clearContainer();
      container2.appendChild(tooltip);
    }
    this.updatePosition(e8);
  };
  Tooltip3.prototype.hideTooltip = function() {
    var tooltip = this.get("tooltip");
    if (tooltip) {
      modifyCSS(tooltip, {
        visibility: "hidden",
        display: "none"
      });
    }
  };
  Tooltip3.prototype.updatePosition = function(e8) {
    var shouldBegin2 = this.get("shouldBegin");
    var tooltip = this.get("tooltip");
    if (!shouldBegin2(e8)) {
      modifyCSS(tooltip, {
        visibility: "hidden",
        display: "none"
      });
      return;
    }
    var graph = this.get("graph");
    var width = graph.get("width");
    var height = graph.get("height");
    var offsetX = this.get("offsetX") || 0;
    var offsetY = this.get("offsetY") || 0;
    var point = graph.getPointByClient(e8.clientX, e8.clientY);
    var fixToNode = this.get("fixToNode");
    var item = e8.item;
    if (item.getType && item.getType() === "node" && fixToNode && is_array_default(fixToNode) && fixToNode.length >= 2) {
      var itemBBox = item.getBBox();
      point = {
        x: itemBBox.minX + itemBBox.width * fixToNode[0],
        y: itemBBox.minY + itemBBox.height * fixToNode[1]
      };
    }
    var _a2 = graph.getCanvasByPoint(point.x, point.y), x2 = _a2.x, y2 = _a2.y;
    var graphContainer = graph.getContainer();
    var res = {
      x: x2 + graphContainer.offsetLeft + offsetX,
      y: y2 + graphContainer.offsetTop + offsetY
    };
    modifyCSS(tooltip, {
      visibility: "visible",
      display: "unset"
    });
    var bbox = tooltip.getBoundingClientRect();
    if (x2 + bbox.width + offsetX > width) {
      res.x -= bbox.width + offsetX;
    }
    if (y2 + bbox.height + offsetY > height) {
      res.y -= bbox.height + offsetY;
    }
    modifyCSS(tooltip, {
      left: "".concat(res.x, "px"),
      top: "".concat(res.y, "px")
    });
  };
  Tooltip3.prototype.hide = function() {
    this.onMouseLeave();
  };
  Tooltip3.prototype.destroy = function() {
    var tooltip = this.get("tooltip");
    if (tooltip) {
      var container2 = this.get("container");
      if (!container2) {
        container2 = this.get("graph").get("container");
      }
      if (is_string_default(container2)) {
        container2 = document.getElementById(container2);
      }
      container2.removeChild(tooltip);
    }
  };
  return Tooltip3;
}(base_default4);
var tooltip_default = Tooltip;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();

// node_modules/@antv/scale/esm/base.js
init_esm();

// node_modules/@antv/scale/esm/tick-method/register.js
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}

// node_modules/@antv/scale/esm/base.js
var Scale = function() {
  function Scale2(cfg) {
    this.type = "base";
    this.isCategory = false;
    this.isLinear = false;
    this.isContinuous = false;
    this.isIdentity = false;
    this.values = [];
    this.range = [0, 1];
    this.ticks = [];
    this.__cfg__ = cfg;
    this.initCfg();
    this.init();
  }
  Scale2.prototype.translate = function(v2) {
    return v2;
  };
  Scale2.prototype.change = function(cfg) {
    mix(this.__cfg__, cfg);
    this.init();
  };
  Scale2.prototype.clone = function() {
    return this.constructor(this.__cfg__);
  };
  Scale2.prototype.getTicks = function() {
    var _this = this;
    return map_default(this.ticks, function(tick, idx) {
      if (is_object_default(tick)) {
        return tick;
      }
      return {
        text: _this.getText(tick, idx),
        tickValue: tick,
        value: _this.scale(tick)
      };
    });
  };
  Scale2.prototype.getText = function(value, key) {
    var formatter = this.formatter;
    var res = formatter ? formatter(value, key) : value;
    if (is_nil_default(res) || !is_function_default(res.toString)) {
      return "";
    }
    return res.toString();
  };
  Scale2.prototype.getConfig = function(key) {
    return this.__cfg__[key];
  };
  Scale2.prototype.init = function() {
    mix(this, this.__cfg__);
    this.setDomain();
    if (is_empty_default(this.getConfig("ticks"))) {
      this.ticks = this.calculateTicks();
    }
  };
  Scale2.prototype.initCfg = function() {
  };
  Scale2.prototype.setDomain = function() {
  };
  Scale2.prototype.calculateTicks = function() {
    var tickMethod = this.tickMethod;
    var ticks = [];
    if (is_string_default(tickMethod)) {
      var method = getTickMethod(tickMethod);
      if (!method) {
        throw new Error("There is no method to to calculate ticks!");
      }
      ticks = method(this);
    } else if (is_function_default(tickMethod)) {
      ticks = tickMethod(this);
    }
    return ticks;
  };
  Scale2.prototype.rangeMin = function() {
    return this.range[0];
  };
  Scale2.prototype.rangeMax = function() {
    return this.range[1];
  };
  Scale2.prototype.calcPercent = function(value, min6, max7) {
    if (is_number_default(value)) {
      return (value - min6) / (max7 - min6);
    }
    return NaN;
  };
  Scale2.prototype.calcValue = function(percent, min6, max7) {
    return min6 + percent * (max7 - min6);
  };
  return Scale2;
}();
var base_default5 = Scale;

// node_modules/@antv/scale/node_modules/tslib/tslib.es6.js
var extendStatics6 = function(d2, b10) {
  extendStatics6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b11) {
    d3.__proto__ = b11;
  } || function(d3, b11) {
    for (var p2 in b11)
      if (Object.prototype.hasOwnProperty.call(b11, p2))
        d3[p2] = b11[p2];
  };
  return extendStatics6(d2, b10);
};
function __extends13(d2, b10) {
  if (typeof b10 !== "function" && b10 !== null)
    throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
  extendStatics6(d2, b10);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
}
function __spreadArrays2() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}

// node_modules/@antv/scale/esm/category/base.js
init_esm();
var Category = function(_super) {
  __extends13(Category2, _super);
  function Category2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "cat";
    _this.isCategory = true;
    return _this;
  }
  Category2.prototype.buildIndexMap = function() {
    if (!this.translateIndexMap) {
      this.translateIndexMap = /* @__PURE__ */ new Map();
      for (var i2 = 0; i2 < this.values.length; i2++) {
        this.translateIndexMap.set(this.values[i2], i2);
      }
    }
  };
  Category2.prototype.translate = function(value) {
    this.buildIndexMap();
    var idx = this.translateIndexMap.get(value);
    if (idx === void 0) {
      idx = is_number_default(value) ? value : NaN;
    }
    return idx;
  };
  Category2.prototype.scale = function(value) {
    var order = this.translate(value);
    var percent = this.calcPercent(order, this.min, this.max);
    return this.calcValue(percent, this.rangeMin(), this.rangeMax());
  };
  Category2.prototype.invert = function(scaledValue) {
    var domainRange = this.max - this.min;
    var percent = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
    var idx = Math.round(domainRange * percent) + this.min;
    if (idx < this.min || idx > this.max) {
      return NaN;
    }
    return this.values[idx];
  };
  Category2.prototype.getText = function(value) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    var v2 = value;
    if (is_number_default(value) && !this.values.includes(value)) {
      v2 = this.values[v2];
    }
    return _super.prototype.getText.apply(this, __spreadArrays2([v2], args));
  };
  Category2.prototype.initCfg = function() {
    this.tickMethod = "cat";
  };
  Category2.prototype.setDomain = function() {
    if (is_nil_default(this.getConfig("min"))) {
      this.min = 0;
    }
    if (is_nil_default(this.getConfig("max"))) {
      var size2 = this.values.length;
      this.max = size2 > 1 ? size2 - 1 : size2;
    }
    if (this.translateIndexMap) {
      this.translateIndexMap = void 0;
    }
  };
  return Category2;
}(base_default5);
var base_default6 = Category;

// node_modules/@antv/scale/esm/category/time.js
init_esm();

// node_modules/@antv/scale/esm/util/time.js
init_esm();

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "[1-9]\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i2 = 0, len5 = arr.length; i2 < len5; i2++) {
    newArr.push(arr[i2].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v2, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v3) {
      return v3.toLowerCase();
    });
    var index = lowerCaseArr.indexOf(v2.toLowerCase());
    if (index > -1) {
      return index;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str7) {
  return str7.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len5) {
  if (len5 === void 0) {
    len5 = 2;
  }
  val = String(val);
  while (val.length < len5) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v2) {
  return +v2 - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v2, i18n) {
    var val = v2.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v2) {
    var parts = (v2 + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v2) {
    return parseInt(v2, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v2) {
      var now2 = new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v2 > 68 ? cent - 1 : cent) + v2);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v2) {
    return +v2 * 100;
  }],
  SS: ["millisecond", twoDigits, function(v2) {
    return +v2 * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i2 = 1; i2 < matches.length; i2++) {
    var _a2 = parseInfo[i2 - 1], field = _a2[0], parser = _a2[2];
    var value = parser ? parser(matches[i2], combinedI18nSettings) : +matches[i2];
    if (value == null) {
      return null;
    }
    dateInfo[field] = value;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateWithoutTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
  var validateFields = [
    ["month", "getMonth"],
    ["day", "getDate"],
    ["hour", "getHours"],
    ["minute", "getMinutes"],
    ["second", "getSeconds"]
  ];
  for (var i2 = 0, len5 = validateFields.length; i2 < len5; i2++) {
    if (specifiedFields[validateFields[i2][0]] && dateInfo[validateFields[i2][0]] !== dateWithoutTZ[validateFields[i2][1]]()) {
      return null;
    }
  }
  if (dateInfo.timezoneOffset == null) {
    return dateWithoutTZ;
  }
  return new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
var fecha_default = fecha;

// node_modules/@antv/scale/esm/util/bisector.js
init_esm();
function bisector_default(getter) {
  return function(a2, x2, _lo, _hi) {
    var lo2 = is_nil_default(_lo) ? 0 : _lo;
    var hi2 = is_nil_default(_hi) ? a2.length : _hi;
    while (lo2 < hi2) {
      var mid = lo2 + hi2 >>> 1;
      if (getter(a2[mid]) > x2) {
        hi2 = mid;
      } else {
        lo2 = mid + 1;
      }
    }
    return lo2;
  };
}

// node_modules/@antv/scale/esm/util/time.js
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha_exports[FORMAT_METHOD] || fecha_default[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value) {
  if (is_string_default(value)) {
    if (value.indexOf("T") > 0) {
      value = new Date(value).getTime();
    } else {
      value = new Date(value.replace(/-/gi, "/")).getTime();
    }
  }
  if (is_date_default(value)) {
    value = value.getTime();
  }
  return value;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min6, max7, tickCount) {
  var target = (max7 - min6) / tickCount;
  var idx = bisector_default(function(o2) {
    return o2[1];
  })(intervals, target) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}

// node_modules/@antv/scale/esm/category/time.js
var TimeCat = function(_super) {
  __extends13(TimeCat2, _super);
  function TimeCat2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "timeCat";
    return _this;
  }
  TimeCat2.prototype.translate = function(value) {
    value = toTimeStamp(value);
    var index = this.values.indexOf(value);
    if (index === -1) {
      if (is_number_default(value) && value < this.values.length) {
        index = value;
      } else {
        index = NaN;
      }
    }
    return index;
  };
  TimeCat2.prototype.getText = function(value, tickIndex) {
    var index = this.translate(value);
    if (index > -1) {
      var result = this.values[index];
      var formatter = this.formatter;
      result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
      return result;
    }
    return value;
  };
  TimeCat2.prototype.initCfg = function() {
    this.tickMethod = "time-cat";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
  };
  TimeCat2.prototype.setDomain = function() {
    var values2 = this.values;
    each_default(values2, function(v2, i2) {
      values2[i2] = toTimeStamp(v2);
    });
    values2.sort(function(v1, v2) {
      return v1 - v2;
    });
    _super.prototype.setDomain.call(this);
  };
  return TimeCat2;
}(base_default6);
var time_default = TimeCat;

// node_modules/@antv/scale/esm/continuous/base.js
init_esm();
var Continuous = function(_super) {
  __extends13(Continuous2, _super);
  function Continuous2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.isContinuous = true;
    return _this;
  }
  Continuous2.prototype.scale = function(value) {
    if (is_nil_default(value)) {
      return NaN;
    }
    var rangeMin = this.rangeMin();
    var rangeMax = this.rangeMax();
    var max7 = this.max;
    var min6 = this.min;
    if (max7 === min6) {
      return rangeMin;
    }
    var percent = this.getScalePercent(value);
    return rangeMin + percent * (rangeMax - rangeMin);
  };
  Continuous2.prototype.init = function() {
    _super.prototype.init.call(this);
    var ticks = this.ticks;
    var firstTick = head(ticks);
    var lastTick = last(ticks);
    if (firstTick < this.min) {
      this.min = firstTick;
    }
    if (lastTick > this.max) {
      this.max = lastTick;
    }
    if (!is_nil_default(this.minLimit)) {
      this.min = firstTick;
    }
    if (!is_nil_default(this.maxLimit)) {
      this.max = lastTick;
    }
  };
  Continuous2.prototype.setDomain = function() {
    var _a2 = get_range_default(this.values), min6 = _a2.min, max7 = _a2.max;
    if (is_nil_default(this.min)) {
      this.min = min6;
    }
    if (is_nil_default(this.max)) {
      this.max = max7;
    }
    if (this.min > this.max) {
      this.min = min6;
      this.max = max7;
    }
  };
  Continuous2.prototype.calculateTicks = function() {
    var _this = this;
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      ticks = filter_default(ticks, function(tick) {
        return tick >= _this.min && tick <= _this.max;
      });
    }
    return ticks;
  };
  Continuous2.prototype.getScalePercent = function(value) {
    var max7 = this.max;
    var min6 = this.min;
    return (value - min6) / (max7 - min6);
  };
  Continuous2.prototype.getInvertPercent = function(value) {
    return (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
  };
  return Continuous2;
}(base_default5);
var base_default7 = Continuous;

// node_modules/@antv/scale/esm/continuous/linear.js
var Linear = function(_super) {
  __extends13(Linear2, _super);
  function Linear2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "linear";
    _this.isLinear = true;
    return _this;
  }
  Linear2.prototype.invert = function(value) {
    var percent = this.getInvertPercent(value);
    return this.min + percent * (this.max - this.min);
  };
  Linear2.prototype.initCfg = function() {
    this.tickMethod = "wilkinson-extended";
    this.nice = false;
  };
  return Linear2;
}(base_default7);
var linear_default = Linear;

// node_modules/@antv/scale/esm/util/math.js
init_esm();
function calBase(a2, b10) {
  var e8 = Math.E;
  var value;
  if (b10 >= 0) {
    value = Math.pow(e8, Math.log(b10) / a2);
  } else {
    value = Math.pow(e8, Math.log(-b10) / a2) * -1;
  }
  return value;
}
function log(a2, b10) {
  if (a2 === 1) {
    return 1;
  }
  return Math.log(b10) / Math.log(a2);
}
function getLogPositiveMin(values2, base, max7) {
  if (is_nil_default(max7)) {
    max7 = Math.max.apply(null, values2);
  }
  var positiveMin = max7;
  each_default(values2, function(value) {
    if (value > 0 && value < positiveMin) {
      positiveMin = value;
    }
  });
  if (positiveMin === max7) {
    positiveMin = max7 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}

// node_modules/@antv/scale/esm/continuous/log.js
var Log = function(_super) {
  __extends13(Log2, _super);
  function Log2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "log";
    return _this;
  }
  Log2.prototype.invert = function(value) {
    var base = this.base;
    var max7 = log(base, this.max);
    var rangeMin = this.rangeMin();
    var range = this.rangeMax() - rangeMin;
    var min6;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      if (value === 0) {
        return 0;
      }
      min6 = log(base, positiveMin / base);
      var appendPercent = 1 / (max7 - min6) * range;
      if (value < appendPercent) {
        return value / appendPercent * positiveMin;
      }
    } else {
      min6 = log(base, this.min);
    }
    var percent = (value - rangeMin) / range;
    var tmp = percent * (max7 - min6) + min6;
    return Math.pow(base, tmp);
  };
  Log2.prototype.initCfg = function() {
    this.tickMethod = "log";
    this.base = 10;
    this.tickCount = 6;
    this.nice = true;
  };
  Log2.prototype.setDomain = function() {
    _super.prototype.setDomain.call(this);
    var min6 = this.min;
    if (min6 < 0) {
      throw new Error("When you use log scale, the minimum value must be greater than zero!");
    }
    if (min6 === 0) {
      this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
    }
  };
  Log2.prototype.getScalePercent = function(value) {
    var max7 = this.max;
    var min6 = this.min;
    if (max7 === min6) {
      return 0;
    }
    if (value <= 0) {
      return 0;
    }
    var base = this.base;
    var positiveMin = this.positiveMin;
    if (positiveMin) {
      min6 = positiveMin * 1 / base;
    }
    var percent;
    if (value < positiveMin) {
      percent = value / positiveMin / (log(base, max7) - log(base, min6));
    } else {
      percent = (log(base, value) - log(base, min6)) / (log(base, max7) - log(base, min6));
    }
    return percent;
  };
  return Log2;
}(base_default7);
var log_default = Log;

// node_modules/@antv/scale/esm/continuous/pow.js
var Pow = function(_super) {
  __extends13(Pow2, _super);
  function Pow2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "pow";
    return _this;
  }
  Pow2.prototype.invert = function(value) {
    var percent = this.getInvertPercent(value);
    var exponent2 = this.exponent;
    var max7 = calBase(exponent2, this.max);
    var min6 = calBase(exponent2, this.min);
    var tmp = percent * (max7 - min6) + min6;
    var factor = tmp >= 0 ? 1 : -1;
    return Math.pow(tmp, exponent2) * factor;
  };
  Pow2.prototype.initCfg = function() {
    this.tickMethod = "pow";
    this.exponent = 2;
    this.tickCount = 5;
    this.nice = true;
  };
  Pow2.prototype.getScalePercent = function(value) {
    var max7 = this.max;
    var min6 = this.min;
    if (max7 === min6) {
      return 0;
    }
    var exponent2 = this.exponent;
    var percent = (calBase(exponent2, value) - calBase(exponent2, min6)) / (calBase(exponent2, max7) - calBase(exponent2, min6));
    return percent;
  };
  return Pow2;
}(base_default7);
var pow_default = Pow;

// node_modules/@antv/scale/esm/continuous/time.js
init_esm();
var Time = function(_super) {
  __extends13(Time2, _super);
  function Time2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "time";
    return _this;
  }
  Time2.prototype.getText = function(value, index) {
    var numberValue = this.translate(value);
    var formatter = this.formatter;
    return formatter ? formatter(numberValue, index) : timeFormat(numberValue, this.mask);
  };
  Time2.prototype.scale = function(value) {
    var v2 = value;
    if (is_string_default(v2) || is_date_default(v2)) {
      v2 = this.translate(v2);
    }
    return _super.prototype.scale.call(this, v2);
  };
  Time2.prototype.translate = function(v2) {
    return toTimeStamp(v2);
  };
  Time2.prototype.initCfg = function() {
    this.tickMethod = "time-pretty";
    this.mask = "YYYY-MM-DD";
    this.tickCount = 7;
    this.nice = false;
  };
  Time2.prototype.setDomain = function() {
    var values2 = this.values;
    var minConfig = this.getConfig("min");
    var maxConfig = this.getConfig("max");
    if (!is_nil_default(minConfig) || !is_number_default(minConfig)) {
      this.min = this.translate(this.min);
    }
    if (!is_nil_default(maxConfig) || !is_number_default(maxConfig)) {
      this.max = this.translate(this.max);
    }
    if (values2 && values2.length) {
      var timeStamps_1 = [];
      var min_1 = Infinity;
      var secondMin_1 = min_1;
      var max_1 = 0;
      each_default(values2, function(v2) {
        var timeStamp = toTimeStamp(v2);
        if (isNaN(timeStamp)) {
          throw new TypeError("Invalid Time: " + v2 + " in time scale!");
        }
        if (min_1 > timeStamp) {
          secondMin_1 = min_1;
          min_1 = timeStamp;
        } else if (secondMin_1 > timeStamp) {
          secondMin_1 = timeStamp;
        }
        if (max_1 < timeStamp) {
          max_1 = timeStamp;
        }
        timeStamps_1.push(timeStamp);
      });
      if (values2.length > 1) {
        this.minTickInterval = secondMin_1 - min_1;
      }
      if (is_nil_default(minConfig)) {
        this.min = min_1;
      }
      if (is_nil_default(maxConfig)) {
        this.max = max_1;
      }
    }
  };
  return Time2;
}(linear_default);
var time_default2 = Time;

// node_modules/@antv/scale/esm/continuous/quantize.js
init_esm();
var Quantize = function(_super) {
  __extends13(Quantize2, _super);
  function Quantize2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantize";
    return _this;
  }
  Quantize2.prototype.invert = function(value) {
    var ticks = this.ticks;
    var length5 = ticks.length;
    var percent = this.getInvertPercent(value);
    var minIndex = Math.floor(percent * (length5 - 1));
    if (minIndex >= length5 - 1) {
      return last(ticks);
    }
    if (minIndex < 0) {
      return head(ticks);
    }
    var minTick = ticks[minIndex];
    var nextTick = ticks[minIndex + 1];
    var minIndexPercent = minIndex / (length5 - 1);
    var maxIndexPercent = (minIndex + 1) / (length5 - 1);
    return minTick + (percent - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick - minTick);
  };
  Quantize2.prototype.initCfg = function() {
    this.tickMethod = "r-pretty";
    this.tickCount = 5;
    this.nice = true;
  };
  Quantize2.prototype.calculateTicks = function() {
    var ticks = _super.prototype.calculateTicks.call(this);
    if (!this.nice) {
      if (last(ticks) !== this.max) {
        ticks.push(this.max);
      }
      if (head(ticks) !== this.min) {
        ticks.unshift(this.min);
      }
    }
    return ticks;
  };
  Quantize2.prototype.getScalePercent = function(value) {
    var ticks = this.ticks;
    if (value < head(ticks)) {
      return 0;
    }
    if (value > last(ticks)) {
      return 1;
    }
    var minIndex = 0;
    each_default(ticks, function(tick, index) {
      if (value >= tick) {
        minIndex = index;
      } else {
        return false;
      }
    });
    return minIndex / (ticks.length - 1);
  };
  return Quantize2;
}(base_default7);
var quantize_default2 = Quantize;

// node_modules/@antv/scale/esm/continuous/quantile.js
var Quantile = function(_super) {
  __extends13(Quantile2, _super);
  function Quantile2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "quantile";
    return _this;
  }
  Quantile2.prototype.initCfg = function() {
    this.tickMethod = "quantile";
    this.tickCount = 5;
    this.nice = true;
  };
  return Quantile2;
}(quantize_default2);
var quantile_default = Quantile;

// node_modules/@antv/scale/esm/factory.js
var map3 = {};
function getClass(key) {
  return map3[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map3[key] = cls;
}

// node_modules/@antv/scale/esm/identity/index.js
init_esm();
var Identity = function(_super) {
  __extends13(Identity2, _super);
  function Identity2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "identity";
    _this.isIdentity = true;
    return _this;
  }
  Identity2.prototype.calculateTicks = function() {
    return this.values;
  };
  Identity2.prototype.scale = function(value) {
    if (this.values[0] !== value && is_number_default(value)) {
      return value;
    }
    return this.range[0];
  };
  Identity2.prototype.invert = function(value) {
    var range = this.range;
    if (value < range[0] || value > range[1]) {
      return NaN;
    }
    return this.values[0];
  };
  return Identity2;
}(base_default5);
var identity_default2 = Identity;

// node_modules/@antv/scale/esm/tick-method/cat.js
init_esm();

// node_modules/@antv/scale/esm/util/extended.js
init_esm();

// node_modules/@antv/scale/esm/util/pretty-number.js
function prettyNumber(n2) {
  return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(15));
}

// node_modules/@antv/scale/esm/util/extended.js
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod2(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function round4(n2) {
  return Math.round(n2 * 1e12) / 1e12;
}
function simplicity(q2, Q2, j2, lmin, lmax, lstep) {
  var n2 = size(Q2);
  var i2 = index_of_default(Q2, q2);
  var v2 = 0;
  var m2 = mod2(lmin, lstep);
  if ((m2 < eps || lstep - m2 < eps) && lmin <= 0 && lmax >= 0) {
    v2 = 1;
  }
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function simplicityMax(q2, Q2, j2) {
  var n2 = size(Q2);
  var i2 = index_of_default(Q2, q2);
  var v2 = 1;
  return 1 - i2 / (n2 - 1) - j2 + v2;
}
function density(k2, m2, dMin, dMax, lMin, lMax) {
  var r2 = (k2 - 1) / (lMax - lMin);
  var rt2 = (m2 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r2 / rt2, rt2 / r2);
}
function densityMax(k2, m2) {
  if (k2 >= m2) {
    return 2 - (k2 - 1) / (m2 - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n2, onlyLoose, Q2, w2) {
  if (n2 === void 0) {
    n2 = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q2 === void 0) {
    Q2 = DEFAULT_Q;
  }
  if (w2 === void 0) {
    w2 = [0.25, 0.2, 0.5, 0.05];
  }
  var m2 = n2 < 0 ? 0 : Math.round(n2);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m2) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m2 === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j2 = 1;
  while (j2 < Infinity) {
    for (var i2 = 0; i2 < Q2.length; i2 += 1) {
      var q2 = Q2[i2];
      var sm = simplicityMax(q2, Q2, j2);
      if (w2[0] * sm + w2[1] + w2[2] + w2[3] < best.score) {
        j2 = Infinity;
        break;
      }
      var k2 = 2;
      while (k2 < Infinity) {
        var dm = densityMax(k2, m2);
        if (w2[0] * sm + w2[1] + w2[2] * dm + w2[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k2 + 1) / j2 / q2;
        var z2 = Math.ceil(Math.log10(delta));
        while (z2 < Infinity) {
          var step = j2 * q2 * Math.pow(10, z2);
          var cm = coverageMax(dMin, dMax, step * (k2 - 1));
          if (w2[0] * sm + w2[1] * cm + w2[2] * dm + w2[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j2 - (k2 - 1) * j2;
          var maxStart = Math.ceil(dMin / step) * j2;
          if (minStart <= maxStart) {
            var count = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j2);
              var lMax = lMin + step * (k2 - 1);
              var lStep = step;
              var s2 = simplicity(q2, Q2, j2, lMin, lMax, lStep);
              var c2 = coverage(dMin, dMax, lMin, lMax);
              var g2 = density(k2, m2, dMin, dMax, lMin, lMax);
              var l2 = legibility();
              var score = w2[0] * s2 + w2[1] * c2 + w2[2] * g2 + w2[3] * l2;
              if (score > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score;
              }
            }
          }
          z2 += 1;
        }
        k2 += 1;
      }
    }
    j2 += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round4((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i2 = 1; i2 < tickCount; i2++) {
    ticks[i2] = prettyNumber(ticks[i2 - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/cat.js
function calculateCatTicks(cfg) {
  var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount;
  var ticks = values2;
  if (is_number_default(tickInterval)) {
    return filter_default(ticks, function(__, i2) {
      return i2 % tickInterval === 0;
    });
  }
  var min6 = cfg.min, max7 = cfg.max;
  if (is_nil_default(min6)) {
    min6 = 0;
  }
  if (is_nil_default(max7)) {
    max7 = values2.length - 1;
  }
  if (is_number_default(tickCount) && tickCount < max7 - min6) {
    var ticks_1 = extended(min6, max7, tickCount, false, [1, 2, 5, 3, 4, 7, 6, 8, 9]).ticks;
    var valid = filter_default(ticks_1, function(tick) {
      return tick >= min6 && tick <= max7;
    });
    return valid.map(function(index) {
      return values2[index];
    });
  }
  return values2.slice(min6, max7 + 1);
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
init_esm();

// node_modules/@antv/scale/esm/util/d3-linear.js
function d3Linear(cfg) {
  var min6 = cfg.min, max7 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear4 = new D3Linear();
  linear4.domain([min6, max7]);
  if (nice) {
    linear4.nice(tickCount);
  }
  return linear4.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
var D3Linear = function() {
  function D3Linear2() {
    this._domain = [0, 1];
  }
  D3Linear2.prototype.domain = function(domain) {
    if (domain) {
      this._domain = Array.from(domain, Number);
      return this;
    }
    return this._domain.slice();
  };
  D3Linear2.prototype.nice = function(count) {
    var _a2, _b;
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    var d2 = this._domain.slice();
    var i0 = 0;
    var i1 = this._domain.length - 1;
    var start = this._domain[i0];
    var stop = this._domain[i1];
    var step;
    if (stop < start) {
      _a2 = [stop, start], start = _a2[0], stop = _a2[1];
      _b = [i1, i0], i0 = _b[0], i1 = _b[1];
    }
    step = tickIncrement(start, stop, count);
    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = tickIncrement(start, stop, count);
    }
    if (step > 0) {
      d2[i0] = Math.floor(start / step) * step;
      d2[i1] = Math.ceil(stop / step) * step;
      this.domain(d2);
    } else if (step < 0) {
      d2[i0] = Math.ceil(start * step) / step;
      d2[i1] = Math.floor(stop * step) / step;
      this.domain(d2);
    }
    return this;
  };
  D3Linear2.prototype.ticks = function(count) {
    if (count === void 0) {
      count = DEFAULT_COUNT;
    }
    return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count || DEFAULT_COUNT);
  };
  return D3Linear2;
}();
function d3ArrayTicks(start, stop, count) {
  var reverse;
  var i2 = -1;
  var n2;
  var ticks;
  var step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n2 = start, start = stop, stop = n2;
  }
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n2 = Math.ceil(stop - start + 1));
    while (++i2 < n2) {
      ticks[i2] = (start + i2) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n2 = Math.ceil(start - stop + 1));
    while (++i2 < n2) {
      ticks[i2] = (start - i2) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count);
  var power = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1);
}

// node_modules/@antv/scale/esm/util/interval.js
init_esm();
function snapMultiple(v2, base, snapType) {
  var div4;
  if (snapType === "ceil") {
    div4 = Math.ceil(v2 / base);
  } else if (snapType === "floor") {
    div4 = Math.floor(v2 / base);
  } else {
    div4 = Math.round(v2 / base);
  }
  return div4 * base;
}
function intervalTicks(min6, max7, interval2) {
  var minTick = snapMultiple(min6, interval2, "floor");
  var maxTick = snapMultiple(max7, interval2, "ceil");
  minTick = fixed_base_default(minTick, interval2);
  maxTick = fixed_base_default(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i2 = minTick; i2 <= maxTick; i2 = i2 + availableInterval) {
    var tickValue = fixed_base_default(i2, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}

// node_modules/@antv/scale/esm/util/strict-limit.js
init_esm();
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a2;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min6 = cfg.min, max7 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = is_nil_default(minLimit) ? is_nil_default(defaultMin) ? min6 : defaultMin : minLimit;
  var tickMax = is_nil_default(maxLimit) ? is_nil_default(defaultMax) ? max7 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a2 = [tickMin, tickMax], tickMax = _a2[0], tickMin = _a2[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    ticks.push(tickMin + step * i2);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/d3-linear.js
function d3LinearTickMethod(cfg) {
  var min6 = cfg.min, max7 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max7, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/linear.js
init_esm();
function linear3(cfg) {
  var min6 = cfg.min, max7 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min6, max7, tickCount, nice).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max7, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/log.js
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min6 = cfg.min, max7 = cfg.max, values2 = cfg.values;
  var minTick;
  var maxTick = log(base, max7);
  if (min6 > 0) {
    minTick = Math.floor(log(base, min6));
  } else {
    var positiveMin = getLogPositiveMin(values2, base, max7);
    minTick = Math.floor(log(base, positiveMin));
  }
  var count = maxTick - minTick;
  var avg = Math.ceil(count / tickCount);
  var ticks = [];
  for (var i2 = minTick; i2 < maxTick + avg; i2 = i2 + avg) {
    ticks.push(Math.pow(base, i2));
  }
  if (min6 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/util/pretty.js
function pretty(min6, max7, m2) {
  if (m2 === void 0) {
    m2 = 5;
  }
  if (min6 === max7) {
    return {
      max: max7,
      min: min6,
      ticks: [min6]
    };
  }
  var n2 = m2 < 0 ? 0 : Math.round(m2);
  if (n2 === 0)
    return { max: max7, min: min6, ticks: [] };
  var h2 = 1.5;
  var h5 = 0.5 + 1.5 * h2;
  var d2 = max7 - min6;
  var c2 = d2 / n2;
  var base = Math.pow(10, Math.floor(Math.log10(c2)));
  var unit = base;
  if (2 * base - c2 < h2 * (c2 - unit)) {
    unit = 2 * base;
    if (5 * base - c2 < h5 * (c2 - unit)) {
      unit = 5 * base;
      if (10 * base - c2 < h2 * (c2 - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu2 = Math.ceil(max7 / unit);
  var ns = Math.floor(min6 / unit);
  var hi2 = Math.max(nu2 * unit, max7);
  var lo2 = Math.min(ns * unit, min6);
  var size2 = Math.floor((hi2 - lo2) / unit) + 1;
  var ticks = new Array(size2);
  for (var i2 = 0; i2 < size2; i2++) {
    ticks[i2] = prettyNumber(lo2 + i2 * unit);
  }
  return {
    min: lo2,
    max: hi2,
    ticks
  };
}

// node_modules/@antv/scale/esm/tick-method/pow.js
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max7 = Math.ceil(calBase(exponent2, cfg.max));
  var min6 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min6, max7, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}

// node_modules/@antv/scale/esm/tick-method/quantile.js
function quantileSorted(x2, p2) {
  var idx = x2.length * p2;
  if (p2 === 1) {
    return x2[x2.length - 1];
  } else if (p2 === 0) {
    return x2[0];
  } else if (idx % 1 !== 0) {
    return x2[Math.ceil(idx) - 1];
  } else if (x2.length % 2 === 0) {
    return (x2[idx - 1] + x2[idx]) / 2;
  } else {
    return x2[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values2 = cfg.values;
  if (!values2 || !values2.length) {
    return [];
  }
  var sorted = values2.slice().sort(function(a2, b10) {
    return a2 - b10;
  });
  var ticks = [];
  for (var i2 = 0; i2 < tickCount; i2++) {
    var p2 = i2 / (tickCount - 1);
    ticks.push(quantileSorted(sorted, p2));
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/r-prettry.js
init_esm();
function linearPretty(cfg) {
  var min6 = cfg.min, max7 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min6, max7, tickCount).ticks;
  if (!is_nil_default(minLimit) || !is_nil_default(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min6, max7, tickInterval).ticks;
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time.js
function calculateTimeTicks(cfg) {
  var min6 = cfg.min, max7 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max7 - min6) / tickInterval);
  } else {
    tickInterval = getTickInterval(min6, max7, tickCount)[1];
    var count = (max7 - min6) / tickInterval;
    var ratio = count / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max7 - min6) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i2 = min6; i2 < max7 + tickInterval; i2 += tickInterval) {
    ticks.push(i2);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-cat.js
init_esm();
function calculateTimeCatTicks(cfg) {
  var ticks = calculateCatTicks(cfg);
  var lastValue = last(cfg.values);
  if (lastValue !== last(ticks)) {
    ticks.push(lastValue);
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/time-pretty.js
function getYear(date) {
  return new Date(date).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date) {
  return new Date(date).getMonth();
}
function diffMonth(min6, max7) {
  var minYear = getYear(min6);
  var maxYear = getYear(max7);
  var minMonth = getMonth(min6);
  var maxMonth = getMonth(max7);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min6, max7) {
  return Math.ceil((max7 - min6) / DAY);
}
function diffHour(min6, max7) {
  return Math.ceil((max7 - min6) / HOUR);
}
function diffMinus(min6, max7) {
  return Math.ceil((max7 - min6) / (60 * 1e3));
}
function timePretty(cfg) {
  var min6 = cfg.min, max7 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max7 - min6) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max7 - min6) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min6);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max7);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i2 = minYear; i2 <= maxYear + yearInterval; i2 = i2 + yearInterval) {
      ticks.push(createYear(i2));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min6);
    var dMonths = diffMonth(min6, max7);
    for (var i2 = 0; i2 <= dMonths + monthInterval; i2 = i2 + monthInterval) {
      ticks.push(creatMonth(minYear, i2 + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date = new Date(min6);
    var year = date.getFullYear();
    var month = date.getMonth();
    var mday = date.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min6, max7);
    for (var i2 = 0; i2 < ddays + day; i2 = i2 + day) {
      ticks.push(new Date(year, month, mday + i2).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date = new Date(min6);
    var year = date.getFullYear();
    var month = date.getMonth();
    var day = date.getDate();
    var hour = date.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min6, max7);
    for (var i2 = 0; i2 <= dHours + hours; i2 = i2 + hours) {
      ticks.push(new Date(year, month, day, hour + i2).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min6, max7);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i2 = 0; i2 <= dMinus + minutes; i2 = i2 + minutes) {
      ticks.push(min6 + i2 * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min6 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max7 - min6) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i2 = 0; i2 < dSeconds + seconds; i2 = i2 + seconds) {
      ticks.push(minSecond + i2 * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}

// node_modules/@antv/scale/esm/tick-method/index.js
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", calculateTimeCatTicks);
registerTickMethod("wilkinson-extended", linear3);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);

// node_modules/@antv/scale/esm/index.js
registerClass("cat", base_default6);
registerClass("category", base_default6);
registerClass("identity", identity_default2);
registerClass("linear", linear_default);
registerClass("log", log_default);
registerClass("pow", pow_default);
registerClass("time", time_default2);
registerClass("timeCat", time_default);
registerClass("quantize", quantize_default2);
registerClass("quantile", quantile_default);

// node_modules/@antv/g6-plugin/es/timeBar/path.js
init_esm();
var __spreadArray7 = function(to2, from, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
      if (ar2 || !(i2 in from)) {
        if (!ar2)
          ar2 = Array.prototype.slice.call(from, 0, i2);
        ar2[i2] = from[i2];
      }
    }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
};
function pointsToPath(points) {
  return map_default(points, function(p2, idx) {
    var command = idx === 0 ? "M" : "L";
    var x2 = p2[0], y2 = p2[1];
    return [command, x2, y2];
  });
}
function getLinePath(points) {
  return pointsToPath(points);
}
function getSmoothLinePath(points) {
  if (points.length <= 2) {
    return getLinePath(points);
  }
  var data = [];
  each_default(points, function(p2) {
    if (!is_equal_default(p2, data.slice(data.length - 2))) {
      data.push(p2[0], p2[1]);
    }
  });
  var path = catmull_rom_2_bezier_default(data, false);
  var _a2 = head(points), x2 = _a2[0], y2 = _a2[1];
  path.unshift(["M", x2, y2]);
  return path;
}
function dataToPath(data, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y2 = new linear_default({
    values: data
  });
  var x2 = new base_default6({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x2.scale(idx) * width, height - y2.scale(v2) * height];
  });
  return smooth ? getSmoothLinePath(points) : getLinePath(points);
}
function dataToRectPath(data, width, height, barWidth) {
  if (barWidth === void 0) {
    barWidth = 5;
  }
  var y2 = new linear_default({
    values: data
  });
  var x2 = new base_default6({
    values: map_default(data, function(v2, idx) {
      return idx;
    })
  });
  var points = map_default(data, function(v2, idx) {
    return [x2.scale(idx) * width, height - y2.scale(v2) * height];
  });
  var rectPoints = [];
  for (var i2 = 0; i2 < points.length; i2++) {
    var point = points[i2];
    var param = {
      x: point[0],
      y: point[1],
      y0: height,
      size: barWidth
    };
    var rectPoint = getRectPoints(param);
    rectPoints.push.apply(rectPoints, rectPoint);
  }
  return getRectPath(rectPoints);
}
function getAreaLineY(data, height) {
  var y2 = new linear_default({
    values: data
  });
  var lineY = Math.max(0, y2.min);
  return height - y2.scale(lineY) * height;
}
function linePathToAreaPath(path, width, height, data) {
  var areaPath = __spreadArray7([], path, true);
  var lineYPx = getAreaLineY(data, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
function getRectPoints(pointInfo) {
  var x2 = pointInfo.x, y2 = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (is_array_default(y2)) {
    yMin = y2[0], yMax = y2[1];
  } else {
    yMin = y0;
    yMax = y2;
  }
  var xMin;
  var xMax;
  if (is_array_default(x2)) {
    xMin = x2[0], xMax = x2[1];
  } else {
    xMin = x2 - size2 / 2;
    xMax = x2 + size2 / 2;
  }
  var points = [{
    x: xMin,
    y: yMin
  }, {
    x: xMin,
    y: yMax
  }];
  points.push({
    x: xMax,
    y: yMax
  }, {
    x: xMax,
    y: yMin
  });
  return points;
}
function getRectPath(points, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path = [];
  var firstPoint = points[0];
  path.push(["M", firstPoint.x, firstPoint.y]);
  for (var i2 = 1, len5 = points.length; i2 < len5; i2++) {
    path.push(["L", points[i2].x, points[i2].y]);
  }
  if (isClosed) {
    path.push(["L", firstPoint.x, firstPoint.y]);
    path.push(["z"]);
  }
  return path;
}

// node_modules/@antv/g6-plugin/es/timeBar/trend.js
var __assign7 = function() {
  __assign7 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign7.apply(this, arguments);
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
var Trend = function() {
  function Trend2(cfg) {
    var _a2 = cfg.x, x2 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y2 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 200 : _c, _d = cfg.height, height = _d === void 0 ? 26 : _d, _e2 = cfg.smooth, smooth = _e2 === void 0 ? true : _e2, _f = cfg.isArea, isArea = _f === void 0 ? false : _f, _g = cfg.data, data = _g === void 0 ? [] : _g, lineStyle = cfg.lineStyle, areaStyle = cfg.areaStyle, group = cfg.group, _h = cfg.interval, interval2 = _h === void 0 ? null : _h;
    this.group = group;
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.data = data;
    this.smooth = smooth;
    this.isArea = isArea;
    this.lineStyle = Object.assign({}, LINE_STYLE, lineStyle);
    this.areaStyle = Object.assign({}, AREA_STYLE, areaStyle);
    this.intervalConfig = interval2;
    this.renderLine();
  }
  Trend2.prototype.renderLine = function() {
    var _a2 = this, x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height, barWidth = _a2.barWidth, data = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
    var trendGroup = this.group.addGroup({
      name: "trend-group"
    });
    if (data) {
      var path = dataToPath(data, width, height, smooth);
      trendGroup.addShape("path", {
        attrs: __assign7({
          path
        }, lineStyle),
        name: "trend-line"
      });
      if (isArea) {
        var areaPath = linePathToAreaPath(path, width, height, data);
        trendGroup.addShape("path", {
          attrs: __assign7({
            path: areaPath
          }, areaStyle),
          name: "trend-area"
        });
      }
    }
    if (this.intervalConfig) {
      trendGroup.addShape("path", {
        attrs: __assign7({
          path: dataToRectPath(this.intervalConfig.data, width, height, this.intervalConfig.style.barWidth)
        }, this.intervalConfig.style),
        name: "trend-interval"
      });
    }
    trendGroup.move(x2, y2);
  };
  Trend2.prototype.destory = function() {
    this.group.destroy();
  };
  return Trend2;
}();
var trend_default = Trend;

// node_modules/@antv/g6-plugin/es/timeBar/handler.js
init_esm();
var __assign8 = function() {
  __assign8 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign8.apply(this, arguments);
};
var DEFAULT_STYLE = {
  fill: "#1890ff",
  stroke: "#1890ff",
  type: "trend",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  highLightFill: "#0050b3"
};
var SIMPLE_DEFAULT_STYLE = {
  fill: "#fff",
  stroke: "#1890ff",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize"
};
var Handler = function() {
  function Handler2(cfg) {
    var group = cfg.group, name = cfg.name, type = cfg.type, _a2 = cfg.x, x2 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y2 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 2 : _c, _d = cfg.height, height = _d === void 0 ? 24 : _d, _e2 = cfg.style, style = _e2 === void 0 ? {} : _e2;
    this.group = group;
    this.name = name;
    this.handleType = type;
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    if (type === "trend") {
      this.style = __assign8(__assign8({}, DEFAULT_STYLE), style);
    } else if (type === "simple") {
      this.style = __assign8(__assign8({}, SIMPLE_DEFAULT_STYLE), style);
    }
    this.renderHandle();
  }
  Handler2.prototype.setX = function(x2) {
    this.setXY(x2, void 0);
  };
  Handler2.prototype.setY = function(y2) {
    this.setXY(void 0, y2);
  };
  Handler2.prototype.setXY = function(x2, y2) {
    if (is_number_default(x2)) {
      this.x = x2;
    }
    if (is_number_default(y2)) {
      this.y = y2;
    }
    this.updateXY();
  };
  Handler2.prototype.renderHandle = function() {
    var _a2 = this, width = _a2.width, height = _a2.height, style = _a2.style, name = _a2.name;
    var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
    this.handleGroup = this.group.addGroup();
    if (this.handleType === "trend") {
      this.verticalLine = this.handleGroup.addShape("rect", {
        attrs: {
          x: 0,
          y: 0,
          width,
          height,
          fill,
          stroke,
          radius,
          opacity,
          cursor
        },
        name: "".concat(name, "-handler")
      });
      this.topCircle = this.handleGroup.addShape("circle", {
        attrs: {
          x: width / 2,
          y: 0,
          r: 2 * width,
          fill,
          stroke,
          radius,
          opacity,
          cursor,
          lineAppendWidth: 12
        },
        name: "".concat(name, "-handler")
      });
      this.bottomCircle = this.handleGroup.addShape("circle", {
        attrs: {
          x: width / 2,
          y: height,
          r: 2 * width,
          fill,
          stroke,
          radius,
          opacity,
          cursor
        },
        name: "".concat(name, "-handler")
      });
    } else if (this.handleType === "simple") {
      this.topCircle = this.handleGroup.addShape("circle", {
        attrs: {
          x: width / 2,
          y: height / 2,
          r: 2 * width,
          fill,
          stroke,
          radius,
          opacity,
          cursor,
          lineWidth: 2
        },
        name: "".concat(name, "-handler")
      });
    }
    this.updateXY();
    if (this.handleType === "trend") {
      this.bindTrendEvents();
    } else if (this.handleType === "simple") {
      this.bindSimpleEvents();
    }
  };
  Handler2.prototype.bindSimpleEvents = function() {
    var _this = this;
    var name = this.name;
    this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
      var highLightFill = _this.style.highLightFill;
      _this.topCircle.attr("fill", highLightFill);
    });
    this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
      var fill = _this.style.fill;
      _this.topCircle.attr("fill", fill);
    });
  };
  Handler2.prototype.bindTrendEvents = function() {
    var _this = this;
    var name = this.name;
    this.handleGroup.on("".concat(name, "-handler:mouseenter"), function() {
      var highLightFill = _this.style.highLightFill;
      _this.verticalLine.attr("fill", highLightFill);
      _this.topCircle.attr("fill", highLightFill);
      _this.bottomCircle.attr("fill", highLightFill);
    });
    this.handleGroup.on("".concat(name, "-handler:mouseleave"), function() {
      var fill = _this.style.fill;
      _this.verticalLine.attr("fill", fill);
      _this.topCircle.attr("fill", fill);
      _this.bottomCircle.attr("fill", fill);
    });
  };
  Handler2.prototype.show = function() {
    this.handleGroup.show();
  };
  Handler2.prototype.hide = function() {
    this.handleGroup.hide();
  };
  Handler2.prototype.updateXY = function() {
    this.handleGroup.setMatrix([1, 0, 0, 0, 1, 0, this.x, this.y, 1]);
  };
  return Handler2;
}();
var handler_default = Handler;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeButton.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/constant.js
var TIMELINE_START = "timebarstartplay";
var TIMELINE_END = "timebarendplay";
var VALUE_CHANGE = "valuechange";
var TIMEBAR_CONFIG_CHANGE = "timebarConfigChanged";
var PLAY_PAUSE_BTN = "playPauseBtn";
var NEXT_STEP_BTN = "nextStepBtn";
var PRE_STEP_BTN = "preStepBtn";

// node_modules/@antv/g6-plugin/es/timeBar/timeButton.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign9.apply(this, arguments);
};
var Button = function() {
  function Button2(cfg) {
    this.config = deep_mix_default({}, cfg);
    this.init();
  }
  Button2.prototype.update = function(cfg) {
    this.config = deep_mix_default({}, this.config, cfg);
    this.updateElement();
    this.renderMarker();
  };
  Button2.prototype.init = function() {
    this.initElement();
    this.renderMarker();
  };
  Button2.prototype.initElement = function() {
    var _a2 = this.config, group = _a2.group, style = _a2.style;
    var _b = style.scale, scale9 = _b === void 0 ? 1 : _b, _c = style.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = style.offsetY, offsetY = _d === void 0 ? 0 : _d;
    var x2 = this.config.x + offsetX;
    var y2 = this.config.y + offsetY;
    var buttonGroup = group.addGroup({
      name: PLAY_PAUSE_BTN
    });
    this.startMarkerGroup = buttonGroup.addGroup({
      name: PLAY_PAUSE_BTN
    });
    this.circle = group.addShape("circle", {
      attrs: __assign9({
        x: x2,
        y: y2,
        r: this.config.r * scale9
      }, style),
      name: PLAY_PAUSE_BTN
    });
    this.startMarker = this.startMarkerGroup.addShape("path", {
      attrs: {
        path: this.getStartMarkerPath(x2, y2, scale9),
        fill: style.stroke || "#aaa"
      },
      name: "start-marker"
    });
    this.pauseMarkerGroup = buttonGroup.addGroup({
      name: PLAY_PAUSE_BTN
    });
    var width = 0.25 * this.config.r * scale9;
    var height = 0.5 * this.config.r * Math.sqrt(3) * scale9;
    this.pauseLeftMarker = this.pauseMarkerGroup.addShape("rect", {
      attrs: {
        x: x2 - 0.375 * this.config.r * scale9,
        y: y2 - height / 2,
        width,
        height,
        fill: style.stroke || "#aaa",
        lineWidth: 0
      }
    });
    this.pauseRightMarker = this.pauseMarkerGroup.addShape("rect", {
      attrs: {
        x: x2 + 1 / 8 * this.config.r * scale9,
        y: y2 - height / 2,
        width,
        height,
        fill: style.stroke || "#aaa",
        lineWidth: 0
      }
    });
  };
  Button2.prototype.updateElement = function() {
    var _a2 = this.config.style, _b = _a2.scale, scale9 = _b === void 0 ? 1 : _b, _c = _a2.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = _a2.offsetY, offsetY = _d === void 0 ? 0 : _d;
    var x2 = this.config.x + offsetX;
    var y2 = this.config.y + offsetY;
    this.circle.attr("x", x2);
    this.circle.attr("y", y2);
    this.circle.attr("r", this.config.r * scale9);
    this.startMarker.attr("path", this.getStartMarkerPath(x2, y2, scale9));
    var width = 0.25 * this.config.r * scale9;
    var height = 0.5 * this.config.r * Math.sqrt(3) * scale9;
    this.pauseLeftMarker.attr("x", x2 - (1 / 4 + 1 / 8) * this.config.r * scale9);
    this.pauseLeftMarker.attr("y", y2 - height / 2);
    this.pauseLeftMarker.attr("width", width);
    this.pauseLeftMarker.attr("height", height);
    this.pauseRightMarker.attr("x", x2 + 1 / 8 * this.config.r * scale9);
    this.pauseRightMarker.attr("y", y2 - height / 2);
    this.pauseRightMarker.attr("width", width);
    this.pauseRightMarker.attr("height", height);
  };
  Button2.prototype.renderMarker = function() {
    if (this.config.isPlay) {
      this.startMarkerGroup.hide();
      this.pauseMarkerGroup.show();
    } else {
      this.startMarkerGroup.show();
      this.pauseMarkerGroup.hide();
    }
  };
  Button2.prototype.getStartMarkerPath = function(x2, y2, scale9) {
    var sideLength = 0.5 * this.config.r * Math.sqrt(3) * scale9;
    return [["M", x2 - sideLength / Math.sqrt(3) / 2, y2 - sideLength / 2], ["L", x2 + sideLength / Math.sqrt(3), y2], ["L", x2 - sideLength / Math.sqrt(3) / 2, y2 + sideLength / 2]];
  };
  return Button2;
}();
var timeButton_default = Button;

// node_modules/@antv/g6-plugin/es/timeBar/controllerBtn.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign10.apply(this, arguments);
};
var transform10 = ext_exports.transform;
var DEFAULT_RECT_FILL = "#aaa";
var DEFAULT_RECT_STROKE = "green";
var DEFAULT_PLAYBTN_STYLE = {
  fill: "#aaa",
  fillOpacity: 0.35,
  stroke: "#aaa"
};
var DEFAULT_PREBTN_STYLE = {
  fill: "#fff"
};
var DEFAULT_NEXTBTN_STYLE = {
  fill: "green"
};
var DEFAULT_SPEED_CONTROLLER_STYLE = {
  pointer: {
    fill: "#aaa",
    lineWidth: 0
  },
  scroller: {
    stroke: "#aaa",
    fill: "#aaa",
    lineWidth: 1,
    lineAppendWidth: 5,
    cursor: "pointer"
  },
  text: {
    fill: "#aaa",
    textBaseline: "top"
  }
};
var DEFAULT_TIMETYPE_CONTROLLER_STYLE = {
  check: {
    stroke: "green",
    lineWidth: 3
  },
  box: {
    fill: "#fff",
    stroke: "#aaa",
    lineWidth: 2,
    radius: 3,
    width: 12,
    height: 12
  },
  text: {
    fill: "#aaa",
    fontSize: 12,
    textBaseline: "top"
  }
};
var DEFAULT_CONTROLLER_CONFIG = {
  speed: 1,
  loop: false,
  fill: "#fff",
  stroke: "#fff",
  hideTimeTypeController: false,
  preBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  nextBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa"
  },
  playBtnStyle: {
    fill: "#aaa",
    stroke: "#aaa",
    fillOpacity: 0.05
  },
  speedControllerStyle: DEFAULT_SPEED_CONTROLLER_STYLE,
  timeTypeControllerStyle: DEFAULT_TIMETYPE_CONTROLLER_STYLE
};
var SPEED_CONTROLLER_OFFSET = 110;
var TOGGLE_MODEL_OFFSET = 50;
var ControllerBtn = function() {
  function ControllerBtn2(cfg) {
    this.controllerCfg = deep_mix_default({}, DEFAULT_CONTROLLER_CONFIG, cfg);
    this.group = cfg.group;
    this.controllerGroup = this.group.addGroup({
      name: "controller-group"
    });
    this.speedAxisY = [];
    this.currentSpeed = this.controllerCfg.speed;
    this.currentType = "range";
    this.fontFamily = cfg.fontFamily || "Arial, sans-serif";
    this.init();
  }
  ControllerBtn2.prototype.init = function() {
    this.renderPlayButton();
  };
  ControllerBtn2.prototype.getNextMarkerPath = function(x2, y2, len5) {
    return [["M", x2, y2 - len5], ["L", x2 + len5, y2], ["L", x2, y2 + len5], ["Z", x2, y2 - len5], ["M", x2, y2], ["L", x2 - len5, y2 - len5], ["L", x2 - len5, y2 + len5], ["Z"]];
  };
  ControllerBtn2.prototype.getPreMarkerPath = function(x2, y2, len5) {
    return [["M", x2, y2 - len5], ["L", x2 - len5, y2], ["L", x2, y2 + len5], ["L", x2, y2 - len5], ["M", x2, y2], ["L", x2 + len5, y2 - len5], ["L", x2 + len5, y2 + len5], ["Z"]];
  };
  ControllerBtn2.prototype.renderPlayButton = function() {
    var controllerCfg = this.controllerCfg;
    var width = controllerCfg.width, height = controllerCfg.height, x2 = controllerCfg.x, y2 = controllerCfg.y, hideTimeTypeController = controllerCfg.hideTimeTypeController, _a2 = controllerCfg.fill, fill = _a2 === void 0 ? DEFAULT_RECT_FILL : _a2, _b = controllerCfg.stroke, stroke = _b === void 0 ? DEFAULT_RECT_STROKE : _b, _c = controllerCfg.containerStyle, containerStyle = _c === void 0 ? {} : _c;
    var playBtnStyle = __assign10(__assign10({}, DEFAULT_PLAYBTN_STYLE), controllerCfg.playBtnStyle || {});
    var preBtnStyle = __assign10(__assign10({}, DEFAULT_PREBTN_STYLE), controllerCfg.preBtnStyle || {});
    var nextBtnStyle = __assign10(__assign10({}, DEFAULT_NEXTBTN_STYLE), controllerCfg.nextBtnStyle || {});
    var r2 = height / 2 - 5;
    var realY = y2 + 10;
    var container2 = this.controllerGroup.addShape("rect", {
      attrs: __assign10({
        x: x2,
        y: realY,
        width,
        height,
        stroke,
        fill
      }, containerStyle),
      name: "container-rect"
    });
    if (this.playButton) {
      this.playButton.update({
        x: width / 2,
        y: realY,
        r: r2
      });
    } else {
      this.playButton = new timeButton_default({
        group: this.controllerGroup,
        x: width / 2,
        y: realY + r2 + 5,
        r: r2,
        isPlay: this.isPlay,
        style: playBtnStyle
      });
    }
    var prePaddingX = preBtnStyle.offsetX || 0;
    var prePaddingY = preBtnStyle.offsetY || 0;
    var preR = (preBtnStyle.scale || 1) * r2;
    this.controllerGroup.addShape("path", {
      attrs: __assign10({
        path: this.getPreMarkerPath(width / 2 - 5 * r2 + prePaddingX, realY + r2 + 5 + prePaddingY, preR * 0.5)
      }, preBtnStyle),
      name: PRE_STEP_BTN
    });
    var nxtPaddingX = nextBtnStyle.offsetX || 0;
    var nxtPaddingY = nextBtnStyle.offsetY || 0;
    var nxtR = (nextBtnStyle.scale || 1) * r2;
    this.controllerGroup.addShape("path", {
      attrs: __assign10({
        path: this.getNextMarkerPath(width / 2 + 5 * r2 + nxtPaddingX, realY + r2 + 5 + nxtPaddingY, nxtR * 0.5)
      }, nextBtnStyle),
      name: NEXT_STEP_BTN
    });
    container2.toBack();
    this.renderSpeedBtn();
    if (!hideTimeTypeController) {
      this.renderToggleTime();
    }
    this.bindEvent();
    var _d = this.controllerCfg.scale, scale9 = _d === void 0 ? 1 : _d;
    var currentBBox = this.controllerGroup.getCanvasBBox();
    var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
    var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
    var matrix = transform10([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -centerY], ["s", scale9, scale9], ["t", centerX, centerY]]);
    this.controllerGroup.setMatrix(matrix);
  };
  ControllerBtn2.prototype.renderSpeedBtn = function() {
    var _a2 = this.controllerCfg, y2 = _a2.y, width = _a2.width, hideTimeTypeController = _a2.hideTimeTypeController;
    var speedControllerStyle = __assign10(__assign10({}, DEFAULT_SPEED_CONTROLLER_STYLE), this.controllerCfg.speedControllerStyle || {});
    var _b = speedControllerStyle.scroller, scroller = _b === void 0 ? {} : _b, _c = speedControllerStyle.text, text = _c === void 0 ? {} : _c, _d = speedControllerStyle.pointer, pointer = _d === void 0 ? {} : _d, _e2 = speedControllerStyle.scale, scale9 = _e2 === void 0 ? 1 : _e2, _f = speedControllerStyle.offsetX, offsetX = _f === void 0 ? 0 : _f, _g = speedControllerStyle.offsetY, offsetY = _g === void 0 ? 0 : _g;
    var speedGroup = this.controllerGroup.addGroup({
      name: "speed-group"
    });
    this.speedGroup = speedGroup;
    var speedNum = [];
    var maxSpeed = 5;
    this.speedAxisY = [19, 22, 26, 32, 39];
    for (var i2 = 0; i2 < 5; i2++) {
      var axisY = y2 + this.speedAxisY[i2];
      var startX = width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET);
      speedGroup.addShape("line", {
        attrs: __assign10({
          x1: startX,
          x2: startX + 15,
          y1: axisY,
          y2: axisY
        }, scroller),
        speed: maxSpeed,
        name: "speed-rect"
      });
      this.speedAxisY[i2] = axisY;
      speedNum.push(maxSpeed);
      maxSpeed = maxSpeed - 1;
    }
    this.speedText = speedGroup.addShape("text", {
      attrs: __assign10({
        x: width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET) + 20,
        y: this.speedAxisY[0] + 4,
        text: "1.0X",
        fontFamily: this.fontFamily || "Arial, sans-serif"
      }, text),
      name: "speed-text"
    });
    this.speedPoint = speedGroup.addShape("path", {
      attrs: __assign10({
        path: this.getPointerPath(width - (!hideTimeTypeController ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET), 0),
        matrix: [1, 0, 0, 0, 1, 0, 0, this.speedAxisY[4], 1]
      }, pointer),
      name: "speed-pointer"
    });
    var currentBBox = this.speedGroup.getCanvasBBox();
    var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
    var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
    var matrix = this.speedGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    matrix = transform10(matrix, [["t", -centerX, -centerY], ["s", scale9, scale9], ["t", centerX + offsetX * scale9, centerY + offsetY * scale9]]);
    this.speedGroup.setMatrix(matrix);
  };
  ControllerBtn2.prototype.getPointerPath = function(x2, y2) {
    return [["M", x2, y2], ["L", x2 - 10, y2 - 4], ["L", x2 - 10, y2 + 4], ["Z"]];
  };
  ControllerBtn2.prototype.renderToggleTime = function() {
    var _a2;
    var width = this.controllerCfg.width;
    var timeTypeControllerStyle = __assign10(__assign10({}, DEFAULT_TIMETYPE_CONTROLLER_STYLE), this.controllerCfg.timeTypeControllerStyle || {});
    var _b = timeTypeControllerStyle.scale, scale9 = _b === void 0 ? 1 : _b, _c = timeTypeControllerStyle.offsetX, offsetX = _c === void 0 ? 0 : _c, _d = timeTypeControllerStyle.offsetY, offsetY = _d === void 0 ? 0 : _d, _e2 = timeTypeControllerStyle.box, box2 = _e2 === void 0 ? {} : _e2, _f = timeTypeControllerStyle.check, check = _f === void 0 ? {} : _f, _g = timeTypeControllerStyle.text, text = _g === void 0 ? {} : _g;
    this.toggleGroup = this.controllerGroup.addGroup({
      name: "toggle-group"
    });
    this.toggleGroup.addShape("rect", {
      attrs: __assign10({
        x: width - TOGGLE_MODEL_OFFSET,
        y: this.speedAxisY[0] + 3.5
      }, box2),
      isChecked: false,
      name: "toggle-model"
    });
    this.checkedIcon = this.toggleGroup.addShape("path", {
      attrs: __assign10({
        path: [["M", width - TOGGLE_MODEL_OFFSET + 3, this.speedAxisY[1] + 6], ["L", width - TOGGLE_MODEL_OFFSET + 7, this.speedAxisY[1] + 10], ["L", width - TOGGLE_MODEL_OFFSET + 12, this.speedAxisY[1] + 4]]
      }, check),
      capture: false,
      name: "check-icon"
    });
    this.checkedIcon.hide();
    this.checkedText = this.toggleGroup.addShape("text", {
      attrs: __assign10({
        text: ((_a2 = this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timePointControllerText) || "\u5355\u4E00\u65F6\u95F4",
        x: width - TOGGLE_MODEL_OFFSET + 15,
        y: this.speedAxisY[0] + 4,
        fontFamily: typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif"
      }, text),
      name: "checked-text"
    });
    var currentBBox = this.toggleGroup.getCanvasBBox();
    var centerX = (currentBBox.maxX + currentBBox.minX) / 2;
    var centerY = (currentBBox.maxY + currentBBox.minY) / 2;
    var matrix = this.toggleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    matrix = transform10(matrix, [["t", -centerX, -centerY], ["s", scale9, scale9], ["t", centerX + offsetX * scale9, centerY + offsetY * scale9]]);
    this.toggleGroup.setMatrix(matrix);
  };
  ControllerBtn2.prototype.bindEvent = function() {
    var _this = this;
    this.speedGroup.on("speed-rect:click", function(evt) {
      var currentPointerY = evt.target.attr("y1");
      var pointerMatrix = _this.speedPoint.attr("matrix");
      var currentYIdx = _this.speedAxisY.indexOf(pointerMatrix[7] || 0);
      var targetYIdx = _this.speedAxisY.indexOf(currentPointerY);
      var yDiff = _this.speedAxisY[targetYIdx] - _this.speedAxisY[currentYIdx];
      pointerMatrix = transform10(pointerMatrix, [["t", 0, yDiff]]);
      _this.speedPoint.setMatrix(pointerMatrix);
      _this.currentSpeed = _this.speedAxisY.length - targetYIdx;
      _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
      _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
        speed: _this.currentSpeed,
        type: _this.currentType
      });
    });
    this.speedGroup.on("mousewheel", function(evt) {
      evt.preventDefault();
      var pointerMatrix = _this.speedPoint.attr("matrix") || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      var currentPointerY = pointerMatrix[7];
      var currentYIdx = _this.speedAxisY.indexOf(currentPointerY);
      if (currentYIdx === -1) {
        var minDist_1 = Infinity;
        _this.speedAxisY.forEach(function(y2, idx) {
          var dist4 = Math.abs(y2 - currentPointerY);
          if (minDist_1 > dist4) {
            minDist_1 = dist4;
            currentYIdx = idx;
          }
        });
      }
      if (evt.originalEvent.deltaY > 0)
        currentYIdx = Math.max(0, currentYIdx - 1);
      else
        currentYIdx = Math.min(_this.speedAxisY.length - 1, currentYIdx + 1);
      var yDiff = _this.speedAxisY[currentYIdx] - currentPointerY;
      pointerMatrix = transform10(pointerMatrix, [["t", 0, yDiff]]);
      _this.speedPoint.setMatrix(pointerMatrix);
      _this.currentSpeed = _this.speedAxisY.length - currentYIdx;
      _this.speedText.attr("text", "".concat(_this.currentSpeed, ".0X"));
      _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
        speed: _this.currentSpeed,
        type: _this.currentType
      });
    });
    if (this.toggleGroup) {
      this.toggleGroup.on("toggle-model:click", function(evt) {
        var _a2, _b;
        var isChecked = evt.target.get("isChecked");
        if (!isChecked) {
          _this.checkedIcon.show();
          _this.checkedText.attr("text", ((_a2 = _this.controllerCfg) === null || _a2 === void 0 ? void 0 : _a2.timeRangeControllerText) || "\u65F6\u95F4\u8303\u56F4");
          _this.currentType = "single";
        } else {
          _this.checkedIcon.hide();
          _this.checkedText.attr("text", ((_b = _this.controllerCfg) === null || _b === void 0 ? void 0 : _b.timePointControllerText) || "\u5355\u4E00\u65F6\u95F4");
          _this.currentType = "range";
        }
        evt.target.set("isChecked", !isChecked);
        _this.group.emit(TIMEBAR_CONFIG_CHANGE, {
          type: _this.currentType,
          speed: _this.currentSpeed
        });
      });
    }
  };
  ControllerBtn2.prototype.destroy = function() {
    this.speedGroup.off("speed-rect:click");
    if (this.toggleGroup) {
      this.toggleGroup.off("toggle-model:click");
      this.toggleGroup.destroy();
    }
    this.speedGroup.destroy();
  };
  return ControllerBtn2;
}();
var controllerBtn_default = ControllerBtn;

// node_modules/@antv/g6-plugin/es/timeBar/trendTimeBar.js
var __assign11 = function() {
  __assign11 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign11.apply(this, arguments);
};
var transform11 = ext_exports.transform;
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var SIMPLE_BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.15,
  radius: 5
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.3,
  cursor: "grab"
};
var DEFAULT_HANDLER_WIDTH = 2;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var TICK_LABEL_STYLE = {
  textAlign: "center",
  textBaseline: "top",
  fill: "#607889",
  opacity: 0.35
};
var TICK_LINE_STYLE = {
  lineWidth: 1,
  stroke: "#ccc"
};
var TrendTimeBar = function() {
  function TrendTimeBar2(cfg) {
    var _this = this;
    this.prevX = 0;
    this.onMouseDown = function(handler) {
      return function(e8) {
        _this.currentHandler = handler;
        var event = e8.originalEvent;
        event.stopPropagation();
        event.preventDefault();
        _this.prevX = get_default(event, "touches.0.pageX", event.pageX);
        var containerDOM = _this.canvas.get("container");
        containerDOM.addEventListener("mousemove", _this.onMouseMove);
        containerDOM.addEventListener("mouseup", _this.onMouseUp);
        containerDOM.addEventListener("mouseleave", _this.onMouseUp);
        containerDOM.addEventListener("touchmove", _this.onMouseMove);
        containerDOM.addEventListener("touchend", _this.onMouseUp);
        containerDOM.addEventListener("touchcancel", _this.onMouseUp);
      };
    };
    this.onMouseMove = function(e8) {
      e8.stopPropagation();
      e8.preventDefault();
      var x3 = get_default(e8, "touches.0.pageX", e8.pageX);
      var offsetX = x3 - _this.prevX;
      var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
      _this.updateStartEnd(offsetXRange);
      _this.updateUI();
      _this.prevX = x3;
    };
    this.onMouseUp = function() {
      if (_this.currentHandler) {
        _this.currentHandler = void 0;
      }
      var containerDOM = _this.canvas.get("container");
      if (containerDOM) {
        containerDOM.removeEventListener("mousemove", _this.onMouseMove);
        containerDOM.removeEventListener("mouseup", _this.onMouseUp);
        containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
        containerDOM.removeEventListener("touchmove", _this.onMouseMove);
        containerDOM.removeEventListener("touchend", _this.onMouseUp);
        containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
      }
    };
    var _a2 = cfg.x, x2 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y2 = _b === void 0 ? 0 : _b, _c = cfg.width, width = _c === void 0 ? 100 : _c, height = cfg.height, _d = cfg.padding, padding = _d === void 0 ? 10 : _d, trendCfg = cfg.trendCfg, _e2 = cfg.controllerCfg, controllerCfg = _e2 === void 0 ? {
      speed: 1
    } : _e2, _f = cfg.backgroundStyle, backgroundStyle = _f === void 0 ? {} : _f, _g = cfg.foregroundStyle, foregroundStyle = _g === void 0 ? {} : _g, _h = cfg.handlerStyle, handlerStyle = _h === void 0 ? {} : _h, _j = cfg.textStyle, textStyle = _j === void 0 ? {} : _j, _k = cfg.start, start = _k === void 0 ? 0 : _k, _l = cfg.end, end2 = _l === void 0 ? 1 : _l, _m = cfg.minText, minText = _m === void 0 ? "" : _m, _o2 = cfg.maxText, maxText = _o2 === void 0 ? "" : _o2, group = cfg.group, graph = cfg.graph, canvas = cfg.canvas, _p = cfg.tick, tick = _p === void 0 ? {
      tickLabelStyle: {},
      tickLineStyle: {},
      tickLabelFormatter: function tickLabelFormatter(d2) {
        return d2;
      },
      ticks: []
    } : _p, type = cfg.type;
    this.graph = graph;
    this.canvas = canvas;
    this.group = group;
    this.timeBarType = type;
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.padding = padding;
    this.ticks = tick.ticks;
    this.trendCfg = trendCfg;
    this.controllerCfg = controllerCfg;
    this.currentSpeed = controllerCfg.speed || 1;
    this.tickLabelFormatter = tick.tickLabelFormatter;
    if (type === "trend") {
      this.backgroundStyle = __assign11(__assign11({}, BACKGROUND_STYLE), backgroundStyle);
    } else if (type === "simple") {
      this.backgroundStyle = __assign11(__assign11({}, SIMPLE_BACKGROUND_STYLE), backgroundStyle);
    }
    this.foregroundStyle = __assign11(__assign11({}, FOREGROUND_STYLE), foregroundStyle);
    this.handlerStyle = __assign11(__assign11({}, HANDLER_STYLE), handlerStyle);
    this.textStyle = __assign11(__assign11({}, TEXT_STYLE), textStyle);
    this.tickLabelStyle = __assign11(__assign11({}, TICK_LABEL_STYLE), tick.tickLabelStyle);
    this.tickLineStyle = __assign11(__assign11({}, TICK_LINE_STYLE), tick.tickLineStyle);
    this.currentMode = "range";
    this.start = start;
    this.end = end2;
    this.minText = minText;
    this.maxText = maxText;
    this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
    this.renderSlider();
  }
  TrendTimeBar2.prototype.update = function(cfg) {
    var x2 = cfg.x, y2 = cfg.y, width = cfg.width, height = cfg.height, minText = cfg.minText, maxText = cfg.maxText, start = cfg.start, end2 = cfg.end;
    this.start = Math.min(1, Math.max(start, 0));
    this.end = Math.min(1, Math.max(end2, 0));
    mix(this, {
      x: x2,
      y: y2,
      width,
      height,
      minText,
      maxText
    });
    this.updateUI();
  };
  TrendTimeBar2.prototype.setText = function(minText, maxText) {
    this.minTextShape.attr("text", minText);
    this.maxTextShape.attr("text", maxText);
  };
  TrendTimeBar2.prototype.renderSlider = function() {
    var _this = this;
    var _a2 = this, width = _a2.width, height = _a2.height, timeBarType = _a2.timeBarType;
    if (timeBarType === "trend" && size(get_default(this.trendCfg, "data"))) {
      var trendComponent = new trend_default(__assign11(__assign11({
        x: this.x,
        y: this.y,
        width,
        height
      }, this.trendCfg), {
        group: this.group
      }));
      this.trendComponent = trendComponent;
    }
    var sliderGroup = this.group.addGroup({
      name: "slider-group"
    });
    sliderGroup.addShape("rect", {
      attrs: __assign11({
        x: 0,
        y: 0,
        width,
        height
      }, this.backgroundStyle),
      name: "background"
    });
    var textGroup = this.group.addGroup();
    if (timeBarType === "trend") {
      this.minTextShape = textGroup.addShape("text", {
        attrs: __assign11({
          x: 0,
          y: height / 2 + this.y,
          textAlign: "right",
          text: this.minText,
          silent: false,
          fontFamily: this.fontFamily || "Arial, sans-serif",
          stroke: "#fff",
          lineWidth: 5
        }, this.textStyle),
        capture: false,
        name: "min-text-shape"
      });
      this.maxTextShape = textGroup.addShape("text", {
        attrs: __assign11({
          y: height / 2 + this.y,
          textAlign: "left",
          text: this.maxText,
          silent: false,
          fontFamily: this.fontFamily || "Arial, sans-serif",
          stroke: "#fff",
          lineWidth: 5
        }, this.textStyle),
        capture: false,
        name: "max-text-shape"
      });
    } else {
      this.minTextShape = textGroup.addShape("text", {
        attrs: __assign11({
          x: 0,
          y: this.y - 10,
          textAlign: "center",
          text: this.minText,
          silent: false,
          fontFamily: this.fontFamily || "Arial, sans-serif",
          stroke: "#fff",
          lineWidth: 5
        }, this.textStyle),
        capture: false,
        name: "min-text-shape"
      });
      this.maxTextShape = textGroup.addShape("text", {
        attrs: __assign11({
          y: this.y - 10,
          textAlign: "center",
          text: this.maxText,
          silent: false,
          fontFamily: this.fontFamily || "Arial, sans-serif",
          stroke: "#fff",
          lineWidth: 5
        }, this.textStyle),
        capture: false,
        name: "max-text-shape"
      });
    }
    this.foregroundShape = this.group.addGroup().addShape("rect", {
      attrs: __assign11({
        x: 0,
        y: this.y,
        height
      }, this.foregroundStyle),
      name: "foreground-shape"
    });
    this.foregroundShape.on("mousedown", function(e8) {
      e8.target.attr("cursor", "grabbing");
    });
    this.foregroundShape.on("mouseup", function(e8) {
      e8.target.attr("cursor", _this.foregroundStyle.cursor || "grab");
    });
    var handlerWidth = get_default(this.handlerStyle, "width", 2);
    var handlerHeight = get_default(this.handlerStyle, "height", 24);
    var minHandleGroup = this.group.addGroup({
      name: "minHandlerShape"
    });
    this.minHandlerShape = new handler_default({
      name: "minHandlerShape",
      group: minHandleGroup,
      type: timeBarType,
      x: this.x,
      y: this.y,
      width: handlerWidth,
      height: handlerHeight,
      style: this.handlerStyle
    });
    var maxHandleGroup = this.group.addGroup({
      name: "maxHandlerShape"
    });
    this.maxHandlerShape = new handler_default({
      name: "maxHandlerShape",
      group: maxHandleGroup,
      type: timeBarType,
      x: this.x,
      y: this.y,
      width: handlerWidth,
      height: handlerHeight,
      style: this.handlerStyle
    });
    var tickData = this.ticks;
    var interval2 = width / (tickData.length - 1);
    this.tickPosList = [];
    if (this.textList && this.textList.length) {
      this.textList.forEach(function(text) {
        text.destroy();
      });
    }
    var lastX = -Infinity;
    var rotate7 = this.tickLabelStyle.rotate;
    delete this.tickLabelStyle.rotate;
    this.textList = tickData.map(function(data, index) {
      _this.tickPosList.push(_this.x + index * interval2);
      var label;
      if (_this.tickLabelFormatter) {
        label = _this.tickLabelFormatter(data);
        if (!is_string_default(label) && label) {
          label = data.date;
        }
      } else {
        label = data.date;
      }
      var textX = _this.x + index * interval2, textY = _this.y + height + 5;
      var text = _this.group.addShape("text", {
        attrs: __assign11({
          x: textX,
          y: textY,
          text: label,
          fontFamily: _this.fontFamily || "Arial, sans-serif"
        }, _this.tickLabelStyle),
        name: "tick-label"
      });
      if (is_number_default(rotate7) && index !== tickData.length - 1) {
        var matrix = transform11([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -textX, -textY], ["r", rotate7], ["t", textX - 5, textY + 2]]);
        text.attr({
          textAlign: "left",
          matrix
        });
      }
      if (index === 0) {
        text.attr({
          textAlign: "left"
        });
      } else if (index !== tickData.length - 1) {
        text.attr({
          textAlign: "right"
        });
      }
      var line = _this.group.addShape("line", {
        attrs: __assign11({
          x1: _this.x + index * interval2,
          y1: _this.y + height + 2,
          x2: _this.x + index * interval2,
          y2: _this.y + height + 6
        }, _this.tickLineStyle),
        name: "tick-line"
      });
      line.toBack();
      var bbox = text.getBBox();
      if (bbox.minX > lastX) {
        text.show();
        line.show();
        lastX = bbox.minX + bbox.width + 10;
      } else {
        text.hide();
        line.hide();
      }
      return text;
    });
    this.controllerBtnGroup = new controllerBtn_default(__assign11({
      group: this.group,
      x: this.x,
      y: this.y + height + 25,
      width,
      height: 35
    }, this.controllerCfg));
    this.updateStartEnd(0);
    this.updateUI();
    sliderGroup.move(this.x, this.y);
    this.bindEvents();
  };
  TrendTimeBar2.prototype.bindEvents = function() {
    var _this = this;
    var minHandleShapeGroup = this.group.find(function(group) {
      return group.get("name") === "minHandlerShape";
    });
    if (minHandleShapeGroup) {
      minHandleShapeGroup.on("minHandlerShape-handler:mousedown", this.onMouseDown(this.minHandlerShape));
      minHandleShapeGroup.on("minHandlerShape-handler:touchstart", this.onMouseDown(this.minHandlerShape));
    }
    var maxHandleShapeGroup = this.group.find(function(group) {
      return group.get("name") === "maxHandlerShape";
    });
    if (maxHandleShapeGroup) {
      maxHandleShapeGroup.on("maxHandlerShape-handler:mousedown", this.onMouseDown(this.maxHandlerShape));
      maxHandleShapeGroup.on("maxHandlerShape-handler:touchstart", this.onMouseDown(this.maxHandlerShape));
    }
    this.foregroundShape.on("mousedown", this.onMouseDown(this.foregroundShape));
    this.foregroundShape.on("touchstart", this.onMouseDown(this.foregroundShape));
    this.group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
      _this.isPlay = !_this.isPlay;
      _this.currentHandler = _this.maxHandlerShape;
      _this.changePlayStatus();
    });
    this.group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
      _this.currentHandler = _this.maxHandlerShape;
      _this.updateStartEnd(0.01);
      _this.updateUI();
    });
    this.group.on("".concat(PRE_STEP_BTN, ":click"), function() {
      _this.currentHandler = _this.maxHandlerShape;
      _this.updateStartEnd(-0.01);
      _this.updateUI();
    });
    this.group.on(TIMEBAR_CONFIG_CHANGE, function(_a2) {
      var type = _a2.type, speed = _a2.speed;
      _this.currentSpeed = speed;
      _this.currentMode = type;
      if (type === "single") {
        _this.minHandlerShape.hide();
        _this.foregroundShape.hide();
        _this.minTextShape.hide();
      } else if (type === "range") {
        _this.minHandlerShape.show();
        _this.foregroundShape.show();
        _this.minTextShape.show();
      }
    });
  };
  TrendTimeBar2.prototype.adjustTickIndex = function(timeSelectX) {
    for (var i2 = 0; i2 < this.tickPosList.length - 1; i2++) {
      if (this.tickPosList[i2] <= timeSelectX && timeSelectX <= this.tickPosList[i2 + 1]) {
        return Math.abs(this.tickPosList[i2] - timeSelectX) < Math.abs(timeSelectX - this.tickPosList[i2 + 1]) ? i2 : i2 + 1;
      }
    }
    return 0;
  };
  TrendTimeBar2.prototype.adjustOffsetRange = function(offsetRange) {
    switch (this.currentHandler) {
      case this.minHandlerShape: {
        var min6 = 0 - this.start;
        var max7 = 1 - this.start;
        return Math.min(max7, Math.max(min6, offsetRange));
      }
      case this.maxHandlerShape: {
        var min6 = 0 - this.end;
        var max7 = 1 - this.end;
        return Math.min(max7, Math.max(min6, offsetRange));
      }
      case this.foregroundShape: {
        var min6 = 0 - this.start;
        var max7 = 1 - this.end;
        return Math.min(max7, Math.max(min6, offsetRange));
      }
      default:
        return 0;
    }
  };
  TrendTimeBar2.prototype.updateStartEnd = function(offsetRange) {
    var minData = this.ticks[this.adjustTickIndex(this.start * this.width)];
    var maxData = this.ticks[this.adjustTickIndex(this.end * this.width)];
    if (!this.currentHandler) {
      this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData === null || minData === void 0 ? void 0 : minData.date;
      this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData === null || maxData === void 0 ? void 0 : maxData.date;
      return;
    }
    switch (this.currentHandler) {
      case this.minHandlerShape:
        this.maxText = this.maxTextShape.attr("text");
        this.start += offsetRange;
        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
        break;
      case this.maxHandlerShape:
        this.minText = this.minTextShape.attr("text");
        this.end += offsetRange;
        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
        break;
      case this.foregroundShape:
        this.start += offsetRange;
        this.end += offsetRange;
        this.minText = this.tickLabelFormatter ? this.tickLabelFormatter(minData) : minData.date;
        this.maxText = this.tickLabelFormatter ? this.tickLabelFormatter(maxData) : maxData.date;
        break;
      default:
        break;
    }
  };
  TrendTimeBar2.prototype.updateUI = function() {
    var _this = this;
    if (this.start < 0) {
      this.start = 0;
    }
    if (this.end > 1) {
      this.end = 1;
    }
    var min6 = this.x + this.start * this.width;
    var max7 = this.x + this.end * this.width;
    this.foregroundShape.attr("x", min6);
    this.foregroundShape.attr("width", max7 - min6);
    var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    this.setText(this.minText, this.maxText);
    var _a2 = this.dodgeText([min6, max7]), minAttrs = _a2[0], maxAttrs = _a2[1];
    this.minHandlerShape.setX(min6 - handlerWidth / 2);
    each_default(minAttrs, function(v2, k2) {
      return _this.minTextShape.attr(k2, v2);
    });
    this.maxHandlerShape.setX(max7 - handlerWidth / 2);
    each_default(maxAttrs, function(v2, k2) {
      return _this.maxTextShape.attr(k2, v2);
    });
    if (this.currentMode === "range") {
      this.graph.emit(VALUE_CHANGE, {
        value: [this.start, this.end].sort()
      });
    } else if (this.currentMode === "single") {
      this.graph.emit(VALUE_CHANGE, {
        value: [this.end, this.end]
      });
    }
  };
  TrendTimeBar2.prototype.dodgeText = function(range) {
    var _a2, _b;
    var TEXTPADDING = 2;
    var handlerWidth = get_default(this.handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
    var minTextShape = this.minTextShape;
    var maxTextShape = this.maxTextShape;
    var min6 = range[0], max7 = range[1];
    var sorted = false;
    if (min6 > max7) {
      _a2 = [max7, min6], min6 = _a2[0], max7 = _a2[1];
      _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
      sorted = true;
    }
    var minBBox = minTextShape.getBBox();
    var maxBBox = maxTextShape.getBBox();
    var minAttrs = null;
    var maxAttrs = null;
    if (this.timeBarType === "trend") {
      minAttrs = min6 - minBBox.width < this.x + TEXTPADDING ? {
        x: min6 + handlerWidth / 2 + TEXTPADDING,
        textAlign: "left"
      } : {
        x: min6 - handlerWidth / 2 - TEXTPADDING,
        textAlign: "right"
      };
      maxAttrs = max7 + maxBBox.width > this.x + this.width ? {
        x: max7 - handlerWidth / 2 - TEXTPADDING,
        textAlign: "right"
      } : {
        x: max7 + handlerWidth / 2 + TEXTPADDING,
        textAlign: "left"
      };
    } else if (this.timeBarType === "simple") {
      minAttrs = minTextShape.attr("x") > minBBox.width ? {
        x: min6,
        textAlign: "center"
      } : {
        x: min6,
        textAlign: "left"
      };
      maxAttrs = maxTextShape.attr("x") > this.width - maxBBox.width ? {
        x: max7,
        textAlign: "right"
      } : {
        x: max7,
        textAlign: "center"
      };
    }
    return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
  };
  TrendTimeBar2.prototype.startPlay = function() {
    var _this = this;
    return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
      var _a2 = _this, ticks = _a2.ticks, width = _a2.width;
      var speed = _this.currentSpeed;
      var tickInterval = width / ticks.length;
      var offsetX = tickInterval / ((10 - speed) * 1e3 / 60);
      var offsetXRange = _this.adjustOffsetRange(offsetX / _this.width);
      _this.updateStartEnd(offsetXRange);
      _this.updateUI();
      if (_this.isPlay) {
        _this.playHandler = _this.startPlay();
      }
    }) : void 0;
  };
  TrendTimeBar2.prototype.changePlayStatus = function(isSync) {
    if (isSync === void 0) {
      isSync = true;
    }
    this.controllerBtnGroup.playButton.update({
      isPlay: this.isPlay
    });
    if (this.isPlay) {
      this.playHandler = this.startPlay();
      this.graph.emit(TIMELINE_START, null);
    } else {
      if (this.playHandler) {
        if (typeof window !== "undefined")
          window.cancelAnimationFrame(this.playHandler);
        if (isSync) {
          this.graph.emit(TIMELINE_END, null);
        }
      }
    }
  };
  TrendTimeBar2.prototype.destory = function() {
    this.graph.off(VALUE_CHANGE, function() {
    });
    var group = this.group;
    var minHandleShapeGroup = group.find(function(g2) {
      return g2.get("name") === "minHandlerShape";
    });
    if (minHandleShapeGroup) {
      minHandleShapeGroup.off("minHandlerShape-handler:mousedown");
      minHandleShapeGroup.off("minHandlerShape-handler:touchstart");
      minHandleShapeGroup.destroy();
    }
    var maxHandleShapeGroup = group.find(function(g2) {
      return g2.get("name") === "maxHandlerShape";
    });
    if (maxHandleShapeGroup) {
      maxHandleShapeGroup.off("maxHandlerShape-handler:mousedown");
      maxHandleShapeGroup.off("maxHandlerShape-handler:touchstart");
      maxHandleShapeGroup.destroy();
    }
    this.foregroundShape.off("mousedown");
    this.foregroundShape.off("touchstart");
    this.foregroundShape.destroy();
    group.off("".concat(PLAY_PAUSE_BTN, ":click"));
    group.off("".concat(NEXT_STEP_BTN, ":click"));
    group.off("".concat(PRE_STEP_BTN, ":click"));
    group.off(TIMEBAR_CONFIG_CHANGE);
    group.destroy();
    if (this.trendComponent) {
      this.trendComponent.destory();
    }
  };
  return TrendTimeBar2;
}();
var trendTimeBar_default = TrendTimeBar;

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
init_esm();

// node_modules/@antv/g6-plugin/es/timeBar/timeBarTooltip.js
init_esm();
var TimeBarTooltip = function() {
  function TimeBarTooltip2(cfg) {
    var _a2 = cfg.x, x2 = _a2 === void 0 ? 0 : _a2, _b = cfg.y, y2 = _b === void 0 ? 0 : _b, container2 = cfg.container, text = cfg.text, _c = cfg.padding, padding = _c === void 0 ? [4, 4, 4, 4] : _c, _d = cfg.className, className = _d === void 0 ? "g6-component-timebar-tooltip" : _d, _e2 = cfg.backgroundColor, backgroundColor = _e2 === void 0 ? "#000" : _e2, _f = cfg.textColor, textColor3 = _f === void 0 ? "#fff" : _f, _g = cfg.opacity, opacity = _g === void 0 ? 0.8 : _g, _h = cfg.fontSize, fontSize = _h === void 0 ? 12 : _h;
    this.container = container2;
    this.className = className;
    this.backgroundColor = backgroundColor;
    this.textColor = textColor3;
    this.x = x2;
    this.y = y2;
    this.text = text;
    this.padding = padding;
    this.opacity = opacity;
    this.fontSize = fontSize;
    this.render();
  }
  TimeBarTooltip2.prototype.render = function() {
    var self2 = this;
    var className = self2.className, x2 = self2.x, y2 = self2.y, backgroundColor = self2.backgroundColor, textColor3 = self2.textColor, text = self2.text, padding = self2.padding, opacity = self2.opacity, fontSize = self2.fontSize;
    var parentNode = self2.container;
    var container2 = createDom2("<div class='".concat(className, `' style="position: absolute; width: fit-content; height: fit-content; opacity: `).concat(opacity, '"></div>'));
    if (is_string_default(parentNode)) {
      parentNode = document.getElementById(parentNode);
    }
    parentNode.appendChild(container2);
    self2.parentHeight = parentNode.offsetHeight;
    self2.parentWidth = parentNode.offsetWidth;
    modifyCSS(container2, {
      visibility: "hidden",
      top: 0,
      left: 0
    });
    var background = createDom2("\n      <div style='position: absolute; white-space:nowrap; background-color: ".concat(backgroundColor, "; font-size: ").concat(fontSize, "px; border-radius: 4px; width: fit-content; height: fit-content; color: ").concat(textColor3, "; padding: ").concat(padding[0], "px ").concat(padding[1], "px ").concat(padding[2], "px ").concat(padding[3], "px'></div>"));
    background.innerHTML = text;
    container2.appendChild(background);
    self2.backgroundDOM = background;
    var arrow = createDom2("<div style='position: absolute; width: 0px; height: 0px; border-left: 5px solid transparent; border-right: 5px solid transparent; border-top: 10px solid ".concat(backgroundColor, "'></div>"));
    container2.appendChild(arrow);
    self2.arrowDOM = arrow;
    self2.container = container2;
  };
  TimeBarTooltip2.prototype.show = function(cfg) {
    var self2 = this;
    var text = cfg.text, x2 = cfg.x, y2 = cfg.y, clientX = cfg.clientX, clientY = cfg.clientY;
    self2.backgroundDOM.innerHTML = text;
    var backgroundWidth = self2.backgroundDOM.offsetWidth;
    var backgroundHeight = self2.backgroundDOM.offsetHeight;
    var arrowWidth = self2.arrowDOM.offsetWidth;
    var arrowHeight = self2.arrowDOM.offsetHeight;
    modifyCSS(self2.container, {
      top: "".concat(-backgroundHeight - arrowHeight, "px"),
      left: "".concat(x2, "px"),
      visibility: "visible"
    });
    modifyCSS(self2.backgroundDOM, {
      marginLeft: "".concat(-backgroundWidth / 2, "px")
    });
    modifyCSS(self2.arrowDOM, {
      marginLeft: "".concat(-arrowWidth / 2, "px"),
      top: "".concat(backgroundHeight, "px")
    });
    var left = x2 - backgroundWidth / 2;
    var right = x2 + backgroundWidth / 2;
    if (left < 0) {
      modifyCSS(self2.backgroundDOM, {
        marginLeft: "".concat(-backgroundWidth / 2 - left, "px")
      });
    } else if (right > self2.parentWidth) {
      modifyCSS(self2.backgroundDOM, {
        marginLeft: "".concat(-backgroundWidth / 2 - right + self2.parentWidth + 12, "px")
      });
    }
  };
  TimeBarTooltip2.prototype.hide = function() {
    modifyCSS(this.container, {
      top: 0,
      left: 0,
      visibility: "hidden"
    });
  };
  return TimeBarTooltip2;
}();
var timeBarTooltip_default = TimeBarTooltip;

// node_modules/@antv/g6-plugin/es/timeBar/timeBarSlice.js
var __assign12 = function() {
  __assign12 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign12.apply(this, arguments);
};
var transform12 = ext_exports.transform;
var DEFAULT_SELECTEDTICK_STYLE = {
  fill: "#5B8FF9"
};
var DEFAULT_UNSELECTEDTICK_STYLE = {
  fill: "#e6e8e9"
};
var TimeBarSlice = function() {
  function TimeBarSlice2(cfgs) {
    this.frameCount = 0;
    this.fontFamily = "Arial, sans-serif";
    var graph = cfgs.graph, canvas = cfgs.canvas, group = cfgs.group, width = cfgs.width, height = cfgs.height, padding = cfgs.padding, data = cfgs.data, start = cfgs.start, end2 = cfgs.end, _a2 = cfgs.x, x2 = _a2 === void 0 ? 0 : _a2, _b = cfgs.y, y2 = _b === void 0 ? 0 : _b, tickLabelFormatter = cfgs.tickLabelFormatter, _c = cfgs.selectedTickStyle, selectedTickStyle = _c === void 0 ? DEFAULT_SELECTEDTICK_STYLE : _c, _d = cfgs.unselectedTickStyle, unselectedTickStyle = _d === void 0 ? DEFAULT_UNSELECTEDTICK_STYLE : _d, tooltipBackgroundColor = cfgs.tooltipBackgroundColor, tooltipFomatter = cfgs.tooltipFomatter, tickLabelStyle = cfgs.tickLabelStyle;
    this.graph = graph;
    this.group = group;
    this.sliceGroup = group.addGroup({
      name: "slice-group"
    });
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this.padding = padding;
    this.data = data;
    this.start = start;
    this.end = end2;
    this.tickLabelFormatter = tickLabelFormatter;
    this.tickLabelStyle = tickLabelStyle || {};
    this.selectedTickStyle = selectedTickStyle;
    this.unselectedTickStyle = unselectedTickStyle;
    this.x = x2;
    this.y = y2;
    this.tooltipBackgroundColor = tooltipBackgroundColor;
    this.tooltipFomatter = tooltipFomatter;
    this.fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
    this.renderSlices();
    this.initEvent();
  }
  TimeBarSlice2.prototype.renderSlices = function() {
    var _this = this;
    var _a2 = this, width = _a2.width, height = _a2.height, padding = _a2.padding, data = _a2.data, start = _a2.start, end2 = _a2.end, tickLabelFormatter = _a2.tickLabelFormatter, selectedTickStyle = _a2.selectedTickStyle, unselectedTickStyle = _a2.unselectedTickStyle, tickLabelStyle = _a2.tickLabelStyle;
    var realWidth = width - 2 * padding;
    var fontSize = 10;
    var labelLineHeight = 4;
    var labelAreaHeight = 3 * padding + labelLineHeight + fontSize;
    var ticksAreaHeight = height - labelAreaHeight - 2 * padding;
    var gap = 2;
    var ticksLength = data.length;
    var tickWidth = (realWidth - gap * (ticksLength - 1)) / ticksLength;
    this.tickWidth = tickWidth;
    var sliceGroup = this.sliceGroup;
    var tickRects = [];
    var labels = [];
    var startTickId = Math.round(ticksLength * start);
    var endTickId = Math.round(ticksLength * end2);
    this.startTickRectId = startTickId;
    this.endTickRectId = endTickId;
    var rotate7 = tickLabelStyle.rotate;
    delete tickLabelStyle.rotate;
    data.forEach(function(d2, i2) {
      var selected = i2 >= startTickId && i2 <= endTickId;
      var tickStyle = selected ? selectedTickStyle : unselectedTickStyle;
      var rect2 = sliceGroup.addShape("rect", {
        attrs: __assign12({
          x: padding + i2 * (tickWidth + gap),
          y: padding,
          width: tickWidth,
          height: ticksAreaHeight
        }, tickStyle),
        draggable: true,
        name: "tick-rect-".concat(i2)
      });
      var pickRect = sliceGroup.addShape("rect", {
        attrs: {
          x: padding + i2 * tickWidth + gap * (2 * i2 - 1) / 2,
          y: padding,
          width: i2 === 0 || i2 === ticksLength - 1 ? tickWidth + gap / 2 : tickWidth + gap,
          height: ticksAreaHeight,
          fill: "#fff",
          opacity: 0
        },
        draggable: true,
        name: "pick-rect-".concat(i2)
      });
      pickRect.toFront();
      var rectBBox = rect2.getBBox();
      var centerX = (rectBBox.minX + rectBBox.maxX) / 2;
      tickRects.push({
        rect: rect2,
        pickRect,
        value: d2.date,
        x: centerX,
        y: rectBBox.minY
      });
      var label;
      if (tickLabelFormatter) {
        label = tickLabelFormatter(d2);
        if (!is_string_default(label) && label) {
          label = d2.date;
        }
      } else if (i2 % Math.round(ticksLength / 10) === 0) {
        label = d2.date;
      }
      if (label) {
        labels.push(label);
        var lineStartY = rectBBox.maxY + padding * 2;
        sliceGroup.addShape("line", {
          attrs: {
            stroke: "#BFBFBF",
            x1: centerX,
            y1: lineStartY,
            x2: centerX,
            y2: lineStartY + labelLineHeight
          },
          name: "tick-line"
        });
        var labelStartY = lineStartY + labelLineHeight + padding;
        var text = sliceGroup.addShape("text", {
          attrs: __assign12({
            fill: "#8c8c8c",
            stroke: "#fff",
            lineWidth: 1,
            x: centerX,
            y: labelStartY,
            textAlign: "center",
            text: label,
            textBaseline: "top",
            fontSize: 10,
            fontFamily: _this.fontFamily || "Arial, sans-serif"
          }, tickLabelStyle),
          capture: false,
          name: "tick-label"
        });
        var textBBox = text.getBBox();
        if (textBBox.maxX > width) {
          text.attr("textAlign", "right");
        } else if (textBBox.minX < 0) {
          text.attr("textAlign", "left");
        }
        if (is_number_default(rotate7) && labels.length !== 10) {
          var matrix = transform12([1, 0, 0, 0, 1, 0, 0, 0, 1], [["t", -centerX, -labelStartY], ["r", rotate7], ["t", centerX - 5, labelStartY + 2]]);
          text.attr({
            textAlign: "left",
            matrix
          });
        }
        if (labels.length === 1) {
          text.attr({
            textAlign: "left"
          });
        } else if (labels.length === 10) {
          text.attr({
            textAlign: "right"
          });
        }
      }
    });
    this.tickRects = tickRects;
    var group = this.group;
    this.currentSpeed = 1;
    this.controllerBtnGroup = new controllerBtn_default({
      group,
      x: this.x,
      y: this.y + height + 5,
      width,
      height: 40,
      hideTimeTypeController: true,
      speed: this.currentSpeed,
      fontFamily: this.fontFamily || "Arial, sans-serif"
    });
  };
  TimeBarSlice2.prototype.initEvent = function() {
    var _this = this;
    var sliceGroup = this.sliceGroup;
    sliceGroup.on("click", function(e8) {
      var targetRect = e8.target;
      if (targetRect.get("type") !== "rect" || !targetRect.get("name"))
        return;
      var id2 = parseInt(targetRect.get("name").split("-")[2], 10);
      if (!isNaN(id2)) {
        var tickRects_1 = _this.tickRects;
        var unselectedTickStyle_1 = _this.unselectedTickStyle;
        tickRects_1.forEach(function(tickRect) {
          tickRect.rect.attr(unselectedTickStyle_1);
        });
        var selectedTickStyle = _this.selectedTickStyle;
        tickRects_1[id2].rect.attr(selectedTickStyle);
        _this.startTickRectId = id2;
        _this.endTickRectId = id2;
        var ticksLength = tickRects_1.length;
        var start = id2 / ticksLength;
        _this.graph.emit(VALUE_CHANGE, {
          value: [start, start]
        });
      }
    });
    sliceGroup.on("dragstart", function(e8) {
      var tickRects2 = _this.tickRects;
      var unselectedTickStyle = _this.unselectedTickStyle;
      tickRects2.forEach(function(tickRect) {
        tickRect.rect.attr(unselectedTickStyle);
      });
      var targetRect = e8.target;
      var id2 = parseInt(targetRect.get("name").split("-")[2], 10);
      var selectedTickStyle = _this.selectedTickStyle;
      tickRects2[id2].rect.attr(selectedTickStyle);
      _this.startTickRectId = id2;
      var ticksLength = tickRects2.length;
      var start = id2 / ticksLength;
      _this.graph.emit(VALUE_CHANGE, {
        value: [start, start]
      });
      _this.dragging = true;
    });
    sliceGroup.on("dragover", function(e8) {
      if (!_this.dragging)
        return;
      if (e8.target.get("type") !== "rect")
        return;
      var id2 = parseInt(e8.target.get("name").split("-")[2], 10);
      var startTickRectId = _this.startTickRectId;
      var tickRects2 = _this.tickRects;
      var selectedTickStyle = _this.selectedTickStyle;
      var unselectedTickStyle = _this.unselectedTickStyle;
      for (var i2 = 0; i2 < tickRects2.length; i2++) {
        var style = i2 >= startTickRectId && i2 <= id2 ? selectedTickStyle : unselectedTickStyle;
        tickRects2[i2].rect.attr(style);
      }
      var ticksLength = tickRects2.length;
      _this.endTickRectId = id2;
      var start = startTickRectId / ticksLength;
      var end2 = id2 / ticksLength;
      _this.graph.emit(VALUE_CHANGE, {
        value: [start, end2]
      });
    });
    sliceGroup.on("drop", function(e8) {
      if (!_this.dragging)
        return;
      _this.dragging = false;
      if (e8.target.get("type") !== "rect")
        return;
      var startTickRectId = _this.startTickRectId;
      var id2 = parseInt(e8.target.get("name").split("-")[2], 10);
      if (id2 < startTickRectId)
        return;
      var selectedTickStyle = _this.selectedTickStyle;
      var tickRects2 = _this.tickRects;
      tickRects2[id2].rect.attr(selectedTickStyle);
      _this.endTickRectId = id2;
      var ticksLength = tickRects2.length;
      var start = startTickRectId / ticksLength;
      var end2 = id2 / ticksLength;
      _this.graph.emit(VALUE_CHANGE, {
        value: [start, end2]
      });
    });
    var _a2 = this, tooltipBackgroundColor = _a2.tooltipBackgroundColor, tooltipFomatter = _a2.tooltipFomatter, canvas = _a2.canvas;
    var tooltip = new timeBarTooltip_default({
      container: canvas.get("container"),
      backgroundColor: tooltipBackgroundColor
    });
    var tickRects = this.tickRects;
    tickRects.forEach(function(tickRect) {
      var pickRect = tickRect.pickRect;
      pickRect.on("mouseenter", function(e8) {
        var rect2 = e8.target;
        if (rect2.get("type") !== "rect")
          return;
        var id2 = parseInt(rect2.get("name").split("-")[2], 10);
        var clientPoint = canvas.getClientByPoint(tickRects[id2].x, tickRects[id2].y);
        tooltip.show({
          x: tickRects[id2].x,
          y: tickRects[id2].y,
          clientX: clientPoint.x,
          clientY: clientPoint.y,
          text: tooltipFomatter ? tooltipFomatter(tickRects[id2].value) : tickRects[id2].value
        });
      });
      pickRect.on("mouseleave", function(e8) {
        tooltip.hide();
      });
    });
    var group = this.group;
    group.on("".concat(PLAY_PAUSE_BTN, ":click"), function() {
      _this.isPlay = !_this.isPlay;
      _this.changePlayStatus();
    });
    group.on("".concat(NEXT_STEP_BTN, ":click"), function() {
      _this.updateStartEnd(1);
    });
    group.on("".concat(PRE_STEP_BTN, ":click"), function() {
      _this.updateStartEnd(-1);
    });
    group.on(TIMEBAR_CONFIG_CHANGE, function(_a3) {
      var type = _a3.type, speed = _a3.speed;
      _this.currentSpeed = speed;
    });
  };
  TimeBarSlice2.prototype.changePlayStatus = function(isSync) {
    if (isSync === void 0) {
      isSync = true;
    }
    this.controllerBtnGroup.playButton.update({
      isPlay: this.isPlay
    });
    if (this.isPlay) {
      this.playHandler = this.startPlay();
      this.graph.emit(TIMELINE_START, null);
    } else {
      if (this.playHandler) {
        if (typeof window !== "undefined")
          window.cancelAnimationFrame(this.playHandler);
        if (isSync) {
          this.graph.emit(TIMELINE_END, null);
        }
      }
    }
  };
  TimeBarSlice2.prototype.startPlay = function() {
    var _this = this;
    return typeof window !== "undefined" ? window.requestAnimationFrame(function() {
      var speed = _this.currentSpeed;
      if (_this.frameCount % (60 / speed) === 0) {
        _this.frameCount = 0;
        _this.updateStartEnd(1);
      }
      _this.frameCount++;
      if (_this.isPlay) {
        _this.playHandler = _this.startPlay();
      }
    }) : void 0;
  };
  TimeBarSlice2.prototype.updateStartEnd = function(sign) {
    var self2 = this;
    var tickRects = this.tickRects;
    var ticksLength = tickRects.length;
    var unselectedTickStyle = this.unselectedTickStyle;
    var selectedTickStyle = this.selectedTickStyle;
    var previousEndTickRectId = self2.endTickRectId;
    if (sign > 0) {
      self2.endTickRectId++;
    } else {
      tickRects[self2.endTickRectId].rect.attr(unselectedTickStyle);
      self2.endTickRectId--;
    }
    if (previousEndTickRectId !== self2.startTickRectId) {
      if (self2.endTickRectId < self2.startTickRectId) {
        self2.startTickRectId = self2.endTickRectId;
      }
    } else {
      for (var i2 = self2.startTickRectId; i2 <= self2.endTickRectId - 1; i2++) {
        tickRects[i2].rect.attr(unselectedTickStyle);
      }
      self2.startTickRectId = self2.endTickRectId;
    }
    if (tickRects[self2.endTickRectId]) {
      tickRects[self2.endTickRectId].rect.attr(selectedTickStyle);
      var start = self2.startTickRectId / ticksLength;
      var end2 = self2.endTickRectId / ticksLength;
      this.graph.emit(VALUE_CHANGE, {
        value: [start, end2]
      });
    }
  };
  TimeBarSlice2.prototype.destory = function() {
    this.graph.off(VALUE_CHANGE, function() {
    });
    var group = this.sliceGroup;
    group.off("click");
    group.off("dragstart");
    group.off("dragover");
    group.off("drop");
    this.tickRects.forEach(function(tickRect) {
      var pickRect = tickRect.pickRect;
      pickRect.off("mouseenter");
      pickRect.off("mouseleave");
    });
    this.tickRects.length = 0;
    group.off("".concat(PLAY_PAUSE_BTN, ":click"));
    group.off("".concat(NEXT_STEP_BTN, ":click"));
    group.off("".concat(PRE_STEP_BTN, ":click"));
    group.off(TIMEBAR_CONFIG_CHANGE);
    this.sliceGroup.destroy();
  };
  return TimeBarSlice2;
}();
var timeBarSlice_default = TimeBarSlice;

// node_modules/@antv/g6-plugin/es/timeBar/index.js
init_esm();
var __extends14 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign13 = function() {
  __assign13 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign13.apply(this, arguments);
};
var __rest4 = function(s2, e8) {
  var t4 = {};
  for (var p2 in s2) {
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e8.indexOf(p2) < 0)
      t4[p2] = s2[p2];
  }
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e8.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t4[p2[i2]] = s2[p2[i2]];
    }
  return t4;
};
var DEFAULT_SIMPLE_HEIGHT = 4;
var DEFAULT_TREND_HEIGHT = 26;
var TimeBar = function(_super) {
  __extends14(TimeBar3, _super);
  function TimeBar3(config) {
    return _super.call(this, config) || this;
  }
  TimeBar3.prototype.getDefaultCfgs = function() {
    return {
      container: null,
      className: "g6-component-timebar",
      padding: 10,
      type: "trend",
      trend: {
        data: [],
        isArea: false,
        smooth: true
      },
      controllerCfg: {
        speed: 1,
        loop: false
      },
      slider: {
        start: 0.1,
        end: 0.9,
        minText: "min",
        maxText: "max"
      },
      tick: {
        start: 0.1,
        end: 0.9,
        data: []
      },
      textStyle: {},
      filterEdge: false,
      filterItemTypes: ["node"],
      containerCSS: {}
    };
  };
  TimeBar3.prototype.initContainer = function() {
    var graph = this.get("graph");
    var _a2 = this._cfgs, width = _a2.width, height = _a2.height;
    var className = this.get("className") || "g6-component-timebar";
    var container2 = this.get("container");
    var graphContainer = this.get("graph").get("container");
    var timeBarContainer;
    if (!container2) {
      timeBarContainer = createDom2("<div class='".concat(className, "'></div>"));
      modifyCSS(timeBarContainer, {
        position: "relative"
      });
    } else {
      if (is_string_default(container2)) {
        container2 = document.getElementById(container2);
      }
      timeBarContainer = container2;
    }
    graphContainer.appendChild(timeBarContainer);
    this.set("timeBarContainer", timeBarContainer);
    var canvas;
    var renderer = graph.get("renderer");
    if (renderer === "SVG") {
      canvas = new canvas_default3({
        container: timeBarContainer,
        width,
        height
      });
    } else {
      canvas = new canvas_default2({
        container: timeBarContainer,
        width,
        height
      });
    }
    if (this.get("containerCSS"))
      modifyCSS(timeBarContainer, this.get("containerCSS"));
    this.set("canvas", canvas);
  };
  TimeBar3.prototype.init = function() {
    this.initContainer();
    var canvas = this.get("canvas");
    var timeBarGroup = canvas.addGroup({
      name: "timebar-group"
    });
    this.set("timeBarGroup", timeBarGroup);
    this.renderTrend();
    this.initEvent();
    var fontFamily = typeof window !== "undefined" ? window.getComputedStyle(document.body, null).getPropertyValue("font-family") || "Arial, sans-serif" : "Arial, sans-serif";
    this.set("fontFamily", fontFamily);
  };
  TimeBar3.prototype.renderTrend = function() {
    var _this = this;
    var _a2 = this._cfgs, width = _a2.width, x2 = _a2.x, y2 = _a2.y, padding = _a2.padding, type = _a2.type, trend = _a2.trend, slider = _a2.slider, controllerCfg = _a2.controllerCfg, textStyle = _a2.textStyle, tick = _a2.tick, backgroundStyle = _a2.backgroundStyle, foregroundStyle = _a2.foregroundStyle;
    var data = trend.data, other = __rest4(trend, ["data"]);
    var realWidth = width - 2 * padding;
    var defaultHeight = type === "trend" ? DEFAULT_TREND_HEIGHT : DEFAULT_SIMPLE_HEIGHT;
    var graph = this.get("graph");
    var group = this.get("timeBarGroup");
    var canvas = this.get("canvas");
    var timebar = null;
    if (type === "trend" || type === "simple") {
      var getValue_1 = this.get("getValue");
      timebar = new trendTimeBar_default(__assign13(__assign13({
        graph,
        canvas,
        group,
        type,
        x: x2 + padding,
        y: type === "trend" ? y2 + padding : y2 + padding + 15,
        width: realWidth,
        height: defaultHeight,
        padding,
        backgroundStyle,
        foregroundStyle,
        trendCfg: __assign13(__assign13({}, other), {
          data: data.map(function(d2) {
            return (getValue_1 === null || getValue_1 === void 0 ? void 0 : getValue_1(d2)) || d2.value;
          })
        })
      }, slider), {
        tick: {
          ticks: data,
          tickLabelFormatter: tick.tickLabelFormatter,
          tickLabelStyle: tick.tickLabelStyle,
          tickLineStyle: tick.tickLineStyle
        },
        handlerStyle: __assign13(__assign13({}, slider.handlerStyle), {
          height: slider.height || defaultHeight
        }),
        controllerCfg,
        textStyle
      }));
    } else if (type === "tick") {
      timebar = new timeBarSlice_default(__assign13({
        graph,
        canvas,
        group,
        x: x2 + padding,
        y: y2 + padding,
        width,
        height: 42,
        padding: 2
      }, tick));
    }
    var handleMouseUp = function handleMouseUp2() {
      var timebarInstance = _this.get("timebar");
      timebarInstance.draggingHandler = false;
      if (timebarInstance.isPlay) {
        timebarInstance.isPlay = false;
        timebarInstance.currentHandler = timebarInstance.maxHandlerShape;
        timebarInstance.changePlayStatus();
      }
      document.removeEventListener("mouseup", handleMouseUp2);
    };
    canvas.on("mousedown", function(e8) {
      if (e8.target.get("name") === "maxHandlerShape-handler" || e8.target.get("name") === "minHandlerShape-handler" || e8.target === timebar.foregroundShape) {
        document.addEventListener("mouseup", handleMouseUp);
      }
    });
    this.set("timebar", timebar);
  };
  TimeBar3.prototype.filterData = function(evt) {
    var _a2;
    var value = evt.value;
    var trendData = null;
    var type = this._cfgs.type;
    if (type === "trend" || type === "simple") {
      trendData = this._cfgs.trend.data;
    } else if (type === "tick") {
      trendData = this._cfgs.tick.data;
    }
    if (!trendData || trendData.length === 0) {
      console.warn("\u8BF7\u914D\u7F6E TimeBar \u7EC4\u4EF6\u7684\u6570\u636E");
      return;
    }
    var rangeChange = this.get("rangeChange");
    var graph = this.get("graph");
    var min6 = Math.round(trendData.length * value[0]);
    var max7 = Math.round(trendData.length * value[1]);
    max7 = max7 >= trendData.length ? trendData.length - 1 : max7;
    min6 = min6 >= trendData.length ? trendData.length - 1 : min6;
    var tickLabelFormatter = (_a2 = this._cfgs.tick) === null || _a2 === void 0 ? void 0 : _a2.tickLabelFormatter;
    var minText = tickLabelFormatter ? tickLabelFormatter(trendData[min6]) : trendData[min6].date;
    var maxText = tickLabelFormatter ? tickLabelFormatter(trendData[max7]) : trendData[max7].date;
    if (type !== "tick") {
      var timebar = this.get("timebar");
      timebar.setText(minText, maxText);
    }
    if (rangeChange) {
      rangeChange(graph, minText, maxText);
    } else {
      if (!this.cacheGraphData || this.cacheGraphData.nodes && this.cacheGraphData.nodes.length === 0) {
        this.cacheGraphData = graph.get("data");
      }
      var filterItemTypes = this.get("filterItemTypes");
      var changeData = this.get("changeData");
      var getDate_1 = this.get("getDate");
      var shouldIgnore_1 = this.get("shouldIgnore");
      var minDate_1 = trendData[min6].date, maxDate_1 = trendData[max7].date;
      if (changeData || changeData === void 0) {
        var filterNodes = this.cacheGraphData.nodes;
        var filterEdges = this.cacheGraphData.edges;
        if (filterItemTypes.includes("node")) {
          filterNodes = filterNodes.filter(function(node) {
            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(node)) || node.date);
            return date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", node, {
              min: minDate_1,
              max: maxDate_1
            }));
          });
          var nodeIds_1 = filterNodes.map(function(node) {
            return node.id;
          });
          if (filterEdges) {
            filterEdges = filterEdges.filter(function(edge) {
              return nodeIds_1.includes(edge.source) && nodeIds_1.includes(edge.target) || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
                min: minDate_1,
                max: maxDate_1
              }));
            });
          }
        }
        if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
          filterEdges = filterEdges.filter(function(edge) {
            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(edge)) || edge.date);
            return date >= minDate_1 && date <= maxDate_1 || (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", edge, {
              min: minDate_1,
              max: maxDate_1
            }));
          });
        }
        graph.changeData({
          nodes: filterNodes,
          edges: filterEdges
        });
      } else {
        if (filterItemTypes.includes("node")) {
          graph.getNodes().forEach(function(node) {
            var model = node.getModel();
            if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("node", model, {
              min: minDate_1,
              max: maxDate_1
            }))
              return;
            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
            if (date < minDate_1 || date > maxDate_1) {
              graph.hideItem(node);
            } else {
              graph.showItem(node);
            }
          });
        }
        if (this.get("filterEdge") || filterItemTypes.includes("edge")) {
          graph.getEdges().forEach(function(edge) {
            var model = edge.getModel();
            if (shouldIgnore_1 === null || shouldIgnore_1 === void 0 ? void 0 : shouldIgnore_1("edge", model, {
              min: trendData[min6].date,
              max: trendData[max7].date
            }))
              return;
            var date = +((getDate_1 === null || getDate_1 === void 0 ? void 0 : getDate_1(model)) || model.date);
            if (date < trendData[min6].date || date > trendData[max7].date) {
              graph.hideItem(edge);
            } else {
              graph.showItem(edge);
            }
          });
        }
      }
    }
  };
  TimeBar3.prototype.initEvent = function() {
    var _this = this;
    var start = 0;
    var end2 = 0;
    var type = this._cfgs.type;
    if (!type || type === "trend" || type === "simple") {
      start = this._cfgs.slider.start;
      end2 = this._cfgs.slider.end;
    } else if (type === "tick") {
      start = this._cfgs.tick.start;
      end2 = this._cfgs.tick.end;
    }
    var graph = this.get("graph");
    graph.on("afterrender", function(e8) {
      _this.filterData({
        value: [start, end2]
      });
    });
    graph.on(VALUE_CHANGE, throttle_default(function(e8) {
      _this.filterData(e8);
    }, 200, {
      trailing: true,
      leading: true
    }));
  };
  TimeBar3.prototype.destroy = function() {
    var timebar = this.get("timebar");
    if (timebar && timebar.destory) {
      timebar.destory();
    }
    _super.prototype.destroy.call(this);
    var timeBarContainer = this.get("timeBarContainer");
    if (timeBarContainer) {
      var container2 = this.get("container");
      if (!container2) {
        container2 = this.get("graph").get("container");
      }
      if (is_string_default(container2)) {
        container2 = document.getElementById(container2);
      }
      container2.removeChild(timeBarContainer);
    }
  };
  return TimeBar3;
}(base_default4);
var timeBar_default = TimeBar;

// node_modules/@antv/g6-plugin/es/imageMinimap/index.js
init_esm();
var __extends15 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var applyMatrix3 = util_default.applyMatrix;
function getImgNaturalDimension(img, callback) {
  var nWidth, nHeight;
  if (img.naturalWidth) {
    nWidth = img.naturalWidth;
    nHeight = img.naturalHeight;
  } else {
    var image_1 = new Image();
    image_1.src = img.src;
    image_1.onload = function() {
      if (callback)
        callback(image_1.width, image_1.height);
    };
  }
  return [nWidth, nHeight];
}
var ImageMiniMap = function(_super) {
  __extends15(ImageMiniMap2, _super);
  function ImageMiniMap2(config) {
    return _super.call(this, config) || this;
  }
  ImageMiniMap2.prototype.getDefaultCfgs = function() {
    return {
      container: null,
      className: "g6-minimap",
      viewportClassName: "g6-minimap-viewport",
      width: 200,
      delegateStyle: {
        fill: "#40a9ff",
        stroke: "#096dd9"
      },
      refresh: true
    };
  };
  ImageMiniMap2.prototype.getEvents = function() {
    return {
      beforepaint: "updateViewport",
      beforeanimate: "disableRefresh",
      afteranimate: "enableRefresh",
      viewportchange: "disableOneRefresh"
    };
  };
  ImageMiniMap2.prototype.disableRefresh = function() {
    this.set("refresh", false);
  };
  ImageMiniMap2.prototype.enableRefresh = function() {
    this.set("refresh", true);
    this.updateCanvas();
  };
  ImageMiniMap2.prototype.disableOneRefresh = function() {
    this.set("viewportChange", true);
  };
  ImageMiniMap2.prototype.initViewport = function() {
    var _this = this;
    var cfgs = this._cfgs;
    var graph = cfgs.graph;
    if (this.destroyed)
      return;
    var containerDOM = this.get("container");
    if (is_string_default(containerDOM)) {
      containerDOM = document.getElementById(containerDOM);
    }
    var viewport = createDom2("<div class=".concat(cfgs.viewportClassName, "\n      style='position:absolute;\n        left:0;\n        top:0;\n        box-sizing:border-box;\n        border: 2px solid #1980ff'>\n      </div>"));
    var x2 = 0;
    var y2 = 0;
    var dragging = false;
    var left = 0;
    var top = 0;
    var width = 0;
    var height = 0;
    var ratio = 0;
    var zoom = 0;
    containerDOM.addEventListener("mousedown", function(e8) {
      cfgs.refresh = false;
      if (e8.target !== viewport) {
        return;
      }
      var style = viewport.style;
      width = parseInt(style.width, 10);
      height = parseInt(style.height, 10);
      var cWidth = _this.get("width");
      var cHeight = _this.get("height");
      if (width > cWidth || height > cHeight) {
        return;
      }
      zoom = graph.getZoom();
      ratio = _this.get("ratio");
      dragging = true;
      x2 = e8.clientX;
      y2 = e8.clientY;
    }, false);
    containerDOM.addEventListener("mousemove", function(e8) {
      if (!dragging || is_nil_default(e8.clientX) || is_nil_default(e8.clientY)) {
        return;
      }
      var cWidth = _this.get("width");
      var cHeight = _this.get("height");
      var style = viewport.style;
      left = parseInt(style.left, 10);
      top = parseInt(style.top, 10);
      width = parseInt(style.width, 10);
      height = parseInt(style.height, 10);
      var dx = x2 - e8.clientX;
      var dy = y2 - e8.clientY;
      if (left - dx < 0) {
        dx = left;
      } else if (left - dx + width >= cWidth) {
        dx = 0;
      }
      if (top - dy < 0) {
        dy = top;
      } else if (top - dy + height >= cHeight) {
        dy = 0;
      }
      left -= dx;
      top -= dy;
      modifyCSS(viewport, {
        left: "".concat(left, "px"),
        top: "".concat(top, "px")
      });
      graph.translate(dx * zoom / ratio, dy * zoom / ratio);
      x2 = e8.clientX;
      y2 = e8.clientY;
    }, false);
    containerDOM.addEventListener("mouseleave", function() {
      dragging = false;
      cfgs.refresh = true;
    }, false);
    containerDOM.addEventListener("mouseup", function() {
      dragging = false;
      cfgs.refresh = true;
    }, false);
    this.set("viewport", viewport);
    containerDOM.appendChild(viewport);
  };
  ImageMiniMap2.prototype.updateViewport = function() {
    if (this.destroyed)
      return;
    var ratio = this.get("ratio");
    var cWidth = this.get("width");
    var cHeight = this.get("height");
    var graph = this.get("graph");
    var graphWidth = graph.get("width");
    var graphHeight = graph.get("height");
    var aspectRatio = graphWidth / graphHeight;
    var graphGroup = graph.getGroup();
    var graphCanvasBBox = graphGroup.getCanvasBBox();
    var graphCanvasBBoxMean = [(graphCanvasBBox.minX + graphCanvasBBox.maxX) / 2, (graphCanvasBBox.minY + graphCanvasBBox.maxY) / 2];
    var graphCanvasBBoxSize = [graphCanvasBBox.maxX - graphCanvasBBox.minX, graphCanvasBBox.maxY - graphCanvasBBox.minY];
    var expandedGraphCanvasBBox = {
      centerX: graphCanvasBBoxMean[0],
      centerY: graphCanvasBBoxMean[1],
      width: 0,
      height: 0,
      minX: 0,
      minY: 0
    };
    if (graphCanvasBBox[0] / graphCanvasBBox[1] > aspectRatio) {
      expandedGraphCanvasBBox.width = graphCanvasBBoxSize[0];
      expandedGraphCanvasBBox.height = expandedGraphCanvasBBox.width / aspectRatio;
    } else {
      expandedGraphCanvasBBox.height = graphCanvasBBoxSize[1];
      expandedGraphCanvasBBox.width = expandedGraphCanvasBBox.height * aspectRatio;
    }
    expandedGraphCanvasBBox.minX = graphCanvasBBoxMean[0] - expandedGraphCanvasBBox.width / 2;
    expandedGraphCanvasBBox.minY = graphCanvasBBoxMean[1] - expandedGraphCanvasBBox.height / 2;
    var graphMatrix = graphGroup.getMatrix();
    if (!graphMatrix)
      graphMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var invertGraphMatrix = mat3_exports.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], graphMatrix);
    var minXY = applyMatrix3({
      x: expandedGraphCanvasBBox.minX,
      y: expandedGraphCanvasBBox.minY
    }, invertGraphMatrix);
    var topLeft = graph.getCanvasByPoint(minXY.x, minXY.y);
    var viewport = this.get("viewport");
    if (!viewport) {
      this.initViewport();
    }
    var vpToMc = graphWidth / expandedGraphCanvasBBox.width;
    var width = vpToMc * cWidth;
    var height = vpToMc * cHeight;
    var left = cWidth * -topLeft.x / expandedGraphCanvasBBox.width;
    var top = cHeight * -topLeft.y / expandedGraphCanvasBBox.height;
    var right = left + width;
    var bottom = top + height;
    if (left < 0) {
      width += left;
      left = 0;
    }
    if (right > cWidth) {
      width = width - (right - cWidth);
    }
    if (top < 0) {
      height += top;
      top = 0;
    }
    if (bottom > cHeight) {
      height = height - (bottom - cHeight);
    }
    this.set("ratio", ratio);
    var correctLeft = "".concat(left, "px");
    var correctTop = "".concat(top, "px");
    modifyCSS(viewport, {
      left: correctLeft,
      top: correctTop,
      width: "".concat(width, "px"),
      height: "".concat(height, "px")
    });
  };
  ImageMiniMap2.prototype.init = function() {
    this.initContainer();
  };
  ImageMiniMap2.prototype.initContainer = function() {
    var self2 = this;
    var graph = self2.get("graph");
    var graphWidth = graph.get("width");
    var graphHeight = graph.get("height");
    var aspectRatio = graphHeight / graphWidth;
    var className = self2.get("className");
    var parentNode = self2.get("container");
    var cWidth = self2.get("width");
    var cHeight = self2.get("height");
    if (!cWidth && !cHeight) {
      cWidth = 200;
    }
    if (cWidth) {
      cHeight = aspectRatio * cWidth;
      self2.set("height", cHeight);
    } else {
      cWidth = 1 / aspectRatio * cHeight;
      self2.set("width", cWidth);
    }
    var container2 = createDom2("<div class='".concat(className, "' style='width: ").concat(cWidth, "px; height: ").concat(cHeight, "px; overflow: hidden; position: relative;'></div>"));
    if (is_string_default(parentNode)) {
      parentNode = document.getElementById(parentNode);
    }
    if (parentNode) {
      parentNode.appendChild(container2);
    } else {
      graph.get("container").appendChild(container2);
    }
    self2.set("container", container2);
    var containerDOM = createDom2('<div class="g6-minimap-container" style="position: relative; width: 100%; height: 100%; text-align: center; display: table;"></div>');
    container2.appendChild(containerDOM);
    var span = createDom2('<span style="display: table-cell; vertical-align: middle; "></span>');
    containerDOM.appendChild(span);
    self2.set("containerDOM", containerDOM);
    self2.set("containerSpan", span);
    var img = createDom2('<img alt="" src="'.concat(this.get("graphImg"), '" style="display: inline-block; user-select: none;" draggable="false" />'));
    self2.set("imgDOM", img);
    self2.updateImgSize();
    span.appendChild(img);
    self2.updateCanvas();
  };
  ImageMiniMap2.prototype.updateImgSize = function() {
    var self2 = this;
    var imgDOM = self2.get("imgDOM");
    var cWidth = self2.get("width");
    var cHeight = self2.get("height");
    imgDOM.onload = function() {
      var naturalSize = getImgNaturalDimension(imgDOM);
      if (naturalSize[0] > naturalSize[1]) {
        imgDOM.width = cWidth;
      } else {
        imgDOM.height = cHeight;
      }
    };
  };
  ImageMiniMap2.prototype.updateCanvas = function() {
    var isRefresh = this.get("refresh");
    if (!isRefresh) {
      return;
    }
    var graph = this.get("graph");
    if (graph.get("destroyed")) {
      return;
    }
    if (this.get("viewportChange")) {
      this.set("viewportChange", false);
      this.updateViewport();
    }
    var cWidth = this.get("width");
    var graphBBox = graph.get("canvas").getCanvasBBox();
    var width = graphBBox.width;
    var ratio = cWidth / width;
    this.set("ratio", ratio);
    this.updateViewport();
  };
  ImageMiniMap2.prototype.getViewport = function() {
    return this.get("viewport");
  };
  ImageMiniMap2.prototype.getContainer = function() {
    return this.get("container");
  };
  ImageMiniMap2.prototype.updateGraphImg = function(img) {
    var self2 = this;
    var oriImgDOM = self2.get("imgDOM");
    oriImgDOM.remove();
    self2.set("graphImg", img);
    var imgDOM = createDom2('<img alt="" src="'.concat(img, '" style="display: inline-block;" ondragstart="return false;" onselectstart="return false;"/>'));
    self2.set("imgDOM", imgDOM);
    imgDOM.src = img;
    self2.updateImgSize();
    var span = self2.get("containerSpan");
    span.appendChild(imgDOM);
    self2.updateCanvas();
  };
  ImageMiniMap2.prototype.destroy = function() {
    var container2 = this.get("container");
    container2.parentNode.removeChild(container2);
  };
  return ImageMiniMap2;
}(base_default4);
var imageMinimap_default = ImageMiniMap;

// node_modules/@antv/g6-plugin/es/edgeFilterLens/index.js
init_esm();
var __extends16 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign14 = function() {
  __assign14 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign14.apply(this, arguments);
};
var distance8 = util_default.distance;
var DELTA3 = 0.05;
var lensDelegateStyle2 = {
  stroke: "#000",
  strokeOpacity: 0.8,
  lineWidth: 2,
  fillOpacity: 1,
  fill: "#fff"
};
var EdgeFilterLens = function(_super) {
  __extends16(EdgeFilterLens3, _super);
  function EdgeFilterLens3(config) {
    return _super.call(this, config) || this;
  }
  EdgeFilterLens3.prototype.getDefaultCfgs = function() {
    return {
      type: "both",
      trigger: "mousemove",
      r: 60,
      delegateStyle: clone_default(lensDelegateStyle2),
      showLabel: "edge",
      scaleRBy: "wheel"
    };
  };
  EdgeFilterLens3.prototype.getEvents = function() {
    var events;
    switch (this.get("trigger")) {
      case "click":
        events = {
          click: "filter"
        };
        break;
      case "drag":
        events = {
          click: "createDelegate"
        };
        break;
      default:
        events = {
          mousemove: "filter"
        };
        break;
    }
    return events;
  };
  EdgeFilterLens3.prototype.init = function() {
    var self2 = this;
    var showLabel = self2.get("showLabel");
    var showNodeLabel = showLabel === "node" || showLabel === "both";
    var showEdgeLabel = showLabel === "edge" || showLabel === "both";
    self2.set("showNodeLabel", showNodeLabel);
    self2.set("showEdgeLabel", showEdgeLabel);
    var shouldShow = self2.get("shouldShow");
    if (!shouldShow)
      self2.set("shouldShow", function() {
        return true;
      });
  };
  EdgeFilterLens3.prototype.createDelegate = function(e8) {
    var self2 = this;
    var lensDelegate = self2.get("delegate");
    if (!lensDelegate || lensDelegate.destroyed) {
      self2.filter(e8);
      lensDelegate = self2.get("delegate");
      lensDelegate.on("dragstart", function(evt) {
      });
      lensDelegate.on("drag", function(evt) {
        self2.filter(evt);
      });
      if (this.get("scaleRBy") === "wheel") {
        lensDelegate.on("mousewheel", function(evt) {
          self2.scaleRByWheel(evt);
        });
      }
    }
  };
  EdgeFilterLens3.prototype.scaleRByWheel = function(e8) {
    var self2 = this;
    if (!e8 || !e8.originalEvent)
      return;
    if (e8.preventDefault)
      e8.preventDefault();
    var graph = self2.get("graph");
    var ratio;
    var lensDelegate = self2.get("delegate");
    var lensCenter = lensDelegate ? {
      x: lensDelegate.attr("x"),
      y: lensDelegate.attr("y")
    } : void 0;
    var mousePos = lensCenter || graph.getPointByClient(e8.clientX, e8.clientY);
    if (e8.originalEvent.wheelDelta < 0) {
      ratio = 1 - DELTA3;
    } else {
      ratio = 1 / (1 - DELTA3);
    }
    var maxR = self2.get("maxR");
    var minR = self2.get("minR");
    var r2 = self2.get("r");
    if (r2 > (maxR || graph.get("height")) && ratio > 1 || r2 < (minR || graph.get("height") * 0.05) && ratio < 1) {
      ratio = 1;
    }
    r2 *= ratio;
    self2.set("r", r2);
    self2.filter(e8);
  };
  EdgeFilterLens3.prototype.filter = function(e8) {
    var self2 = this;
    var graph = self2.get("graph");
    var nodes = graph.getNodes();
    var hitNodesMap = {};
    var r2 = self2.get("r");
    var type = self2.get("type");
    var fCenter = {
      x: e8.x,
      y: e8.y
    };
    self2.updateDelegate(fCenter, r2);
    var shouldShow = self2.get("shouldShow");
    var vShapes = self2.get("vShapes");
    if (vShapes) {
      vShapes.forEach(function(shape) {
        shape.remove();
        shape.destroy();
      });
    }
    vShapes = [];
    nodes.forEach(function(node) {
      var model = node.getModel();
      var x2 = model.x, y2 = model.y;
      if (distance8({
        x: x2,
        y: y2
      }, fCenter) < r2) {
        hitNodesMap[model.id] = node;
      }
    });
    var edges = graph.getEdges();
    var hitEdges = [];
    edges.forEach(function(edge) {
      var model = edge.getModel();
      var sourceId = model.source;
      var targetId = model.target;
      if (shouldShow(model)) {
        if (type === "only-source" || type === "one") {
          if (hitNodesMap[sourceId] && !hitNodesMap[targetId])
            hitEdges.push(edge);
        } else if (type === "only-target" || type === "one") {
          if (hitNodesMap[targetId] && !hitNodesMap[sourceId])
            hitEdges.push(edge);
        } else if (type === "both" && hitNodesMap[sourceId] && hitNodesMap[targetId]) {
          hitEdges.push(edge);
        }
      }
    });
    var showNodeLabel = self2.get("showNodeLabel");
    var showEdgeLabel = self2.get("showEdgelabel");
    var group = graph.get("group");
    hitEdges.forEach(function(edge) {
      var shapes = edge.get("group").get("children");
      shapes.forEach(function(shape) {
        var shapeType = shape.get("type");
        var vShape = group.addShape(shapeType, {
          attrs: shape.attr()
        });
        vShapes.push(vShape);
        if (showNodeLabel && shapeType === "text") {
          vShape.set("visible", true);
        }
      });
    });
    Object.keys(hitNodesMap).forEach(function(key) {
      var node = hitNodesMap[key];
      var clonedGroup = node.get("group").clone();
      group.add(clonedGroup);
      vShapes.push(clonedGroup);
      if (showEdgeLabel) {
        var shapes = clonedGroup.get("children");
        for (var j2 = 0; j2 < shapes.length; j2++) {
          var shape = shapes[j2];
          if (shape.get("type") === "text") {
            shape.set("visible", true);
          }
        }
      }
    });
    self2.set("vShapes", vShapes);
  };
  EdgeFilterLens3.prototype.updateParams = function(cfg) {
    var self2 = this;
    var r2 = cfg.r, trigger = cfg.trigger, minR = cfg.minR, maxR = cfg.maxR, scaleRBy = cfg.scaleRBy, showLabel = cfg.showLabel, shouldShow = cfg.shouldShow;
    if (!isNaN(cfg.r)) {
      self2.set("r", r2);
    }
    if (!isNaN(maxR)) {
      self2.set("maxR", maxR);
    }
    if (!isNaN(minR)) {
      self2.set("minR", minR);
    }
    if (trigger === "mousemove" || trigger === "click") {
      self2.set("trigger", trigger);
    }
    if (scaleRBy === "wheel" || scaleRBy === "unset") {
      self2.set("scaleRBy", scaleRBy);
      self2.get("delegate").remove();
      self2.get("delegate").destroy();
      var dPercentText = self2.get("dPercentText");
      if (dPercentText) {
        dPercentText.remove();
        dPercentText.destroy();
      }
    }
    if (showLabel === "node" || showLabel === "both") {
      self2.set("showNodeLabel", true);
    }
    if (showLabel === "edge" || showLabel === "both") {
      self2.set("showEdgeLabel", true);
    }
    if (shouldShow) {
      self2.set("shouldShow", shouldShow);
    }
  };
  EdgeFilterLens3.prototype.updateDelegate = function(mCenter, r2) {
    var self2 = this;
    var graph = self2.get("graph");
    var lensDelegate = self2.get("delegate");
    if (!lensDelegate || lensDelegate.destroyed) {
      var parent_1 = graph.get("group");
      var attrs = self2.get("delegateStyle") || lensDelegateStyle2;
      lensDelegate = parent_1.addShape("circle", {
        attrs: __assign14({
          r: r2,
          x: mCenter.x,
          y: mCenter.y
        }, attrs),
        name: "lens-shape",
        draggable: true
      });
      if (this.get("trigger") !== "drag") {
        if (this.get("scaleRBy") === "wheel") {
          lensDelegate.on("mousewheel", function(evt) {
            self2.scaleRByWheel(evt);
          });
        }
      }
    } else {
      lensDelegate.attr({
        x: mCenter.x,
        y: mCenter.y,
        r: r2
      });
    }
    self2.set("delegate", lensDelegate);
  };
  EdgeFilterLens3.prototype.clear = function() {
    var self2 = this;
    var vShapes = self2.get("vShapes");
    if (vShapes) {
      vShapes.forEach(function(shape) {
        shape.remove();
        shape.destroy();
      });
    }
    vShapes = [];
    self2.set("vShapes", vShapes);
    var lensDelegate = self2.get("delegate");
    if (lensDelegate && !lensDelegate.destroyed) {
      lensDelegate.remove();
      lensDelegate.destroy();
    }
  };
  EdgeFilterLens3.prototype.destroy = function() {
    this.clear();
  };
  return EdgeFilterLens3;
}(base_default4);
var edgeFilterLens_default = EdgeFilterLens;

// node_modules/@antv/g6-plugin/es/snapline/index.js
init_esm();
var __extends17 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var pointLineDistance3 = util_default.pointLineDistance;
var alignLineStyle = {
  stroke: "#FA8C16",
  lineWidth: 1
};
var SnapLine = function(_super) {
  __extends17(SnapLine3, _super);
  function SnapLine3(props) {
    return _super.call(this, props) || this;
  }
  SnapLine3.prototype.getDefaultCfgs = function() {
    return {
      line: alignLineStyle,
      itemAlignType: "center",
      tolerance: 5,
      horizontalLines: {},
      verticalLines: {},
      alignLines: []
    };
  };
  SnapLine3.prototype.init = function() {
  };
  SnapLine3.prototype.getEvents = function() {
    return {
      "node:dragstart": "onDragStart",
      "node:drag": "onDrag",
      "node:dragend": "onDragEnd"
    };
  };
  SnapLine3.prototype.onDragStart = function() {
    this.initBoxLine();
  };
  SnapLine3.prototype.onDrag = function(e8) {
    var item = e8.item;
    var delegateShape = item.get("delegateShape") || item;
    var bbox = delegateShape.getBBox();
    var model = item.getModel();
    var dx = model.x - bbox.x;
    var dy = model.y - bbox.y;
    this.show({
      x: bbox.minX + dx,
      y: bbox.minY + dy
    }, {
      width: bbox.width,
      height: bbox.height
    });
  };
  SnapLine3.prototype.onDragEnd = function() {
    this.destory();
  };
  SnapLine3.prototype.initBoxLine = function() {
    var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, itemAlignType = _a2.itemAlignType;
    var graph = this.get("graph");
    var nodes = graph.getNodes();
    nodes.forEach(function(item) {
      var bbox = item.getBBox();
      var nodeId = item.get("id");
      if (itemAlignType === true || itemAlignType === "horizontal") {
        horizontalLines["".concat(nodeId, "tltr")] = [bbox.minX, bbox.minY, bbox.maxX, bbox.minY, item];
        horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
        horizontalLines["".concat(nodeId, "blbr")] = [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY, item];
      } else if (itemAlignType === "center") {
        horizontalLines["".concat(nodeId, "lcrc")] = [bbox.minX, bbox.centerY, bbox.maxX, bbox.centerY, item];
      }
      if (itemAlignType === true || itemAlignType === "vertical") {
        verticalLines["".concat(nodeId, "tlbl")] = [bbox.minX, bbox.minY, bbox.minX, bbox.maxY, item];
        verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
        verticalLines["".concat(nodeId, "trbr")] = [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY, item];
      } else if (itemAlignType === "center") {
        verticalLines["".concat(nodeId, "tcbc")] = [bbox.centerX, bbox.minY, bbox.centerX, bbox.maxY, item];
      }
    });
  };
  SnapLine3.prototype.show = function(point, bbox) {
    var originPoint = mix({}, point);
    this.itemAlign(point, bbox, originPoint);
    return point;
  };
  SnapLine3.prototype.itemAlign = function(point, bbox, originPoint) {
    var _this = this;
    var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines, tolerance2 = _a2.tolerance;
    var tc2 = {
      x: originPoint.x + bbox.width / 2,
      y: originPoint.y
    };
    var cc2 = {
      x: originPoint.x + bbox.width / 2,
      y: originPoint.y + bbox.height / 2
    };
    var bc = {
      x: originPoint.x + bbox.width / 2,
      y: originPoint.y + bbox.height
    };
    var lc = {
      x: originPoint.x,
      y: originPoint.y + bbox.height / 2
    };
    var rc2 = {
      x: originPoint.x + bbox.width,
      y: originPoint.y + bbox.height / 2
    };
    var horizontalDis = [];
    var verticalDis = [];
    var alignCfg = null;
    this.clearAlignLine();
    each_default(horizontalLines, function(line) {
      if (line[4].isVisible) {
        horizontalDis.push(_this.getLineDisObject(line, tc2));
        horizontalDis.push(_this.getLineDisObject(line, cc2));
        horizontalDis.push(_this.getLineDisObject(line, bc));
      }
    });
    each_default(verticalLines, function(line) {
      if (line[4].isVisible) {
        verticalDis.push(_this.getLineDisObject(line, lc));
        verticalDis.push(_this.getLineDisObject(line, cc2));
        verticalDis.push(_this.getLineDisObject(line, rc2));
      }
    });
    horizontalDis.sort(function(a2, b10) {
      return a2.dis - b10.dis;
    });
    verticalDis.sort(function(a2, b10) {
      return a2.dis - b10.dis;
    });
    if (horizontalDis.length !== 0 && horizontalDis[0].dis < tolerance2) {
      point.y = horizontalDis[0].line[1] - horizontalDis[0].point.y + originPoint.y;
      alignCfg = {
        type: "item",
        horizontals: [horizontalDis[0]]
      };
      for (var i2 = 1; i2 < 3; i2++) {
        if (horizontalDis[0].dis === horizontalDis[i2].dis) {
          alignCfg.horizontals.push(horizontalDis[i2]);
        }
      }
    }
    if (verticalDis.length !== 0 && verticalDis[0].dis < tolerance2) {
      point.x = verticalDis[0].line[0] - verticalDis[0].point.x + originPoint.x;
      if (!alignCfg) {
        alignCfg = {
          type: "item",
          verticals: [verticalDis[0]]
        };
      } else {
        alignCfg.verticals = [verticalDis[0]];
      }
      for (var i2 = 1; i2 < 3; i2++) {
        if (verticalDis[0].dis === verticalDis[i2].dis) {
          alignCfg.verticals.push(verticalDis[i2]);
        }
      }
    }
    if (alignCfg) {
      alignCfg.bbox = bbox;
      this.addAlignLine(alignCfg);
    }
  };
  SnapLine3.prototype.addAlignLine = function(cfg) {
    var bbox = cfg.bbox, type = cfg.type, horizontals = cfg.horizontals, verticals = cfg.verticals;
    var _a2 = this._cfgs, lineStyle = _a2.line, alignLines = _a2.alignLines;
    var graph = this.get("graph");
    var group = graph.get("group");
    if (type === "item") {
      if (horizontals) {
        each_default(horizontals, function(horizontal) {
          var refLine = horizontal.line, refPoint = horizontal.point;
          var lineCenterX = (refLine[0] + refLine[2]) / 2;
          var x1;
          var x2;
          if (refPoint.x < lineCenterX) {
            x1 = refPoint.x - bbox.width / 2;
            x2 = Math.max(refLine[0], refLine[2]);
          } else {
            x1 = refPoint.x + bbox.width / 2;
            x2 = Math.min(refLine[0], refLine[2]);
          }
          var lineAttrs = mix({
            x1,
            y1: refLine[1],
            x2,
            y2: refLine[1]
          }, lineStyle);
          var line = group.addShape("line", {
            attrs: lineAttrs,
            capture: false
          });
          alignLines.push(line);
        });
      }
      if (verticals) {
        each_default(verticals, function(vertical2) {
          var refLine = vertical2.line, refPoint = vertical2.point;
          var lineCenterY = (refLine[1] + refLine[3]) / 2;
          var y1;
          var y2;
          if (refPoint.y < lineCenterY) {
            y1 = refPoint.y - bbox.height / 2;
            y2 = Math.max(refLine[1], refLine[3]);
          } else {
            y1 = refPoint.y + bbox.height / 2;
            y2 = Math.min(refLine[1], refLine[3]);
          }
          var lineAtts = mix({
            x1: refLine[0],
            y1,
            x2: refLine[0],
            y2
          }, lineStyle);
          var line = group.addShape("line", {
            attrs: lineAtts,
            capture: false
          });
          alignLines.push(line);
        });
      }
    }
  };
  SnapLine3.prototype.getLineDisObject = function(line, point) {
    return {
      line,
      point,
      dis: pointLineDistance3(line, point)
    };
  };
  SnapLine3.prototype.getContainer = function() {
    return this.get("container");
  };
  SnapLine3.prototype.clearAlignLine = function() {
    var alignLines = this._cfgs.alignLines;
    each_default(alignLines, function(line) {
      line.remove();
    });
    alignLines.length = 0;
  };
  SnapLine3.prototype.destory = function() {
    var _a2 = this._cfgs, horizontalLines = _a2.horizontalLines, verticalLines = _a2.verticalLines;
    var graph = this.get("graph");
    var nodes = graph.getNodes();
    nodes.forEach(function(node) {
      var itemId = node.get("id");
      delete horizontalLines["".concat(itemId, "tltr")];
      delete horizontalLines["".concat(itemId, "lcrc")];
      delete horizontalLines["".concat(itemId, "blbr")];
      delete verticalLines["".concat(itemId, "tlbl")];
      delete verticalLines["".concat(itemId, "tcbc")];
      delete verticalLines["".concat(itemId, "trbr")];
    });
    this.clearAlignLine();
  };
  return SnapLine3;
}(base_default4);
var snapline_default = SnapLine;

// node_modules/@antv/g6-plugin/es/legend/index.js
init_esm();
var __extends18 = function() {
  var _extendStatics = function extendStatics7(d2, b10) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function(d3, b11) {
      d3.__proto__ = b11;
    } || function(d3, b11) {
      for (var p2 in b11) {
        if (Object.prototype.hasOwnProperty.call(b11, p2))
          d3[p2] = b11[p2];
      }
    };
    return _extendStatics(d2, b10);
  };
  return function(d2, b10) {
    if (typeof b10 !== "function" && b10 !== null)
      throw new TypeError("Class extends value " + String(b10) + " is not a constructor or null");
    _extendStatics(d2, b10);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b10 === null ? Object.create(b10) : (__.prototype = b10.prototype, new __());
  };
}();
var __assign15 = function() {
  __assign15 = Object.assign || function(t4) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t4[p2] = s2[p2];
      }
    }
    return t4;
  };
  return __assign15.apply(this, arguments);
};
var ALLOW_EVENTS = ["click", "mouseenter"];
var Legend = function(_super) {
  __extends18(Legend3, _super);
  function Legend3(config) {
    return _super.call(this, config) || this;
  }
  Legend3.prototype.getDefaultCfgs = function() {
    return {
      data: {},
      position: "top",
      padding: 8,
      margin: 8,
      offsetX: 0,
      offsetY: 0,
      layout: "horizontal",
      flipPage: false,
      containerStyle: {},
      align: void 0,
      horiSep: 8,
      vertiSep: 8,
      filter: {
        enable: false,
        trigger: "click"
      }
    };
  };
  Legend3.prototype.init = function() {
    this.formatArray("padding");
    this.formatArray("margin");
    var filter2 = this.get("filter") || {};
    var multiple = filter2.multiple;
    if (multiple && filter2.trigger === "mouseenter")
      this.set("multiple", false);
    var align = this.get("align");
    if (!align) {
      var positions = this.get("position").split("-");
      if (positions.includes("left"))
        align = "left";
      if (positions.includes("right"))
        align = "right";
      else
        align = "center";
      this.set("align", align);
    }
    var graph = this.get("graph");
    var graphContainer = graph.get("container");
    var container2 = createDom2(`<div class='g6-legend-container' style="position: absolute;"></div>`);
    graphContainer.appendChild(container2);
    this.set("container", container2);
    var size2 = this.render();
    modifyCSS(container2, this.getContainerPos(size2));
    this.bindEvents();
  };
  Legend3.prototype.getContainerPos = function(size2) {
    if (size2 === void 0) {
      size2 = [0, 0];
    }
    var self2 = this;
    var graph = self2.get("graph");
    var offsetX = this.get("offsetX");
    var offsetY = this.get("offsetY");
    var margin = this.get("margin");
    var positions = this.get("position").split("-");
    var posIdxMap = {
      "top": 0,
      "right": 1,
      "bottom": 2,
      "left": 3
    };
    var x2 = 0, y2 = 0;
    var containerCSS = {
      left: (graph.getWidth() - size2[0]) / 2 + x2,
      top: (graph.getHeight() - size2[1]) / 2 + y2
    };
    positions.forEach(function(pos) {
      var marginValue = margin[posIdxMap[pos]];
      var key = pos;
      switch (pos) {
        case "top":
          marginValue += y2;
          break;
        case "left":
          marginValue += x2;
          break;
        case "bottom":
          marginValue = graph.getHeight() - size2[1] - marginValue + y2;
          key = "top";
          break;
        default:
          marginValue = graph.getWidth() - size2[0] - marginValue + x2;
          key = "left";
          break;
      }
      containerCSS[key] = marginValue;
    });
    containerCSS.top += offsetY + graph.getContainer().offsetTop;
    containerCSS.left += offsetX + graph.getContainer().offsetLeft;
    Object.keys(containerCSS).forEach(function(key) {
      containerCSS[key] = "".concat(containerCSS[key], "px");
    });
    return containerCSS;
  };
  Legend3.prototype.bindEvents = function() {
    var self2 = this;
    var filter2 = self2.get("filter");
    if (!filter2 || !filter2.enable)
      return;
    var trigger = filter2.trigger || "click";
    if (!ALLOW_EVENTS.includes(trigger)) {
      console.warn("Trigger for legend filterling must be 'click' or 'mouseenter', 'click' will take effect by default.");
      trigger = "click";
    }
    var lc = self2.get("legendCanvas");
    if (trigger === "mouseenter") {
      lc.on("node-container:mouseenter", function(e8) {
        return self2.filterData(e8);
      });
      lc.on("node-container:mouseleave", function(e8) {
        self2.clearFilter();
        self2.clearActiveLegend();
      });
    } else {
      lc.on("node-container:click", function(e8) {
        return self2.filterData(e8);
      });
      lc.on("click", function(e8) {
        if (e8.target && e8.target.isCanvas && e8.target.isCanvas()) {
          self2.clearFilter();
          self2.clearActiveLegend();
        }
      });
    }
  };
  Legend3.prototype.changeData = function(data) {
    this.set("data", data);
    var size2 = this.render();
    modifyCSS(this.get("container"), this.getContainerPos(size2));
  };
  Legend3.prototype.activateLegend = function(shape) {
    var filter2 = this.get("filter");
    var multiple = filter2 === null || filter2 === void 0 ? void 0 : filter2.multiple;
    if (!multiple)
      this.clearActiveLegend();
    var shapeGroup = shape.get("parent");
    if (shapeGroup.get("active")) {
      shapeGroup.set("active", false);
      if (this.findLegendItemsByState("active").length)
        shapeGroup.set("inactive", true);
    } else {
      shapeGroup.set("inactive", false);
      shapeGroup.set("active", true);
    }
    if (this.findLegendItemsByState("active").length) {
      this.findLegendItemsByState("active", "all", false).forEach(function(subGroup) {
        subGroup.set("inactive", true);
      });
    } else {
      this.clearActiveLegend();
    }
    var stateStyles = (filter2 === null || filter2 === void 0 ? void 0 : filter2.lengedStateStyles) || {};
    var legendInactive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.inactive) || {
      opacity: 0.5,
      "text-shape": {
        opacity: 0.5
      }
    };
    var legendTextInactive = legendInactive["text-shape"] || {};
    this.findLegendItemsByState("inactive").forEach(function(subGroup) {
      var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
      keyShape.attr(__assign15(__assign15({}, keyShape.get("oriAttrs")), legendInactive));
      text.attr(__assign15(__assign15({}, text.get("oriAttrs")), legendTextInactive));
    });
    var legendActive = (stateStyles === null || stateStyles === void 0 ? void 0 : stateStyles.active) || {
      stroke: "#000",
      lineWidth: 2,
      "text-shape": {
        fontWeight: "bold"
      }
    };
    var legendTextActive = legendActive["text-shape"] || {};
    this.findLegendItemsByState("active").forEach(function(subGroup) {
      var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
      keyShape.attr(__assign15(__assign15({}, keyShape.get("oriAttrs")), legendActive));
      text.attr(__assign15(__assign15({}, text.get("oriAttrs")), legendTextActive));
    });
  };
  Legend3.prototype.findLegendItemsByState = function(stateName, type, value) {
    if (type === void 0) {
      type = "all";
    }
    if (value === void 0) {
      value = true;
    }
    var group = this.get("legendCanvas").find(function(e8) {
      return e8.get("name") === "root";
    });
    var nodeGroup = group.find(function(e8) {
      return e8.get("name") === "node-group";
    });
    var edgeGroup = group.find(function(e8) {
      return e8.get("name") === "edge-group";
    });
    if (type === "node")
      return nodeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      });
    if (type === "edge")
      return edgeGroup.get("children").filter(function(g2) {
        return !!g2.get(stateName) === value;
      });
    return nodeGroup.get("children").filter(function(g2) {
      return !!g2.get(stateName) === value;
    }).concat(edgeGroup.get("children").filter(function(g2) {
      return !!g2.get(stateName) === value;
    }));
  };
  Legend3.prototype.clearActiveLegend = function() {
    var lg = this.get("legendCanvas");
    var group = lg.find(function(e8) {
      return e8.get("name") === "root";
    });
    var groups = [group.find(function(e8) {
      return e8.get("name") === "node-group";
    }), group.find(function(e8) {
      return e8.get("name") === "edge-group";
    })];
    groups.forEach(function(itemGroup) {
      itemGroup.get("children").forEach(function(subGroup) {
        subGroup.set("active", false);
        subGroup.set("inactive", false);
        var _a2 = subGroup.get("children"), keyShape = _a2[0], text = _a2[1];
        keyShape.attr(keyShape.get("oriAttrs"));
        text.attr(text.get("oriAttrs"));
      });
    });
  };
  Legend3.prototype.filterData = function(e8) {
    var filter2 = this.get("filter");
    var filterFunctions = filter2 === null || filter2 === void 0 ? void 0 : filter2.filterFunctions;
    if (!filter2 || !filterFunctions)
      return;
    var lc = this.get("legendCanvas");
    var graph = this.get("graph");
    var activeState = filter2.graphActiveState || "active";
    var inactiveState = filter2.graphInactiveState || "inactive";
    var multiple = filter2.multiple;
    this.clearFilter();
    if (!multiple)
      this.clearActiveLegend();
    this.activateLegend(e8.target);
    var group = lc.find(function(e9) {
      return e9.get("name") === "root";
    });
    var nodeGroup = group.find(function(e9) {
      return e9.get("name") === "node-group";
    });
    var edgeGroup = group.find(function(e9) {
      return e9.get("name") === "edge-group";
    });
    var activeNodeLegend = nodeGroup.get("children").filter(function(e9) {
      return e9.get("active");
    });
    var activeEdgeLegend = edgeGroup.get("children").filter(function(e9) {
      return e9.get("active");
    });
    var activeCount = 0;
    var typeFuncs = ["getNodes", "getEdges"];
    typeFuncs.forEach(function(typeFunc) {
      graph[typeFunc]().forEach(function(graphItem) {
        var active = false;
        var activeLegend = typeFunc === "getNodes" ? activeNodeLegend : activeEdgeLegend;
        activeLegend.forEach(function(itemGroup) {
          var func = filterFunctions[itemGroup.get("id")];
          active = active || func(graphItem.getModel());
        });
        if (active) {
          graph.setItemState(graphItem, inactiveState, false);
          graph.setItemState(graphItem, activeState, true);
          activeCount++;
        } else {
          graph.setItemState(graphItem, activeState, false);
          graph.setItemState(graphItem, inactiveState, true);
        }
      });
    });
    if (!activeCount)
      typeFuncs.forEach(function(typeFunc) {
        graph[typeFunc]().forEach(function(graphItem) {
          graph.clearItemStates(graphItem, [inactiveState]);
        });
      });
  };
  Legend3.prototype.clearFilter = function() {
    var graph = this.get("graph");
    var filter2 = this.get("filter");
    if (!filter2)
      return;
    var activeState = filter2.graphActiveState || "active";
    var inactiveState = filter2.graphInactiveState || "inactive";
    graph.getNodes().forEach(function(node) {
      graph.clearItemStates(node, [activeState, inactiveState]);
    });
    graph.getEdges().forEach(function(edge) {
      graph.clearItemStates(edge, [activeState, inactiveState]);
    });
  };
  Legend3.prototype.render = function() {
    var _this = this;
    this.processData();
    var lc = this.get("legendCanvas");
    if (!lc) {
      lc = new canvas_default2({
        container: this.get("container"),
        width: 200,
        height: 200
      });
      var rootGroup = lc.addGroup({
        name: "root"
      });
      rootGroup.addGroup({
        name: "node-group"
      });
      rootGroup.addGroup({
        name: "edge-group"
      });
      this.set("legendCanvas", lc);
    }
    var group = lc.find(function(e8) {
      return e8.get("name") === "root";
    });
    var nodeGroup = group.find(function(e8) {
      return e8.get("name") === "node-group";
    });
    var edgeGroup = group.find(function(e8) {
      return e8.get("name") === "edge-group";
    });
    var itemsData = this.get("itemsData");
    var itemTypes = ["nodes", "edges"];
    var itemGroup = [nodeGroup, edgeGroup];
    itemTypes.forEach(function(itemType, i2) {
      itemsData[itemType].forEach(function(data) {
        var _a2;
        var subGroup = itemGroup[i2].addGroup({
          id: data.id,
          name: "node-container"
        });
        var attrs;
        var shapeType = data.type;
        var _b = _this.getShapeSize(data), width = _b.width, height = _b.height, r2 = _b.r;
        var style2 = _this.getStyle(itemType.substr(0, 4), data);
        switch (data.type) {
          case "circle":
            attrs = {
              r: r2,
              x: 0,
              y: 0
            };
            break;
          case "rect":
            attrs = {
              width,
              height,
              x: -width / 2,
              y: -height / 2
            };
            break;
          case "ellipse":
            attrs = {
              r1: width,
              r2: height,
              x: 0,
              y: 0
            };
            break;
          case "line":
            attrs = {
              x1: -width / 2,
              y1: 0,
              x2: width / 2,
              y2: 0
            };
            shapeType = "line";
            break;
          case "quadratic":
            attrs = {
              path: [["M", -width / 2, 0], ["Q", 0, width / 2, width / 2, 0]]
            };
            shapeType = "path";
            break;
          case "cubic":
            attrs = {
              path: [["M", -width / 2, 0], ["C", -width / 6, width / 2, width / 6, -width / 2, width / 2, 0]]
            };
            shapeType = "path";
            break;
          default:
            attrs = {
              r: r2,
              x: 0,
              y: 0
            };
            break;
        }
        var keyShape = subGroup.addShape(shapeType, {
          attrs: __assign15(__assign15({}, attrs), style2),
          name: "".concat(data.type, "-node-keyShape"),
          oriAttrs: __assign15({
            opacity: 1
          }, style2)
        });
        if (data.label) {
          var keyShapeBBox = keyShape.getBBox();
          var labelStyle = ((_a2 = data.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
          var attrs_1 = __assign15({
            textAlign: "begin",
            fontSize: 12,
            textBaseline: "middle",
            fill: "#000",
            opacity: 1,
            fontWeight: "normal"
          }, labelStyle);
          subGroup.addShape("text", {
            attrs: __assign15({
              x: keyShapeBBox.maxX + 4,
              y: 0,
              text: data.label
            }, attrs_1),
            className: "legend-label",
            name: "".concat(data.type, "-node-text"),
            oriAttrs: attrs_1
          });
        }
      });
    });
    var padding = this.get("padding");
    var titleShape;
    var titleGroup = group.find(function(e8) {
      return e8.get("name") === "title-container";
    });
    var titleGroupBBox = {
      height: 0,
      maxY: 0,
      width: 0
    };
    if (this.get("title")) {
      if (!titleGroup) {
        titleGroup = group.addGroup({
          name: "title-container"
        });
      }
      var defaultTitleStyle = {
        fontSize: 20,
        fontFamily: "Arial",
        fontWeight: 300,
        textBaseline: "top",
        textAlign: "center",
        fill: "#000",
        x: 0,
        y: padding[0]
      };
      var titleConfig = this.get("titleConfig") || {};
      var style = Object.assign(defaultTitleStyle, titleConfig.style || {});
      titleShape = titleGroup.addShape("text", {
        attrs: __assign15({
          text: this.get("title")
        }, style)
      });
      titleGroupBBox = titleGroup.getCanvasBBox();
      titleGroup.setMatrix([1, 0, 0, 0, 1, 0, titleConfig.offsetX, titleConfig.offsetY, 1]);
    }
    this.layoutItems();
    var lcBBox = group.getCanvasBBox();
    var nodeGroupBBox = nodeGroup.getCanvasBBox();
    var nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
    var nodeGroupBeginY = titleGroupBBox.maxY < nodeGroupBBox.minY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
    var nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
    nodeGroup.setMatrix(nodeGroupMatrix);
    lcBBox = group.getCanvasBBox();
    var size2 = [lcBBox.minX + lcBBox.width + padding[1], lcBBox.minY + lcBBox.height + padding[2]];
    if (titleShape) {
      var titleConfig = __assign15({
        position: "center",
        offsetX: 0,
        offsetY: 0
      }, this.get("titleConfig"));
      titleGroupBBox = titleGroup.getCanvasBBox();
      var titleGroupMatrix = titleGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (titleConfig.position === "center") {
        titleGroupMatrix[6] = size2[0] / 2 + titleConfig.offsetX;
      } else if (titleConfig.position === "right") {
        titleGroupMatrix[6] = size2[0] - padding[3] + titleConfig.offsetX;
        titleShape.attr({
          textAlign: "right"
        });
      } else {
        titleGroupMatrix[6] = padding[3] + titleConfig.offsetX;
        titleShape.attr({
          textAlign: "left"
        });
      }
      titleGroup.setMatrix(titleGroupMatrix);
      titleGroupBBox = titleGroup.getCanvasBBox();
      nodeGroupBeginX = nodeGroupBBox.minX < 0 ? Math.abs(nodeGroupBBox.minX) + padding[3] : padding[3];
      nodeGroupBeginY = nodeGroupBBox.minY < titleGroupBBox.maxY ? Math.abs(titleGroupBBox.maxY - nodeGroupBBox.minY) + padding[0] : titleGroupBBox.maxY + padding[0];
      nodeGroupMatrix = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
      nodeGroup.setMatrix(nodeGroupMatrix);
      var edgeGroupMatrix_1 = [1, 0, 0, 0, 1, 0, nodeGroupBeginX, nodeGroupBeginY, 1];
      if (this.get("layout") === "vertical")
        edgeGroupMatrix_1[6] += nodeGroupBBox.maxX + this.get("horiSep");
      else
        edgeGroupMatrix_1[7] += nodeGroupBBox.maxY + this.get("vertiSep");
      edgeGroup.setMatrix(edgeGroupMatrix_1);
    } else {
      nodeGroupBBox = nodeGroup.getCanvasBBox();
      var edgeGroupMatrix_2 = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (this.get("layout") === "vertical")
        edgeGroupMatrix_2[6] += nodeGroupMatrix[6] + nodeGroupBBox.maxX + this.get("horiSep");
      else
        edgeGroupMatrix_2[7] += nodeGroupMatrix[7] + nodeGroupBBox.maxY + this.get("vertiSep");
      edgeGroup.setMatrix(edgeGroupMatrix_2);
    }
    lcBBox = group.getCanvasBBox();
    nodeGroupBBox = nodeGroup.getCanvasBBox();
    nodeGroupMatrix = nodeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var edgeGroupMatrix = edgeGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var edgeGroupBBox = edgeGroup.getCanvasBBox();
    size2 = [Math.max(nodeGroupBBox.width + nodeGroupMatrix[6], edgeGroupBBox.width + edgeGroupMatrix[6]) + padding[1], Math.max(nodeGroupBBox.height + nodeGroupMatrix[7], edgeGroupBBox.height + edgeGroupMatrix[7]) + padding[2]];
    lc.changeSize(size2[0], size2[1]);
    var containerStyle = this.get("containerStyle");
    var viewportMatrix = group.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
    var beginPos = util_default.invertMatrix({
      x: 0,
      y: 0
    }, viewportMatrix);
    var backRect = group.addShape("rect", {
      attrs: __assign15({
        x: beginPos.x + (containerStyle.lineWidth || 1),
        y: beginPos.y + (containerStyle.lineWidth || 1),
        width: size2[0] - 2 * (containerStyle.lineWidth || 1),
        height: size2[1] - 2 * (containerStyle.lineWidth || 1),
        fill: "#f00",
        stroke: "#000",
        lineWidth: 1,
        opacity: 0.5
      }, containerStyle),
      name: "legend-back-rect",
      capture: false
    });
    backRect.toBack();
    return size2;
  };
  Legend3.prototype.layoutItems = function() {
    var lc = this.get("legendCanvas");
    var horiSep = this.get("horiSep");
    var vertiSep = this.get("vertiSep");
    var layout2 = this.get("layout");
    var align = this.get("align");
    var begin = [0, 0];
    var group = lc.find(function(e8) {
      return e8.get("name") === "root";
    });
    var nodeGroup = group.find(function(e8) {
      return e8.get("name") === "node-group";
    });
    var edgeGroup = group.find(function(e8) {
      return e8.get("name") === "edge-group";
    });
    var nodeLegendSize = {
      min: 0,
      max: -Infinity
    };
    var rowMaxY = -Infinity;
    nodeGroup.get("children").forEach(function(cNodeGroup, i2) {
      if (i2 === 0)
        nodeLegendSize.min = begin[0];
      var keyShape = cNodeGroup.get("children")[0];
      var bbox = cNodeGroup.getCanvasBBox();
      var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
      var curHeight = 0, x2 = 0, y2 = 0;
      if (layout2 === "vertical") {
        x2 = begin[1];
        y2 = begin[0] + keyShapeWidth / 2;
        begin[0] = y2 + bbox.height + vertiSep;
        curHeight = bbox.maxX + x2 + keyShapeWidth / 2;
      } else {
        x2 = begin[0] + keyShapeWidth / 2;
        y2 = begin[1];
        begin[0] = x2 + bbox.width + horiSep;
        curHeight = bbox.maxY + y2 + keyShapeHeight / 2;
      }
      if (begin[0] > nodeLegendSize.max)
        nodeLegendSize.max = begin[0];
      if (curHeight > rowMaxY)
        rowMaxY = curHeight;
      cNodeGroup.setMatrix([1, 0, 0, 0, 1, 0, x2, y2, 1]);
    });
    var nw = nodeLegendSize.max - nodeLegendSize.min;
    var edgeLegendSize = {
      min: 0,
      max: -Infinity
    };
    var nodeGroupBBox = nodeGroup.getCanvasBBox();
    begin[0] = 0;
    begin[1] = layout2 === "vertical" ? nodeGroupBBox.maxX + horiSep : nodeGroupBBox.maxY + vertiSep;
    edgeGroup.get("children").forEach(function(subGroup, i2) {
      if (i2 === 0)
        edgeLegendSize.min = begin[0];
      var keyShape = subGroup.get("children")[0];
      var bbox = subGroup.getCanvasBBox();
      var _a2 = keyShape.getBBox(), keyShapeWidth = _a2.width, keyShapeHeight = _a2.height;
      var x2 = 0, y2 = 0;
      if (layout2 === "vertical") {
        x2 = begin[1];
        y2 = begin[0];
        begin[0] = y2 + bbox.height + vertiSep;
        subGroup.setMatrix([1, 0, 0, 0, 1, 0, 0, y2 + keyShapeHeight / 2, 1]);
      } else {
        x2 = begin[0];
        y2 = begin[1];
        begin[0] = x2 + bbox.width + horiSep;
        subGroup.setMatrix([1, 0, 0, 0, 1, 0, x2 + keyShapeWidth / 2, 0, 1]);
      }
      if (begin[0] > edgeLegendSize.max)
        edgeLegendSize.max = begin[0];
    });
    var ew = edgeLegendSize.max - edgeLegendSize.min;
    if (align && align !== "" && align !== "left") {
      var widthDiff = nw - ew;
      var movement_1 = align === "center" ? Math.abs(widthDiff) / 2 : Math.abs(widthDiff);
      var shouldAdjustGroup = widthDiff < 0 ? nodeGroup : edgeGroup;
      shouldAdjustGroup.get("children").forEach(function(subGroup) {
        var matrix = subGroup.getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (layout2 === "vertical")
          matrix[7] += movement_1;
        else
          matrix[6] += movement_1;
        subGroup.setMatrix(matrix);
      });
    }
  };
  Legend3.prototype.processData = function() {
    var data = this.get("data");
    var itemsData = {
      nodes: [],
      edges: []
    };
    if (data.nodes) {
      data.nodes.sort(function(a2, b10) {
        return a2.order - b10.order;
      });
      data.nodes.forEach(function(node) {
        var _a2, _b, _c, _d, _e2;
        var size2 = node.size || [((_a2 = node.style) === null || _a2 === void 0 ? void 0 : _a2.width) || ((_b = node.style) === null || _b === void 0 ? void 0 : _b.r) || 8, ((_c = node.style) === null || _c === void 0 ? void 0 : _c.height) || ((_d = node.style) === null || _d === void 0 ? void 0 : _d.r) || 8];
        var labelStyle = ((_e2 = node.labelCfg) === null || _e2 === void 0 ? void 0 : _e2.style) || {};
        itemsData.nodes.push({
          id: node.id || unique_id_default(),
          type: node.type || "circle",
          style: __assign15({}, node.style),
          order: node.order,
          label: node.label,
          itemType: "node",
          size: size2,
          labelCfg: {
            position: "right",
            style: __assign15({
              fontFamily: "Arial"
            }, labelStyle)
          }
        });
      });
    }
    if (data.edges) {
      data.edges.sort(function(a2, b10) {
        return a2.order - b10.order;
      });
      data.edges.forEach(function(edge) {
        var _a2, _b;
        var type = edge.type || "line";
        if (edge.type === "cubic-horizontal")
          type = "cubic";
        var labelStyle = ((_a2 = edge.labelCfg) === null || _a2 === void 0 ? void 0 : _a2.style) || {};
        var size2 = edge.size || [((_b = edge.style) === null || _b === void 0 ? void 0 : _b.width) || 8, 1];
        itemsData.edges.push({
          id: edge.id || unique_id_default(),
          type,
          size: size2,
          style: __assign15({
            lineWidth: is_array_default(size2) ? size2[1] : 1
          }, edge.style),
          order: edge.order,
          label: edge.label,
          itemType: "edge",
          labelCfg: {
            position: "right",
            style: __assign15({
              fontFamily: "Arial"
            }, labelStyle)
          }
        });
      });
    }
    this.set("itemsData", itemsData);
  };
  Legend3.prototype.getContainer = function() {
    return this.get("container");
  };
  Legend3.prototype.formatArray = function(key) {
    var value = this.get(key);
    if (is_number_default(value))
      this.set(key, [value, value, value, value]);
    else if (is_array_default(value)) {
      switch (value.length) {
        case 0:
          this.set(key, [0, 0, 0, 0]);
          break;
        case 1:
          this.set(key, [value[0], value[0], value[0], value[0]]);
          break;
        case 2:
          this.set(key, [value[0], value[1], value[0], value[1]]);
          break;
        case 3:
          this.set(key, [value[0], value[1], value[2], value[1]]);
          break;
        default:
          break;
      }
    }
    return this.get(key);
  };
  Legend3.prototype.getShapeSize = function(data) {
    var width, height, r2;
    if (data.size) {
      if (is_array_default(data.size)) {
        width = data.size[0];
        height = data.size[1] || data.size[0];
        r2 = data.size[0] / 2;
      } else if (is_number_default(data.size)) {
        width = data.size;
        height = data.size;
        r2 = data.size / 2;
      }
    }
    if (data.style) {
      if (data.style.width)
        width = data.style.width;
      if (data.style.height)
        height = data.style.height;
      if (data.style.r)
        r2 = data.style.r;
    }
    if (!r2)
      r2 = 5;
    if (!width)
      width = r2;
    if (!height)
      height = r2;
    return {
      width,
      height,
      r: r2
    };
  };
  Legend3.prototype.getStyle = function(type, data) {
    var defaultStyle = type === "node" ? {
      fill: "#ccc",
      lineWidth: 0
    } : {
      stroke: "#000",
      lineWidth: 1
    };
    return __assign15(__assign15({}, defaultStyle), data.style || {});
  };
  Legend3.prototype.destroy = function() {
    var graph = this.get("graph");
    var graphContainer = graph.get("container");
    var container2 = this.get("container");
    graphContainer.removeChild(container2);
  };
  return Legend3;
}(base_default4);
var legend_default = Legend;

// node_modules/@antv/g6-plugin/es/index.js
var Plugin = {
  PluginBase: base_default4,
  Menu: menu_default,
  Grid: grid_default,
  Minimap: minimap_default,
  Bundling: bundling_default,
  ToolBar: toolBar_default,
  Tooltip: tooltip_default,
  Fisheye: fisheye_default,
  TimeBar: timeBar_default,
  ImageMinimap: imageMinimap_default,
  EdgeFilterLens: edgeFilterLens_default,
  SnapLine: snapline_default,
  Legend: legend_default
};
var es_default4 = Plugin;

// node_modules/@antv/g6-pc/es/plugin/index.js
var plugin_default = es_default4;

// node_modules/@antv/g6-element/es/nodes/circle.js
init_esm();
registerNode("circle", {
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  labelPosition: "center",
  drawShape: function drawShape11(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var name = "".concat(this.type, "-keyShape");
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: name,
      name,
      draggable: true
    });
    group["shapeMap"][name] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      var iconName = "".concat(this.type, "-icon");
      if (text) {
        group["shapeMap"][iconName] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      } else {
        group["shapeMap"][iconName] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: iconName,
          name: iconName,
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints(cfg, group) {
    var linkPoints = (this.mergeStyle || this.getOptions(cfg)).linkPoints;
    if (!linkPoints)
      return;
    var _a2 = linkPoints || {}, top = _a2.top, left = _a2.left, right = _a2.right, bottom = _a2.bottom, markSize = _a2.size, markR = _a2.r, markStyle = __rest(_a2, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var r2 = size2[0] / 2;
    if (left) {
      var name_1 = "link-point-left";
      group["shapeMap"][name_1] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_1,
        name: name_1,
        isAnchorPoint: true
      });
    }
    if (right) {
      var name_2 = "link-point-right";
      group["shapeMap"][name_2] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: r2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: name_2,
        name: name_2,
        isAnchorPoint: true
      });
    }
    if (top) {
      var name_3 = "link-point-top";
      group["shapeMap"][name_3] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_3,
        name: name_3,
        isAnchorPoint: true
      });
    }
    if (bottom) {
      var name_4 = "link-point-bottom";
      group["shapeMap"][name_4] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: r2,
          r: markSize / 2 || markR || 5
        }),
        className: name_4,
        name: name_4,
        isAnchorPoint: true
      });
    }
  },
  getShapeStyle: function getShapeStyle8(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = deep_mix_default({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var r2 = size2[0] / 2;
    var styles = __assign({
      x: 0,
      y: 0,
      r: r2
    }, style);
    return styles;
  },
  update: function update7(cfg, item, updateType) {
    var group = item.getContainer();
    var size2 = this.getSize(cfg);
    var style = __assign({}, cfg.style);
    if (cfg.style.stroke === void 0 && cfg.color) {
      style.stroke = cfg.color;
    }
    if (cfg.style.r === void 0 && !isNaN(size2[0])) {
      style.r = size2[0] / 2;
    }
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/rect.js
init_esm();
registerNode("rect", {
  options: {
    size: [100, 30],
    style: {
      radius: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    anchorPoints: [[0, 0.5], [1, 0.5]],
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "rect",
  labelPosition: "center",
  drawShape: function drawShape12(cfg, group) {
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints2(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  getShapeStyle: function getShapeStyle9(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var width = style.width || size2[0];
    var height = style.height || size2[1];
    var styles = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update8(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size2 = this.getSize(cfg);
    var keyShape = item.get("keyShape");
    if (!cfg.size) {
      size2[0] = keyShape.attr("width") || defaultStyle.width;
      size2[1] = keyShape.attr("height") || defaultStyle.height;
    }
    var strokeStyle = {
      stroke: cfg.color,
      x: -size2[0] / 2,
      y: -size2[1] / 2,
      width: size2[0],
      height: size2[1]
    };
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, false, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/ellipse.js
init_esm();
registerNode("ellipse", {
  options: {
    size: [80, 40],
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "ellipse",
  labelPosition: "center",
  drawShape: function drawShape13(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("ellipse", {
      attrs: style,
      className: "ellipse-keyShape",
      name: "ellipse-keyShape",
      draggable: true
    });
    group["shapeMap"]["ellipse-keyShape"] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints3(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var rx = size2[0] / 2;
    var ry = size2[1] / 2;
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: rx,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: ry,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  getShapeStyle: function getShapeStyle10(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var rx = size2[0] / 2;
    var ry = size2[1] / 2;
    var styles = __assign({
      x: 0,
      y: 0,
      rx,
      ry
    }, style);
    return styles;
  },
  update: function update9(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var size2 = this.getSize(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      rx: size2[0] / 2,
      ry: size2[1] / 2
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/diamond.js
init_esm();
registerNode("diamond", {
  options: {
    size: [80, 80],
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "diamond",
  labelPosition: "center",
  drawShape: function drawShape14(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints4(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  getPath: function getPath6(cfg) {
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    var path = [
      ["M", 0, -height / 2],
      ["L", width / 2, 0],
      ["L", 0, height / 2],
      ["L", -width / 2, 0],
      ["Z"]
    ];
    return path;
  },
  getShapeStyle: function getShapeStyle11(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update10(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/triangle.js
init_esm();
registerNode("triangle", {
  options: {
    size: 40,
    direction: "up",
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize
      },
      offset: 15
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20,
      offset: 6
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "triangle",
  labelPosition: "bottom",
  drawShape: function drawShape15(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.icon, icon = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var style = this.getShapeStyle(cfg);
    var direction3 = cfg.direction || defaultDirection;
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, offset = icon.offset, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        var iconW = -w2 / 2;
        var iconH = -h2 / 2;
        if (direction3 === "up" || direction3 === "down") {
          iconH += offset;
        }
        if (direction3 === "left" || direction3 === "right") {
          iconW += offset;
        }
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: iconW,
            y: iconH
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints5(cfg, group) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.linkPoints, linkPoints = _b === void 0 ? {} : _b, defaultDirection = _a2.direction;
    var direction3 = cfg.direction || defaultDirection;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var len5 = size2[0];
    if (left) {
      var leftPos = null;
      var diffY = len5 * Math.sin(1 / 3 * Math.PI);
      var r2 = len5 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        leftPos = [-r2, diffY];
      } else if (direction3 === "down") {
        leftPos = [-r2, -diffY];
      } else if (direction3 === "left") {
        leftPos = [-r2, r2 - diffY];
      }
      if (leftPos) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: leftPos[0],
            y: leftPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-left",
          name: "link-point-left"
        });
      }
    }
    if (right) {
      var rightPos = null;
      var diffY = len5 * Math.sin(1 / 3 * Math.PI);
      var r2 = len5 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        rightPos = [r2, diffY];
      } else if (direction3 === "down") {
        rightPos = [r2, -diffY];
      } else if (direction3 === "right") {
        rightPos = [r2, r2 - diffY];
      }
      if (rightPos) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: rightPos[0],
            y: rightPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-right",
          name: "link-point-right"
        });
      }
    }
    if (top) {
      var topPos = null;
      var diffY = len5 * Math.sin(1 / 3 * Math.PI);
      var r2 = len5 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "up") {
        topPos = [r2 - diffY, -diffY];
      } else if (direction3 === "left") {
        topPos = [r2, -diffY];
      } else if (direction3 === "right") {
        topPos = [-r2, -diffY];
      }
      if (topPos) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: topPos[0],
            y: topPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-top",
          name: "link-point-top"
        });
      }
    }
    if (bottom) {
      var bottomPos = null;
      var diffY = len5 * Math.sin(1 / 3 * Math.PI);
      var r2 = len5 * Math.sin(1 / 3 * Math.PI);
      if (direction3 === "down") {
        bottomPos = [-r2 + diffY, diffY];
      } else if (direction3 === "left") {
        bottomPos = [r2, diffY];
      } else if (direction3 === "right") {
        bottomPos = [-r2, diffY];
      }
      if (bottomPos) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign(__assign({}, markStyle), {
            x: bottomPos[0],
            y: bottomPos[1],
            r: markSize / 2 || markR || 5
          }),
          className: "link-point-bottom",
          name: "link-point-bottom"
        });
      }
    }
  },
  getPath: function getPath7(cfg) {
    var defaultDirection = (this.mergeStyle || this.getOptions(cfg)).direction;
    var direction3 = cfg.direction || defaultDirection;
    var size2 = this.getSize(cfg);
    var len5 = size2[0];
    var diffY = len5 * Math.sin(1 / 3 * Math.PI);
    var r2 = len5 * Math.sin(1 / 3 * Math.PI);
    var path = [
      ["M", -r2, diffY],
      ["L", 0, -diffY],
      ["L", r2, diffY],
      ["Z"]
    ];
    if (direction3 === "down") {
      path = [
        ["M", -r2, -diffY],
        ["L", r2, -diffY],
        ["L", 0, diffY],
        ["Z"]
      ];
    } else if (direction3 === "left") {
      path = [
        ["M", -r2, r2 - diffY],
        ["L", r2, -r2],
        ["L", r2, r2],
        ["Z"]
      ];
    } else if (direction3 === "right") {
      path = [
        ["M", r2, r2 - diffY],
        ["L", -r2, r2],
        ["L", -r2, -r2],
        ["Z"]
      ];
    }
    return path;
  },
  getShapeStyle: function getShapeStyle12(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update11(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  updateLinkPoints: function updateLinkPoints2(cfg, group) {
    var _a2 = this.getOptions({}), defaultLinkPoints = _a2.linkPoints, defaultDirection = _a2.direction;
    var direction3 = cfg.direction || defaultDirection;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markBottom = group["shapeMap"]["link-point-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _b = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }, left = _b.left, right = _b.right, top = _b.top, bottom = _b.bottom;
    var size2 = this.getSize(cfg);
    var len5 = size2[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var leftPos = null;
    var diffY = len5 * Math.sin(1 / 3 * Math.PI);
    var r2 = len5 * Math.sin(1 / 3 * Math.PI);
    if (direction3 === "up") {
      leftPos = [-r2, diffY];
    } else if (direction3 === "down") {
      leftPos = [-r2, -diffY];
    } else if (direction3 === "left") {
      leftPos = [-r2, r2 - diffY];
    }
    if (leftPos) {
      if (markLeft) {
        if (!left && left !== void 0) {
          markLeft.remove();
          delete group["shapeMap"]["link-point-left"];
        } else {
          markLeft.attr(__assign(__assign({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }));
        }
      } else if (left) {
        group["shapeMap"]["link-point-left"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: leftPos[0],
            y: leftPos[1]
          }),
          className: "link-point-left",
          name: "link-point-left",
          isAnchorPoint: true
        });
      }
    }
    var rightPos = null;
    if (direction3 === "up") {
      rightPos = [r2, diffY];
    } else if (direction3 === "down") {
      rightPos = [r2, -diffY];
    } else if (direction3 === "right") {
      rightPos = [r2, r2 - diffY];
    }
    if (rightPos) {
      if (markRight) {
        if (!right && right !== void 0) {
          markRight.remove();
          delete group["shapeMap"]["link-point-right"];
        } else {
          markRight.attr(__assign(__assign({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }));
        }
      } else if (right) {
        group["shapeMap"]["link-point-right"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: rightPos[0],
            y: rightPos[1]
          }),
          className: "link-point-right",
          name: "link-point-right",
          isAnchorPoint: true
        });
      }
    }
    var topPos = null;
    if (direction3 === "up") {
      topPos = [r2 - diffY, -diffY];
    } else if (direction3 === "left") {
      topPos = [r2, -diffY];
    } else if (direction3 === "right") {
      topPos = [-r2, -diffY];
    }
    if (topPos) {
      if (markTop) {
        if (!top && top !== void 0) {
          markTop.remove();
          delete group["shapeMap"]["link-point-top"];
        } else {
          markTop.attr(__assign(__assign({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }));
        }
      } else if (top) {
        group["shapeMap"]["link-point-top"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: topPos[0],
            y: topPos[1]
          }),
          className: "link-point-top",
          name: "link-point-top",
          isAnchorPoint: true
        });
      }
    }
    var bottomPos = null;
    if (direction3 === "down") {
      bottomPos = [-r2 + diffY, diffY];
    } else if (direction3 === "left") {
      bottomPos = [r2, diffY];
    } else if (direction3 === "right") {
      bottomPos = [-r2, diffY];
    }
    if (bottomPos) {
      if (markBottom) {
        if (!bottom && bottom !== void 0) {
          markBottom.remove();
          delete group["shapeMap"]["link-point-bottom"];
        } else {
          markBottom.attr(__assign(__assign({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }));
        }
      } else if (bottom) {
        group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
          attrs: __assign(__assign({}, styles), {
            x: bottomPos[0],
            y: bottomPos[1]
          }),
          className: "link-point-bottom",
          name: "link-point-bottom",
          isAnchorPoint: true
        });
      }
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/modelRect.js
init_esm();
registerNode("modelRect", {
  options: {
    size: [185, 70],
    style: {
      radius: 5,
      stroke: "#69c0ff",
      fill: "#ffffff",
      lineWidth: BaseGlobal.defaultNode.style.lineWidth,
      fillOpacity: 1
    },
    labelCfg: {
      style: {
        fill: "#595959",
        fontSize: 14,
        fontFamily: BaseGlobal.windowFontFamily
      },
      offset: 30
    },
    descriptionCfg: {
      style: {
        fontSize: 12,
        fill: "#bfbfbf",
        fontFamily: BaseGlobal.windowFontFamily
      },
      paddingTop: 0
    },
    preRect: {
      show: true,
      width: 4,
      fill: "#40a9ff",
      radius: 2
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: 10,
      lineWidth: 1,
      fill: "#72CC4A",
      stroke: "#72CC4A"
    },
    logoIcon: {
      show: true,
      x: 0,
      y: 0,
      img: "https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg",
      width: 16,
      height: 16,
      offset: 0
    },
    stateIcon: {
      show: true,
      x: 0,
      y: 0,
      img: "https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg",
      width: 16,
      height: 16,
      offset: -5
    },
    anchorPoints: [[0, 0.5], [1, 0.5]]
  },
  shapeType: "modelRect",
  drawShape: function drawShape16(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).preRect, preRect = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    var keyShape = group.addShape("rect", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var preRectShow = preRect.show, preRectStyle = __rest(preRect, ["show"]);
    if (preRectShow) {
      group["shapeMap"]["pre-rect"] = group.addShape("rect", {
        attrs: __assign({
          x: -width / 2,
          y: -height / 2,
          height
        }, preRectStyle),
        className: "pre-rect",
        name: "pre-rect",
        draggable: true
      });
    }
    this.drawLogoIcon(cfg, group);
    this.drawStateIcon(cfg, group);
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLogoIcon: function drawLogoIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).logoIcon, logoIcon = _a2 === void 0 ? {} : _a2;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    if (logoIcon.show) {
      var w2 = logoIcon.width, h2 = logoIcon.height, x2 = logoIcon.x, y2 = logoIcon.y, offset = logoIcon.offset, text = logoIcon.text, logoIconStyle = __rest(logoIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, logoIconStyle),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-logo-icon"] = group.addShape("image", {
          attrs: __assign(__assign({}, logoIconStyle), {
            x: x2 || -width / 2 + w2 + offset,
            y: y2 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-logo-icon",
          name: "rect-logo-icon",
          draggable: true
        });
      }
    }
  },
  drawStateIcon: function drawStateIcon(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).stateIcon, stateIcon = _a2 === void 0 ? {} : _a2;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    if (stateIcon.show) {
      var w2 = stateIcon.width, h2 = stateIcon.height, x2 = stateIcon.x, y2 = stateIcon.y, offset = stateIcon.offset, text = stateIcon.text, iconStyle = __rest(stateIcon, ["width", "height", "x", "y", "offset", "text"]);
      if (text) {
        group["shapeMap"]["rect-state-icon"] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, iconStyle),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      } else {
        group["shapeMap"]["rect-state-icon"] = group.addShape("image", {
          attrs: __assign(__assign({}, iconStyle), {
            x: x2 || width / 2 - w2 + offset,
            y: y2 || -h2 / 2,
            width: w2,
            height: h2
          }),
          className: "rect-state-icon",
          name: "rect-state-icon",
          draggable: true
        });
      }
    }
  },
  drawLinkPoints: function drawLinkPoints6(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, bottom = linkPoints.bottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "bottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: -width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: width / 2,
          y: 0,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: -height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    if (bottom) {
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: 0,
          y: height / 2,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-bottom",
        name: "link-point-bottom",
        isAnchorPoint: true
      });
    }
  },
  drawLabel: function drawLabel3(cfg, group) {
    var _a2 = this.getOptions(cfg), _b = _a2.labelCfg, labelCfg = _b === void 0 ? {} : _b, _c = _a2.logoIcon, logoIcon = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var label = null;
    var show = logoIcon.show, w2 = logoIcon.width;
    var offsetX = -width / 2 + labelCfg.offset;
    if (show) {
      offsetX = -width / 2 + w2 + labelCfg.offset;
    }
    var fontStyle = labelCfg.style;
    var descriptionStyle = descriptionCfg.style, descriptionPaddingTop = descriptionCfg.paddingTop;
    if (is_string_default(cfg.description)) {
      label = group.addShape("text", {
        attrs: __assign(__assign({}, fontStyle), {
          x: offsetX,
          y: -5,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
      group["shapeMap"]["rect-description"] = group.addShape("text", {
        attrs: __assign(__assign({}, descriptionStyle), {
          x: offsetX,
          y: 17 + (descriptionPaddingTop || 0),
          text: cfg.description
        }),
        className: "rect-description",
        name: "rect-description",
        draggable: true,
        labelRelated: true
      });
    } else {
      label = group.addShape("text", {
        attrs: __assign(__assign({}, fontStyle), {
          x: offsetX,
          y: 7,
          text: cfg.label
        }),
        className: "text-shape",
        name: "text-shape",
        draggable: true,
        labelRelated: true
      });
      group["shapeMap"]["text-shape"] = label;
    }
    return label;
  },
  getShapeStyle: function getShapeStyle13(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var size2 = this.getSize(cfg);
    var width = style.width || size2[0];
    var height = style.height || size2[1];
    var styles = __assign({
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }, style);
    return styles;
  },
  update: function update12(cfg, item) {
    var _a2 = this.mergeStyle || this.getOptions(cfg), _b = _a2.style, style = _b === void 0 ? {} : _b, _c = _a2.labelCfg, labelCfg = _c === void 0 ? {} : _c, _d = _a2.descriptionCfg, descriptionCfg = _d === void 0 ? {} : _d;
    var size2 = this.getSize(cfg);
    var width = size2[0];
    var height = size2[1];
    var keyShape = item.get("keyShape");
    keyShape.attr(__assign(__assign({}, style), {
      x: -width / 2,
      y: -height / 2,
      width,
      height
    }));
    var group = item.getContainer();
    var logoIconShape = group["shapeMap"]["rect-logo-icon"] || group.find(function(element) {
      return element.get("className") === "rect-logo-icon";
    });
    var currentLogoIconAttr = logoIconShape ? logoIconShape.attr() : {};
    var logoIcon = mix({}, currentLogoIconAttr, cfg.logoIcon);
    var w2 = logoIcon.width;
    if (w2 === void 0) {
      w2 = this.options.logoIcon.width;
    }
    var show = cfg.logoIcon ? cfg.logoIcon.show : void 0;
    var offset = labelCfg.offset;
    var offsetX = -width / 2 + w2 + offset;
    if (!show && show !== void 0) {
      offsetX = -width / 2 + offset;
    }
    var label = group["shapeMap"]["node-label"] || group.find(function(element) {
      return element.get("className") === "node-label";
    });
    var description = group["shapeMap"]["rect-description"] || group.find(function(element) {
      return element.get("className") === "rect-description";
    });
    if (cfg.label) {
      if (!label) {
        group["shapeMap"]["node-label"] = group.addShape("text", {
          attrs: __assign(__assign({}, labelCfg.style), {
            x: offsetX,
            y: cfg.description ? -5 : 7,
            text: cfg.label
          }),
          className: "node-label",
          name: "node-label",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.labelCfg ? cfg.labelCfg.style : {};
        var labelStyle = mix({}, label.attr(), cfgStyle);
        if (cfg.label)
          labelStyle.text = cfg.label;
        labelStyle.x = offsetX;
        if (is_string_default(cfg.description))
          labelStyle.y = -5;
        if (description) {
          description.resetMatrix();
          description.attr({
            x: offsetX
          });
        }
        label.resetMatrix();
        label.attr(labelStyle);
      }
    }
    if (is_string_default(cfg.description)) {
      var paddingTop = descriptionCfg.paddingTop;
      if (!description) {
        group["shapeMap"]["rect-description"] = group.addShape("text", {
          attrs: __assign(__assign({}, descriptionCfg.style), {
            x: offsetX,
            y: 17 + (paddingTop || 0),
            text: cfg.description
          }),
          className: "rect-description",
          name: "rect-description",
          draggable: true,
          labelRelated: true
        });
      } else {
        var cfgStyle = cfg.descriptionCfg ? cfg.descriptionCfg.style : {};
        var descriptionStyle = mix({}, description.attr(), cfgStyle);
        if (is_string_default(cfg.description))
          descriptionStyle.text = cfg.description;
        descriptionStyle.x = offsetX;
        description.resetMatrix();
        description.attr(__assign(__assign({}, descriptionStyle), {
          y: 17 + (paddingTop || 0)
        }));
      }
    }
    var preRectShape = group["shapeMap"]["pre-rect"] || group.find(function(element) {
      return element.get("className") === "pre-rect";
    });
    if (preRectShape && !preRectShape.destroyed) {
      var preRect = mix({}, preRectShape.attr(), cfg.preRect);
      preRectShape.attr(__assign(__assign({}, preRect), {
        x: -width / 2,
        y: -height / 2,
        height
      }));
    }
    if (logoIconShape && !logoIconShape.destroyed) {
      if (!show && show !== void 0) {
        logoIconShape.remove();
        delete group["shapeMap"]["pre-rect"];
      } else {
        var logoW = logoIcon.width, h2 = logoIcon.height, x2 = logoIcon.x, y2 = logoIcon.y, logoOffset = logoIcon.offset, logoIconStyle = __rest(logoIcon, ["width", "height", "x", "y", "offset"]);
        logoIconShape.attr(__assign(__assign({}, logoIconStyle), {
          x: x2 || -width / 2 + logoW + logoOffset,
          y: y2 || -h2 / 2,
          width: logoW,
          height: h2
        }));
      }
    } else if (show) {
      this.drawLogoIcon(cfg, group);
    }
    var stateIconShape = group["shapeMap"]["rect-state-icon"] || group.find(function(element) {
      return element.get("className") === "rect-state-icon";
    });
    var currentStateIconAttr = stateIconShape ? stateIconShape.attr() : {};
    var stateIcon = mix({}, currentStateIconAttr, cfg.stateIcon);
    if (stateIconShape) {
      if (!stateIcon.show && stateIcon.show !== void 0) {
        stateIconShape.remove();
        delete group["shapeMap"]["rect-state-icon"];
      }
      var stateW = stateIcon.width, h2 = stateIcon.height, x2 = stateIcon.x, y2 = stateIcon.y, stateOffset = stateIcon.offset, stateIconStyle = __rest(stateIcon, ["width", "height", "x", "y", "offset"]);
      stateIconShape.attr(__assign(__assign({}, stateIconStyle), {
        x: x2 || width / 2 - stateW + stateOffset,
        y: y2 || -h2 / 2,
        width: stateW,
        height: h2
      }));
    } else if (stateIcon.show) {
      this.drawStateIcon(cfg, group);
    }
    this.updateLinkPoints(cfg, group);
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/star.js
init_esm();
registerNode("star", {
  options: {
    size: 60,
    style: {
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "star",
  labelPosition: "center",
  drawShape: function drawShape17(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, icon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var keyShape = group.addShape("path", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      name: "".concat(this.type, "-keyShape"),
      draggable: true
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var w2 = icon.width, h2 = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -w2 / 2,
            y: -h2 / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  drawLinkPoints: function drawLinkPoints7(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).linkPoints, linkPoints = _a2 === void 0 ? {} : _a2;
    var top = linkPoints.top, left = linkPoints.left, right = linkPoints.right, leftBottom = linkPoints.leftBottom, rightBottom = linkPoints.rightBottom, markSize = linkPoints.size, markR = linkPoints.r, markStyle = __rest(linkPoints, ["top", "left", "right", "leftBottom", "rightBottom", "size", "r"]);
    var size2 = this.getSize(cfg);
    var outerR = size2[0];
    if (right) {
      var x1 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right",
        name: "link-point-right"
      });
    }
    if (top) {
      var x1 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-top",
        name: "link-point-top"
      });
    }
    if (left) {
      var x1 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left",
        name: "link-point-left"
      });
    }
    if (leftBottom) {
      var x1 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom"
      });
    }
    if (rightBottom) {
      var x1 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, markStyle), {
          x: x1,
          y: -y1,
          r: markSize / 2 || markR || 5
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom"
      });
    }
  },
  getPath: function getPath8(cfg) {
    var size2 = this.getSize(cfg);
    var outerR = size2[0];
    var defaultInnerR = outerR * 3 / 8;
    var innerR = cfg.innerR || defaultInnerR;
    var path = [];
    for (var i2 = 0; i2 < 5; i2++) {
      var x1 = Math.cos((18 + 72 * i2) / 180 * Math.PI) * outerR;
      var y1 = Math.sin((18 + 72 * i2) / 180 * Math.PI) * outerR;
      var x2 = Math.cos((54 + 72 * i2) / 180 * Math.PI) * innerR;
      var y2 = Math.sin((54 + 72 * i2) / 180 * Math.PI) * innerR;
      if (i2 === 0) {
        path.push(["M", x1, -y1]);
      } else {
        path.push(["L", x1, -y1]);
      }
      path.push(["L", x2, -y2]);
    }
    path.push(["Z"]);
    return path;
  },
  getShapeStyle: function getShapeStyle14(cfg) {
    var defaultStyle = (this.mergeStyle || this.getOptions(cfg)).style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle);
    var path = this.getPath(cfg);
    var styles = __assign({
      path
    }, style);
    return styles;
  },
  update: function update13(cfg, item, updateType) {
    var group = item.getContainer();
    var defaultStyle = this.getOptions({}).style;
    var path = this.getPath(cfg);
    var strokeStyle = {
      stroke: cfg.color,
      path
    };
    var keyShape = item.get("keyShape");
    var style = mix({}, defaultStyle, keyShape.attr(), strokeStyle);
    style = mix(style, cfg.style);
    this.updateShape(cfg, item, style, true, updateType);
    this.updateLinkPoints(cfg, group);
  },
  updateLinkPoints: function updateLinkPoints3(cfg, group) {
    var defaultLinkPoints = this.getOptions({}).linkPoints;
    var markLeft = group["shapeMap"]["link-point-left"] || group.find(function(element) {
      return element.get("className") === "link-point-left";
    });
    var markRight = group["shapeMap"]["link-point-right"] || group.find(function(element) {
      return element.get("className") === "link-point-right";
    });
    var markTop = group["shapeMap"]["link-point-top"] || group.find(function(element) {
      return element.get("className") === "link-point-top";
    });
    var markLeftBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-left-bottom";
    });
    var markRightBottom = group["shapeMap"]["link-point-left-bottom"] || group.find(function(element) {
      return element.get("className") === "link-point-right-bottom";
    });
    var currentLinkPoints = defaultLinkPoints;
    var existLinkPoint = markLeft || markRight || markTop || markLeftBottom || markRightBottom;
    if (existLinkPoint) {
      currentLinkPoints = existLinkPoint.attr();
    }
    var linkPoints = mix({}, currentLinkPoints, cfg.linkPoints);
    var markFill = linkPoints.fill, markStroke = linkPoints.stroke, borderWidth = linkPoints.lineWidth;
    var markSize = linkPoints.size / 2;
    if (!markSize)
      markSize = linkPoints.r;
    var _a2 = cfg.linkPoints ? cfg.linkPoints : {
      left: void 0,
      right: void 0,
      top: void 0,
      leftBottom: void 0,
      rightBottom: void 0
    }, left = _a2.left, right = _a2.right, top = _a2.top, leftBottom = _a2.leftBottom, rightBottom = _a2.rightBottom;
    var size2 = this.getSize(cfg);
    var outerR = size2[0];
    var styles = {
      r: markSize,
      fill: markFill,
      stroke: markStroke,
      lineWidth: borderWidth
    };
    var x2 = Math.cos((18 + 72 * 0) / 180 * Math.PI) * outerR;
    var y2 = Math.sin((18 + 72 * 0) / 180 * Math.PI) * outerR;
    if (markRight) {
      if (!right && right !== void 0) {
        markRight.remove();
        delete group["shapeMap"]["link-point-right"];
      } else {
        markRight.attr(__assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }));
      }
    } else if (right) {
      group["shapeMap"]["link-point-right"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }),
        className: "link-point-right",
        name: "link-point-right",
        isAnchorPoint: true
      });
    }
    x2 = Math.cos((18 + 72 * 1) / 180 * Math.PI) * outerR;
    y2 = Math.sin((18 + 72 * 1) / 180 * Math.PI) * outerR;
    if (markTop) {
      if (!top && top !== void 0) {
        markTop.remove();
        delete group["shapeMap"]["link-point-top"];
      } else {
        markTop.attr(__assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }));
      }
    } else if (top) {
      group["shapeMap"]["link-point-top"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }),
        className: "link-point-top",
        name: "link-point-top",
        isAnchorPoint: true
      });
    }
    x2 = Math.cos((18 + 72 * 2) / 180 * Math.PI) * outerR;
    y2 = Math.sin((18 + 72 * 2) / 180 * Math.PI) * outerR;
    if (markLeft) {
      if (!left && left !== void 0) {
        markLeft.remove();
        delete group["shapeMap"]["link-point-left"];
      } else {
        markLeft.attr(__assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }));
      }
    } else if (left) {
      group["shapeMap"]["link-point-left"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }),
        className: "link-point-left",
        name: "link-point-left",
        isAnchorPoint: true
      });
    }
    x2 = Math.cos((18 + 72 * 3) / 180 * Math.PI) * outerR;
    y2 = Math.sin((18 + 72 * 3) / 180 * Math.PI) * outerR;
    if (markLeftBottom) {
      if (!leftBottom && leftBottom !== void 0) {
        markLeftBottom.remove();
        delete group["shapeMap"]["link-point-left-bottom"];
      } else {
        markLeftBottom.attr(__assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }));
      }
    } else if (leftBottom) {
      group["shapeMap"]["link-point-left-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }),
        className: "link-point-left-bottom",
        name: "link-point-left-bottom",
        isAnchorPoint: true
      });
    }
    x2 = Math.cos((18 + 72 * 4) / 180 * Math.PI) * outerR;
    y2 = Math.sin((18 + 72 * 4) / 180 * Math.PI) * outerR;
    if (markRightBottom) {
      if (!rightBottom && rightBottom !== void 0) {
        markLeftBottom.remove();
        delete group["shapeMap"]["link-point-right-bottom"];
      } else {
        markRightBottom.attr(__assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }));
      }
    } else if (rightBottom) {
      group["shapeMap"]["link-point-right-bottom"] = group.addShape("circle", {
        attrs: __assign(__assign({}, styles), {
          x: x2,
          y: -y2
        }),
        className: "link-point-right-bottom",
        name: "link-point-right-bottom",
        isAnchorPoint: true
      });
    }
  }
}, "single-node");

// node_modules/@antv/g6-element/es/nodes/donut.js
init_esm();
var defaultSubjectColors2 = util_default.defaultSubjectColors;
registerNode("donut", {
  options: {
    size: BaseGlobal.defaultNode.size,
    style: {
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultNode.style.stroke,
      fill: BaseGlobal.defaultNode.style.fill,
      lineWidth: BaseGlobal.defaultNode.style.lineWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.nodeLabel.style.fill,
        fontSize: BaseGlobal.nodeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    linkPoints: {
      top: false,
      right: false,
      bottom: false,
      left: false,
      size: BaseGlobal.defaultNode.linkPoints.size,
      lineWidth: BaseGlobal.defaultNode.linkPoints.lineWidth,
      fill: BaseGlobal.defaultNode.linkPoints.fill,
      stroke: BaseGlobal.defaultNode.linkPoints.stroke
    },
    icon: {
      show: false,
      img: "https://gw.alipayobjects.com/zos/bmw-prod/5d015065-8505-4e7a-baec-976f81e3c41d.svg",
      width: 20,
      height: 20
    },
    stateStyles: __assign({}, BaseGlobal.nodeStateStyles)
  },
  shapeType: "circle",
  labelPosition: "center",
  drawShape: function drawShape18(cfg, group) {
    var _a2 = (this.mergeStyle || this.getOptions(cfg)).icon, defaultIcon = _a2 === void 0 ? {} : _a2;
    var style = this.getShapeStyle(cfg);
    var icon = deep_mix_default({}, defaultIcon, cfg.icon);
    var keyShape = group.addShape("circle", {
      attrs: style,
      className: "".concat(this.type, "-keyShape"),
      draggable: true,
      name: "".concat(this.type, "-keyShape")
    });
    group["shapeMap"]["".concat(this.type, "-keyShape")] = keyShape;
    var width = icon.width, height = icon.height, show = icon.show, text = icon.text;
    if (show) {
      if (text) {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("text", {
          attrs: __assign({
            x: 0,
            y: 0,
            fontSize: 12,
            fill: "#000",
            stroke: "#000",
            textBaseline: "middle",
            textAlign: "center"
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      } else {
        group["shapeMap"]["".concat(this.type, "-icon")] = group.addShape("image", {
          attrs: __assign({
            x: -width / 2,
            y: -height / 2
          }, icon),
          className: "".concat(this.type, "-icon"),
          name: "".concat(this.type, "-icon"),
          draggable: true
        });
      }
    }
    var donutR = keyShape.attr("r");
    var innerR = 0.6 * donutR;
    var arcR = (donutR + innerR) / 2;
    var _b = cfg, _c = _b.donutAttrs, donutAttrs = _c === void 0 ? {} : _c, _d = _b.donutColorMap, donutColorMap = _d === void 0 ? {} : _d;
    var attrNum = Object.keys(donutAttrs).length;
    if (donutAttrs && attrNum > 1) {
      var attrs_1 = [];
      var totalValue_1 = 0;
      Object.keys(donutAttrs).forEach(function(name) {
        var value = donutAttrs[name] || 0;
        if (!is_number_default(value))
          return;
        attrs_1.push({
          key: name,
          value,
          color: donutColorMap[name]
        });
        totalValue_1 += value;
      });
      if (totalValue_1) {
        var lineWidth_1 = donutR - innerR;
        if (attrNum === 1) {
          group["shapeMap"]["fan-shape-0"] = group.addShape("circle", {
            attrs: {
              r: arcR,
              x: 0,
              y: 0,
              stroke: attrs_1[0].color || defaultSubjectColors2[0],
              lineWidth: lineWidth_1
            },
            name: "fan-shape-0"
          });
          return;
        }
        var arcBegin_1 = [arcR, 0];
        var beginAngle_1 = 0;
        attrs_1.forEach(function(attr, i2) {
          var percent = attr.value / totalValue_1;
          if (percent < 1e-3)
            return;
          if (percent > 0.999)
            percent = 1;
          if (percent === 1) {
            group["shapeMap"]["fan-shape-".concat(i2)] = group.addShape("circle", {
              attrs: {
                r: arcR,
                x: 0,
                y: 0,
                stroke: attr.color || defaultSubjectColors2[i2 % defaultSubjectColors2.length],
                lineWidth: lineWidth_1
              },
              name: "fan-shape-".concat(i2)
            });
            return;
          }
          attr.percent = percent;
          attr.angle = percent * Math.PI * 2;
          attr.beginAgnle = beginAngle_1;
          beginAngle_1 += attr.angle;
          attr.endAngle = beginAngle_1;
          attr.arcBegin = arcBegin_1;
          attr.arcEnd = [arcR * Math.cos(attr.endAngle), -arcR * Math.sin(attr.endAngle)];
          var isBig = attr.angle > Math.PI ? 1 : 0;
          var path = [["M", attr.arcBegin[0], attr.arcBegin[1]], ["A", arcR, arcR, 0, isBig, 0, attr.arcEnd[0], attr.arcEnd[1]], ["L", attr.arcEnd[0], attr.arcEnd[1]]];
          group["shapeMap"]["fan-shape-".concat(i2)] = group.addShape("path", {
            attrs: {
              path,
              lineWidth: lineWidth_1,
              stroke: attr.color || defaultSubjectColors2[i2 % defaultSubjectColors2.length]
            },
            name: "fan-shape-".concat(i2)
          });
          arcBegin_1 = attr.arcEnd;
        });
      }
    }
    this.drawLinkPoints(cfg, group);
    return keyShape;
  },
  update: void 0
}, "circle");

// node_modules/@antv/g6-element/es/edges/polyline.js
init_esm();

// node_modules/@antv/g6-element/es/edges/polyline-util.js
var getBBoxFromPoint = function getBBoxFromPoint2(point) {
  var x2 = point.x, y2 = point.y;
  return {
    x: x2,
    y: y2,
    centerX: x2,
    centerY: y2,
    minX: x2,
    minY: y2,
    maxX: x2,
    maxY: y2,
    height: 0,
    width: 0
  };
};
var getBBoxFromPoints = function getBBoxFromPoints2(points) {
  if (points === void 0) {
    points = [];
  }
  var xs = [];
  var ys = [];
  points.forEach(function(p2) {
    xs.push(p2.x);
    ys.push(p2.y);
  });
  var minX = Math.min.apply(Math, xs);
  var maxX = Math.max.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxY = Math.max.apply(Math, ys);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    maxX,
    maxY,
    minX,
    minY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var filterConnectPoints = function filterConnectPoints2(points) {
  var result = [];
  var pointsMap = {};
  var pointsLength = points.length;
  for (var i2 = pointsLength - 1; i2 >= 0; i2--) {
    var p2 = points[i2];
    p2.id = "".concat(p2.x, "|||").concat(p2.y);
    pointsMap[p2.id] = p2;
    result.push(p2);
  }
  return result;
};
var simplifyPolyline = function simplifyPolyline2(points) {
  return filterConnectPoints(points);
};
var getExpandedBBox = function getExpandedBBox2(bbox, offset) {
  if (bbox.width || bbox.height) {
    return {
      centerX: bbox.centerX,
      centerY: bbox.centerY,
      minX: bbox.minX - offset,
      minY: bbox.minY - offset,
      maxX: bbox.maxX + offset,
      maxY: bbox.maxY + offset,
      height: bbox.height + 2 * offset,
      width: bbox.width + 2 * offset
    };
  }
  return bbox;
};
var isHorizontalPort = function isHorizontalPort2(port, bbox) {
  var dx = Math.abs(port.x - bbox.centerX);
  var dy = Math.abs(port.y - bbox.centerY);
  if (dx === 0 && dy === 0)
    return 0;
  return dx / bbox.width > dy / bbox.height;
};
var getExpandedBBoxPoint = function getExpandedBBoxPoint2(bbox, point, anotherPoint) {
  var isHorizontal = isHorizontalPort(point, bbox);
  if (isHorizontal === 0) {
    var x2 = bbox.centerX;
    var y2 = bbox.centerY;
    if (anotherPoint.y < point.y) {
      y2 = bbox.minY;
    } else if (anotherPoint.x > point.x) {
      x2 = bbox.maxX;
    } else if (anotherPoint.x < point.x) {
      x2 = bbox.minX;
    } else if (anotherPoint.x === point.x) {
      y2 = bbox.maxY;
    }
    return {
      x: x2,
      y: y2
    };
  }
  if (isHorizontal) {
    return {
      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,
      y: point.y
    };
  }
  return {
    x: point.x,
    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY
  };
};
var mergeBBox2 = function mergeBBox3(b12, b22) {
  var minX = Math.min(b12.minX, b22.minX);
  var minY = Math.min(b12.minY, b22.minY);
  var maxX = Math.max(b12.maxX, b22.maxX);
  var maxY = Math.max(b12.maxY, b22.maxY);
  return {
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY) / 2,
    minX,
    minY,
    maxX,
    maxY,
    height: maxY - minY,
    width: maxX - minX
  };
};
var getPointsFromBBox = function getPointsFromBBox2(bbox) {
  return [{
    x: bbox.minX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.minY
  }, {
    x: bbox.maxX,
    y: bbox.maxY
  }, {
    x: bbox.minX,
    y: bbox.maxY
  }];
};
var isPointOutsideBBox = function isPointOutsideBBox2(point, bbox) {
  var x2 = point.x, y2 = point.y;
  return x2 < bbox.minX || x2 > bbox.maxX || y2 < bbox.minY || y2 > bbox.maxY;
};
var getBBoxXCrossPoints = function getBBoxXCrossPoints2(bbox, x2) {
  if (x2 < bbox.minX || x2 > bbox.maxX) {
    return [];
  }
  return [{
    x: x2,
    y: bbox.minY
  }, {
    x: x2,
    y: bbox.maxY
  }];
};
var getBBoxYCrossPoints = function getBBoxYCrossPoints2(bbox, y2) {
  if (y2 < bbox.minY || y2 > bbox.maxY) {
    return [];
  }
  return [{
    x: bbox.minX,
    y: y2
  }, {
    x: bbox.maxX,
    y: y2
  }];
};
var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint2(bbox, point) {
  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));
};
var distance9 = function distance10(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var _costByPoints = function _costByPoints2(p2, points) {
  var offset = -2;
  var result = 0;
  points.forEach(function(point) {
    if (point) {
      if (p2.x === point.x) {
        result += offset;
      }
      if (p2.y === point.y) {
        result += offset;
      }
    }
  });
  return result;
};
var heuristicCostEstimate = function heuristicCostEstimate2(p2, ps, pt2, source, target) {
  return distance9(p2, ps) + distance9(p2, pt2) + _costByPoints(p2, [ps, pt2, source, target]);
};
var reconstructPath = function reconstructPath2(pathPoints, pointById, cameFrom, currentId, iterator) {
  if (iterator === void 0) {
    iterator = 0;
  }
  pathPoints.unshift(pointById[currentId]);
  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {
    reconstructPath2(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);
  }
};
var removeFrom = function removeFrom2(arr, item) {
  var index = arr.indexOf(item);
  if (index > -1) {
    arr.splice(index, 1);
  }
};
var isSegmentsIntersected = function isSegmentsIntersected2(p0, p1, p2, p3) {
  var v1x = p2.x - p0.x;
  var v1y = p2.y - p0.y;
  var v2x = p3.x - p0.x;
  var v2y = p3.y - p0.y;
  var v3x = p2.x - p1.x;
  var v3y = p2.y - p1.y;
  var v4x = p3.x - p1.x;
  var v4y = p3.y - p1.y;
  var pd1 = v1x * v2y - v1y * v2x;
  var pd2 = v3x * v4y - v3y * v4x;
  var pd3 = v1x * v3y - v1y * v3x;
  var pd4 = v2x * v4y - v2y * v4x;
  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;
};
var isSegmentCrossingBBox = function isSegmentCrossingBBox2(p1, p2, bbox) {
  if (bbox.width || bbox.height) {
    var _a2 = getPointsFromBBox(bbox), pa2 = _a2[0], pb = _a2[1], pc = _a2[2], pd = _a2[3];
    return isSegmentsIntersected(p1, p2, pa2, pb) || isSegmentsIntersected(p1, p2, pa2, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);
  }
  return false;
};
var getNeighborPoints = function getNeighborPoints2(points, point, bbox1, bbox2) {
  var neighbors = [];
  points.forEach(function(p2) {
    if (p2 === point)
      return;
    if (p2.x === point.x || p2.y === point.y) {
      if (isSegmentCrossingBBox(p2, point, bbox1) || isSegmentCrossingBBox(p2, point, bbox2))
        return;
      neighbors.push(p2);
    }
  });
  return filterConnectPoints(neighbors);
};
var pathFinder = function pathFinder2(points, start, goal, sBBox, tBBox, os, ot2) {
  var closedSet = [];
  var openSet = [start];
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  gScore[start.id] = 0;
  fScore[start.id] = heuristicCostEstimate(start, goal, start);
  var pointById = {};
  points.forEach(function(p2) {
    pointById[p2.id] = p2;
  });
  var current, lowestFScore;
  while (openSet.length) {
    current = void 0;
    lowestFScore = Infinity;
    openSet.forEach(function(p2) {
      if (fScore[p2.id] <= lowestFScore) {
        lowestFScore = fScore[p2.id];
        current = p2;
      }
    });
    if (current === goal) {
      var pathPoints = [];
      reconstructPath(pathPoints, pointById, cameFrom, goal.id);
      return pathPoints;
    }
    removeFrom(openSet, current);
    closedSet.push(current);
    getNeighborPoints(points, current, sBBox, tBBox).forEach(function(neighbor) {
      if (closedSet.indexOf(neighbor) !== -1) {
        return;
      }
      if (openSet.indexOf(neighbor) === -1) {
        openSet.push(neighbor);
      }
      var tentativeGScore = fScore[current.id] + distance9(current, neighbor);
      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {
        return;
      }
      cameFrom[neighbor.id] = current.id;
      gScore[neighbor.id] = tentativeGScore;
      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot2);
    });
  }
  return [start, goal];
};
var isBending = function isBending2(p0, p1, p2) {
  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);
};
var getBorderRadiusPoints = function getBorderRadiusPoints2(p0, p1, p2, r2) {
  var d0 = distance9(p0, p1);
  var d1 = distance9(p2, p1);
  if (d0 < r2) {
    r2 = d0;
  }
  if (d1 < r2) {
    r2 = d1;
  }
  var ps = {
    x: p1.x - r2 / d0 * (p1.x - p0.x),
    y: p1.y - r2 / d0 * (p1.y - p0.y)
  };
  var pt2 = {
    x: p1.x - r2 / d1 * (p1.x - p2.x),
    y: p1.y - r2 / d1 * (p1.y - p2.y)
  };
  return [ps, pt2];
};
var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline2(points, borderRadius) {
  var pathSegments = [];
  var startPoint = points[0];
  pathSegments.push("M".concat(startPoint.x, " ").concat(startPoint.y));
  points.forEach(function(p2, i2) {
    var p1 = points[i2 + 1];
    var p22 = points[i2 + 2];
    if (p1 && p22) {
      if (isBending(p2, p1, p22)) {
        var _a2 = getBorderRadiusPoints(p2, p1, p22, borderRadius), ps = _a2[0], pt2 = _a2[1];
        pathSegments.push("L".concat(ps.x, " ").concat(ps.y));
        pathSegments.push("Q".concat(p1.x, " ").concat(p1.y, " ").concat(pt2.x, " ").concat(pt2.y));
        pathSegments.push("L".concat(pt2.x, " ").concat(pt2.y));
      } else {
        pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
      }
    } else if (p1) {
      pathSegments.push("L".concat(p1.x, " ").concat(p1.y));
    }
  });
  return pathSegments.join("");
};
var getPolylinePoints = function getPolylinePoints2(start, end2, sNode, tNode, offset) {
  var sBBox, tBBox;
  if (!sNode || !sNode.getType()) {
    sBBox = getBBoxFromPoint(start);
  } else if (sNode.getType() === "combo") {
    var sNodeKeyShape = sNode.getKeyShape();
    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);
    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;
    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;
  } else {
    sBBox = sNode.getBBox();
  }
  if (!tNode || !tNode.getType()) {
    tBBox = getBBoxFromPoint(end2);
  } else if (tNode.getType() === "combo") {
    var tKeyShapeBBox = tNode.getKeyShape().getBBox();
    if (tKeyShapeBBox) {
      var _a2 = tNode.getModel(), tx = _a2.x, ty = _a2.y;
      tBBox = {
        x: tx,
        y: ty,
        width: tKeyShapeBBox.width,
        height: tKeyShapeBBox.height,
        minX: tKeyShapeBBox.minX + tx,
        maxX: tKeyShapeBBox.maxX + tx,
        minY: tKeyShapeBBox.minY + ty,
        maxY: tKeyShapeBBox.maxY + ty
      };
      tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;
      tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;
    } else {
      tBBox = getBBoxFromPoint(end2);
    }
  } else {
    tBBox = tNode && tNode.getBBox();
  }
  var sxBBox = getExpandedBBox(sBBox, offset);
  var txBBox = getExpandedBBox(tBBox, offset);
  var sPoint = getExpandedBBoxPoint(sxBBox, start, end2);
  var tPoint = getExpandedBBoxPoint(txBBox, end2, start);
  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);
  var sMixBBox = mergeBBox2(sxBBox, lineBBox);
  var tMixBBox = mergeBBox2(txBBox, lineBBox);
  var connectPoints = [];
  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox)).concat(getPointsFromBBox(tMixBBox));
  var centerPoint = {
    x: (start.x + end2.x) / 2,
    y: (start.y + end2.y) / 2
  };
  [lineBBox, sMixBBox, tMixBBox].forEach(function(bbox) {
    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function(p2) {
      return isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox);
    }));
  });
  [{
    x: sPoint.x,
    y: tPoint.y
  }, {
    x: tPoint.x,
    y: sPoint.y
  }].forEach(function(p2) {
    if (isPointOutsideBBox(p2, sxBBox) && isPointOutsideBBox(p2, txBBox)) {
      connectPoints.push(p2);
    }
  });
  connectPoints.unshift(sPoint);
  connectPoints.push(tPoint);
  connectPoints = filterConnectPoints(connectPoints);
  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end2);
  pathPoints.unshift(start);
  pathPoints.push(end2);
  return simplifyPolyline(pathPoints);
};

// node_modules/@antv/g6-element/es/edges/router.js
init_esm();
var manhattanDist = function manhattanDist2(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};
var eucliDist = function eucliDist2(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};
var straightPath = function straightPath2(start, end2) {
  return [start, end2];
};
var simplePolyline = function simplePolyline2(start, end2, startNode, endNode, cfg) {
  return simplifyPolyline(getPolylinePoints(start, end2, startNode, endNode, cfg.offset));
};
var defaultCfg = {
  offset: 20,
  maxAllowedDirectionChange: Math.PI / 2,
  maximumLoops: 2e3,
  gridSize: 10,
  directions: [
    {
      stepX: 1,
      stepY: 0
    },
    {
      stepX: -1,
      stepY: 0
    },
    {
      stepX: 0,
      stepY: 1
    },
    {
      stepX: 0,
      stepY: -1
    }
  ],
  get penalties() {
    return {
      0: 0,
      45: this.gridSize / 2,
      90: this.gridSize / 2
    };
  },
  distFunc: manhattanDist,
  fallbackRoute: simplePolyline
};
var octolinearCfg = {
  maxAllowedDirectionChange: Math.PI / 4,
  directions: [{
    stepX: 1,
    stepY: 0
  }, {
    stepX: 1,
    stepY: 1
  }, {
    stepX: 0,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 0
  }, {
    stepX: -1,
    stepY: -1
  }, {
    stepX: 0,
    stepY: -1
  }, {
    stepX: 1,
    stepY: -1
  }],
  distFunc: eucliDist,
  fallbackRoute: straightPath
};
var pos2GridIx = function pos2GridIx2(pos, gridSize) {
  var gridIx = Math.round(Math.abs(pos / gridSize));
  var sign = pos < 0 ? -1 : 1;
  return gridIx < 0 ? 0 : sign * gridIx;
};
var getObstacleMap = function getObstacleMap2(items, gridSize, offset) {
  var map4 = {};
  items.forEach(function(item) {
    if (!item)
      return;
    var bbox = getExpandedBBox(item.getBBox(), offset);
    for (var x2 = pos2GridIx(bbox.minX, gridSize); x2 <= pos2GridIx(bbox.maxX, gridSize); x2 += 1) {
      for (var y2 = pos2GridIx(bbox.minY, gridSize); y2 <= pos2GridIx(bbox.maxY, gridSize); y2 += 1) {
        map4["".concat(x2, "|||").concat(y2)] = true;
      }
    }
  });
  return map4;
};
var getDirectionAngle = function getDirectionAngle2(p1, p2) {
  var deltaX = p2.x - p1.x;
  var deltaY = p2.y - p1.y;
  if (deltaX || deltaY) {
    return Math.atan2(deltaY, deltaX);
  }
  return 0;
};
var getAngleDiff = function getAngleDiff2(angle1, angle22) {
  var directionChange = Math.abs(angle1 - angle22);
  return directionChange > Math.PI ? 2 * Math.PI - directionChange : directionChange;
};
var estimateCost = function estimateCost2(from, endPoints, distFunc) {
  var min6 = Infinity;
  for (var i2 = 0, len5 = endPoints.length; i2 < len5; i2++) {
    var cost = distFunc(from, endPoints[i2]);
    if (cost < min6) {
      min6 = cost;
    }
  }
  return min6;
};
var getBoxPoints = function getBoxPoints2(point, oriPoint, node, anotherPoint, cfg) {
  var points = [];
  if (!node) {
    return [point];
  }
  var directions = cfg.directions, offset = cfg.offset;
  var bbox = node.getBBox();
  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;
  var expandBBox = getExpandedBBox(bbox, offset);
  for (var i2 in expandBBox) {
    expandBBox[i2] = pos2GridIx(expandBBox[i2], cfg.gridSize);
  }
  if (isInside) {
    for (var _i2 = 0, directions_1 = directions; _i2 < directions_1.length; _i2++) {
      var dir = directions_1[_i2];
      var bounds = [[{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.minY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.minX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.maxX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.maxY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }]];
      for (var i2 = 0; i2 < 4; i2++) {
        var boundLine = bounds[i2];
        var insterctP_1 = util_default.getLineIntersect(point, {
          x: point.x + dir.stepX * expandBBox.width,
          y: point.y + dir.stepY * expandBBox.height
        }, boundLine[0], boundLine[1]);
        if (insterctP_1 && !isSegmentCrossingBBox(point, insterctP_1, bbox)) {
          insterctP_1.id = "".concat(insterctP_1.x, "|||").concat(insterctP_1.y);
          points.push(insterctP_1);
        }
      }
    }
    return points;
  }
  var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);
  insterctP.id = "".concat(insterctP.x, "|||").concat(insterctP.y);
  return [insterctP];
};
var getDirectionChange = function getDirectionChange2(current, neighbor, cameFrom, scaleStartPoint) {
  var directionAngle = getDirectionAngle(current, neighbor);
  if (!cameFrom[current.id]) {
    var startAngle = getDirectionAngle(scaleStartPoint, current);
    return getAngleDiff(startAngle, directionAngle);
  }
  var prevDirectionAngle = getDirectionAngle({
    x: cameFrom[current.id].x,
    y: cameFrom[current.id].y
  }, current);
  return getAngleDiff(prevDirectionAngle, directionAngle);
};
var getControlPoints12 = function getControlPoints13(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize) {
  var controlPoints = [endPoint];
  var currentId = current.id;
  var currentX = current.x;
  var currentY = current.y;
  var lastPoint = {
    x: currentX,
    y: currentY,
    id: currentId
  };
  if (getDirectionChange(lastPoint, scaleEndPoint, cameFrom, scaleStartPoint)) {
    controlPoints.unshift({
      x: scaleEndPoint.x === endPoint.x ? endPoint.x : lastPoint.x * gridSize,
      y: scaleEndPoint.y === endPoint.y ? endPoint.y : lastPoint.y * gridSize
    });
  }
  while (cameFrom[currentId] && cameFrom[currentId].id !== currentId) {
    var point = {
      x: currentX,
      y: currentY,
      id: currentId
    };
    var preId = cameFrom[currentId].id;
    var preX = cameFrom[currentId].x;
    var preY = cameFrom[currentId].y;
    var prePoint = {
      x: preX,
      y: preY,
      id: preId
    };
    var directionChange = getDirectionChange(prePoint, point, cameFrom, scaleStartPoint);
    if (directionChange) {
      controlPoints.unshift({
        x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * gridSize,
        y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * gridSize
      });
    }
    currentId = preId;
    currentX = preX;
    currentY = preY;
  }
  var firstPoint = {
    x: currentX,
    y: currentY,
    id: currentId
  };
  controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;
  controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;
  controlPoints.unshift(startPoint);
  return controlPoints;
};
var pathFinder3 = function pathFinder4(startPoint, endPoint, startNode, endNode, routerCfg) {
  if (isNaN(startPoint.x) || isNaN(endPoint.x))
    return [];
  var cfg = deep_mix_default(defaultCfg, routerCfg);
  cfg.obstacles = cfg.obstacles || [];
  var gridSize = cfg.gridSize;
  var map4 = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), gridSize, cfg.offset);
  var scaleStartPoint = {
    x: pos2GridIx(startPoint.x, gridSize),
    y: pos2GridIx(startPoint.y, gridSize)
  };
  var scaleEndPoint = {
    x: pos2GridIx(endPoint.x, gridSize),
    y: pos2GridIx(endPoint.y, gridSize)
  };
  startPoint.id = "".concat(scaleStartPoint.x, "|||").concat(scaleStartPoint.y);
  endPoint.id = "".concat(scaleEndPoint.x, "|||").concat(scaleEndPoint.y);
  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);
  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);
  startPoints.forEach(function(point) {
    delete map4[point.id];
  });
  endPoints.forEach(function(point) {
    delete map4[point.id];
  });
  var openSet = {};
  var closedSet = {};
  var cameFrom = {};
  var gScore = {};
  var fScore = {};
  for (var i2 = 0; i2 < startPoints.length; i2++) {
    var firstStep = startPoints[i2];
    openSet[firstStep.id] = firstStep;
    gScore[firstStep.id] = 0;
    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);
  }
  var remainLoops = cfg.maximumLoops;
  var penalties = cfg.penalties;
  var current, curCost, direction3, neighbor, neighborCost, costFromStart, directionChange;
  while (Object.keys(openSet).length > 0 && remainLoops > 0) {
    current = void 0;
    curCost = Infinity;
    Object.keys(openSet).forEach(function(key) {
      var id2 = openSet[key].id;
      if (fScore[id2] <= curCost) {
        curCost = fScore[id2];
        current = openSet[id2];
      }
    });
    if (!current)
      break;
    if (endPoints.findIndex(function(point) {
      return point.x === current.x && point.y === current.y;
    }) > -1) {
      return getControlPoints12(current, cameFrom, scaleStartPoint, endPoint, startPoint, scaleEndPoint, gridSize);
    }
    delete openSet[current.id];
    closedSet[current.id] = true;
    for (var i2 = 0; i2 < cfg.directions.length; i2++) {
      direction3 = cfg.directions[i2];
      neighbor = {
        x: current.x + direction3.stepX,
        y: current.y + direction3.stepY,
        id: "".concat(Math.round(current.x) + direction3.stepX, "|||").concat(Math.round(current.y) + direction3.stepY)
      };
      if (closedSet[neighbor.id])
        continue;
      directionChange = getDirectionChange(current, neighbor, cameFrom, scaleStartPoint);
      if (directionChange > cfg.maxAllowedDirectionChange)
        continue;
      if (map4[neighbor.id])
        continue;
      if (!openSet[neighbor.id]) {
        openSet[neighbor.id] = neighbor;
      }
      neighborCost = cfg.distFunc(current, neighbor) + (isNaN(penalties[directionChange]) ? gridSize : penalties[directionChange]);
      costFromStart = gScore[current.id] + neighborCost;
      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {
        continue;
      }
      cameFrom[neighbor.id] = current;
      gScore[neighbor.id] = costFromStart;
      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);
    }
    remainLoops -= 1;
  }
  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);
};

// node_modules/@antv/g6-element/es/edges/polyline.js
registerEdge("polyline", {
  options: {
    color: BaseGlobal.defaultEdge.color,
    size: BaseGlobal.defaultEdge.size,
    style: {
      radius: 0,
      offset: 15,
      x: 0,
      y: 0,
      stroke: BaseGlobal.defaultEdge.style.stroke,
      lineAppendWidth: BaseGlobal.defaultEdge.style.lineAppendWidth
    },
    labelCfg: {
      style: {
        fill: BaseGlobal.edgeLabel.style.fill,
        fontSize: BaseGlobal.edgeLabel.style.fontSize,
        fontFamily: BaseGlobal.windowFontFamily
      }
    },
    routeCfg: {
      obstacles: [],
      maxAllowedDirectionChange: Math.PI,
      maximumLoops: 500,
      gridSize: 10
    },
    stateStyles: __assign({}, BaseGlobal.edgeStateStyles)
  },
  shapeType: "polyline",
  labelPosition: "center",
  drawShape: function drawShape19(cfg, group) {
    var shapeStyle = this.getShapeStyle(cfg);
    if (shapeStyle.radius === 0)
      delete shapeStyle.radius;
    var keyShape = group.addShape("path", {
      className: "edge-shape",
      name: "edge-shape",
      attrs: shapeStyle
    });
    group["shapeMap"]["edge-shape"] = keyShape;
    return keyShape;
  },
  getShapeStyle: function getShapeStyle15(cfg) {
    var defaultStyle = this.options.style;
    var strokeStyle = {
      stroke: cfg.color
    };
    var style = mix({}, defaultStyle, strokeStyle, cfg.style);
    cfg = this.getPathPoints(cfg);
    this.radius = style.radius;
    this.offset = style.offset;
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = style.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = style.offset;
    var path = this.getPath(points, source, target, radius, routeCfg);
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    var attrs = mix({}, BaseGlobal.defaultEdge.style, style, {
      lineWidth: cfg.size,
      path
    });
    return attrs;
  },
  updateShapeStyle: function updateShapeStyle4(cfg, item) {
    var group = item.getContainer();
    if (!item.isVisible())
      return;
    var strokeStyle = {
      stroke: cfg.color
    };
    var shape = group["shapeMap"]["edge-shape"] || group.find(function(element) {
      return element.get("className") === "edge-shape";
    }) || item.getKeyShape();
    var size2 = cfg.size;
    cfg = this.getPathPoints(cfg);
    var startPoint = cfg.startPoint, endPoint = cfg.endPoint;
    var controlPoints = this.getControlPoints(cfg);
    var points = [startPoint];
    if (controlPoints) {
      points = points.concat(controlPoints);
    }
    points.push(endPoint);
    var currentAttr = shape.attr();
    var previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);
    var source = cfg.sourceNode;
    var target = cfg.targetNode;
    var radius = previousStyle.radius;
    var defaultRouteCfg = this.options.routeCfg;
    var routeCfg = mix({}, defaultRouteCfg, cfg.routeCfg);
    routeCfg.offset = previousStyle.offset;
    var path = this.getPath(points, source, target, radius, routeCfg);
    if (is_array_default(path) && path.length <= 1 || is_string_default(path) && path.indexOf("L") === -1) {
      path = "M0 0, L0 0";
    }
    if (isNaN(startPoint.x) || isNaN(startPoint.y) || isNaN(endPoint.x) || isNaN(endPoint.y)) {
      path = "M0 0, L0 0";
    }
    if (currentAttr.endArrow && previousStyle.endArrow === false) {
      cfg.style.endArrow = {
        path: ""
      };
    }
    if (currentAttr.startArrow && previousStyle.startArrow === false) {
      cfg.style.startArrow = {
        path: ""
      };
    }
    var style = mix(strokeStyle, shape.attr(), {
      lineWidth: size2,
      path
    }, cfg.style);
    if (shape) {
      shape.attr(style);
    }
  },
  getPath: function getPath9(points, source, target, radius, routeCfg) {
    var offset = routeCfg.offset, simple = routeCfg.simple;
    if (!offset || points.length > 2) {
      if (radius) {
        return getPathWithBorderRadiusByPolyline(points, radius);
      }
      var pathArray_1 = [];
      each_default(points, function(point, index) {
        if (index === 0) {
          pathArray_1.push(["M", point.x, point.y]);
        } else {
          pathArray_1.push(["L", point.x, point.y]);
        }
      });
      return pathArray_1;
    }
    var polylinePoints = simple ? getPolylinePoints(points[points.length - 1], points[0], target, source, offset) : pathFinder3(points[0], points[points.length - 1], source, target, routeCfg);
    if (!polylinePoints || !polylinePoints.length)
      return "M0 0, L0 0";
    if (radius) {
      var res_1 = getPathWithBorderRadiusByPolyline(polylinePoints, radius);
      return res_1;
    }
    var res = util_default.pointsToPolygon(polylinePoints);
    return res;
  }
}, "single-edge");

// node_modules/@antv/g6-pc/es/behavior/index.js
init_esm();

// node_modules/@antv/g6-pc/es/behavior/drag-canvas.js
var cloneEvent4 = util_default2.cloneEvent;
var isNaN4 = util_default2.isNaN;
var abs = Math.abs;
var DRAG_OFFSET = 10;
var ALLOW_EVENTS2 = ["shift", "ctrl", "alt", "control"];
var drag_canvas_default = {
  getDefaultCfg: function getDefaultCfg2() {
    return {
      direction: "both",
      enableOptimize: false,
      scalableRange: 0,
      allowDragOnItem: false
    };
  },
  getEvents: function getEvents2() {
    return {
      "dragstart": "onMouseDown",
      "drag": "onMouseMove",
      "dragend": "onMouseUp",
      "canvas:click": "onMouseUp",
      "keyup": "onKeyUp",
      "focus": "onKeyUp",
      "keydown": "onKeyDown",
      "touchstart": "onTouchStart",
      "touchmove": "onTouchMove",
      "touchend": "onMouseUp"
    };
  },
  updateViewport: function updateViewport(e8) {
    var origin = this.origin;
    var clientX = +e8.clientX;
    var clientY = +e8.clientY;
    if (isNaN4(clientX) || isNaN4(clientY)) {
      return;
    }
    var dx = clientX - origin.x;
    var dy = clientY - origin.y;
    if (this.get("direction") === "x") {
      dy = 0;
    } else if (this.get("direction") === "y") {
      dx = 0;
    }
    this.origin = {
      x: clientX,
      y: clientY
    };
    var width = this.graph.get("width");
    var height = this.graph.get("height");
    var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
    var expandWidth = this.scalableRange;
    var expandHeight = this.scalableRange;
    if (expandWidth < 1 && expandWidth > -1) {
      expandWidth = width * expandWidth;
      expandHeight = height * expandHeight;
    }
    if (graphCanvasBBox.minX <= width + expandWidth && graphCanvasBBox.minX + dx > width + expandWidth || graphCanvasBBox.maxX + expandWidth >= 0 && graphCanvasBBox.maxX + expandWidth + dx < 0) {
      dx = 0;
    }
    if (graphCanvasBBox.minY <= height + expandHeight && graphCanvasBBox.minY + dy > height + expandHeight || graphCanvasBBox.maxY + expandHeight >= 0 && graphCanvasBBox.maxY + expandHeight + dy < 0) {
      dy = 0;
    }
    this.graph.translate(dx, dy);
  },
  onTouchStart: function onTouchStart(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      return;
    }
    e8.preventDefault();
    self2.onMouseDown(e8);
  },
  onMouseDown: function onMouseDown(e8) {
    var self2 = this;
    var event = e8.originalEvent;
    if (event && e8.name !== "touchstart" && event.button !== 0) {
      return;
    }
    if (e8.name !== "touchstart" && typeof window !== "undefined" && window.event && !window.event.buttons && !window.event.button) {
      return;
    }
    if (!this.shouldBegin.call(this, e8)) {
      return;
    }
    if (self2.keydown)
      return;
    var target = e8.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (!this.allowDragOnItem && !targetIsCanvas)
      return;
    self2.origin = {
      x: e8.clientX,
      y: e8.clientY
    };
    self2.dragging = false;
    if (this.enableOptimize) {
      var graph = this.graph;
      var edges = graph.getEdges();
      for (var i2 = 0, len5 = edges.length; i2 < len5; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes)
          continue;
        shapes.forEach(function(shape) {
          shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
          shape.hide();
        });
      }
      var nodes = graph.getNodes();
      for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
        var container2 = nodes[j2].getContainer();
        var children = container2.get("children");
        for (var _i2 = 0, children_1 = children; _i2 < children_1.length; _i2++) {
          var child = children_1[_i2];
          var isKeyShape = child.get("isKeyShape");
          if (!isKeyShape) {
            child.set("ori-visibility", child.get("ori-visibility") || child.get("visible"));
            child.hide();
          }
        }
      }
    }
  },
  onTouchMove: function onTouchMove(e8) {
    var self2 = this;
    var touches = e8.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (event1 && event2) {
      this.onMouseUp(e8);
      return;
    }
    e8.preventDefault();
    self2.onMouseMove(e8);
  },
  onMouseMove: function onMouseMove(e8) {
    var graph = this.graph;
    if (this.keydown)
      return;
    var target = e8.target;
    var targetIsCanvas = target && target.isCanvas && target.isCanvas();
    if (!this.allowDragOnItem && !targetIsCanvas)
      return;
    e8 = cloneEvent4(e8);
    if (!this.origin) {
      return;
    }
    if (!this.dragging) {
      if (abs(this.origin.x - e8.clientX) + abs(this.origin.y - e8.clientY) < DRAG_OFFSET) {
        return;
      }
      if (this.shouldBegin.call(this, e8)) {
        e8.type = "dragstart";
        graph.emit("canvas:dragstart", e8);
        this.originPosition = {
          x: e8.clientX,
          y: e8.clientY
        };
        this.dragging = true;
      }
    } else {
      e8.type = "drag";
      graph.emit("canvas:drag", e8);
    }
    if (this.shouldUpdate.call(this, e8)) {
      this.updateViewport(e8);
    }
  },
  onMouseUp: function onMouseUp(e8) {
    var _a2, _b;
    var graph = this.graph;
    if (this.keydown)
      return;
    var currentZoom = graph.getZoom();
    var modeController = graph.get("modeController");
    var zoomCanvas = (_b = (_a2 = modeController === null || modeController === void 0 ? void 0 : modeController.modes[modeController.mode]) === null || _a2 === void 0 ? void 0 : _a2.filter(function(behavior) {
      return behavior.type === "zoom-canvas";
    })) === null || _b === void 0 ? void 0 : _b[0];
    var optimizeZoom = zoomCanvas ? zoomCanvas.optimizeZoom || 0.1 : 0;
    if (this.enableOptimize) {
      var edges = graph.getEdges();
      for (var i2 = 0, len5 = edges.length; i2 < len5; i2++) {
        var shapes = edges[i2].get("group").get("children");
        if (!shapes)
          continue;
        shapes.forEach(function(shape) {
          var oriVis2 = shape.get("ori-visibility");
          if (oriVis2)
            shape.show();
        });
      }
      if (currentZoom > optimizeZoom) {
        var nodes = graph.getNodes();
        for (var j2 = 0, nodeLen = nodes.length; j2 < nodeLen; j2++) {
          var container2 = nodes[j2].getContainer();
          var children = container2.get("children");
          for (var _i2 = 0, children_2 = children; _i2 < children_2.length; _i2++) {
            var child = children_2[_i2];
            var isKeyShape = child.get("isKeyShape");
            if (!isKeyShape) {
              var oriVis = child.get("ori-visibility");
              if (oriVis)
                child.show();
            }
          }
        }
      }
    }
    if (!this.dragging) {
      this.origin = null;
      return;
    }
    e8 = cloneEvent4(e8);
    if (this.shouldEnd.call(this, e8)) {
      this.updateViewport(e8);
    }
    e8.type = "dragend";
    e8.dx = e8.clientX - this.originPosition.x;
    e8.dy = e8.clientY - this.originPosition.y;
    graph.emit("canvas:dragend", e8);
    this.endDrag();
  },
  endDrag: function endDrag() {
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
  },
  onKeyDown: function onKeyDown(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (ALLOW_EVENTS2.indexOf(code.toLowerCase()) > -1) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp() {
    this.keydown = false;
    this.origin = null;
    this.dragging = false;
    this.dragbegin = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-node.js
init_esm();
var drag_node_default = {
  getDefaultCfg: function getDefaultCfg3() {
    return {
      updateEdge: true,
      delegateStyle: {},
      enableDelegate: false,
      onlyChangeComboSize: false,
      comboActiveState: "",
      selectedState: "selected",
      enableOptimize: false,
      enableDebounce: false,
      enableStack: true
    };
  },
  getEvents: function getEvents3() {
    return {
      "node:dragstart": "onDragStart",
      "node:drag": "onDrag",
      "node:dragend": "onDragEnd",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave",
      "combo:drop": "onDropCombo",
      "node:drop": "onDropNode",
      "canvas:drop": "onDropCanvas",
      "touchstart": "onTouchStart",
      "touchmove": "onTouchMove",
      "touchend": "onDragEnd"
    };
  },
  validationCombo: function validationCombo(item) {
    if (!this.origin || !item || item.destroyed) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onTouchStart: function onTouchStart2(e8) {
    if (!e8.item)
      return;
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.onDragStart(e8);
  },
  onTouchMove: function onTouchMove2(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        self2.onDragEnd(e8);
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.onDrag(e8);
  },
  onDragStart: function onDragStart(evt) {
    var _this = this;
    this.currentShouldEnd = true;
    if (!this.shouldBegin.call(this, evt)) {
      return;
    }
    var item = evt.item;
    if (!item || item.destroyed || item.hasLocked()) {
      return;
    }
    var group = item.getContainer();
    group.set("capture", false);
    if (!this.cachedCaptureItems)
      this.cachedCaptureItems = [];
    this.cachedCaptureItems.push(item);
    var target = evt.target;
    if (target) {
      var isAnchorPoint = target.get("isAnchorPoint");
      if (isAnchorPoint) {
        return;
      }
    }
    var graph = this.graph;
    this.targets = [];
    this.targetCombo = null;
    var nodes = graph.findAllByState("node", this.selectedState);
    var currentNodeId = item.get("id");
    var dragNodes = nodes.filter(function(node) {
      var nodeId = node.get("id");
      return currentNodeId === nodeId;
    });
    if (dragNodes.length === 0) {
      this.targets.push(item);
    } else if (nodes.length > 1) {
      nodes.forEach(function(node) {
        var locked = node.hasLocked();
        if (!locked) {
          _this.targets.push(node);
        }
      });
    } else {
      this.targets.push(item);
    }
    var beforeDragNodes = [];
    this.targets.forEach(function(t4) {
      beforeDragNodes.push(clone_default(t4.getModel()));
    });
    this.set("beforeDragNodes", beforeDragNodes);
    this.hidenEdge = {};
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          _this.hidenEdge[edge.getID()] = true;
          edge.hide();
        });
      });
    }
    this.origin = {
      x: evt.x,
      y: evt.y
    };
    this.point = {};
    this.originPoint = {};
  },
  onDrag: function onDrag(evt) {
    var _this = this;
    if (!this.origin) {
      return;
    }
    if (!this.shouldUpdate.call(this, evt)) {
      return;
    }
    if (this.get("enableDelegate")) {
      this.updateDelegate(evt);
    } else {
      if (this.enableDebounce)
        this.debounceUpdate({
          targets: this.targets,
          graph: this.graph,
          point: this.point,
          origin: this.origin,
          evt,
          updateEdge: this.get("updateEdge")
        });
      else
        this.targets.map(function(target) {
          _this.update(target, evt);
        });
    }
  },
  onDragEnd: function onDragEnd(evt) {
    var _this = this;
    var _a2;
    if (!this.origin) {
      return;
    }
    (_a2 = this.cachedCaptureItems) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(item) {
      var group = item.getContainer();
      group.set("capture", true);
    });
    this.cachedCaptureItems = [];
    if (this.delegateRect) {
      this.delegateRect.remove();
      this.delegateRect = null;
    }
    if (this.get("updateEdge") && this.enableOptimize && !this.enableDelegate) {
      this.targets.forEach(function(node) {
        var edges = node.getEdges();
        edges.forEach(function(edge) {
          if (_this.hidenEdge[edge.getID()])
            edge.show();
          edge.refresh();
        });
      });
    }
    this.hidenEdge = {};
    var graph = this.graph;
    if (graph.get("enabledStack") && this.enableStack) {
      var stackData_1 = {
        before: {
          nodes: [],
          edges: [],
          combos: []
        },
        after: {
          nodes: [],
          edges: [],
          combos: []
        }
      };
      this.get("beforeDragNodes").forEach(function(model) {
        stackData_1.before.nodes.push({
          id: model.id,
          x: model.x,
          y: model.y
        });
      });
      this.targets.forEach(function(target) {
        var targetModel = target.getModel();
        stackData_1.after.nodes.push({
          id: targetModel.id,
          x: targetModel.x,
          y: targetModel.y
        });
      });
      graph.pushStack("update", clone_default(stackData_1));
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: null
    });
    this.point = {};
    this.origin = null;
    this.originPoint = {};
    this.targets.length = 0;
    this.targetCombo = null;
  },
  onDropCombo: function onDropCombo(evt) {
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd.call(this, evt, item);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
    this.targetCombo = item;
    if (this.onlyChangeComboSize) {
      graph.updateCombos();
    } else {
      var targetComboModel_1 = item.getModel();
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (nodeModel.comboId !== targetComboModel_1.id) {
          graph.updateComboTree(node, targetComboModel_1.id);
        }
      });
      graph.updateCombo(item);
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: this.targetCombo
    });
  },
  onDropCanvas: function onDropCanvas(evt) {
    var graph = this.graph;
    this.currentShouldEnd = this.shouldEnd.call(this, evt, void 0);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.targets || this.targets.length === 0 || !this.currentShouldEnd)
      return;
    if (this.onlyChangeComboSize) {
      graph.updateCombos();
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
  },
  onDropNode: function onDropNode(evt) {
    if (!this.targets || this.targets.length === 0)
      return;
    var self2 = this;
    var item = evt.item;
    var graph = self2.graph;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd)
      return;
    if (this.onlyChangeComboSize) {
      graph.updateCombos();
    } else if (comboId) {
      var combo = graph.findById(comboId);
      if (self2.comboActiveState) {
        graph.setItemState(combo, self2.comboActiveState, false);
      }
      this.targets.map(function(node) {
        var nodeModel = node.getModel();
        if (comboId !== nodeModel.comboId) {
          graph.updateComboTree(node, comboId);
        }
      });
      graph.updateCombo(combo);
    } else {
      this.targets.map(function(node) {
        var model = node.getModel();
        if (model.comboId) {
          graph.updateComboTree(node);
        }
      });
    }
    graph.emit("dragnodeend", {
      items: this.targets,
      targetItem: item
    });
  },
  onDragEnter: function onDragEnter(evt) {
    var item = evt.item;
    if (!this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, true);
    }
  },
  onDragLeave: function onDragLeave(evt) {
    var item = evt.item;
    if (!this.validationCombo(item))
      return;
    var graph = this.graph;
    if (this.comboActiveState) {
      graph.setItemState(item, this.comboActiveState, false);
    }
  },
  updatePositions: function updatePositions(evt, restore) {
    var _this = this;
    if (!this.targets || this.targets.length === 0)
      return;
    if (this.get("enableDelegate")) {
      if (this.enableDebounce)
        this.debounceUpdate({
          targets: this.targets,
          graph: this.graph,
          point: this.point,
          origin: this.origin,
          evt,
          updateEdge: this.get("updateEdge"),
          updateFunc: this.update
        });
      else if (!restore)
        this.targets.map(function(node) {
          return _this.update(node, evt);
        });
    } else
      this.targets.map(function(node) {
        return _this.update(node, evt, restore);
      });
  },
  update: function update14(item, evt, restore) {
    var origin = this.origin;
    var model = item.get("model");
    var nodeId = item.get("id");
    if (!this.point[nodeId]) {
      this.point[nodeId] = {
        x: model.x || 0,
        y: model.y || 0
      };
    }
    var x2 = evt.x - origin.x + this.point[nodeId].x;
    var y2 = evt.y - origin.y + this.point[nodeId].y;
    if (restore) {
      x2 += origin.x - evt.x;
      y2 += origin.y - evt.y;
    }
    var pos = {
      x: x2,
      y: y2
    };
    if (this.get("updateEdge")) {
      this.graph.updateItem(item, pos, false);
    } else {
      item.updatePosition(pos);
    }
  },
  debounceUpdate: debounce_default(function(event) {
    var targets = event.targets, graph = event.graph, point = event.point, origin = event.origin, evt = event.evt, updateEdge = event.updateEdge, updateFunc = event.updateFunc;
    targets.map(function(item) {
      var model = item.get("model");
      var nodeId = item.get("id");
      if (!point[nodeId]) {
        point[nodeId] = {
          x: model.x || 0,
          y: model.y || 0
        };
      }
      var x2 = evt.x - origin.x + point[nodeId].x;
      var y2 = evt.y - origin.y + point[nodeId].y;
      var pos = {
        x: x2,
        y: y2
      };
      if (updateEdge) {
        graph.updateItem(item, pos, false);
      } else {
        item.updatePosition(pos);
      }
    });
  }, 50, true),
  updateDelegate: function updateDelegate(e8) {
    var graph = this.graph;
    if (!this.delegateRect) {
      var parent_1 = graph.get("group");
      var attrs = deep_mix_default({}, global_default2.delegateStyle, this.delegateStyle);
      var _a2 = this.calculationGroupPosition(e8), cx = _a2.x, cy = _a2.y, width = _a2.width, height = _a2.height, minX = _a2.minX, minY = _a2.minY;
      this.originPoint = {
        x: cx,
        y: cy,
        width,
        height,
        minX,
        minY
      };
      this.delegateRect = parent_1.addShape("rect", {
        attrs: __assign({
          width,
          height,
          x: cx,
          y: cy
        }, attrs),
        name: "rect-delegate-shape"
      });
      this.delegate = this.delegateRect;
      this.delegateRect.set("capture", false);
    } else {
      var clientX = e8.x - this.origin.x + this.originPoint.minX;
      var clientY = e8.y - this.origin.y + this.originPoint.minY;
      this.delegateRect.attr({
        x: clientX,
        y: clientY
      });
    }
  },
  calculationGroupPosition: function calculationGroupPosition(evt) {
    var nodes = this.targets;
    if (nodes.length === 0) {
      nodes.push(evt.item);
    }
    var minx = Infinity;
    var maxx = -Infinity;
    var miny = Infinity;
    var maxy = -Infinity;
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var element = nodes[i2];
      var bbox = element.getBBox();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY = bbox.maxY;
      if (minX < minx) {
        minx = minX;
      }
      if (minY < miny) {
        miny = minY;
      }
      if (maxX > maxx) {
        maxx = maxX;
      }
      if (maxY > maxy) {
        maxy = maxY;
      }
    }
    var x2 = Math.floor(minx);
    var y2 = Math.floor(miny);
    var width = Math.ceil(maxx) - Math.floor(minx);
    var height = Math.ceil(maxy) - Math.floor(miny);
    return {
      x: x2,
      y: y2,
      width,
      height,
      minX: minx,
      minY: miny
    };
  }
};

// node_modules/@antv/g6-pc/es/behavior/activate-relations.js
var activate_relations_default = {
  getDefaultCfg: function getDefaultCfg4() {
    return {
      trigger: "mouseenter",
      activeState: "active",
      inactiveState: "inactive",
      resetSelected: false,
      shouldUpdate: function shouldUpdate3() {
        return true;
      }
    };
  },
  getEvents: function getEvents4() {
    if (this.get("trigger") === "mouseenter") {
      return {
        "node:mouseenter": "setAllItemStates",
        "combo:mouseenter": "setAllItemStates",
        "node:mouseleave": "clearActiveState",
        "combo:mouseleave": "clearActiveState"
      };
    }
    return {
      "node:click": "setAllItemStates",
      "combo:click": "setAllItemStates",
      "canvas:click": "clearActiveState",
      "node:touchstart": "setOnTouchStart",
      "combo:touchstart": "setOnTouchStart",
      "canvas:touchstart": "clearOnTouchStart"
    };
  },
  setOnTouchStart: function setOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.setAllItemStates(e8);
  },
  clearOnTouchStart: function clearOnTouchStart(e8) {
    var self2 = this;
    try {
      var touches = e8.originalEvent.touches;
      var event1 = touches[0];
      var event2 = touches[1];
      if (event1 && event2) {
        return;
      }
      e8.preventDefault();
    } catch (e9) {
      console.warn("Touch original event not exist!");
    }
    self2.clearActiveState(e8);
  },
  setAllItemStates: function setAllItemStates(e8) {
    var item = e8.item;
    var graph = this.graph;
    this.item = item;
    if (!this.shouldUpdate(e8.item, {
      event: e8,
      action: "activate"
    })) {
      return;
    }
    var self2 = this;
    var activeState = this.activeState;
    var inactiveState = this.inactiveState;
    var nodes = graph.getNodes();
    var combos = graph.getCombos();
    var edges = graph.getEdges();
    var vEdges = graph.get("vedges");
    var nodeLength = nodes.length;
    var comboLength = combos.length;
    var edgeLength = edges.length;
    var vEdgeLength = vEdges.length;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      var hasSelected = node.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(node, "selected", false);
        }
      }
      graph.setItemState(node, activeState, false);
      if (inactiveState) {
        graph.setItemState(node, inactiveState, true);
      }
    }
    for (var i2 = 0; i2 < comboLength; i2++) {
      var combo = combos[i2];
      var hasSelected = combo.hasState("selected");
      if (self2.resetSelected) {
        if (hasSelected) {
          graph.setItemState(combo, "selected", false);
        }
      }
      graph.setItemState(combo, activeState, false);
      if (inactiveState) {
        graph.setItemState(combo, inactiveState, true);
      }
    }
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      graph.setItemState(edge, activeState, false);
      if (inactiveState) {
        graph.setItemState(edge, inactiveState, true);
      }
    }
    for (var i2 = 0; i2 < vEdgeLength; i2++) {
      var vEdge = vEdges[i2];
      graph.setItemState(vEdge, activeState, false);
      if (inactiveState) {
        graph.setItemState(vEdge, inactiveState, true);
      }
    }
    if (inactiveState) {
      graph.setItemState(item, inactiveState, false);
    }
    graph.setItemState(item, activeState, true);
    var rEdges = item.getEdges();
    var rEdgeLegnth = rEdges.length;
    for (var i2 = 0; i2 < rEdgeLegnth; i2++) {
      var edge = rEdges[i2];
      var otherEnd = void 0;
      if (edge.getSource() === item) {
        otherEnd = edge.getTarget();
      } else {
        otherEnd = edge.getSource();
      }
      if (inactiveState) {
        graph.setItemState(otherEnd, inactiveState, false);
      }
      graph.setItemState(otherEnd, activeState, true);
      graph.setItemState(edge, inactiveState, false);
      graph.setItemState(edge, activeState, true);
      edge.toFront();
    }
    graph.emit("afteractivaterelations", {
      item: e8.item,
      action: "activate"
    });
  },
  clearActiveState: function clearActiveState(e8) {
    var self2 = this;
    var graph = self2.get("graph");
    if (!self2.shouldUpdate(e8.item, {
      event: e8,
      action: "deactivate"
    })) {
      return;
    }
    var activeState = this.activeState;
    var inactiveState = this.inactiveState;
    var autoPaint = graph.get("autoPaint");
    graph.setAutoPaint(false);
    var nodes = graph.getNodes() || [];
    var combos = graph.getCombos() || [];
    var edges = graph.getEdges() || [];
    var vEdges = graph.get("vedges") || [];
    var nodeLength = nodes.length;
    var comboLength = combos.length;
    var edgeLength = edges.length;
    var vEdgeLength = vEdges.length;
    for (var i2 = 0; i2 < nodeLength; i2++) {
      var node = nodes[i2];
      graph.clearItemStates(node, [activeState, inactiveState]);
    }
    for (var i2 = 0; i2 < comboLength; i2++) {
      var combo = combos[i2];
      graph.clearItemStates(combo, [activeState, inactiveState]);
    }
    for (var i2 = 0; i2 < edgeLength; i2++) {
      var edge = edges[i2];
      graph.clearItemStates(edge, [activeState, inactiveState, "deactivate"]);
    }
    for (var i2 = 0; i2 < vEdgeLength; i2++) {
      var vEdge = vEdges[i2];
      graph.clearItemStates(vEdge, [activeState, inactiveState, "deactivate"]);
    }
    graph.paint();
    graph.setAutoPaint(autoPaint);
    graph.emit("afteractivaterelations", {
      item: e8.item || self2.get("item"),
      action: "deactivate"
    });
  }
};

// node_modules/@antv/g6-pc/es/behavior/brush-select.js
var min5 = Math.min;
var max6 = Math.max;
var abs2 = Math.abs;
var DEFAULT_TRIGGER = "shift";
var ALLOW_EVENTS3 = ["drag", "shift", "ctrl", "alt", "control"];
var brush_select_default = {
  getDefaultCfg: function getDefaultCfg5() {
    return {
      brushStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER,
      includeEdges: true,
      selectedEdges: [],
      selectedNodes: []
    };
  },
  getEvents: function getEvents5() {
    if (!(ALLOW_EVENTS3.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER;
      console.warn("Behavior brush-select \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'drag'\u3001'shift'\u3001'ctrl' \u6216 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        "dragstart": "onMouseDown",
        "drag": "onMouseMove",
        "dragend": "onMouseUp",
        "canvas:click": "clearStates"
      };
    }
    return {
      "dragstart": "onMouseDown",
      "drag": "onMouseMove",
      "dragend": "onMouseUp",
      "canvas:click": "clearStates",
      "keyup": "onKeyUp",
      "keydown": "onKeyDown"
    };
  },
  onMouseDown: function onMouseDown2(e8) {
    var item = e8.item;
    var brush = this.brush;
    if (item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates();
    }
    if (!brush) {
      brush = this.createBrush();
    }
    this.originPoint = {
      x: e8.canvasX,
      y: e8.canvasY
    };
    brush.attr({
      width: 0,
      height: 0
    });
    brush.show();
    this.dragging = true;
  },
  onMouseMove: function onMouseMove2(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.updateBrush(e8);
  },
  onMouseUp: function onMouseUp2(e8) {
    var graph = this.graph;
    if (!this.brush && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.brush.remove(true);
    this.brush = null;
    this.getSelectedNodes(e8);
    this.dragging = false;
  },
  clearStates: function clearStates() {
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    nodes.forEach(function(node) {
      return graph.setItemState(node, selectedState, false);
    });
    edges.forEach(function(edge) {
      return graph.setItemState(edge, selectedState, false);
    });
    this.selectedNodes = [];
    this.selectedEdges = [];
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: []
      },
      select: false
    });
  },
  getSelectedNodes: function getSelectedNodes(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, originPoint = _a2.originPoint, shouldUpdate3 = _a2.shouldUpdate;
    var state = this.selectedState;
    var p1 = {
      x: e8.x,
      y: e8.y
    };
    var p2 = graph.getPointByCanvas(originPoint.x, originPoint.y);
    var left = min5(p1.x, p2.x);
    var right = max6(p1.x, p2.x);
    var top = min5(p1.y, p2.y);
    var bottom = max6(p1.y, p2.y);
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (!node.isVisible())
        return;
      var bbox = node.getBBox();
      if (bbox.centerX >= left && bbox.centerX <= right && bbox.centerY >= top && bbox.centerY <= bottom) {
        if (shouldUpdate3(node, "select")) {
          selectedNodes.push(node);
          var model = node.getModel();
          selectedIds.push(model.id);
          graph.setItemState(node, state, true);
        }
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select")) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges
      },
      select: true
    });
  },
  createBrush: function createBrush() {
    var self2 = this;
    var brush = self2.graph.get("canvas").addShape("rect", {
      attrs: self2.brushStyle,
      capture: false,
      name: "brush-shape"
    });
    this.brush = brush;
    this.delegate = brush;
    return brush;
  },
  updateBrush: function updateBrush(e8) {
    var originPoint = this.originPoint;
    this.brush.attr({
      width: abs2(e8.canvasX - originPoint.x),
      height: abs2(e8.canvasY - originPoint.y),
      x: min5(e8.canvasX, originPoint.x),
      y: min5(e8.canvasY, originPoint.y)
    });
  },
  onKeyDown: function onKeyDown2(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp2() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/click-select.js
init_esm();
var DEFAULT_TRIGGER2 = "shift";
var ALLOW_EVENTS4 = ["shift", "ctrl", "alt", "control"];
var click_select_default = {
  getDefaultCfg: function getDefaultCfg6() {
    return {
      multiple: true,
      trigger: DEFAULT_TRIGGER2,
      selectedState: "selected"
    };
  },
  getEvents: function getEvents6() {
    var self2 = this;
    if (!(ALLOW_EVENTS4.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER2;
      console.warn("Behavior brush-select \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'drag'\u3001'shift'\u3001'ctrl' \u6216 'alt'");
    }
    if (!self2.multiple) {
      return {
        "node:click": "onClick",
        "combo:click": "onClick",
        "canvas:click": "onCanvasClick"
      };
    }
    return {
      "node:click": "onClick",
      "combo:click": "onClick",
      "canvas:click": "onCanvasClick",
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onClick: function onClick(evt) {
    var self2 = this;
    var item = evt.item;
    if (!item || item.destroyed) {
      return;
    }
    var type = item.getType();
    var graph = self2.graph, keydown = self2.keydown, multiple = self2.multiple, shouldUpdate3 = self2.shouldUpdate, shouldBegin2 = self2.shouldBegin;
    if (!shouldBegin2.call(self2, evt)) {
      return;
    }
    if (!keydown || !multiple) {
      var selected = graph.findAllByState("node", self2.selectedState).concat(graph.findAllByState("combo", self2.selectedState));
      each_default(selected, function(combo) {
        if (combo !== item) {
          graph.setItemState(combo, self2.selectedState, false);
        }
      });
    }
    if (item.hasState(self2.selectedState)) {
      if (shouldUpdate3.call(self2, evt)) {
        graph.setItemState(item, self2.selectedState, false);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          combos: selectedCombos
        },
        select: false
      });
    } else {
      if (shouldUpdate3.call(self2, evt)) {
        graph.setItemState(item, self2.selectedState, true);
      }
      var selectedNodes = graph.findAllByState("node", self2.selectedState);
      var selectedCombos = graph.findAllByState("combo", self2.selectedState);
      graph.emit("nodeselectchange", {
        target: item,
        selectedItems: {
          nodes: selectedNodes,
          combos: selectedCombos
        },
        select: true
      });
    }
  },
  onCanvasClick: function onCanvasClick(evt) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldBegin2 = _a2.shouldBegin;
    if (!shouldBegin2.call(this, evt)) {
      return;
    }
    var selected = graph.findAllByState("node", this.selectedState);
    each_default(selected, function(node) {
      graph.setItemState(node, _this.selectedState, false);
    });
    var selectedCombos = graph.findAllByState("combo", this.selectedState);
    each_default(selectedCombos, function(combo) {
      graph.setItemState(combo, _this.selectedState, false);
    });
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: [],
        combos: []
      },
      select: false
    });
  },
  onKeyDown: function onKeyDown3(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase() || code.toLowerCase() === "control") {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp3() {
    var self2 = this;
    self2.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/zoom-canvas.js
init_esm();
var transform13 = ext_exports.transform;
var DELTA4 = 0.05;
var zoom_canvas_default = {
  getDefaultCfg: function getDefaultCfg7() {
    return {
      sensitivity: 2,
      minZoom: void 0,
      maxZoom: void 0,
      enableOptimize: false,
      optimizeZoom: 0.1,
      fixSelectedItems: {
        fixAll: false,
        fixLineWidth: false,
        fixLabel: false,
        fixState: "selected"
      },
      animate: false,
      animateCfg: {
        duration: 500
      }
    };
  },
  getEvents: function getEvents7() {
    var fixSelectedItems = this.fixSelectedItems;
    if (!fixSelectedItems.fixState)
      fixSelectedItems.fixState = "selected";
    if (fixSelectedItems.fixAll) {
      fixSelectedItems.fixLineWidth = true;
      fixSelectedItems.fixLabel = true;
    }
    return {
      wheel: "onWheel",
      touchstart: "onTouchStart",
      touchmove: "onTouchMove",
      touchend: "onTouchEnd"
    };
  },
  onTouchStart: function onTouchStart3(evt) {
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    evt.preventDefault();
    if (!event2) {
      return;
    }
    if (this.shouldBegin && !this.shouldBegin.call(this, evt)) {
      return;
    }
    this.startPoint = {
      pageX: event1.pageX,
      pageY: event1.pageY
    };
    this.moveable = true;
    if (event2) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    this.originScale = this.graph.getZoom() || this.currentScale || 1;
  },
  onTouchMove: function onTouchMove3(evt) {
    if (!this.moveable) {
      return;
    }
    evt.preventDefault();
    var touches = evt.originalEvent.touches;
    var event1 = touches[0];
    var event2 = touches[1];
    if (!event2) {
      return;
    }
    if (!this.endPoint) {
      this.endPoint = {
        pageX: event2.pageX,
        pageY: event2.pageY
      };
    }
    var getDistance3 = function getDistance4(start, end2) {
      return Math.hypot(end2.x - start.x, end2.y - start.y);
    };
    var scale9 = getDistance3({
      x: event1.pageX,
      y: event1.pageY
    }, {
      x: event2.pageX,
      y: event2.pageY
    }) / getDistance3({
      x: this.startPoint.pageX,
      y: this.startPoint.pageY
    }, {
      x: this.endPoint.pageX,
      y: this.endPoint.pageY
    });
    var zoom = this.originScale * scale9;
    this.currentScale = zoom;
    var minZoom = this.get("minZoom") || this.graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || this.graph.get("maxZoom");
    if (zoom > maxZoom || zoom < minZoom) {
      return;
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    var canvas = this.graph.get("canvas");
    var point = canvas.getPointByClient(evt.clientX, evt.clientY);
    this.graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    this.graph.emit("wheelzoom", evt);
  },
  onTouchEnd: function onTouchEnd() {
    this.moveable = false;
    this.endPoint = null;
  },
  onWheel: function onWheel(e8) {
    var _this = this;
    var _a2 = this, graph = _a2.graph, fixSelectedItems = _a2.fixSelectedItems;
    if (this.shouldBegin && !this.shouldBegin.call(this, e8)) {
      return;
    }
    if (!this.shouldUpdate.call(this, e8)) {
      return;
    }
    e8.preventDefault();
    var canvas = graph.get("canvas");
    var point = canvas.getPointByClient(e8.clientX, e8.clientY);
    var sensitivity = this.get("sensitivity");
    var graphZoom = graph.getZoom();
    var ratio = graphZoom;
    var zoom = graphZoom;
    if (e8.wheelDelta < 0) {
      ratio = 1 - DELTA4 * sensitivity;
    } else {
      ratio = 1 / (1 - DELTA4 * sensitivity);
    }
    zoom = graphZoom * ratio;
    var minZoom = this.get("minZoom") || graph.get("minZoom");
    var maxZoom = this.get("maxZoom") || graph.get("maxZoom");
    if (zoom > maxZoom || zoom < minZoom) {
      return;
    }
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c2 = 0; c2 < childrenLength; c2++) {
              var shape = children[c2];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c2 = 0; c2 < childrenLength; c2++) {
            var shape = children[c2];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout2 = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c3 = 0; c3 < childrenLength2; c3++) {
                var shape2 = children2[c3];
                var oriVis = shape2.get("ori-visibility");
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c3 = 0; c3 < childrenLength2; c3++) {
                var shape2 = children2[c3];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout2);
    }
    if (graphZoom <= 1) {
      var fixNodes = void 0, fixEdges = void 0;
      if (fixSelectedItems.fixAll || fixSelectedItems.fixLineWidth || fixSelectedItems.fixLabel) {
        fixNodes = graph.findAllByState("node", fixSelectedItems.fixState);
        fixEdges = graph.findAllByState("edge", fixSelectedItems.fixState);
        var scale9 = graphZoom / zoom;
        var fixNodesLength = fixNodes.length;
        for (var fn2 = 0; fn2 < fixNodesLength; fn2++) {
          var node = fixNodes[fn2];
          var group = node.getContainer();
          var nodeModel = node.getModel();
          var originStyle = node.getOriginStyle();
          var itemStateStyle = node.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = node.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, node)[fixSelectedItems.fixState];
          if (fixSelectedItems.fixAll) {
            if (zoom <= 1) {
              var groupMatrix = clone_default(group.getMatrix());
              if (!groupMatrix)
                groupMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
              var _b = node.getModel(), x2 = _b.x, y2 = _b.y;
              groupMatrix = transform13(groupMatrix, [["t", -x2, -y2], ["s", scale9, scale9], ["t", x2, y2]]);
              group.setMatrix(groupMatrix);
            }
          } else {
            var children = group.get("children");
            var childrenLength = children.length;
            for (var c2 = 0; c2 < childrenLength; c2++) {
              var shape = children[c2];
              var fontSize = void 0, lineWidth = void 0;
              if (fixSelectedItems.fixLabel) {
                var shapeType = shape.get("type");
                if (shapeType === "text") {
                  fontSize = shape.attr("fontSize") || 12;
                  var itemStyle = itemStateStyle[shape.get("name")];
                  var shapeStyle = shapeStateStyle[shape.get("name")];
                  var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                  var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                  var oriFontSize = itemFontSize || shapeFontSize || 12;
                  if (zoom <= 1)
                    shape.attr("fontSize", oriFontSize / zoom);
                  if (lineWidth)
                    break;
                }
              }
              if (fixSelectedItems.fixLineWidth) {
                if (shape.get("isKeyShape")) {
                  lineWidth = shape.attr("lineWidth") || 0;
                  var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || originStyle.lineWidth || 0;
                  if (zoom <= 1)
                    shape.attr("lineWidth", oriLineWidth / zoom);
                  if (fontSize)
                    break;
                }
              }
            }
          }
        }
        var fixEdgesLength = fixEdges.length;
        for (var fe2 = 0; fe2 < fixEdgesLength; fe2++) {
          var edge = fixEdges[fe2];
          var group = edge.getContainer();
          var children = group.get("children");
          var nodeModel = edge.getModel();
          var itemStateStyle = edge.getStateStyle(fixSelectedItems.fixState);
          var shapeStateStyle = edge.get("shapeFactory").getShape(nodeModel.type).getStateStyle(fixSelectedItems.fixState, edge)[fixSelectedItems.fixState];
          var childrenLength = children.length;
          for (var c2 = 0; c2 < childrenLength; c2++) {
            var shape = children[c2];
            var fontSize = void 0, lineWidth = void 0;
            if (fixSelectedItems.fixLabel || fixSelectedItems.fixAll) {
              var shapeType = shape.get("type");
              if (shapeType === "text") {
                fontSize = shape.attr("fontSize") || 12;
                var itemStyle = itemStateStyle[shape.get("name")];
                var shapeStyle = shapeStateStyle[shape.get("name")];
                var itemFontSize = itemStyle ? itemStyle.fontSize : 12;
                var shapeFontSize = shapeStyle ? shapeStyle.fontSize : 12;
                var oriFontSize = itemFontSize || shapeFontSize || 12;
                if (zoom <= 1)
                  shape.attr("fontSize", oriFontSize / zoom);
                if (lineWidth)
                  break;
              }
            }
            if (fixSelectedItems.fixLineWidth || fixSelectedItems.fixAll) {
              if (shape.get("isKeyShape")) {
                lineWidth = shape.attr("lineWidth") || 0;
                var oriLineWidth = itemStateStyle.lineWidth || shapeStateStyle.lineWidth || 1;
                if (zoom <= 1)
                  shape.attr("lineWidth", oriLineWidth / zoom);
                if (fontSize)
                  break;
              }
            }
          }
        }
      }
    }
    var animate = this.get("animate");
    var animateCfg = this.get("animateCfg");
    graph.zoomTo(zoom, {
      x: point.x,
      y: point.y
    }, animate, animateCfg);
    graph.emit("wheelzoom", e8);
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip-base.js
var tooltip_base_default = {
  onMouseEnter: function onMouseEnter(e8) {
    var item = e8.item;
    this.currentTarget = item;
    this.showTooltip(e8);
    this.graph.emit("tooltipchange", {
      item: e8.item,
      action: "show"
    });
  },
  onMouseMove: function onMouseMove3(e8) {
    if (!this.shouldUpdate(e8)) {
      this.hideTooltip();
      return;
    }
    if (!this.currentTarget || e8.item !== this.currentTarget) {
      return;
    }
    this.updatePosition(e8);
  },
  onMouseLeave: function onMouseLeave(e8) {
    if (!this.shouldEnd(e8)) {
      return;
    }
    this.hideTooltip();
    this.graph.emit("tooltipchange", {
      item: this.currentTarget,
      action: "hide"
    });
    this.currentTarget = null;
  },
  showTooltip: function showTooltip(e8) {
    var container2 = this.container;
    if (!e8.item || e8.item.destroyed) {
      return;
    }
    if (!container2) {
      container2 = this.createTooltip(this.graph.get("canvas"));
      this.container = container2;
    }
    var text = this.formatText(e8.item.get("model"), e8);
    container2.innerHTML = text;
    modifyCSS(this.container, {
      visibility: "visible"
    });
    this.updatePosition(e8);
  },
  hideTooltip: function hideTooltip() {
    modifyCSS(this.container, {
      visibility: "hidden"
    });
  },
  updatePosition: function updatePosition(e8) {
    var shouldBegin2 = this.get("shouldBegin");
    var _a2 = this, width = _a2.width, height = _a2.height, container2 = _a2.container, graph = _a2.graph;
    if (!shouldBegin2(e8)) {
      modifyCSS(container2, {
        visibility: "hidden"
      });
      return;
    }
    var point = graph.getPointByClient(e8.clientX, e8.clientY);
    var _b = graph.getCanvasByPoint(point.x, point.y), x2 = _b.x, y2 = _b.y;
    var bbox = container2.getBoundingClientRect();
    if (x2 > width / 2) {
      x2 -= bbox.width;
    } else {
      x2 += this.offset;
    }
    if (y2 > height / 2) {
      y2 -= bbox.height;
    } else {
      y2 += this.offset;
    }
    var left = "".concat(x2, "px");
    var top = "".concat(y2, "px");
    modifyCSS(this.container, {
      left,
      top,
      visibility: "visible"
    });
  },
  createTooltip: function createTooltip(canvas) {
    var el = canvas.get("el");
    el.style.position = "relative";
    var container2 = createDom2('<div class="g6-tooltip g6-'.concat(this.item, '-tooltip"></div>'));
    el.parentNode.appendChild(container2);
    modifyCSS(container2, {
      position: "absolute",
      visibility: "visible"
    });
    this.width = canvas.get("width");
    this.height = canvas.get("height");
    this.container = container2;
    this.graph.get("tooltips").push(container2);
    return container2;
  }
};

// node_modules/@antv/g6-pc/es/behavior/tooltip.js
var tooltip_default2 = __assign({
  getDefaultCfg: function getDefaultCfg8() {
    return {
      item: "node",
      offset: 12,
      formatText: function formatText(model) {
        return model.label;
      }
    };
  },
  getEvents: function getEvents8() {
    return {
      "node:mouseenter": "onMouseEnter",
      "node:mouseleave": "onMouseLeave",
      "node:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/edge-tooltip.js
var edge_tooltip_default = __assign({
  getDefaultCfg: function getDefaultCfg9() {
    return {
      item: "edge",
      offset: 12,
      formatText: function formatText(model) {
        return "source: ".concat(model.source, " target: ").concat(model.target);
      }
    };
  },
  getEvents: function getEvents9() {
    return {
      "edge:mouseenter": "onMouseEnter",
      "edge:mouseleave": "onMouseLeave",
      "edge:mousemove": "onMouseMove",
      afterremoveitem: "onMouseLeave"
    };
  }
}, tooltip_base_default);

// node_modules/@antv/g6-pc/es/behavior/collapse-expand.js
var DEFAULT_TRIGGER3 = "click";
var ALLOW_EVENTS5 = ["click", "dblclick"];
var collapse_expand_default = {
  getDefaultCfg: function getDefaultCfg10() {
    return {
      trigger: DEFAULT_TRIGGER3,
      onChange: function onChange() {
      }
    };
  },
  getEvents: function getEvents10() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS5.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER3;
      console.warn("Behavior collapse-expand \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'click' \u6216 'dblclick'");
    }
    return _a2 = {}, _a2["node:".concat(trigger)] = "onNodeClick", _a2.touchstart = "onNodeClick", _a2;
  },
  onNodeClick: function onNodeClick(e8) {
    var item = e8.item;
    if (!item)
      return;
    var sourceData = this.graph.findDataById(item.get("id"));
    if (!sourceData) {
      return;
    }
    var children = sourceData.children;
    if (!children || children.length === 0) {
      return;
    }
    var collapsed = !sourceData.collapsed;
    if (!this.shouldBegin(e8, collapsed)) {
      return;
    }
    sourceData.collapsed = collapsed;
    item.getModel().collapsed = collapsed;
    this.graph.emit("itemcollapsed", {
      item: e8.item,
      collapsed
    });
    if (!this.shouldUpdate(e8, collapsed)) {
      return;
    }
    this.onChange(item, collapsed);
    this.graph.layout();
  }
};

// node_modules/@antv/g6-pc/es/behavior/drag-combo.js
init_esm();
var calculationItemsBBox3 = util_default2.calculationItemsBBox;
var traverseCombo = function traverseCombo2(data, fn2) {
  if (fn2(data) === false) {
    return;
  }
  if (data) {
    var combos = data.get("combos");
    if (combos.length === 0) {
      return false;
    }
    each_default(combos, function(child) {
      traverseCombo2(child, fn2);
    });
  }
};
var drag_combo_default = {
  getDefaultCfg: function getDefaultCfg11() {
    return {
      enableDelegate: false,
      delegateStyle: {},
      onlyChangeComboSize: false,
      activeState: "",
      selectedState: "selected"
    };
  },
  getEvents: function getEvents11() {
    return {
      "combo:dragstart": "onDragStart",
      "combo:drag": "onDrag",
      "combo:dragend": "onDragEnd",
      "combo:drop": "onDrop",
      "node:drop": "onNodeDrop",
      "combo:dragenter": "onDragEnter",
      "combo:dragleave": "onDragLeave"
    };
  },
  validationCombo: function validationCombo2(evt) {
    var item = evt.item;
    if (!item || item.destroyed) {
      return false;
    }
    if (!this.shouldUpdate.call(this, evt)) {
      return false;
    }
    var type = item.getType();
    if (type !== "combo") {
      return false;
    }
    return true;
  },
  onDragStart: function onDragStart2(evt) {
    var _this = this;
    var graph = this.graph;
    var item = evt.item;
    this.currentShouldEnd = true;
    if (!this.validationCombo(evt))
      return;
    this.targets = [];
    var combos = graph.findAllByState("combo", this.selectedState);
    var currentCombo = item.get("id");
    var dragCombos = combos.filter(function(combo) {
      var comboId = combo.get("id");
      return currentCombo === comboId;
    });
    if (dragCombos.length === 0) {
      this.targets.push(item);
    } else {
      this.targets = combos;
    }
    if (this.activeState) {
      this.targets.map(function(combo) {
        var model = combo.getModel();
        if (model.parentId) {
          var parentCombo = graph.findById(model.parentId);
          if (parentCombo) {
            graph.setItemState(parentCombo, _this.activeState, true);
          }
        }
      });
    }
    this.point = {};
    this.originPoint = {};
    this.origin = {
      x: evt.x,
      y: evt.y
    };
    this.currentItemChildCombos = [];
    traverseCombo(item, function(param) {
      if (param.destroyed) {
        return false;
      }
      var model = param.getModel();
      _this.currentItemChildCombos.push(model.id);
      return true;
    });
  },
  onDrag: function onDrag2(evt) {
    var _this = this;
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    if (this.enableDelegate) {
      this.updateDelegate(evt);
    } else {
      if (this.activeState) {
        var graph_1 = this.graph;
        var item = evt.item;
        var model_1 = item.getModel();
        var combos = graph_1.getCombos();
        var sourceBBox = item.getBBox();
        var centerX_1 = sourceBBox.centerX, centerY_1 = sourceBBox.centerY, width_1 = sourceBBox.width;
        var calcCombos = combos.filter(function(combo) {
          var cmodel = combo.getModel();
          if (!model_1.parentId) {
            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
          }
          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);
        });
        calcCombos.map(function(combo) {
          var _a2 = combo.getBBox(), cx = _a2.centerX, cy = _a2.centerY, w2 = _a2.width;
          var disX = centerX_1 - cx;
          var disY = centerY_1 - cy;
          var distance11 = 2 * Math.sqrt(disX * disX + disY * disY);
          if (width_1 + w2 - distance11 > 0.8 * width_1) {
            graph_1.setItemState(combo, _this.activeState, true);
          } else {
            graph_1.setItemState(combo, _this.activeState, false);
          }
        });
      }
      each_default(this.targets, function(item2) {
        _this.updateCombo(item2, evt);
      });
    }
  },
  updatePositions: function updatePositions2(evt, restore) {
    var _this = this;
    if (this.enableDelegate || restore) {
      each_default(this.targets, function(item) {
        _this.updateCombo(item, evt, restore);
      });
    }
  },
  onDrop: function onDrop(evt) {
    var _this = this;
    var item = evt.item;
    this.currentShouldEnd = this.shouldEnd.call(this, evt, item);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed)
      return;
    var graph = this.graph;
    var targetModel = item.getModel();
    this.targets.map(function(combo) {
      var model = combo.getModel();
      if (model.parentId !== targetModel.id) {
        if (_this.activeState) {
          graph.setItemState(item, _this.activeState, false);
        }
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo, targetModel.id);
        } else {
          graph.updateCombo(combo);
        }
      } else {
        graph.updateCombo(item);
      }
    });
    this.end(item, evt);
    this.endComparison = true;
  },
  onNodeDrop: function onNodeDrop(evt) {
    var _this = this;
    if (!this.targets || this.targets.length === 0)
      return;
    var graph = this.graph;
    var item = evt.item;
    var comboId = item.getModel().comboId;
    var newParentCombo = comboId ? graph.findById(comboId) : void 0;
    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo);
    this.updatePositions(evt, !this.currentShouldEnd);
    if (!this.currentShouldEnd)
      return;
    var droppedCombo;
    if (comboId) {
      if (this.activeState) {
        var combo = graph.findById(comboId);
        graph.setItemState(combo, this.activeState, false);
      }
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          if (comboId !== combo2.getID()) {
            droppedCombo = graph.findById(comboId);
            if (comboId !== combo2.getModel().parentId)
              graph.updateComboTree(combo2, comboId);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    } else {
      this.targets.map(function(combo2) {
        if (!_this.onlyChangeComboSize) {
          var model = combo2.getModel();
          if (model.comboId) {
            graph.updateComboTree(combo2);
          }
        } else {
          graph.updateCombo(combo2);
        }
      });
    }
    this.endComparison = true;
    this.end(droppedCombo, evt);
  },
  onDragEnter: function onDragEnter2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, true);
    }
  },
  onDragLeave: function onDragLeave2(evt) {
    if (!this.origin) {
      return;
    }
    if (!this.validationCombo(evt))
      return;
    var item = evt.item;
    var graph = this.graph;
    if (this.activeState) {
      graph.setItemState(item, this.activeState, false);
    }
  },
  onDragEnd: function onDragEnd2(evt) {
    if (!this.targets || this.targets.length === 0)
      return;
    var item = evt.item;
    if (this.currentShouldEnd) {
      this.updatePositions(evt);
    }
    var parentCombo = this.getParentCombo(item.getModel().parentId);
    var graph = this.graph;
    if (parentCombo && this.activeState) {
      graph.setItemState(parentCombo, this.activeState, false);
    }
    this.end(void 0, evt);
  },
  end: function end(comboDropedOn, evt) {
    var _this = this;
    if (!this.origin)
      return;
    var graph = this.graph;
    if (this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      delegateGroup.clear();
      this.delegateShape = null;
    }
    if (comboDropedOn && this.activeState) {
      graph.setItemState(comboDropedOn, this.activeState, false);
    }
    if (!comboDropedOn) {
      this.targets.map(function(combo) {
        if (!_this.onlyChangeComboSize) {
          graph.updateComboTree(combo);
        } else {
          graph.updateCombo(combo);
        }
      });
    }
    this.point = [];
    this.origin = null;
    this.originPoint = null;
    this.targets.length = 0;
  },
  traverse: function traverse3(data, fn2) {
    var _this = this;
    if (fn2(data) === false) {
      return;
    }
    if (data) {
      var combos = data.get("combos");
      each_default(combos, function(child) {
        _this.traverse(child, fn2);
      });
      var nodes = data.get("nodes");
      each_default(nodes, function(child) {
        _this.traverse(child, fn2);
      });
    }
  },
  updateCombo: function updateCombo(item, evt, restore) {
    var _this = this;
    this.traverse(item, function(param) {
      if (param.destroyed) {
        return false;
      }
      _this.updateSignleItem(param, evt, restore);
      return true;
    });
  },
  updateSignleItem: function updateSignleItem(item, evt, restore) {
    var origin = this.origin;
    var graph = this.graph;
    var model = item.getModel();
    var itemId = item.get("id");
    if (!this.point[itemId]) {
      this.point[itemId] = {
        x: model.x,
        y: model.y
      };
    }
    var x2 = evt.x - origin.x + this.point[itemId].x;
    var y2 = evt.y - origin.y + this.point[itemId].y;
    if (restore) {
      x2 += origin.x - evt.x;
      y2 += origin.y - evt.y;
    }
    graph.updateItem(item, {
      x: x2,
      y: y2
    });
  },
  getParentCombo: function getParentCombo(parentId) {
    var graph = this.graph;
    if (!parentId) {
      return void 0;
    }
    var parentCombo = graph.findById(parentId);
    if (!parentCombo) {
      return void 0;
    }
    return parentCombo;
  },
  updateDelegate: function updateDelegate2(evt) {
    var graph = this.graph;
    if (!this.delegateShape) {
      var delegateGroup = graph.get("delegateGroup");
      var bbox = null;
      if (this.targets.length > 1) {
        bbox = calculationItemsBBox3(this.targets);
      } else {
        bbox = this.targets[0].getBBox();
      }
      var x2 = bbox.x, y2 = bbox.y, width = bbox.width, height = bbox.height, minX = bbox.minX, minY = bbox.minY;
      this.originPoint = {
        x: x2,
        y: y2,
        width,
        height,
        minX,
        minY
      };
      var attrs = __assign(__assign({}, global_default2.delegateStyle), this.delegateStyle);
      this.delegateShape = delegateGroup.addShape("rect", {
        attrs: __assign({
          width: bbox.width,
          height: bbox.height,
          x: bbox.x,
          y: bbox.y
        }, attrs),
        name: "combo-delegate-shape"
      });
      this.delegateShape.set("capture", false);
      this.delegate = this.delegateShape;
    } else {
      var clientX = evt.x - this.origin.x + this.originPoint.minX;
      var clientY = evt.y - this.origin.y + this.originPoint.minY;
      this.delegateShape.attr({
        x: clientX,
        y: clientY
      });
    }
  }
};

// node_modules/@antv/g6-pc/es/behavior/collapse-expand-combo.js
var DEFAULT_TRIGGER4 = "dblclick";
var ALLOW_EVENTS6 = ["click", "dblclick"];
var collapse_expand_combo_default = {
  getDefaultCfg: function getDefaultCfg12() {
    return {
      trigger: DEFAULT_TRIGGER4,
      relayout: true
    };
  },
  getEvents: function getEvents12() {
    var _a2;
    var trigger;
    if (ALLOW_EVENTS6.includes(this.trigger)) {
      trigger = this.trigger;
    } else {
      trigger = DEFAULT_TRIGGER4;
      console.warn("Behavior collapse-expand-group \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'click' \u6216 'dblclick'");
    }
    return _a2 = {}, _a2["combo:".concat(trigger)] = "onComboClick", _a2;
  },
  onComboClick: function onComboClick(evt) {
    var item = evt.item;
    var _a2 = this, graph = _a2.graph, relayout = _a2.relayout;
    if (!item || item.destroyed || item.getType() !== "combo")
      return;
    var model = item.getModel();
    var comboId = model.id;
    if (!comboId) {
      return;
    }
    graph.collapseExpandCombo(comboId);
    if (relayout && graph.get("layout"))
      graph.layout();
    else
      graph.refreshPositions();
  }
};

// node_modules/@antv/g6-pc/es/behavior/lasso-select.js
var isPolygonsIntersect4 = util_default2.isPolygonsIntersect;
var pathToPoints3 = util_default2.pathToPoints;
var DEFAULT_TRIGGER5 = "shift";
var ALLOW_EVENTS7 = ["drag", "shift", "ctrl", "alt", "control"];
var isItemIntersecPolygon = function isItemIntersecPolygon2(item, polyPoints) {
  var shapePoints;
  var shape = item.getKeyShape();
  if (item.get("type") === "path") {
    shapePoints = pathToPoints3(shape.attr("path"));
  } else {
    var shapeBBox = shape.getCanvasBBox();
    shapePoints = [[shapeBBox.minX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.minY], [shapeBBox.maxX, shapeBBox.maxY], [shapeBBox.minX, shapeBBox.maxY]];
  }
  return isPolygonsIntersect4(polyPoints, shapePoints);
};
var lasso_select_default = {
  getDefaultCfg: function getDefaultCfg13() {
    return {
      delegateStyle: {
        fill: "#EEF6FF",
        fillOpacity: 0.4,
        stroke: "#DDEEFE",
        lineWidth: 1
      },
      onSelect: function onSelect() {
      },
      onDeselect: function onDeselect() {
      },
      shouldDeselect: void 0,
      selectedState: "selected",
      trigger: DEFAULT_TRIGGER5,
      includeEdges: true,
      selectedEdges: [],
      selectedNodes: []
    };
  },
  getEvents: function getEvents13() {
    if (!(ALLOW_EVENTS7.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER5;
      console.warn("Behavior lasso-select \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'drag'\u3001'shift'\u3001'ctrl' \u6216 'alt'");
    }
    if (this.trigger === "drag") {
      return {
        dragstart: "onDragStart",
        drag: "onDragMove",
        dragend: "onDragEnd",
        "canvas:click": "clearStates"
      };
    }
    return {
      dragstart: "onDragStart",
      drag: "onDragMove",
      dragend: "onDragEnd",
      keyup: "onKeyUp",
      keydown: "onKeyDown",
      "canvas:click": "clearStates"
    };
  },
  onDragStart: function onDragStart3(e8) {
    var lasso = this.lasso;
    var item = e8.item;
    if (item) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    if (this.selectedNodes && this.selectedNodes.length !== 0) {
      this.clearStates("dragstart");
    }
    if (!lasso) {
      lasso = this.createLasso();
    }
    this.dragging = true;
    this.originPoint = {
      x: e8.x,
      y: e8.y
    };
    this.points.push(this.originPoint);
    lasso.show();
  },
  onDragMove: function onDragMove(e8) {
    if (!this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push({
      x: e8.x,
      y: e8.y
    });
    this.updateLasso(e8);
  },
  onDragEnd: function onDragEnd3(e8) {
    if (!this.lasso && !this.dragging) {
      return;
    }
    if (this.trigger !== "drag" && !this.keydown) {
      return;
    }
    this.points.push(this.originPoint);
    this.getSelectedItems();
    this.lasso.remove(true);
    this.lasso = null;
    this.points = [];
    this.dragging = false;
  },
  getLassoPath: function getLassoPath() {
    var points = this.points;
    var path = [];
    if (points.length) {
      points.forEach(function(point, index) {
        if (index === 0) {
          path.push(["M", point.x, point.y]);
        } else {
          path.push(["L", point.x, point.y]);
        }
      });
      path.push(["L", points[0].x, points[0].y]);
    }
    return path;
  },
  clearStates: function clearStates2(action) {
    if (action === void 0) {
      action = "canvas:click";
    }
    var _a2 = this, graph = _a2.graph, selectedState = _a2.selectedState, shouldDeselect = _a2.shouldDeselect;
    var nodes = graph.findAllByState("node", selectedState);
    var edges = graph.findAllByState("edge", selectedState);
    if (!shouldDeselect || shouldDeselect({
      action,
      nodes,
      edges
    })) {
      nodes.forEach(function(node) {
        return graph.setItemState(node, selectedState, false);
      });
      edges.forEach(function(edge) {
        return graph.setItemState(edge, selectedState, false);
      });
    }
    if (this.onDeselect) {
      this.onDeselect(this.selectedNodes, this.selectedEdges);
    }
    this.selectedNodes = [];
    this.selectedEdges = [];
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: [],
        edges: []
      },
      select: false
    });
  },
  getSelectedItems: function getSelectedItems() {
    var _this = this;
    var _a2 = this, graph = _a2.graph, shouldUpdate3 = _a2.shouldUpdate;
    var lassoContour = this.points.map(function(point) {
      return [graph.getCanvasByPoint(point.x, point.y).x, graph.getCanvasByPoint(point.x, point.y).y];
    });
    var state = this.selectedState;
    var selectedNodes = [];
    var selectedIds = [];
    graph.getNodes().forEach(function(node) {
      if (!node.isVisible())
        return;
      if (isItemIntersecPolygon(node, lassoContour)) {
        if (shouldUpdate3(node, "select")) {
          selectedNodes.push(node);
          var model = node.getModel();
          selectedIds.push(model.id);
          graph.setItemState(node, state, true);
        }
      }
    });
    var selectedEdges = [];
    if (this.includeEdges) {
      selectedNodes.forEach(function(node) {
        var edges = node.getOutEdges();
        edges.forEach(function(edge) {
          if (!edge.isVisible())
            return;
          var model = edge.getModel();
          var source = model.source, target = model.target;
          if (selectedIds.includes(source) && selectedIds.includes(target) && shouldUpdate3(edge, "select")) {
            selectedEdges.push(edge);
            graph.setItemState(edge, _this.selectedState, true);
          }
        });
      });
    }
    this.selectedEdges = selectedEdges;
    this.selectedNodes = selectedNodes;
    if (this.onSelect) {
      this.onSelect(selectedNodes, selectedEdges);
    }
    graph.emit("nodeselectchange", {
      selectedItems: {
        nodes: selectedNodes,
        edges: selectedEdges
      },
      select: true
    });
  },
  createLasso: function createLasso() {
    var self2 = this;
    var lasso = self2.graph.get("delegateGroup").addShape("path", {
      attrs: __assign({
        path: []
      }, self2.delegateStyle),
      capture: false,
      name: "lasso-shape"
    });
    this.lasso = lasso;
    this.delegate = lasso;
    this.points = [];
    return lasso;
  },
  updateLasso: function updateLasso(e8) {
    var self2 = this;
    this.lasso.attr({
      path: self2.getLassoPath()
    });
  },
  onKeyDown: function onKeyDown4(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === this.trigger.toLowerCase()) {
      this.keydown = true;
    } else {
      this.keydown = false;
    }
  },
  onKeyUp: function onKeyUp4() {
    if (this.lasso) {
      this.lasso.remove(true);
      this.lasso = null;
      this.points = [];
      this.dragging = false;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/create-edge.js
init_esm();
var DEFAULT_TRIGGER6 = "click";
var ALLOW_EVENTS8 = ["click", "drag"];
var DEFAULT_KEY = void 0;
var ALLOW_KEYS = ["shift", "ctrl", "control", "alt", "meta", void 0];
var create_edge_default = {
  getDefaultCfg: function getDefaultCfg14() {
    return {
      trigger: DEFAULT_TRIGGER6,
      key: DEFAULT_KEY,
      edgeConfig: {},
      getEdgeConfig: void 0
    };
  },
  getEvents: function getEvents14() {
    var self2 = this;
    if (!(ALLOW_EVENTS8.indexOf(self2.trigger.toLowerCase()) > -1)) {
      self2.trigger = DEFAULT_TRIGGER6;
      console.warn("Behavior create-edge \u7684 trigger \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'click'\uFF0C'drag'");
    }
    if (self2.key && ALLOW_KEYS.indexOf(self2.key.toLowerCase()) === -1) {
      self2.trigger = DEFAULT_KEY;
      console.warn("Behavior create-edge \u7684 key \u53C2\u6570\u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'shift'\uFF0C'ctrl'\uFF0C'alt'\uFF0C'control'\uFF0C\u6216 undefined");
    }
    var events;
    if (self2.trigger === "drag") {
      events = {
        "node:dragstart": "onClick",
        "combo:dragstart": "onClick",
        drag: "updateEndPoint",
        "node:drop": "onClick",
        "combo:drop": "onClick",
        dragend: "onDragEnd"
      };
    } else if (self2.trigger === "click") {
      events = {
        "node:click": "onClick",
        mousemove: "updateEndPoint",
        "edge:click": "cancelCreating",
        "canvas:click": "cancelCreating",
        "combo:click": "onClick"
      };
    }
    if (self2.key) {
      events.keydown = "onKeyDown";
      events.keyup = "onKeyUp";
    }
    return events;
  },
  onDragEnd: function onDragEnd4(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var item = ev.item;
    if (!item || item.getID() === self2.source || item.getType() !== "node")
      self2.cancelCreating({
        item: self2.edge,
        x: ev.x,
        y: ev.y
      });
  },
  onClick: function onClick2(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var node = ev.item;
    var graph = self2.graph;
    var model = node.getModel();
    var getEdgeConfig = self2.getEdgeConfig;
    if (self2.addingEdge && self2.edge) {
      if (!self2.shouldEnd.call(self2, ev))
        return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: self2.source,
          target: model.id
        });
      } else {
        edgeConfig = self2.edgeConfig;
      }
      var updateCfg2 = __assign({
        target: model.id
      }, edgeConfig);
      if (self2.source === model.id) {
        updateCfg2.type = "loop";
      }
      graph.emit("beforecreateedge", {});
      graph.updateItem(self2.edge, updateCfg2, false);
      if (graph.get("enabledStack")) {
        var addedModel = __assign(__assign({}, self2.edge.getModel()), {
          itemType: "edge"
        });
        var after = {};
        after.edges = [addedModel];
        graph.pushStack("add", {
          before: {},
          after
        });
      }
      graph.emit("aftercreateedge", {
        edge: self2.edge
      });
      self2.edge.getKeyShape().set("capture", true);
      self2.edge = null;
      self2.addingEdge = false;
    } else {
      if (!self2.shouldBegin.call(self2, ev))
        return;
      var edgeConfig = void 0;
      if (getEdgeConfig && is_function_default(getEdgeConfig)) {
        edgeConfig = getEdgeConfig({
          source: model.id,
          target: model.id
        });
      } else {
        edgeConfig = self2.edgeConfig;
      }
      self2.edge = graph.addItem("edge", __assign({
        source: model.id,
        target: model.id
      }, edgeConfig), false);
      self2.source = model.id;
      self2.addingEdge = true;
      self2.edge.getKeyShape().set("capture", false);
    }
  },
  updateEndPoint: function updateEndPoint(ev) {
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    if (self2.edge && self2.edge.destroyed)
      self2.cancelCreating({
        item: self2.edge
      });
    var point = {
      x: ev.x,
      y: ev.y
    };
    if (!self2.graph.findById(self2.source)) {
      self2.addingEdge = false;
      return;
    }
    if (self2.addingEdge && self2.edge) {
      self2.graph.updateItem(self2.edge, {
        target: point
      }, false);
    }
  },
  cancelCreating: function cancelCreating(ev) {
    var _a2, _b;
    var self2 = this;
    if (self2.key && !self2.keydown)
      return;
    var graph = self2.graph;
    var currentEdge = ev.item;
    if (self2.addingEdge && (self2.edge === currentEdge || ((_b = (_a2 = ev.target) === null || _a2 === void 0 ? void 0 : _a2.isCanvas) === null || _b === void 0 ? void 0 : _b.call(_a2)))) {
      if (self2.edge && !self2.edge.destroyed)
        graph.removeItem(self2.edge, false);
      self2.edge = null;
      self2.addingEdge = false;
      return;
    }
  },
  onKeyDown: function onKeyDown5(e8) {
    var self2 = this;
    var code = e8.key;
    if (!code) {
      return;
    }
    if (code.toLowerCase() === self2.key.toLowerCase()) {
      self2.keydown = true;
    } else {
      self2.keydown = false;
    }
  },
  onKeyUp: function onKeyUp5() {
    var self2 = this;
    if (self2.addingEdge && self2.edge) {
      self2.graph.removeItem(self2.edge, false);
      self2.addingEdge = false;
      self2.edge = null;
    }
    this.keydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/shortcuts-call.js
var DEFAULT_TRIGGER7 = "ctrl";
var ALLOW_EVENTS9 = ["shift", "ctrl", "alt", "control"];
var DEFAULT_COMBINED_KEY = "1";
var shortcuts_call_default = {
  getDefaultCfg: function getDefaultCfg15() {
    return {
      trigger: DEFAULT_TRIGGER7,
      combinedKey: DEFAULT_COMBINED_KEY,
      functionName: "fitView",
      functionParams: []
    };
  },
  getEvents: function getEvents15() {
    if (!(ALLOW_EVENTS9.indexOf(this.trigger.toLowerCase()) > -1)) {
      this.trigger = DEFAULT_TRIGGER7;
      console.warn("Behavior shortcuts-fit-view \u7684 trigger \u53C2\u6570 '".concat(this.trigger, "' \u4E0D\u5408\u6CD5\uFF0C\u8BF7\u8F93\u5165 'drag'\u3001'shift'\u3001'ctrl' \u6216 'alt'"));
    }
    if (this.combinedKey === this.trigger) {
      this.combinedKey = void 0;
    }
    return {
      keyup: "onKeyUp",
      keydown: "onKeyDown"
    };
  },
  onKeyDown: function onKeyDown6(e8) {
    var code = e8.key;
    if (!code) {
      return;
    }
    var triggerLowerCase = this.trigger.toLowerCase();
    var codeLowerCase = code.toLowerCase();
    if (!this.triggerKeydown) {
      if (codeLowerCase === triggerLowerCase || codeLowerCase === "control" && triggerLowerCase === "ctrl" || codeLowerCase === "ctrl" && triggerLowerCase === "control") {
        this.triggerKeydown = true;
      } else {
        this.triggerKeydown = false;
      }
    }
    var graph = this.graph;
    if (!graph[this.functionName]) {
      console.warn("Behavior shortcuts-fit-view \u7684 functionName \u53C2\u6570 '".concat(this.functionName, "' \u4E0D\u5408\u6CD5\uFF0C\u5B83\u4E0D\u662F Graph \u7684\u4E00\u4E2A\u51FD\u6570\u540D"));
      return {};
    }
    if (this.triggerKeydown && !this.combinedKey) {
      if (this.functionParams && this.functionParams.length)
        graph[this.functionName].apply(graph, this.functionParams);
      else
        graph[this.functionName]();
      return;
    }
    var combinedKeyLowerCase = this.combinedKey.toLowerCase();
    if (this.triggerKeydown) {
      if (codeLowerCase === combinedKeyLowerCase || codeLowerCase === "control" && combinedKeyLowerCase === "ctrl" || codeLowerCase === "ctrl" && combinedKeyLowerCase === "control") {
        if (this.functionParams && this.functionParams.length)
          graph[this.functionName].apply(graph, this.functionParams);
        else
          graph[this.functionName]();
      }
    }
  },
  onKeyUp: function onKeyUp6() {
    if (this.brush) {
      this.brush.remove(true);
      this.brush = null;
      this.dragging = false;
    }
    this.triggerKeydown = false;
  }
};

// node_modules/@antv/g6-pc/es/behavior/scroll-canvas.js
var ALLOW_EVENTS10 = ["shift", "ctrl", "alt", "control", "meta"];
var scroll_canvas_default = {
  getDefaultCfg: function getDefaultCfg16() {
    return {
      direction: "both",
      enableOptimize: false,
      zoomKey: "ctrl",
      scalableRange: 0
    };
  },
  getEvents: function getEvents16() {
    if (!this.zoomKey || ALLOW_EVENTS10.indexOf(this.zoomKey) === -1)
      this.zoomKey = "ctrl";
    return {
      wheel: "onWheel"
    };
  },
  onWheel: function onWheel2(ev) {
    var _this = this;
    var graph = this.graph;
    var zoomKeys = Array.isArray(this.zoomKey) ? [].concat(this.zoomKey) : [this.zoomKey];
    if (zoomKeys.includes("control"))
      zoomKeys.push("ctrl");
    var keyDown = zoomKeys.some(function(ele) {
      return ev["".concat(ele, "Key")];
    });
    if (keyDown) {
      var canvas = graph.get("canvas");
      var point = canvas.getPointByClient(ev.clientX, ev.clientY);
      var ratio = graph.getZoom();
      if (ev.wheelDelta > 0) {
        ratio = ratio + ratio * 0.05;
      } else {
        ratio = ratio - ratio * 0.05;
      }
      graph.zoomTo(ratio, {
        x: point.x,
        y: point.y
      });
    } else {
      var dx = ev.deltaX || ev.movementX;
      var dy = ev.deltaY || ev.movementY;
      if (!dy && navigator.userAgent.indexOf("Firefox") > -1)
        dy = -ev.wheelDelta * 125 / 3;
      var width = this.graph.get("width");
      var height = this.graph.get("height");
      var graphCanvasBBox = this.graph.get("canvas").getCanvasBBox();
      var expandWidth = this.scalableRange;
      var expandHeight = this.scalableRange;
      if (expandWidth < 1 && expandWidth > -1) {
        expandWidth = width * expandWidth;
        expandHeight = height * expandHeight;
      }
      var minX = graphCanvasBBox.minX, maxX = graphCanvasBBox.maxX, minY = graphCanvasBBox.minY, maxY = graphCanvasBBox.maxY;
      if (dx > 0) {
        if (maxX < -expandWidth) {
          dx = 0;
        } else if (maxX - dx < -expandWidth) {
          dx = maxX + expandWidth;
        }
      } else if (dx < 0) {
        if (minX > width + expandWidth) {
          dx = 0;
        } else if (minX - dx > width + expandWidth) {
          dx = minX - (width + expandWidth);
        }
      }
      if (dy > 0) {
        if (maxY < -expandHeight) {
          dy = 0;
        } else if (maxY - dy < -expandHeight) {
          dy = maxY + expandHeight;
        }
      } else if (dy < 0) {
        if (minY > height + expandHeight) {
          dy = 0;
        } else if (minY - dy > height + expandHeight) {
          dy = minY - (height + expandHeight);
        }
      }
      if (this.get("direction") === "x") {
        dy = 0;
      } else if (this.get("direction") === "y") {
        dx = 0;
      }
      graph.translate(-dx, -dy);
    }
    ev.preventDefault();
    var enableOptimize = this.get("enableOptimize");
    if (enableOptimize) {
      var optimizeZoom_1 = this.get("optimizeZoom");
      var optimized = this.get("optimized");
      var nodes_1 = graph.getNodes();
      var edges_1 = graph.getEdges();
      var nodesLength_1 = nodes_1.length;
      var edgesLength_1 = edges_1.length;
      if (!optimized) {
        for (var n2 = 0; n2 < nodesLength_1; n2++) {
          var node = nodes_1[n2];
          if (!node.destroyed) {
            var children = node.get("group").get("children");
            var childrenLength = children.length;
            for (var c2 = 0; c2 < childrenLength; c2++) {
              var shape = children[c2];
              if (!shape.destoryed && !shape.get("isKeyShape")) {
                shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
                shape.hide();
              }
            }
          }
        }
        for (var edgeIndex = 0; edgeIndex < edgesLength_1; edgeIndex++) {
          var edge = edges_1[edgeIndex];
          var children = edge.get("group").get("children");
          var childrenLength = children.length;
          for (var c2 = 0; c2 < childrenLength; c2++) {
            var shape = children[c2];
            shape.set("ori-visibility", shape.get("ori-visibility") || shape.get("visible"));
            shape.hide();
          }
        }
        this.set("optimized", true);
      }
      clearTimeout(this.get("timeout"));
      var timeout2 = setTimeout(function() {
        var currentZoom = graph.getZoom();
        var curOptimized = _this.get("optimized");
        if (curOptimized) {
          _this.set("optimized", false);
          for (var n3 = 0; n3 < nodesLength_1; n3++) {
            var node2 = nodes_1[n3];
            var children2 = node2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = node2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c3 = 0; c3 < childrenLength2; c3++) {
                var shape2 = children2[c3];
                var oriVis = shape2.get("ori-visibility");
                if (!shape2.get("visible") && oriVis) {
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
          for (var edgeIndex2 = 0; edgeIndex2 < edgesLength_1; edgeIndex2++) {
            var edge2 = edges_1[edgeIndex2];
            var children2 = edge2.get("group").get("children");
            var childrenLength2 = children2.length;
            if (currentZoom < optimizeZoom_1) {
              var keyShape = edge2.getKeyShape();
              var oriVis = keyShape.get("ori-visibility");
              if (oriVis)
                keyShape.show();
            } else {
              for (var c3 = 0; c3 < childrenLength2; c3++) {
                var shape2 = children2[c3];
                if (!shape2.get("visible")) {
                  var oriVis = shape2.get("ori-visibility");
                  if (oriVis)
                    shape2.show();
                }
              }
            }
          }
        }
      }, 100);
      this.set("timeout", timeout2);
    }
  }
};

// node_modules/@antv/g6-pc/es/behavior/index.js
var behaviors = {
  "drag-canvas": drag_canvas_default,
  "zoom-canvas": zoom_canvas_default,
  "drag-node": drag_node_default,
  "activate-relations": activate_relations_default,
  "brush-select": brush_select_default,
  "click-select": click_select_default,
  "lasso-select": lasso_select_default,
  tooltip: tooltip_default2,
  "edge-tooltip": edge_tooltip_default,
  "collapse-expand": collapse_expand_default,
  "drag-combo": drag_combo_default,
  "collapse-expand-combo": collapse_expand_combo_default,
  "create-edge": create_edge_default,
  "shortcuts-call": shortcuts_call_default,
  "scroll-canvas": scroll_canvas_default
};
each_default(behaviors, function(behavior, type) {
  registerBehavior(type, behavior);
});

// node_modules/@antv/g6-pc/es/index.js
var Algorithm = __assign(__assign({}, es_exports), AlgorithmAsync);
var Grid3 = plugin_default.Grid;
var Minimap = plugin_default.Minimap;
var Bundling2 = plugin_default.Bundling;
var Menu2 = plugin_default.Menu;
var Fisheye2 = plugin_default.Fisheye;
var ToolBar2 = plugin_default.ToolBar;
var Tooltip2 = plugin_default.Tooltip;
var TimeBar2 = plugin_default.TimeBar;
var ImageMinimap = plugin_default.ImageMinimap;
var EdgeFilterLens2 = plugin_default.EdgeFilterLens;
var SnapLine2 = plugin_default.SnapLine;
var Legend2 = plugin_default.Legend;
var es_default5 = {
  version: global_default2.version,
  Graph: graph_default2,
  TreeGraph: tree_graph_default,
  Util: util_default2,
  Layout: import_lib.Layouts,
  TreeLayout: tree_layout_default,
  registerLayout,
  Global: global_default2,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerNode,
  Minimap: plugin_default.Minimap,
  Grid: plugin_default.Grid,
  Bundling: plugin_default.Bundling,
  Menu: plugin_default.Menu,
  ToolBar: plugin_default.ToolBar,
  Tooltip: plugin_default.Tooltip,
  Legend: plugin_default.Legend,
  TimeBar: TimeBar2,
  SnapLine: SnapLine2,
  Fisheye: Fisheye2,
  ImageMinimap,
  EdgeFilterLens: EdgeFilterLens2,
  Algorithm,
  Arrow: arrow_default,
  Marker: marker_default,
  Shape: element_default2
};

// node_modules/@antv/g6/es/index.js
es_default5.version = "4.6.4";
var es_default6 = es_default5;
var version = "4.6.4";

// dep:@antv_g6
var antv_g6_default = es_default6;
var export_Layout = import_lib.Layouts;
export {
  event_default as AbstractEvent,
  graph_default as AbstractGraph,
  layout_default as AbstractLayout,
  Algorithm,
  arrow_default as Arrow,
  BaseGlobal,
  Bundling2 as Bundling,
  combo_default as Combo,
  edge_default as Edge,
  EdgeFilterLens2 as EdgeFilterLens,
  Fisheye2 as Fisheye,
  G6GraphEvent,
  global_default2 as Global,
  graph_default2 as Graph,
  Grid3 as Grid,
  hull_default as Hull,
  ImageMinimap,
  export_Layout as Layout,
  Legend2 as Legend,
  marker_default as Marker,
  Menu2 as Menu,
  Minimap,
  node_default as Node,
  element_default2 as Shape,
  SnapLine2 as SnapLine,
  TimeBar2 as TimeBar,
  ToolBar2 as ToolBar,
  Tooltip2 as Tooltip,
  tree_graph_default as TreeGraph,
  tree_layout_default as TreeLayout,
  util_default2 as Util,
  antv_g6_default as default,
  registerBehavior,
  registerCombo,
  registerEdge,
  registerLayout,
  registerNode,
  version
};
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
//# sourceMappingURL=@antv_g6.js.map
